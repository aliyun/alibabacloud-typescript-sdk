// This file is auto-generated, don't edit it
/**
 */
import Util, * as $Util from '@alicloud/tea-util';
import OSS, * as $OSS from '@alicloud/oss-client';
import OpenPlatform, * as $OpenPlatform from '@alicloud/openplatform20191219';
import OSSUtil, * as $OSSUtil from '@alicloud/oss-util';
import FileForm, * as $FileForm from '@alicloud/tea-fileform';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import { Readable } from 'stream';
import * as $tea from '@alicloud/tea-typescript';

export class Cluster extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * c-d8a7523****
   */
  clusterBizId?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  clusterId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterBizId: 'ClusterBizId',
      clusterId: 'ClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterBizId: 'string',
      clusterId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ClusterConfig extends $tea.Model {
  /**
   * @example
   * {"spark.driver.memory":"1g"}
   */
  configValue?: string;
  /**
   * @example
   * false
   */
  enableOverwrite?: boolean;
  /**
   * @example
   * ide
   */
  moduleName?: string;
  static names(): { [key: string]: string } {
    return {
      configValue: 'ConfigValue',
      enableOverwrite: 'EnableOverwrite',
      moduleName: 'ModuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configValue: 'string',
      enableOverwrite: 'boolean',
      moduleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Collection extends $tea.Model {
  /**
   * @example
   * album
   */
  collectionType?: string;
  /**
   * @example
   * comment
   */
  comment?: string;
  /**
   * @example
   * 1668600147617
   */
  createTime?: number;
  /**
   * @example
   * 1
   */
  level?: number;
  /**
   * @example
   * collectionName
   */
  name?: string;
  /**
   * @example
   * 1234444
   */
  ownerId?: string;
  /**
   * @example
   * owner
   */
  ownerName?: string;
  /**
   * @example
   * album.12334
   */
  qualifiedName?: string;
  /**
   * @example
   * 1668600148617
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      collectionType: 'CollectionType',
      comment: 'Comment',
      createTime: 'CreateTime',
      level: 'Level',
      name: 'Name',
      ownerId: 'OwnerId',
      ownerName: 'OwnerName',
      qualifiedName: 'QualifiedName',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      collectionType: 'string',
      comment: 'string',
      createTime: 'number',
      level: 'number',
      name: 'string',
      ownerId: 'string',
      ownerName: 'string',
      qualifiedName: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class Entity extends $tea.Model {
  entityContent?: { [key: string]: any };
  /**
   * @example
   * maxcompute_table.563f0357118d05ef145d6bddf2966cc23e86ca8f2f013f915e565afdf09f7a23
   */
  qualifiedName?: string;
  /**
   * @example
   * 12345
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      entityContent: 'EntityContent',
      qualifiedName: 'QualifiedName',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityContent: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      qualifiedName: 'string',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LineageEntityVO extends $tea.Model {
  /**
   * @example
   * attribute map
   */
  attributes?: { [key: string]: string };
  /**
   * @example
   * http://domain.test.url/entity
   */
  detailUrl?: string;
  /**
   * @example
   * maxcompute-table
   */
  entityType?: string;
  /**
   * @example
   * tableName
   */
  name?: string;
  /**
   * @example
   * owner
   */
  owner?: string;
  /**
   * @example
   * dbName
   */
  parentName?: string;
  /**
   * @example
   * maxcompute-table.projectName.tablename
   */
  qualifiedName?: string;
  static names(): { [key: string]: string } {
    return {
      attributes: 'Attributes',
      detailUrl: 'DetailUrl',
      entityType: 'EntityType',
      name: 'Name',
      owner: 'Owner',
      parentName: 'ParentName',
      qualifiedName: 'QualifiedName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributes: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      detailUrl: 'string',
      entityType: 'string',
      name: 'string',
      owner: 'string',
      parentName: 'string',
      qualifiedName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LineageRelationRegisterBulkVO extends $tea.Model {
  /**
   * @example
   * 1684327487964
   */
  createTimestamp?: number;
  destEntities?: LineageEntityVO[];
  relationship?: RelationshipVO;
  srcEntities?: LineageEntityVO[];
  static names(): { [key: string]: string } {
    return {
      createTimestamp: 'CreateTimestamp',
      destEntities: 'DestEntities',
      relationship: 'Relationship',
      srcEntities: 'SrcEntities',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTimestamp: 'number',
      destEntities: { 'type': 'array', 'itemType': LineageEntityVO },
      relationship: RelationshipVO,
      srcEntities: { 'type': 'array', 'itemType': LineageEntityVO },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class LineageRelationRegisterVO extends $tea.Model {
  /**
   * @example
   * 1684327487964
   */
  createTimestamp?: number;
  destEntity?: LineageEntityVO;
  relationship?: RelationshipVO;
  srcEntity?: LineageEntityVO;
  static names(): { [key: string]: string } {
    return {
      createTimestamp: 'CreateTimestamp',
      destEntity: 'DestEntity',
      relationship: 'Relationship',
      srcEntity: 'SrcEntity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTimestamp: 'number',
      destEntity: LineageEntityVO,
      relationship: RelationshipVO,
      srcEntity: LineageEntityVO,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RelationshipVO extends $tea.Model {
  attributes?: { [key: string]: string };
  relationshipGuid?: string;
  /**
   * @example
   * sql
   */
  relationshipType?: string;
  static names(): { [key: string]: string } {
    return {
      attributes: 'Attributes',
      relationshipGuid: 'RelationshipGuid',
      relationshipType: 'RelationshipType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attributes: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      relationshipGuid: 'string',
      relationshipType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UserEntityTag extends $tea.Model {
  /**
   * @example
   * priority
   */
  tagKey?: string;
  /**
   * @example
   * p1
   */
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DataDesensPlanTemplateValue extends $tea.Model {
  /**
   * @remarks
   * The name of the data masking method.
   * 
   * @example
   * hash
   */
  name?: string;
  /**
   * @remarks
   * Indicates whether a watermark is added. Valid values:
   * 
   * *   true: allow
   * *   false: disallow
   * 
   * @example
   * true
   */
  supportWaterMark?: boolean;
  /**
   * @remarks
   * The data masking parameters and their descriptions.
   */
  extParamTemplate?: any[];
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      supportWaterMark: 'SupportWaterMark',
      extParamTemplate: 'ExtParamTemplate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      supportWaterMark: 'boolean',
      extParamTemplate: { 'type': 'array', 'itemType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AbolishDataServiceApiRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the DataService Studio API.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  apiId?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * @example
   * 10002
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AbolishDataServiceApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the API is unpublished.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AbolishDataServiceApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AbolishDataServiceApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AbolishDataServiceApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMetaCollectionEntityRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the collection.
   * 
   * This parameter is required.
   * 
   * @example
   * album.2222
   */
  collectionQualifiedName?: string;
  /**
   * @remarks
   * The unique identifier of the entity. Example: maxcompute-table.projectA.tableA.
   * 
   * This parameter is required.
   * 
   * @example
   * maxcompute-table.projectA.tableB
   */
  entityQualifiedName?: string;
  /**
   * @remarks
   * The remarks of the entity. Example: latest product table.
   * 
   * @example
   * this is a remark
   */
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      collectionQualifiedName: 'CollectionQualifiedName',
      entityQualifiedName: 'EntityQualifiedName',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      collectionQualifiedName: 'string',
      entityQualifiedName: 'string',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMetaCollectionEntityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9999
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified product does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the request ID to query logs and troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @remarks
   * The result of the operation. Valid values:
   * 
   * *   true: succeeded
   * *   false: failed
   * 
   * @example
   * true
   */
  status?: boolean;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      status: 'Status',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      status: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddMetaCollectionEntityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddMetaCollectionEntityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddMetaCollectionEntityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddProjectMemberToRoleRequest extends $tea.Model {
  /**
   * @remarks
   * The client token that is used to ensure the idempotence of the request. We recommend that you set this parameter to a UUID. This parameter is used to uniquely identify the API operation call.
   * 
   * @example
   * 1AFAE64E-D1BE-432B-A9*****
   */
  clientToken?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can call the [ListProjects](https://help.aliyun.com/document_detail/2780068.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 27
   */
  projectId?: number;
  /**
   * @remarks
   * The code of the role that you want to assign to a member of the DataWorks workspace. You can call the [ListProjectRoles](https://help.aliyun.com/document_detail/2780079.html) operation to query the codes of all roles in a DataWorks workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * role_project_guest
   */
  roleCode?: string;
  /**
   * @remarks
   * The Alibaba Cloud account ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and move the pointer over the profile picture in the upper-right corner to view the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      projectId: 'ProjectId',
      roleCode: 'RoleCode',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      projectId: 'number',
      roleCode: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddProjectMemberToRoleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1AFAE64E-D1BE-432B-A9****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddProjectMemberToRoleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddProjectMemberToRoleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddProjectMemberToRoleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRecognizeRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The Alibaba Cloud account that is used to create a sensitive data identification rule. Enter the username of the Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * dsg-uat
   */
  accountName?: string;
  /**
   * @remarks
   * Excludes fields. The system does not identify fields that are assigned with values.
   * 
   * *   The value must be in the ${Project name}.${Table name}.${Field name} or ${Project name}.${Schema name}.${Table name}.${Field name} format.
   * *   *Wildcards are supported. For example, the asterisk (\\*) in default.table.column1\\* can be used to match any content following default.table.column1, such as default.table.column10.
   * 
   * @example
   * default.qujian.*6
   */
  colExclude?: string;
  /**
   * @remarks
   * Scans fields. The system identifies only fields that are assigned with values.
   * 
   * *   The value must be in the ${Project name}.${Table name}.${Field name} or ${Project name}.${Schema name}.${Table name}.${Field name} format.
   * *   *Wildcards are supported. For example, the asterisk (\\*) in default.table.column1\\* can be used to match any content following default.table.column1, such as default.table.column10.
   * 
   * @example
   * default.qujian.*
   */
  colScan?: string;
  /**
   * @remarks
   * Scans content. The value is the text of each field comment in your data asset. Fuzzy match is supported.
   * 
   * @example
   * test
   */
  commentScan?: string;
  /**
   * @remarks
   * Identifies content. You can call the [QuerySensNodeInfo](https://help.aliyun.com/document_detail/2747189.html) operation to query the value of the current parameter for a built-in sensitive field.
   * 
   * @example
   * {"_clazz":"com.alipay.dsgclient.sdk.dsg.fastscan.engine.cond.NationalityCond"}
   */
  contentScan?: string;
  /**
   * @remarks
   * The hit ratio threshold. If more than 60%, which is a sample hit ratio threshold, of all sample data records hit the Name Entity Recognition (NER) model, the sensitive field is hit. The value can be an integer from 0 to 100.
   * 
   * @example
   * 50
   */
  hitThreshold?: number;
  /**
   * @remarks
   * The sensitivity level of the sensitive field. You can select one from all sensitivity levels that are defined in a template as the sensitivity level of the sensitive field, such as level 1 to level 10.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  level?: string;
  /**
   * @remarks
   * The name of the sensitivity level. You can call the [QueryDefaultTemplate](https://help.aliyun.com/document_detail/2743948.html) operation to obtain the name of the sensitivity level in the related template.
   */
  levelName?: string;
  /**
   * @remarks
   * The ID of the data category. You can call the [QuerySensClassification](https://help.aliyun.com/document_detail/2746850.html) operation to query the ID of all data categories. Then, you can select a data category to create a sensitive field. Enter the ID of the selected data category.
   * 
   * This parameter is required.
   * 
   * @example
   * 0ce67949-0810-400f-a24a-cc5ffafe1024
   */
  nodeId?: string;
  /**
   * @remarks
   * The information about the parent data category of the current data category. You can call the [QuerySensClassification](https://help.aliyun.com/document_detail/2746850.html) operation to obtain the ID of a data category.
   * 
   * This parameter is required.
   */
  nodeParent?: string;
  /**
   * @remarks
   * The type of the arithmetic operation. Valid values:
   * 
   * *   0: OR
   * *   1: AND
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  operationType?: number;
  /**
   * @remarks
   * The content of the sensitive data identification rule. You can call the [QuerySensNodeInfo](https://help.aliyun.com/document_detail/2747189.html) operation to query the value of the current parameter for a built-in sensitive field.
   * 
   * @example
   * {"contentRule":{"_clazz":"com.alipay.dsgclient.sdk.dsg.fastscan.engine.cond.GenderCond"},"_clazz":"com.alipay.dsg.dal.model.RuleContent"}
   */
  recognizeRules?: string;
  /**
   * @remarks
   * The type of the sensitive data identification rule. Valid values:
   * 
   * *   1: regular expression
   * *   2: built-in rule
   * *   3: sample library
   * *   4: self-generated data identification model
   * 
   * @example
   * 1
   */
  recognizeRulesType?: string;
  /**
   * @remarks
   * The description of the sensitive field. Enter a string that is less than 128 characters in length.
   */
  sensitiveDescription?: string;
  /**
   * @remarks
   * The name of the custom sensitive field. Enter a string that is less than 128 characters in length.
   * 
   * This parameter is required.
   */
  sensitiveName?: string;
  /**
   * @remarks
   * The status of the sensitive field. Valid values:
   * 
   * *   0: draft
   * *   1: effective
   * 
   * @example
   * 0
   */
  status?: number;
  /**
   * @remarks
   * The template ID. You can call the [QueryDefaultTemplate](https://help.aliyun.com/document_detail/2743948.html) operation to obtain the template ID.
   * 
   * This parameter is required.
   * 
   * @example
   * e1970541-6cf5-4d23-b101-d5b66f6e1024
   */
  templateId?: string;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * This parameter is required.
   * 
   * @example
   * 10241024
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      accountName: 'AccountName',
      colExclude: 'ColExclude',
      colScan: 'ColScan',
      commentScan: 'CommentScan',
      contentScan: 'ContentScan',
      hitThreshold: 'HitThreshold',
      level: 'Level',
      levelName: 'LevelName',
      nodeId: 'NodeId',
      nodeParent: 'NodeParent',
      operationType: 'OperationType',
      recognizeRules: 'RecognizeRules',
      recognizeRulesType: 'RecognizeRulesType',
      sensitiveDescription: 'SensitiveDescription',
      sensitiveName: 'SensitiveName',
      status: 'Status',
      templateId: 'TemplateId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountName: 'string',
      colExclude: 'string',
      colScan: 'string',
      commentScan: 'string',
      contentScan: 'string',
      hitThreshold: 'number',
      level: 'string',
      levelName: 'string',
      nodeId: 'string',
      nodeParent: 'string',
      operationType: 'number',
      recognizeRules: 'string',
      recognizeRulesType: 'string',
      sensitiveDescription: 'string',
      sensitiveName: 'string',
      status: 'number',
      templateId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRecognizeRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned result in the JSON format.
   * 
   * @example
   * {   "HttpStatusCode": 200,   "Success": true }
   */
  data?: any;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9990030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 10000001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddRecognizeRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddRecognizeRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddRecognizeRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddToMetaCategoryRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the category.
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  categoryId?: number;
  /**
   * @remarks
   * The GUID of the metatable.
   * 
   * This parameter is required.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  static names(): { [key: string]: string } {
    return {
      categoryId: 'CategoryId',
      tableGuid: 'TableGuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryId: 'number',
      tableGuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddToMetaCategoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the metatable was added to the specified category.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddToMetaCategoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddToMetaCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddToMetaCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApprovePermissionApplyOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The action for the permission request order. Valid values:
   * 
   * *   1: approve
   * *   2: reject
   * 
   * <!---->
   * 
   * *   0
   * *   1
   * *   2\\.
   * *   3\\.
   * *   4
   * *   5
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  approveAction?: number;
  /**
   * @remarks
   * The comment on the order.
   * 
   * This parameter is required.
   * 
   * @example
   * agree
   */
  approveComment?: string;
  /**
   * @remarks
   * The ID of the permission request order. You can call the ListPermissionApplyOrders operation to obtain the order ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 48f36729-05f9-4a40-9286-933fd940f30a
   */
  flowId?: string;
  static names(): { [key: string]: string } {
    return {
      approveAction: 'ApproveAction',
      approveComment: 'ApproveComment',
      flowId: 'FlowId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      approveAction: 'number',
      approveComment: 'string',
      flowId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApprovePermissionApplyOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the permission request order is processed.
   * 
   * @example
   * true
   */
  approveSuccess?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      approveSuccess: 'ApproveSuccess',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      approveSuccess: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApprovePermissionApplyOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApprovePermissionApplyOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApprovePermissionApplyOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CallbackExtensionRequest extends $tea.Model {
  /**
   * @remarks
   * The check message of the extension point event. If CheckResult is set to FAIL, you must provide the failure cause.
   */
  checkMessage?: string;
  /**
   * @remarks
   * The check status of the extension point event. Valid values:
   * 
   * *   OK: The event passes the check.
   * *   FAIL: The event fails to pass the check. You must check and handle the reported error at the earliest opportunity to ensure that your program is run as expected.
   * *   WARN: The event passes the check, but an alert is reported.
   * 
   * This parameter is required.
   * 
   * @example
   * FAIL
   */
  checkResult?: string;
  /**
   * @remarks
   * The unique code of the extension.
   * 
   * This parameter is required.
   * 
   * @example
   * 8abcb91f-d266-4073-b907-2ed670378ed1
   */
  extensionCode?: string;
  /**
   * @remarks
   * The message ID in DataWorks OpenEvent. You can obtain the ID from a received message when an extension point event is triggered.
   * 
   * This parameter is required.
   * 
   * @example
   * 03400b03-b721-4c34-8727-2d6884077091
   */
  messageId?: string;
  static names(): { [key: string]: string } {
    return {
      checkMessage: 'CheckMessage',
      checkResult: 'CheckResult',
      extensionCode: 'ExtensionCode',
      messageId: 'MessageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkMessage: 'string',
      checkResult: 'string',
      extensionCode: 'string',
      messageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CallbackExtensionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 7C352CB7-CD88-50CF-9D0D-E81BDF020E7F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true
   * 
   * false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CallbackExtensionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CallbackExtensionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CallbackExtensionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeResourceManagerResourceGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the resource type.
   * 
   * *   If you set ResourceType to project, set this parameter to the value of ProjectIdentifier. You can call the [ListProjects](https://help.aliyun.com/document_detail/2780068.html) operation to obtain the value of ProjectIdentifier.
   * *   If you set ResourceType to tenantresourcegroup, set this parameter to the value of ResourceGroupType. You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/2780075.html) operation to obtain the value of ResourceGroupType. Only the values 7, 8, and 9 are valid.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  resourceId?: string;
  /**
   * @remarks
   * The ID of the new resource group.
   * 
   * This parameter is required.
   * 
   * @example
   * rg-bp67acfmxazb4p****
   */
  resourceManagerResourceGroupId?: string;
  /**
   * @remarks
   * The resource type. Valid values:
   * 
   * *   project: workspace. If you want to change the resource group that you specify when you activate DataWorks, set the value to project.
   * *   tenantresourcegroup: exclusive resource group. If you want to change the resource group that you specify when you purchase a DataWorks exclusive resource group, set the value to tenantresourcegroup.
   * 
   * This parameter is required.
   * 
   * @example
   * project
   */
  resourceType?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceManagerResourceGroupId: 'ResourceManagerResourceGroupId',
      resourceType: 'ResourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceManagerResourceGroupId: 'string',
      resourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeResourceManagerResourceGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the resource group is changed.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1AFAE64E-D1BE-432B-A9****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeResourceManagerResourceGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ChangeResourceManagerResourceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeResourceManagerResourceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckFileDeploymentRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * https://result.aliyun.com/?checkerInstanceId=
   */
  checkDetailUrl?: string;
  /**
   * @remarks
   * The ID of the instance to which the file checker belongs. You can obtain the ID from the CheckerInstanceId parameter in the check event logs returned by DataWorks.
   * 
   * This parameter is required.
   * 
   * @example
   * 66_123455623_2
   */
  checkerInstanceId?: string;
  /**
   * @remarks
   * The check status of the file that you want to deploy. Valid values:
   * 
   * *   OK: The file passes the check.
   * *   WARN: The file passes the check, but an alert is reported.
   * *   FAIL: The file fails the check.
   * 
   * This parameter is required.
   * 
   * @example
   * OK
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      checkDetailUrl: 'CheckDetailUrl',
      checkerInstanceId: 'CheckerInstanceId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkDetailUrl: 'string',
      checkerInstanceId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckFileDeploymentResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 86d5a5ac-0cc0-4c5f-a374-a15713b252ab
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckFileDeploymentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckFileDeploymentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckFileDeploymentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckMetaPartitionRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the data source. Set the value to odps.
   * 
   * @example
   * emr
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The name of the metadatabase.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * The name of the partition in the MaxCompute metatable.
   * 
   * This parameter is required.
   * 
   * @example
   * ds=202005
   */
  partition?: string;
  /**
   * @remarks
   * The GUID of the MaxCompute metatable.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the metatable.
   * 
   * @example
   * abc
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dataSourceType: 'DataSourceType',
      databaseName: 'DatabaseName',
      partition: 'Partition',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dataSourceType: 'string',
      databaseName: 'string',
      partition: 'string',
      tableGuid: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckMetaPartitionResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the partition in the MaxCompute metatable exists. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckMetaPartitionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckMetaPartitionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckMetaPartitionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckMetaTableRequest extends $tea.Model {
  /**
   * @remarks
   * The E-MapReduce (EMR) cluster ID.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the data source. Valid values: odps and emr.
   * 
   * @example
   * emr
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The name of the metadatabase of the EMR cluster.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * The GUID of the metatable.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the EMR metatable.
   * 
   * @example
   * abc
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dataSourceType: 'DataSourceType',
      databaseName: 'DatabaseName',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dataSourceType: 'string',
      databaseName: 'string',
      tableGuid: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckMetaTableResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the metatable exists.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckMetaTableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckMetaTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckMetaTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBaselineRequest extends $tea.Model {
  /**
   * @remarks
   * The alert margin threshold of the baseline. Unit: minutes.
   * 
   * @example
   * 30
   */
  alertMarginThreshold?: number;
  /**
   * @remarks
   * The name of the baseline.
   * 
   * This parameter is required.
   * 
   * @example
   * BaselineName
   */
  baselineName?: string;
  /**
   * @remarks
   * The type of the baseline. Valid values: DAILY and HOURLY.
   * 
   * This parameter is required.
   * 
   * @example
   * DAILY
   */
  baselineType?: string;
  /**
   * @remarks
   * The ancestor nodes of nodes in the baseline.
   * 
   * @example
   * 210001233239,210001236482
   */
  nodeIds?: string;
  /**
   * @remarks
   * The settings of the committed completion time of the baseline.
   * 
   * This parameter is required.
   */
  overtimeSettings?: CreateBaselineRequestOvertimeSettings[];
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the baseline owner.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000000000001
   */
  owner?: string;
  /**
   * @remarks
   * The priority of the baseline. Valid values: {1,3,5,7,8}.
   * 
   * This parameter is required.
   * 
   * @example
   * 1,3,5,7,8
   */
  priority?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      alertMarginThreshold: 'AlertMarginThreshold',
      baselineName: 'BaselineName',
      baselineType: 'BaselineType',
      nodeIds: 'NodeIds',
      overtimeSettings: 'OvertimeSettings',
      owner: 'Owner',
      priority: 'Priority',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertMarginThreshold: 'number',
      baselineName: 'string',
      baselineType: 'string',
      nodeIds: 'string',
      overtimeSettings: { 'type': 'array', 'itemType': CreateBaselineRequestOvertimeSettings },
      owner: 'string',
      priority: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBaselineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The baseline ID.
   * 
   * @example
   * 100003
   */
  data?: number;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F05080B0-CCE6-5D22-B284-34A51C5D4E28
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBaselineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateBaselineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateBaselineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBusinessRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   */
  businessName?: string;
  description?: string;
  /**
   * @example
   * 1000000000001
   */
  owner?: string;
  /**
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  /**
   * @example
   * NORMAL
   */
  useType?: string;
  static names(): { [key: string]: string } {
    return {
      businessName: 'BusinessName',
      description: 'Description',
      owner: 'Owner',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
      useType: 'UseType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessName: 'string',
      description: 'string',
      owner: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
      useType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBusinessResponseBody extends $tea.Model {
  /**
   * @example
   * 100001
   */
  businessId?: number;
  /**
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      businessId: 'BusinessId',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessId: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBusinessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateBusinessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateBusinessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConnectionRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the connection string. Valid values:
   * 
   * *   odps
   * *   mysql
   * *   rds
   * *   oss
   * *   sqlserver
   * *   polardb
   * *   oracle
   * *   mongodb
   * *   emr
   * *   postgresql
   * *   analyticdb_for_mysql
   * *   hybriddb_for_postgresql
   * *   holo
   * 
   * This parameter is required.
   * 
   * @example
   * rds
   */
  connectionType?: string;
  /**
   * @remarks
   * The details of the data source. Examples of details of some common data sources:
   * 
   * *   odps
   * 
   * <!---->
   * 
   *     {
   *       "accessId": "xssssss",
   *       "accessKey": "xsaxsaxsa",
   *       "authType": 2,
   *       "endpoint": "http://service.odps.aliyun.com/api",
   *       "project": "xsaxsax",
   *       "tag": "public"
   *     }
   * 
   * *   mysql
   * 
   * <!---->
   * 
   *     {
   *       "database": "xsaxsa",
   *       "instanceName": "rm-xsaxsa",
   *       "password": "xsaxsa",
   *       "rdsOwnerId": "xasxsa",
   *       "regionId": "cn-shanghai",
   *       "tag": "rds",
   *       "username": "xsaxsa"
   *     }
   * 
   * *   rds
   * 
   * <!---->
   * 
   *     {
   *       "configType": 1,
   *       "tag": "rds",
   *       "database": "xsaxsa",
   *       "username": "xsaxsa",
   *       "password": "xssaxsa$32050",
   *       "instanceName": "rm-xsaxs",
   *       "rdsOwnerId": "11111111"
   *     }
   * 
   * *   oss
   * 
   * <!---->
   * 
   *     {
   *       "accessId": "sssssxx",
   *       "accessKey": "xsaxaxsaxs",
   *       "bucket": "xsa-xs-xs",
   *       "endpoint": "http://oss-cn-shanghai.aliyuncs.com",
   *       "tag": "public"
   *     }
   * 
   * *   sqlserver
   * 
   * <!---->
   * 
   *     {
   *       "jdbcUrl": "jdbc:sqlserver://xsaxsa-xsaxsa.database.xxx.cn:123;DatabaseName=xsxs-xsxs",
   *       "password": "sdasda$fs",
   *       "tag": "public",
   *       "username": "sxaxacdacdd"
   *     }
   * 
   * *   polardb
   * 
   * <!---->
   * 
   *     {
   *       "clusterId": "pc-sdadsadsa",
   *       "database": "dsadsadsa",
   *       "ownerId": "121212122",
   *       "password": "sdasdafssa",
   *       "region": "cn-shanghai",
   *       "tag": "polardb",
   *       "username": "asdadsads"
   *     }
   * 
   * *   oracle
   * 
   * <!---->
   * 
   *     {
   *       "jdbcUrl": "jdbc:oracle:saaa:@xxxxx:1521:PROD",
   *       "password": "sxasaxsa",
   *       "tag": "public",
   *       "username": "sasfadfa"
   *     }
   * 
   * *   mongodb
   * 
   * <!---->
   * 
   *     {
   *       "address": "[\\"xsaxxsa.mongodb.rds.aliyuncs.com:3717\\"]",
   *       "database": "admin",
   *       "password": "sadsda@",
   *       "tag": "public",
   *       "username": "dsadsadas"
   *     }
   * 
   * *   emr
   * 
   * <!---->
   * 
   *     {
   *       "accessId": "xsaxsa",
   *       "emrClusterId": "C-dsads",
   *       "emrResourceQueueName": "default",
   *       "emrEndpoint": "emr.aliyuncs.com",
   *       "accessKey": "dsadsad",
   *       "emrUserId": "224833315798889783",
   *       "name": "sasdsadsa",
   *       "emrAccessMode": "simple",
   *       "region": "cn-shanghai",
   *       "authType": "2",
   *       "emrProjectId": "FP-sdadsad"
   *     }
   * 
   * *   postgresql
   * 
   * <!---->
   * 
   *     {
   *       "jdbcUrl": "jdbc:postgresql://xxxx:1921/ssss",
   *       "password": "sdadsads",
   *       "tag": "public",
   *       "username": "sdsasda"
   *     }
   * 
   * *   analyticdb_for_mysql
   * 
   * <!---->
   * 
   *     {
   *       "instanceId": "am-sadsada",
   *       "database": "xsxsx",
   *       "username": "xsxsa",
   *       "password": "asdadsa",
   *       "connectionString": "am-xssxsxs.ads.aliyuncs.com:3306"
   *     }
   * 
   * *   hybriddb_for_postgresql
   * 
   * <!---->
   * 
   *     {
   *       "connectionString": "gp-xsaxsaxa-master.gpdbmaster.rds.aliyuncs.com",
   *       "database": "xsaxsaxas",
   *       "password": "xsaxsaxsa@11",
   *       "instanceId": "gp-xsaxsaxsa",
   *       "port": "541132",
   *       "ownerId": "xsaxsaxsas",
   *       "username": "sadsad"
   *     }
   * 
   * *   holo
   * 
   * <!---->
   * 
   *     {
   *       "accessId": "xsaxsaxs",
   *       "accessKey": "xsaxsaxsa",
   *       "database": "xsaxsaxsa",
   *       "instanceId": "xsaxa",
   *       "tag": "aliyun"
   *     }
   * 
   * *   kafka
   * 
   * <!---->
   * 
   *     {
   *       "instanceId": "xsax-cn-xsaxsa",
   *       "regionId": "cn-shanghai",
   *       "tag": "aliyun",
   *       "ownerId": "1212121212112"
   *     }
   * 
   * This parameter is required.
   * 
   * @example
   * {"database":"dbname","instanceName":"instancename","password":"password","rdsOwnerId":"123","username":"username"}
   */
  content?: string;
  /**
   * @remarks
   * The description of the connection string.
   * 
   * @example
   * abc
   */
  description?: string;
  /**
   * @remarks
   * The environment in which the data source is used. Valid values: 0 and 1. The value 0 indicates the development environment. The value 1 indicates the production environment.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The name of the data source.
   * 
   * This parameter is required.
   * 
   * @example
   * abc
   */
  name?: string;
  /**
   * @remarks
   * The ID of the workspace with which the data source is associated. You can call the [ListProjects](https://help.aliyun.com/document_detail/178393.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  projectId?: number;
  /**
   * @remarks
   * The subtype of the connection string. This parameter is used for scenarios where a type includes subtypes. The following type and subtypes are supported:
   * 
   * *   Type: `rds`
   * *   Subtypes: `mysql`, `sqlserver`, and `postgresql`.
   * 
   * @example
   * mysql
   */
  subType?: string;
  static names(): { [key: string]: string } {
    return {
      connectionType: 'ConnectionType',
      content: 'Content',
      description: 'Description',
      envType: 'EnvType',
      name: 'Name',
      projectId: 'ProjectId',
      subType: 'SubType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionType: 'string',
      content: 'string',
      description: 'string',
      envType: 'number',
      name: 'string',
      projectId: 'number',
      subType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConnectionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data source ID.
   * 
   * @example
   * 123
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc141151593763****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      httpStatusCode: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConnectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateConnectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIAlarmRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task with which the alert rule is associated.
   * 
   * This parameter is required.
   * 
   * @example
   * 11265
   */
  DIJobId?: number;
  /**
   * @remarks
   * The description of the alert rule.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to enable the alert rule. By default, the alert rule is disabled.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * The metric type in the alert rule. Valid values:
   * 
   * *   Heartbeat
   * *   FailoverCount
   * *   Delay
   * 
   * This parameter is required.
   * 
   * @example
   * Heartbeat
   */
  metricType?: string;
  /**
   * @remarks
   * The alert notification settings.
   * 
   * This parameter is required.
   */
  notificationSettings?: CreateDIAlarmRuleRequestNotificationSettings;
  /**
   * @remarks
   * The conditions that can trigger the alert rule.
   * 
   * This parameter is required.
   */
  triggerConditions?: CreateDIAlarmRuleRequestTriggerConditions[];
  static names(): { [key: string]: string } {
    return {
      DIJobId: 'DIJobId',
      description: 'Description',
      enabled: 'Enabled',
      metricType: 'MetricType',
      notificationSettings: 'NotificationSettings',
      triggerConditions: 'TriggerConditions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobId: 'number',
      description: 'string',
      enabled: 'boolean',
      metricType: 'string',
      notificationSettings: CreateDIAlarmRuleRequestNotificationSettings,
      triggerConditions: { 'type': 'array', 'itemType': CreateDIAlarmRuleRequestTriggerConditions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIAlarmRuleShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task with which the alert rule is associated.
   * 
   * This parameter is required.
   * 
   * @example
   * 11265
   */
  DIJobId?: number;
  /**
   * @remarks
   * The description of the alert rule.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to enable the alert rule. By default, the alert rule is disabled.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * The metric type in the alert rule. Valid values:
   * 
   * *   Heartbeat
   * *   FailoverCount
   * *   Delay
   * 
   * This parameter is required.
   * 
   * @example
   * Heartbeat
   */
  metricType?: string;
  /**
   * @remarks
   * The alert notification settings.
   * 
   * This parameter is required.
   */
  notificationSettingsShrink?: string;
  /**
   * @remarks
   * The conditions that can trigger the alert rule.
   * 
   * This parameter is required.
   */
  triggerConditionsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      DIJobId: 'DIJobId',
      description: 'Description',
      enabled: 'Enabled',
      metricType: 'MetricType',
      notificationSettingsShrink: 'NotificationSettings',
      triggerConditionsShrink: 'TriggerConditions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobId: 'number',
      description: 'string',
      enabled: 'boolean',
      metricType: 'string',
      notificationSettingsShrink: 'string',
      triggerConditionsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIAlarmRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The alert rule ID.
   * 
   * @example
   * 34988
   */
  DIAlarmRuleId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C636A747-7E4E-594D-94CD-2B4F8A9A9A63
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      DIAlarmRuleId: 'DIAlarmRuleId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIAlarmRuleId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIAlarmRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDIAlarmRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDIAlarmRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the synchronization task.
   */
  description?: string;
  /**
   * @remarks
   * The settings of the destination. Only a single destination is supported.
   */
  destinationDataSourceSettings?: CreateDIJobRequestDestinationDataSourceSettings[];
  /**
   * @remarks
   * The type of the destination. Valid values: Hologres and Hive.
   * 
   * @example
   * Hologres
   */
  destinationDataSourceType?: string;
  /**
   * @remarks
   * The name of the synchronization task.
   * 
   * @example
   * mysql_to_holo_sync_8772
   */
  jobName?: string;
  /**
   * @remarks
   * The settings for the dimension of the synchronization task. The settings include processing policies for DDL messages, policies for data type mappings between source fields and destination fields, and runtime parameters of the synchronization task.
   */
  jobSettings?: CreateDIJobRequestJobSettings;
  /**
   * @remarks
   * The synchronization type. Valid values:
   * 
   * *   FullAndRealtimeIncremental (one-time full synchronization and real-time incremental synchronization)
   * *   RealtimeIncremental (real-time incremental synchronization)
   * *   Full (full synchronization)
   * *   OfflineIncremental (batch incremental synchronization)
   * *   FullAndOfflineIncremental (one-time full synchronization and batch incremental synchronization)
   * 
   * @example
   * FullAndRealtimeIncremental
   */
  migrationType?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can call the [ListProjects](https://help.aliyun.com/document_detail/178393.html) operation to obtain the ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The resource settings.
   */
  resourceSettings?: CreateDIJobRequestResourceSettings;
  /**
   * @remarks
   * The settings of the source. Only a single source is supported.
   */
  sourceDataSourceSettings?: CreateDIJobRequestSourceDataSourceSettings[];
  /**
   * @remarks
   * The type of the source. Set the value to MySQL.
   * 
   * @example
   * MySQL
   */
  sourceDataSourceType?: string;
  /**
   * @remarks
   * Specifies whether to perform system debugging. Valid values: true and false. Default value: false.
   * 
   * @example
   * false
   */
  systemDebug?: string;
  /**
   * @remarks
   * The list of mappings between rules used to select synchronization objects in the source and transformation rules applied to the selected synchronization objects. Each entry in the list displays a mapping between a rule used to select synchronization objects and a transformation rule applied to the selected synchronization objects.
   */
  tableMappings?: CreateDIJobRequestTableMappings[];
  /**
   * @remarks
   * The list of transformation rules for objects involved in the synchronization task. Each entry in the list defines a transformation rule.
   */
  transformationRules?: CreateDIJobRequestTransformationRules[];
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      destinationDataSourceSettings: 'DestinationDataSourceSettings',
      destinationDataSourceType: 'DestinationDataSourceType',
      jobName: 'JobName',
      jobSettings: 'JobSettings',
      migrationType: 'MigrationType',
      projectId: 'ProjectId',
      resourceSettings: 'ResourceSettings',
      sourceDataSourceSettings: 'SourceDataSourceSettings',
      sourceDataSourceType: 'SourceDataSourceType',
      systemDebug: 'SystemDebug',
      tableMappings: 'TableMappings',
      transformationRules: 'TransformationRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      destinationDataSourceSettings: { 'type': 'array', 'itemType': CreateDIJobRequestDestinationDataSourceSettings },
      destinationDataSourceType: 'string',
      jobName: 'string',
      jobSettings: CreateDIJobRequestJobSettings,
      migrationType: 'string',
      projectId: 'number',
      resourceSettings: CreateDIJobRequestResourceSettings,
      sourceDataSourceSettings: { 'type': 'array', 'itemType': CreateDIJobRequestSourceDataSourceSettings },
      sourceDataSourceType: 'string',
      systemDebug: 'string',
      tableMappings: { 'type': 'array', 'itemType': CreateDIJobRequestTableMappings },
      transformationRules: { 'type': 'array', 'itemType': CreateDIJobRequestTransformationRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the synchronization task.
   */
  description?: string;
  /**
   * @remarks
   * The settings of the destination. Only a single destination is supported.
   */
  destinationDataSourceSettingsShrink?: string;
  /**
   * @remarks
   * The type of the destination. Valid values: Hologres and Hive.
   * 
   * @example
   * Hologres
   */
  destinationDataSourceType?: string;
  /**
   * @remarks
   * The name of the synchronization task.
   * 
   * @example
   * mysql_to_holo_sync_8772
   */
  jobName?: string;
  /**
   * @remarks
   * The settings for the dimension of the synchronization task. The settings include processing policies for DDL messages, policies for data type mappings between source fields and destination fields, and runtime parameters of the synchronization task.
   */
  jobSettingsShrink?: string;
  /**
   * @remarks
   * The synchronization type. Valid values:
   * 
   * *   FullAndRealtimeIncremental (one-time full synchronization and real-time incremental synchronization)
   * *   RealtimeIncremental (real-time incremental synchronization)
   * *   Full (full synchronization)
   * *   OfflineIncremental (batch incremental synchronization)
   * *   FullAndOfflineIncremental (one-time full synchronization and batch incremental synchronization)
   * 
   * @example
   * FullAndRealtimeIncremental
   */
  migrationType?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can call the [ListProjects](https://help.aliyun.com/document_detail/178393.html) operation to obtain the ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The resource settings.
   */
  resourceSettingsShrink?: string;
  /**
   * @remarks
   * The settings of the source. Only a single source is supported.
   */
  sourceDataSourceSettingsShrink?: string;
  /**
   * @remarks
   * The type of the source. Set the value to MySQL.
   * 
   * @example
   * MySQL
   */
  sourceDataSourceType?: string;
  /**
   * @remarks
   * Specifies whether to perform system debugging. Valid values: true and false. Default value: false.
   * 
   * @example
   * false
   */
  systemDebug?: string;
  /**
   * @remarks
   * The list of mappings between rules used to select synchronization objects in the source and transformation rules applied to the selected synchronization objects. Each entry in the list displays a mapping between a rule used to select synchronization objects and a transformation rule applied to the selected synchronization objects.
   */
  tableMappingsShrink?: string;
  /**
   * @remarks
   * The list of transformation rules for objects involved in the synchronization task. Each entry in the list defines a transformation rule.
   */
  transformationRulesShrink?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      destinationDataSourceSettingsShrink: 'DestinationDataSourceSettings',
      destinationDataSourceType: 'DestinationDataSourceType',
      jobName: 'JobName',
      jobSettingsShrink: 'JobSettings',
      migrationType: 'MigrationType',
      projectId: 'ProjectId',
      resourceSettingsShrink: 'ResourceSettings',
      sourceDataSourceSettingsShrink: 'SourceDataSourceSettings',
      sourceDataSourceType: 'SourceDataSourceType',
      systemDebug: 'SystemDebug',
      tableMappingsShrink: 'TableMappings',
      transformationRulesShrink: 'TransformationRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      destinationDataSourceSettingsShrink: 'string',
      destinationDataSourceType: 'string',
      jobName: 'string',
      jobSettingsShrink: 'string',
      migrationType: 'string',
      projectId: 'number',
      resourceSettingsShrink: 'string',
      sourceDataSourceSettingsShrink: 'string',
      sourceDataSourceType: 'string',
      systemDebug: 'string',
      tableMappingsShrink: 'string',
      transformationRulesShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The synchronization task ID.
   * 
   * @example
   * 11792
   */
  DIJobId?: number;
  /**
   * @remarks
   * The request ID. You can use the request ID to query logs and troubleshoot issues.
   * 
   * @example
   * 4F6AB6B3-41FB-5EBB-AFB2-0C98D49DA2BB
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      DIJobId: 'DIJobId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDIJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDIJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDISyncTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The client token that is used to ensure the idempotence of the request. This parameter can be left empty.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  clientToken?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * This parameter is required.
   */
  taskContent?: string;
  /**
   * @remarks
   * The name of the data synchronization task.
   * 
   * @example
   * new_di_task
   */
  taskName?: string;
  /**
   * @remarks
   * The settings that specify the storage path of the data synchronization task and the resource group used by the task. The following parameters are supported:
   * 
   * *   FileFolderPath: the storage path of the data synchronization task.
   * *   ResourceGroup: the identifier of the resource group for Data Integration that is used by the data synchronization task. You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/173913.html) operation to query the identifier of the resource group.
   * 
   * @example
   * {"FileFolderPath":"Business Flow/XXX/Data Integration","ResourceGroup":"S_res_group_XXX_XXXX"}
   */
  taskParam?: string;
  /**
   * @remarks
   * The type of the data synchronization task. Valid values: DI_OFFLINE, DI_REALTIME, and DI_SOLUTION.
   * 
   * This parameter is required.
   * 
   * @example
   * DI_OFFLINE
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      projectId: 'ProjectId',
      taskContent: 'TaskContent',
      taskName: 'TaskName',
      taskParam: 'TaskParam',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      projectId: 'number',
      taskContent: 'string',
      taskName: 'string',
      taskParam: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDISyncTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information that indicates whether the data synchronization task is created.
   */
  data?: CreateDISyncTaskResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: CreateDISyncTaskResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDISyncTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDISyncTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDISyncTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDagComplementRequest extends $tea.Model {
  /**
   * @example
   * 00:00:00
   */
  bizBeginTime?: string;
  /**
   * @example
   * 23:00:00
   */
  bizEndTime?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2020-05-21 00:00:00
   */
  endBizDate?: string;
  /**
   * @example
   * 1234
   */
  excludeNodeIds?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 74324,74325
   */
  includeNodeIds?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * xm_test
   */
  name?: string;
  /**
   * @example
   * {74324:"key1=val1 key2=val"}
   */
  nodeParams?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * false
   */
  parallelism?: boolean;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  rootNodeId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2020-05-20 00:00:00
   */
  startBizDate?: string;
  static names(): { [key: string]: string } {
    return {
      bizBeginTime: 'BizBeginTime',
      bizEndTime: 'BizEndTime',
      endBizDate: 'EndBizDate',
      excludeNodeIds: 'ExcludeNodeIds',
      includeNodeIds: 'IncludeNodeIds',
      name: 'Name',
      nodeParams: 'NodeParams',
      parallelism: 'Parallelism',
      projectEnv: 'ProjectEnv',
      rootNodeId: 'RootNodeId',
      startBizDate: 'StartBizDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizBeginTime: 'string',
      bizEndTime: 'string',
      endBizDate: 'string',
      excludeNodeIds: 'string',
      includeNodeIds: 'string',
      name: 'string',
      nodeParams: 'string',
      parallelism: 'boolean',
      projectEnv: 'string',
      rootNodeId: 'number',
      startBizDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDagComplementResponseBody extends $tea.Model {
  data?: number[];
  /**
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDagComplementResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDagComplementResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDagComplementResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDagTestRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 2020-05-26 00:00:00
   */
  bizdate?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * xm_create_test
   */
  name?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @example
   * bizdate=$bizdate tbods=$tbods
   */
  nodeParams?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      bizdate: 'Bizdate',
      name: 'Name',
      nodeId: 'NodeId',
      nodeParams: 'NodeParams',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizdate: 'string',
      name: 'string',
      nodeId: 'number',
      nodeParams: 'string',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDagTestResponseBody extends $tea.Model {
  /**
   * @example
   * 3333333
   */
  data?: number;
  /**
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDagTestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDagTestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDagTestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataServiceApiRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the API.
   * 
   * This parameter is required.
   */
  apiDescription?: string;
  /**
   * @remarks
   * The type of the API. Valid values: 0, 1, and 2. The value 0 indicates that the API is generated in wizard mode. The value 1 indicates that the API is generated in script mode. The value 2 indicates that the API is generated by registration.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  apiMode?: number;
  /**
   * @remarks
   * The name of the API. The name must be 4 to 50 characters in length. The name can contain letters, digits, and underscores (_) and must start with a letter.
   * 
   * This parameter is required.
   */
  apiName?: string;
  /**
   * @remarks
   * The path of the API. The path cannot exceed 200 characters in length. The path can contain letters, digits, underscores (_), and hyphens (-) and must start with a forward slash (/).
   * 
   * This parameter is required.
   * 
   * @example
   * /test/1
   */
  apiPath?: string;
  /**
   * @remarks
   * The ID of the folder used to store the API. The ID of the root folder in a business process is 0. The ID of the folder created by a user must be greater than 0.
   * 
   * @example
   * 0
   */
  folderId?: number;
  /**
   * @remarks
   * The business process ID.
   * 
   * This parameter is required.
   */
  groupId?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The protocol used by the API. Valid values: 0 and 1. The value 0 indicates HTTP. The value 1 indicates HTTPS. You can specify multiple protocols. Separate them with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * 0,1
   */
  protocols?: string;
  /**
   * @remarks
   * The details of the API generated by registration. For more information, see the registrationDetails parameter returned by the [GetDataServiceApi](https://help.aliyun.com/document_detail/174013.html) operation.
   * 
   * @example
   * {"failedResultSample":"fail","registrationErrorCodes":[{"errorCode":"e1","errorMessage":"msg1","errorSolution":"sol1"},{"errorCode":"e2","errorMessage":"msg2","errorSolution":"sol2"}],"registrationRequestParameters":[{"columnName":"","defaultValue":"","exampleValue":"","isRequiredParameter":true,"parameterDataType":0,"parameterDescription":"","parameterName":"id","parameterOperator":0,"parameterPosition":1},{"columnName":"","defaultValue":"xx","exampleValue":"","isRequiredParameter":true,"parameterDataType":0,"parameterDescription":"","parameterName":"cc","parameterOperator":2,"parameterPosition":2}],"serviceContentType":1,"serviceHost":"http://www.baidu.com","servicePath":"/[uid]","serviceRequestBodyDescription":"body","successfulResultSample":"success"}
   */
  registrationDetails?: string;
  /**
   * @remarks
   * The format of the data to be requested. Valid values:
   * 
   * *   0: XML format
   * *   1: JSON format
   * *   2: form format
   * 
   * @example
   * 0
   */
  requestContentType?: number;
  /**
   * @remarks
   * The request method of the API. Valid values: 0, 1, 2, and 3. The value 0 indicates the GET method. The value 1 indicates the POST method. The value 2 indicates the PUT method. The value 3 indicates the DELETE method. APIs generated in wizard or script mode support the GET and POST methods. APIs generated by registration support the GET, POST, PUT, and DELETE methods.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  requestMethod?: number;
  /**
   * @remarks
   * The ID of the exclusive resource group.
   * 
   * @example
   * 3242432423
   */
  resourceGroupId?: number;
  /**
   * @remarks
   * The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  responseContentType?: number;
  /**
   * @remarks
   * The details of the API generated in script mode. For more information, see the scriptDetails parameter returned by the [GetDataServiceApi](https://help.aliyun.com/document_detail/174013.html) operation.
   * 
   * @example
   * {"isPagedResponse":false,"script":"select id as id1, name as name1 from person where id=${inputid}","scriptConnection":{"connectionId":122786,"tableName":"person"},"scriptRequestParameters":[{"defaultValue":"","exampleValue":"","isRequiredParameter":true,"parameterDataType":0,"parameterDescription":"","parameterName":"inputid","parameterOperator":0,"parameterPosition":1}],"scriptResponseParameters":[{"exampleValue":"","parameterDataType":0,"parameterDescription":"","parameterName":"id1"},{"exampleValue":"","parameterDataType":0,"parameterDescription":"","parameterName":"name1"}]}
   */
  scriptDetails?: string;
  /**
   * @remarks
   * *   The SQL mode. Valid values: 0: The basic mode is used.
   * *   1: Mybatis is used.
   * 
   * @example
   * 0
   */
  sqlMode?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 10001
   */
  tenantId?: number;
  /**
   * @remarks
   * The timeout period of the API request. Unit: milliseconds. Valid values: (0,30000].
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  timeout?: number;
  /**
   * @remarks
   * The scope in which the API is visible. Valid values: 0 and 1. The value 0 indicates that the API is visible to all members in the workspace. The value 1 indicates that the API is visible only to its owner.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  visibleRange?: number;
  /**
   * @remarks
   * The details of the API generated in wizard mode. For more information, see the WizardDetails parameter returned by the [GetDataServiceApi](https://help.aliyun.com/document_detail/174013.html) operation.
   * 
   * @example
   * {"isPagedResponse":true,"wizardConnection":{"connectionId":122786,"tableName":"person"},"wizardRequestParameters":[{"columnName":"id","defaultValue":"","exampleValue":"1","isRequiredParameter":true,"parameterDataType":2,"parameterDescription":"","parameterName":"id","parameterOperator":0,"parameterPosition":0}],"wizardResponseParameters":[{"columnName":"id","exampleValue":"11","parameterDataType":2,"parameterDescription":"","parameterName":"id"}]}
   */
  wizardDetails?: string;
  static names(): { [key: string]: string } {
    return {
      apiDescription: 'ApiDescription',
      apiMode: 'ApiMode',
      apiName: 'ApiName',
      apiPath: 'ApiPath',
      folderId: 'FolderId',
      groupId: 'GroupId',
      projectId: 'ProjectId',
      protocols: 'Protocols',
      registrationDetails: 'RegistrationDetails',
      requestContentType: 'RequestContentType',
      requestMethod: 'RequestMethod',
      resourceGroupId: 'ResourceGroupId',
      responseContentType: 'ResponseContentType',
      scriptDetails: 'ScriptDetails',
      sqlMode: 'SqlMode',
      tenantId: 'TenantId',
      timeout: 'Timeout',
      visibleRange: 'VisibleRange',
      wizardDetails: 'WizardDetails',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiDescription: 'string',
      apiMode: 'number',
      apiName: 'string',
      apiPath: 'string',
      folderId: 'number',
      groupId: 'string',
      projectId: 'number',
      protocols: 'string',
      registrationDetails: 'string',
      requestContentType: 'number',
      requestMethod: 'number',
      resourceGroupId: 'number',
      responseContentType: 'number',
      scriptDetails: 'string',
      sqlMode: 'number',
      tenantId: 'number',
      timeout: 'number',
      visibleRange: 'number',
      wizardDetails: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataServiceApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * @example
   * 100003
   */
  data?: number;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataServiceApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataServiceApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataServiceApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataServiceApiAuthorityRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  apiId?: number;
  /**
   * @remarks
   * The ID of the workspace to which the access permissions on the API are granted.
   * 
   * This parameter is required.
   * 
   * @example
   * 10002
   */
  authorizedProjectId?: number;
  /**
   * @remarks
   * The end time of the validity period of the access permissions. The time must be a UNIX timestamp. Unit: seconds. Example: 1600531564, which indicates 2020-09-20 00:06:04 (UTC+8).
   * 
   * This parameter is required.
   * 
   * @example
   * 1600531564
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10003
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 1004
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      authorizedProjectId: 'AuthorizedProjectId',
      endTime: 'EndTime',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      authorizedProjectId: 'number',
      endTime: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataServiceApiAuthorityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the authorization was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataServiceApiAuthorityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataServiceApiAuthorityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataServiceApiAuthorityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataServiceFolderRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the folder.
   * 
   * This parameter is required.
   * 
   * @example
   * Test folder
   */
  folderName?: string;
  /**
   * @remarks
   * The ID of the desired workflow to which the folder belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000abcd
   */
  groupId?: string;
  /**
   * @remarks
   * The ID of the desired parent folder of the folder. The ID of the root folder in a workflow is 0. The ID of the folder created by users in a workflow is greater than 0.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  parentId?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 10002
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      folderName: 'FolderName',
      groupId: 'GroupId',
      parentId: 'ParentId',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folderName: 'string',
      groupId: 'string',
      parentId: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataServiceFolderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the created folder.
   * 
   * @example
   * 123
   */
  folderId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      folderId: 'FolderId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folderId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataServiceFolderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataServiceFolderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataServiceFolderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataServiceGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group that is associated with the business process in the API Gateway console. You can log on to the API Gateway console and go to the Group Details page to view the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000abcd
   */
  apiGatewayGroupId?: string;
  /**
   * @remarks
   * The description of the business process.
   * 
   * @example
   * Test business process
   */
  description?: string;
  /**
   * @remarks
   * The name of the business process.
   * 
   * This parameter is required.
   * 
   * @example
   * Business process name
   */
  groupName?: string;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. This parameter is deprecated.
   * 
   * @example
   * 10002
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiGatewayGroupId: 'ApiGatewayGroupId',
      description: 'Description',
      groupName: 'GroupName',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiGatewayGroupId: 'string',
      description: 'string',
      groupName: 'string',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataServiceGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The business process ID.
   * 
   * @example
   * ds_12345
   */
  groupId?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EF****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataServiceGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataServiceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataServiceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataSourceRequest extends $tea.Model {
  /**
   * @remarks
   * The details of the data source. Examples of details of some common data sources:
   * 
   * *   odps
   * 
   *         {
   *           "accessId": "xssssss",
   *           "accessKey": "xsaxsaxsa",
   *           "authType": 2,
   *           "endpoint": "http://service.odps.aliyun.com/api",
   *           "project": "xsaxsax",
   *           "tag": "public"
   *         }
   * 
   * *   mysql
   * 
   *         {
   *           "database": "xsaxsa",
   *           "instanceName": "rm-xsaxsa",
   *           "password": "xsaxsa",
   *           "rdsOwnerId": "xasxsa",
   *           "regionId": "cn-shanghai",
   *           "tag": "rds",
   *           "username": "xsaxsa"
   *         }
   * 
   * *   rds
   * 
   *         {
   *           "configType": 1,
   *           "tag": "rds",
   *           "database": "xsaxsa",
   *           "username": "xsaxsa",
   *           "password": "xssaxsa$32050",
   *           "instanceName": "rm-xsaxs",
   *           "rdsOwnerId": "11111111"
   *         }
   * 
   * *   oss
   * 
   *         {
   *           "accessId": "sssssxx",
   *           "accessKey": "xsaxaxsaxs",
   *           "bucket": "xsa-xs-xs",
   *           "endpoint": "http://oss-cn-shanghai.aliyuncs.com",
   *           "tag": "public"
   *         }
   * 
   * *   sqlserver
   * 
   *         {
   *           "jdbcUrl": "jdbc:sqlserver://xsaxsa-xsaxsa.database.xxx.cn:123;DatabaseName=xsxs-xsxs",
   *           "password": "sdasda$fs",
   *           "tag": "public",
   *           "username": "sxaxacdacdd"
   *         }
   * 
   * *   polardb
   * 
   *         {
   *           "clusterId": "pc-sdadsadsa",
   *           "database": "dsadsadsa",
   *           "ownerId": "121212122",
   *           "password": "sdasdafssa",
   *           "region": "cn-shanghai",
   *           "tag": "polardb",
   *           "username": "asdadsads"
   *         }
   * 
   * *   redis
   * 
   *         {    
   *         "password": "xxxxxx",   
   *          "address":"[{\\"host\\":\\"xxxxxxx.redis.rds.aliyuncs.com\\",\\"port\\":6379}]",    
   *         "tag": "public"
   *         }
   * 
   * *   oracle
   * 
   *         {
   *           "jdbcUrl": "jdbc:oracle:saaa:@xxxxx:1521:PROD",
   *           "password": "sxasaxsa",
   *           "tag": "public",
   *           "username": "sasfadfa"
   *         }
   * 
   * *   mongodb
   * 
   *         {
   *           "address": "[\\"xsaxxsa.mongodb.rds.aliyuncs.com:3717\\"]",
   *           "database": "admin",
   *           "password": "sadsda@",
   *           "tag": "public",
   *           "username": "dsadsadas"
   *         }
   * 
   * *   emr
   * 
   *         {
   *           "accessId": "xsaxsa",
   *           "emrClusterId": "C-dsads",
   *           "emrResourceQueueName": "default",
   *           "emrEndpoint": "emr.aliyuncs.com",
   *           "accessKey": "dsadsad",
   *           "emrUserId": "224833315798889783",
   *           "name": "sasdsadsa",
   *           "emrAccessMode": "simple",
   *           "region": "cn-shanghai",
   *           "authType": "2",
   *           "emrProjectId": "FP-sdadsad"
   *         }
   * 
   * *   postgresql
   * 
   *         {
   *           "jdbcUrl": "jdbc:postgresql://xxxx:1921/ssss",
   *           "password": "sdadsads",
   *           "tag": "public",
   *           "username": "sdsasda"
   *         }
   * 
   * *   analyticdb_for_mysql
   * 
   *         {
   *           "instanceId": "am-sadsada",
   *           "database": "xsxsx",
   *           "username": "xsxsa",
   *           "password": "asdadsa",
   *           "connectionString": "am-xssxsxs.ads.aliyuncs.com:3306"
   *         }
   * 
   * *   hybriddb_for_postgresql
   * 
   *         {
   *           "connectionString": "gp-xsaxsaxa-master.gpdbmaster.rds.aliyuncs.com",
   *           "database": "xsaxsaxas",
   *           "password": "xsaxsaxsa@11",
   *           "instanceId": "gp-xsaxsaxsa",
   *           "port": "541132",
   *           "ownerId": "xsaxsaxsas",
   *           "username": "sadsad"
   *         }
   * 
   * *   holo
   * 
   *         {
   *           "accessId": "xsaxsaxs",
   *           "accessKey": "xsaxsaxsa",
   *           "database": "xsaxsaxsa",
   *           "instanceId": "xsaxa",
   *           "tag": "aliyun"
   *         }
   * 
   * *   kafka
   * 
   *         {
   *           "instanceId": "xsax-cn-xsaxsa",
   *           "regionId": "cn-shanghai",
   *           "tag": "aliyun",
   *           "ownerId": "1212121212112"
   *         }
   * 
   * This parameter is required.
   * 
   * @example
   * {"database":"dbname","instanceName":"instancename","password":"password","rdsOwnerId":"123","username":"username"}
   */
  content?: string;
  /**
   * @remarks
   * The type of the data source. Valid values:
   * 
   * *   odps
   * *   mysql
   * *   rds
   * *   oss
   * *   sqlserver
   * *   polardb
   * *   oracle
   * *   mongodb
   * *   emr
   * *   postgresql
   * *   analyticdb_for_mysql
   * *   hybriddb_for_postgresql
   * *   holo
   * 
   * This parameter is required.
   * 
   * @example
   * rds
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The description of the data source.
   * 
   * @example
   * abc
   */
  description?: string;
  /**
   * @remarks
   * The environment in which the data source is used. Valid values: 0 and 1. The value 0 indicates the development environment. The value 1 indicates the production environment.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The name of the data source.
   * 
   * This parameter is required.
   * 
   * @example
   * abc
   */
  name?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace to which the data source belongs. You can call the [ListProjects](https://help.aliyun.com/document_detail/2780068.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  projectId?: number;
  /**
   * @remarks
   * The subtype of the data source.
   * 
   * *   This parameter takes effect only if you set the DataSourceType parameter to rds.
   * *   If the DataSourceType parameter is set to rds, this parameter can be set to mysql, sqlserver, or postgresql.
   * 
   * @example
   * mysql
   */
  subType?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      dataSourceType: 'DataSourceType',
      description: 'Description',
      envType: 'EnvType',
      name: 'Name',
      projectId: 'ProjectId',
      subType: 'SubType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      dataSourceType: 'string',
      description: 'string',
      envType: 'number',
      name: 'string',
      projectId: 'number',
      subType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataSourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data source ID.
   * 
   * @example
   * 123
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc141151593763****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      httpStatusCode: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDataSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateExportMigrationRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the export task.
   * 
   * @example
   * test
   * 
   * **if can be null:**
   * true
   */
  description?: string;
  /**
   * @remarks
   * The export mode of the export task. Valid values:
   * 
   * *   FULL: The export task is used to export all data objects.
   * *   INCREMENTAL: The export task is used to export data objects that were modified since the specified point in time. If you set this parameter to INCREMENTAL, you must configure the IncrementalSince parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * FULL
   */
  exportMode?: string;
  /**
   * @remarks
   * The status of the data objects that you want to export in the export task. The system exports data objects in the state that is specified by this parameter. Valid values:
   * 
   * *   SAVED
   * *   SUBMITTED
   * *   DEPLOYED
   * 
   * @example
   * SAVED
   * 
   * **if can be null:**
   * true
   */
  exportObjectStatus?: string;
  /**
   * @remarks
   * The start time of the incremental export task.
   * 
   * The IncrementalSince parameter takes effect only when the ExportMode parameter is set to INCREMENTAL.
   * 
   * @example
   * 1589904000000
   * 
   * **if can be null:**
   * true
   */
  incrementalSince?: number;
  /**
   * @remarks
   * The name of the export task.
   * 
   * The name of each export task must be unique. You must ensure that no duplicate export task exists in the current workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * test_export_01
   */
  name?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      exportMode: 'ExportMode',
      exportObjectStatus: 'ExportObjectStatus',
      incrementalSince: 'IncrementalSince',
      name: 'Name',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      exportMode: 'string',
      exportObjectStatus: 'string',
      incrementalSince: 'number',
      name: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateExportMigrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The export task ID.
   * 
   * @example
   * 1234
   */
  data?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 34267E2E-0335-1A60-A1F0-ADA530890CBA
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateExportMigrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateExportMigrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateExportMigrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileRequest extends $tea.Model {
  /**
   * @remarks
   * The advanced configurations of the node.
   * 
   * This parameter is valid only for an EMR Spark Streaming node or an EMR Streaming SQL node. This parameter corresponds to the Advanced Settings tab of the node in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * The value of this parameter must be in the JSON format.
   * 
   * @example
   * {"queue":"default","SPARK_CONF":"--conf spark.driver.memory=2g"}
   */
  advancedSettings?: string;
  /**
   * @remarks
   * Specifies whether scheduling configurations immediately take effect after the node is deployed.
   * 
   * @example
   * true
   */
  applyScheduleImmediately?: boolean;
  /**
   * @remarks
   * Specifies whether to enable the automatic parsing feature for the file. Valid values:
   * 
   * *   true
   * *   false
   * 
   * This parameter corresponds to the Analyze Code parameter that is displayed after Same Cycle is selected in the Dependencies section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * true
   */
  autoParsing?: boolean;
  /**
   * @remarks
   * The interval between automatic reruns after an error occurs. Unit: milliseconds. Maximum value: 1800000 (30 minutes).
   * 
   * This parameter corresponds to the Rerun Interval parameter that is displayed after the Auto Rerun upon Error check box is selected in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * The interval that you specify in the DataWorks console is measured in minutes. Pay attention to the conversion between the units of time when you call the operation.
   * 
   * @example
   * 120000
   */
  autoRerunIntervalMillis?: number;
  /**
   * @remarks
   * The number of automatic reruns that are allowed after an error occurs. Maximum value: 10.
   * 
   * @example
   * 3
   */
  autoRerunTimes?: number;
  /**
   * @remarks
   * The name of the data source for which the node is run.
   * 
   * You can call the [UpdateDataSource](https://help.aliyun.com/document_detail/211432.html) operation to query the available data sources in the workspace.
   * 
   * @example
   * odps_first
   */
  connectionName?: string;
  /**
   * @remarks
   * The code for the file. The code format varies based on the file type. To view the code format for a specific file type, go to Operation Center, right-click a node of the file type, and then select View Code.
   * 
   * @example
   * SHOW TABLES;
   */
  content?: string;
  /**
   * @example
   * false
   */
  createFolderIfNotExists?: boolean;
  /**
   * @remarks
   * The CRON expression that represents the periodic scheduling policy of the node. This parameter corresponds to the Cron Expression parameter in the Schedule section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console). After you configure the Scheduling Cycle and Scheduled time parameters in the DataWorks console, DataWorks generates the value of the Cron Expression parameter.
   * 
   * Examples:
   * 
   * *   CRON expression for a node that is scheduled to run at 05:30 every day: `00 30 05 * * ?`
   * *   CRON expression for a node that is scheduled to run at the fifteenth minute of each hour: `00 15 00-23/1 * * ?`
   * *   CRON expression for a node that is scheduled to run every 10 minutes: `00 00/10 * * * ?`
   * *   CRON expression for a node that is scheduled to run every 10 minutes from 08:00 to 17:00 every day: `00 00-59/10 8-17 * * * ?`
   * *   CRON expression for a node that is scheduled to run at 00:20 on the first day of each month: `00 20 00 1 * ?`
   * *   CRON expression for a node that is scheduled to run every three months from 00:10 on January 1: `00 10 00 1 1-12/3 ?`
   * *   CRON expression for a node that is scheduled to run at 00:05 every Tuesday and Friday: `00 05 00 * * 2,5`
   * 
   * The scheduling system of DataWorks imposes the following limits on CRON expressions:
   * 
   * *   The minimum interval specified in a CRON expression to schedule a node is 5 minutes.
   * *   The earliest time specified in a CRON expression to schedule a node every day is 00:05.
   * 
   * @example
   * 00 05 00 * * ?
   */
  cronExpress?: string;
  /**
   * @remarks
   * The type of the scheduling cycle of the node that corresponds to the file. Valid values: NOT_DAY and DAY. The value NOT_DAY indicates that the node is scheduled to run by minute or hour. The value DAY indicates that the node is scheduled to run by day, week, or month.
   * 
   * This parameter corresponds to the Scheduling Cycle parameter in the Schedule section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * DAY
   */
  cycleType?: string;
  /**
   * @remarks
   * The IDs of the nodes that generate instances in the previous cycle on which the current node depends.
   * 
   * @example
   * abc
   */
  dependentNodeIdList?: string;
  /**
   * @remarks
   * The type of the cross-cycle scheduling dependency of the node. Valid values:
   * 
   * *   SELF: The instance generated for the node in the current cycle depends on the instance generated for the node in the previous cycle.
   * *   CHILD: The instance generated for the node in the current cycle depends on the instances generated for the descendant nodes at the nearest level of the node in the previous cycle.
   * *   USER_DEFINE: The instance generated for the node in the current cycle depends on the instances generated for one or more specified nodes in the previous cycle.
   * *   NONE: No cross-cycle scheduling dependency type is selected for the node.
   * *   USER_DEFINE_AND_SELF: The instance generated for the node in the current cycle depends on the instance generated for the node in the previous cycle and the instances generated for one or more specified nodes in the previous cycle.
   * *   CHILD_AND_SELF: The instance generated for the node in the current cycle depends on the instances generated for the descendant nodes at the nearest level of the node in the previous cycle and the instance generated for the node in the previous cycle.
   * 
   * @example
   * NONE
   */
  dependentType?: string;
  /**
   * @remarks
   * The end time of automatic scheduling. Set the value to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * This parameter corresponds to the Validity Period parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * 1671694850000
   */
  endEffectDate?: number;
  /**
   * @remarks
   * The description of the file.
   */
  fileDescription?: string;
  /**
   * @remarks
   * The path of the file.
   */
  fileFolderPath?: string;
  /**
   * @remarks
   * The name of the file.
   * 
   * This parameter is required.
   */
  fileName?: string;
  /**
   * @remarks
   * The type of the code in the file.
   * 
   * Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3).
   * 
   * You can call the [ListFileType](https://help.aliyun.com/document_detail/212428.html) operation to query the type of the code for the file.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  fileType?: number;
  /**
   * @example
   * false
   */
  ignoreParentSkipRunningProperty?: boolean;
  /**
   * @remarks
   * The output name of the parent file on which the current file depends. If you specify multiple output names, separate them with commas (,).
   * 
   * This parameter corresponds to the Output Name parameter under Parent Nodes in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * project_root,project.file1,project.001_out
   */
  inputList?: string;
  /**
   * @remarks
   * The input parameters of the node. The value of this parameter must be in the JSON format. For more information about the input parameters, see the InputContextParameterList parameter in the Response parameters section of the [GetFile](https://help.aliyun.com/document_detail/173954.html) operation.
   * 
   * This parameter corresponds to the Input Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * [{"ValueSource": "project_001.first_node:bizdate_param","ParameterName": "bizdate_input"}]
   */
  inputParameters?: string;
  /**
   * @remarks
   * The output parameters of the node. The value of this parameter must be in the JSON format. For more information about the output parameters, see the OutputContextParameterList parameter in the Response parameters section of the [GetFile](https://help.aliyun.com/document_detail/173954.html) operation.
   * 
   * This parameter corresponds to the Output Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * [{"Type": 1,"Value": "${bizdate}","ParameterName": "bizdate_param"}]
   */
  outputParameters?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the file owner. If this parameter is not configured, the ID of the Alibaba Cloud account of the user who calls the operation is used.
   * 
   * @example
   * 1000000000001
   */
  owner?: string;
  /**
   * @remarks
   * The scheduling parameters of the node. Separate multiple parameters with spaces.
   * 
   * This parameter corresponds to the Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console). For more information about the configurations of the scheduling parameters, see [Configure scheduling parameters](https://help.aliyun.com/document_detail/137548.html).
   * 
   * @example
   * a=x b=y
   */
  paraValue?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
   * 
   * You must configure this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace name.
   * 
   * You must configure this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  /**
   * @remarks
   * Specifies whether the node that corresponds to the file can be rerun. Valid values:
   * 
   * *   ALL_ALLOWED: The node can be rerun regardless of whether it is successfully run or fails to run.
   * *   FAILURE_ALLOWED: The node can be rerun only after it fails to run.
   * *   ALL_DENIED: The node cannot be rerun regardless of whether it is successfully run or fails to run.
   * 
   * This parameter corresponds to the Rerun parameter in the Schedule section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * ALL_ALLOWED
   */
  rerunMode?: string;
  /**
   * @remarks
   * This parameter is deprecated. Do not use this parameter.
   * 
   * The identifier of the resource group that is used to run the node. This parameter corresponds to the Resource Group parameter in the Resource Group section of the Properties tab in the DataWorks console. You must configure one of the ResourceGroupId and ResourceGroupIdentifier parameters to determine the resource group that is used to run the node.
   * 
   * You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/173913.html) operation to query the available resource groups in the workspace. When you call the operation, set the ResourceGroupType parameter to 1. The response parameter Id indicates the ID of an available resource group.
   * 
   * @example
   * 375827434852437
   */
  resourceGroupId?: number;
  /**
   * @remarks
   * The identifier of the resource group that is used to run the node. You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/173913.html) operation to query the available resource groups in the workspace. The **Identifier** parameter in the response of the operation indicates the identifier of an available resource group.
   * 
   * >  You must make sure that the available resource groups in the response of the ListResourceGroups operation are associated with the workspace for which you want to create a file by calling the CreateFile operation.
   * 
   * @example
   * group_375827434852437
   */
  resourceGroupIdentifier?: string;
  /**
   * @remarks
   * The scheduling type of the node. Valid values:
   * 
   * *   NORMAL: The node is an auto triggered node.
   * *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered. They correspond to the nodes in the Manually Triggered Workflows pane.
   * *   PAUSE: The node is a paused node.
   * *   SKIP: The node is a dry-run node. Dry-run nodes are started as scheduled, but the system sets the status of the nodes to successful when it starts to run them
   * 
   * @example
   * NORMAL
   */
  schedulerType?: string;
  /**
   * @remarks
   * The start time of automatic scheduling. Set the value to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * Configuring this parameter is equivalent to specifying a start time for the Validity Period parameter in the Schedule section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * 1671608450000
   */
  startEffectDate?: number;
  /**
   * @remarks
   * Specifies whether to immediately run a node after the node is deployed.
   * 
   * This parameter is valid only for an EMR Spark Streaming node or an EMR Streaming SQL node. This parameter corresponds to the Start Method parameter in the Schedule section of the Configure tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * true
   */
  startImmediately?: boolean;
  /**
   * @remarks
   * Specifies whether to suspend the scheduling of the node. Valid values:
   * 
   * *   true
   * *   false
   * 
   * This parameter corresponds to the Recurrence parameter in the Schedule section of the Properties tab on the DataStudio page in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * false
   */
  stop?: boolean;
  static names(): { [key: string]: string } {
    return {
      advancedSettings: 'AdvancedSettings',
      applyScheduleImmediately: 'ApplyScheduleImmediately',
      autoParsing: 'AutoParsing',
      autoRerunIntervalMillis: 'AutoRerunIntervalMillis',
      autoRerunTimes: 'AutoRerunTimes',
      connectionName: 'ConnectionName',
      content: 'Content',
      createFolderIfNotExists: 'CreateFolderIfNotExists',
      cronExpress: 'CronExpress',
      cycleType: 'CycleType',
      dependentNodeIdList: 'DependentNodeIdList',
      dependentType: 'DependentType',
      endEffectDate: 'EndEffectDate',
      fileDescription: 'FileDescription',
      fileFolderPath: 'FileFolderPath',
      fileName: 'FileName',
      fileType: 'FileType',
      ignoreParentSkipRunningProperty: 'IgnoreParentSkipRunningProperty',
      inputList: 'InputList',
      inputParameters: 'InputParameters',
      outputParameters: 'OutputParameters',
      owner: 'Owner',
      paraValue: 'ParaValue',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
      rerunMode: 'RerunMode',
      resourceGroupId: 'ResourceGroupId',
      resourceGroupIdentifier: 'ResourceGroupIdentifier',
      schedulerType: 'SchedulerType',
      startEffectDate: 'StartEffectDate',
      startImmediately: 'StartImmediately',
      stop: 'Stop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advancedSettings: 'string',
      applyScheduleImmediately: 'boolean',
      autoParsing: 'boolean',
      autoRerunIntervalMillis: 'number',
      autoRerunTimes: 'number',
      connectionName: 'string',
      content: 'string',
      createFolderIfNotExists: 'boolean',
      cronExpress: 'string',
      cycleType: 'string',
      dependentNodeIdList: 'string',
      dependentType: 'string',
      endEffectDate: 'number',
      fileDescription: 'string',
      fileFolderPath: 'string',
      fileName: 'string',
      fileType: 'number',
      ignoreParentSkipRunningProperty: 'boolean',
      inputList: 'string',
      inputParameters: 'string',
      outputParameters: 'string',
      owner: 'string',
      paraValue: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
      rerunMode: 'string',
      resourceGroupId: 'number',
      resourceGroupIdentifier: 'string',
      schedulerType: 'string',
      startEffectDate: 'number',
      startImmediately: 'boolean',
      stop: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the file that was created.
   * 
   * @example
   * 1000001
   */
  data?: number;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFolderRequest extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * This parameter is required.
   */
  folderPath?: string;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace name. You must configure either the ProjectId or ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The path of the folder.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      folderPath: 'FolderPath',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folderPath: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFolderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * bdfd68****
   */
  data?: string;
  /**
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The unique identifier of the folder.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFolderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateFolderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFolderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImportMigrationRequest extends $tea.Model {
  /**
   * @remarks
   * The mapping between the source compute engine instance and the destination compute engine instance. The following types of compute engine instances are supported: MaxCompute, E-MapReduce (EMR), Hadoop CDH, and Hologres.
   * 
   * @example
   * {     "ODPS": {       "zxy_8221431_engine": "wzp_kaifazheban_engine"     },     "EMR": {         "aaaa": "bbb"     }   }
   */
  calculateEngineMap?: string;
  /**
   * @remarks
   * The rule configured for automatically committing and deploying the import task. The rule contains the following parameters:
   * 
   * *   resourceAutoCommit: specifies whether resources are automatically committed. The value true indicates yes and the value false indicates no.
   * *   resourceAutoDeploy: specifies whether resources are automatically deployed. The value true indicates yes and the value false indicates no.
   * *   functionAutoCommit: specifies whether the function is automatically committed. The value true indicates yes and the value false indicates no.
   * *   functionAutoDeploy: specifies whether the function is automatically deployed. The value true indicates yes and the value false indicates no.
   * *   tableAutoCommitToDev: specifies whether the table is automatically committed to the development environment. The value true indicates yes and the value false indicates no.
   * *   tableAutoCommitToProd: specifies whether the table is automatically committed to the production environment. The value true indicates yes and the value false indicates no.
   * *   ignoreLock: specifies whether the lock is automatically ignored when an import task is locked. The value true indicates yes and the value false indicates no. If you set this parameter to true for an import task, you can forcefully update the task even if the task is locked.
   * *   fileAutoCommit: specifies whether the file is automatically committed. The value true indicates yes and the value false indicates no.
   * *   fileAutoDeploy: specifies whether the file is automatically deployed. The value true indicates yes and the value false indicates no.
   * 
   * @example
   * {     "resourceAutoCommit": false,     "resourceAutoDeploy": false,     "functionAutoCommit": false,     "functionAutoDeploy": false,     "tableAutoCommitToDev": false,     "tableAutoCommitToProd": false,     "ignoreLock": false,     "fileAutoCommit": false,     "fileAutoDeploy": false   }
   */
  commitRule?: string;
  /**
   * @remarks
   * The description of the import package.
   * 
   * @example
   * test description
   */
  description?: string;
  /**
   * @remarks
   * The name of the import task. The name must be unique within the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * test_import_001
   */
  name?: string;
  /**
   * @remarks
   * The path of the import package. **The import package must be uploaded. Example of the upload method:**
   * 
   * ```java
   *         Config config = new Config();
   *         config.setAccessKeyId(accessId);
   *         config.setAccessKeySecret(accessKey);
   *         config.setEndpoint(popEndpoint);
   *         config.setRegionId(regionId);
   * 
   *         Client client = new Client(config);
   * 
   *         CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest();
   *         request.setName("test_migration_api_" + System.currentTimeMillis());
   *         request.setProjectId(123456L); 
   *         request.setPackageType("DATAWORKS_MODEL");
   *         request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip"));
   * 
   *         RuntimeOptions runtime = new RuntimeOptions();
   *         CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime);
   * ```
   * 
   * This parameter is required.
   * 
   * @example
   * /home/admin/xxx/import.zip
   */
  packageFile?: string;
  /**
   * @remarks
   * The type of the import package. Valid values:
   * 
   * *   DATAWORKS_MODEL (standard format)
   * *   DATAWORKS_V2 (Apsara Stack DataWorks V3.6.1 to V3.11)
   * *   DATAWORKS_V3 (Apsara Stack DataWorks V3.12 and later)
   * 
   * This parameter is required.
   * 
   * @example
   * DATAWORKS_MODEL
   */
  packageType?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  projectId?: number;
  /**
   * @remarks
   * The mapping between the resource group for scheduling and the resource group for Data Integration. The keys and values in the mapping are the identifiers of the resource groups. Specify the mapping in the following format:
   * 
   * ```json
   * {
   *     "SCHEDULER_RESOURCE_GROUP": {
   *         "xxx": "yyy"
   *     },
   *     "DI_RESOURCE_GROUP": {
   *         "ccc": "dfdd"
   *     }
   * }
   * ```
   * 
   * @example
   * {"SCHEDULER_RESOURCE_GROUP": {"xxx":"yyy"},"DI_RESOURCE_GROUP":{"ccc":"ddd"}}
   */
  resourceGroupMap?: string;
  /**
   * @remarks
   * The mapping between the prefixes for the names of the source and destination workspaces. When the system performs the import operation, the prefix for the name of the source workspace in the import package is replaced based on the mapping.
   * 
   * @example
   * {"test_workspace_src": "test_workspace_target"}
   */
  workspaceMap?: string;
  static names(): { [key: string]: string } {
    return {
      calculateEngineMap: 'CalculateEngineMap',
      commitRule: 'CommitRule',
      description: 'Description',
      name: 'Name',
      packageFile: 'PackageFile',
      packageType: 'PackageType',
      projectId: 'ProjectId',
      resourceGroupMap: 'ResourceGroupMap',
      workspaceMap: 'WorkspaceMap',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calculateEngineMap: 'string',
      commitRule: 'string',
      description: 'string',
      name: 'string',
      packageFile: 'string',
      packageType: 'string',
      projectId: 'number',
      resourceGroupMap: 'string',
      workspaceMap: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImportMigrationAdvanceRequest extends $tea.Model {
  /**
   * @remarks
   * The mapping between the source compute engine instance and the destination compute engine instance. The following types of compute engine instances are supported: MaxCompute, E-MapReduce (EMR), Hadoop CDH, and Hologres.
   * 
   * @example
   * {     "ODPS": {       "zxy_8221431_engine": "wzp_kaifazheban_engine"     },     "EMR": {         "aaaa": "bbb"     }   }
   */
  calculateEngineMap?: string;
  /**
   * @remarks
   * The rule configured for automatically committing and deploying the import task. The rule contains the following parameters:
   * 
   * *   resourceAutoCommit: specifies whether resources are automatically committed. The value true indicates yes and the value false indicates no.
   * *   resourceAutoDeploy: specifies whether resources are automatically deployed. The value true indicates yes and the value false indicates no.
   * *   functionAutoCommit: specifies whether the function is automatically committed. The value true indicates yes and the value false indicates no.
   * *   functionAutoDeploy: specifies whether the function is automatically deployed. The value true indicates yes and the value false indicates no.
   * *   tableAutoCommitToDev: specifies whether the table is automatically committed to the development environment. The value true indicates yes and the value false indicates no.
   * *   tableAutoCommitToProd: specifies whether the table is automatically committed to the production environment. The value true indicates yes and the value false indicates no.
   * *   ignoreLock: specifies whether the lock is automatically ignored when an import task is locked. The value true indicates yes and the value false indicates no. If you set this parameter to true for an import task, you can forcefully update the task even if the task is locked.
   * *   fileAutoCommit: specifies whether the file is automatically committed. The value true indicates yes and the value false indicates no.
   * *   fileAutoDeploy: specifies whether the file is automatically deployed. The value true indicates yes and the value false indicates no.
   * 
   * @example
   * {     "resourceAutoCommit": false,     "resourceAutoDeploy": false,     "functionAutoCommit": false,     "functionAutoDeploy": false,     "tableAutoCommitToDev": false,     "tableAutoCommitToProd": false,     "ignoreLock": false,     "fileAutoCommit": false,     "fileAutoDeploy": false   }
   */
  commitRule?: string;
  /**
   * @remarks
   * The description of the import package.
   * 
   * @example
   * test description
   */
  description?: string;
  /**
   * @remarks
   * The name of the import task. The name must be unique within the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * test_import_001
   */
  name?: string;
  /**
   * @remarks
   * The path of the import package. **The import package must be uploaded. Example of the upload method:**
   * 
   * ```java
   *         Config config = new Config();
   *         config.setAccessKeyId(accessId);
   *         config.setAccessKeySecret(accessKey);
   *         config.setEndpoint(popEndpoint);
   *         config.setRegionId(regionId);
   * 
   *         Client client = new Client(config);
   * 
   *         CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest();
   *         request.setName("test_migration_api_" + System.currentTimeMillis());
   *         request.setProjectId(123456L); 
   *         request.setPackageType("DATAWORKS_MODEL");
   *         request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip"));
   * 
   *         RuntimeOptions runtime = new RuntimeOptions();
   *         CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime);
   * ```
   * 
   * This parameter is required.
   * 
   * @example
   * /home/admin/xxx/import.zip
   */
  packageFileObject?: Readable;
  /**
   * @remarks
   * The type of the import package. Valid values:
   * 
   * *   DATAWORKS_MODEL (standard format)
   * *   DATAWORKS_V2 (Apsara Stack DataWorks V3.6.1 to V3.11)
   * *   DATAWORKS_V3 (Apsara Stack DataWorks V3.12 and later)
   * 
   * This parameter is required.
   * 
   * @example
   * DATAWORKS_MODEL
   */
  packageType?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  projectId?: number;
  /**
   * @remarks
   * The mapping between the resource group for scheduling and the resource group for Data Integration. The keys and values in the mapping are the identifiers of the resource groups. Specify the mapping in the following format:
   * 
   * ```json
   * {
   *     "SCHEDULER_RESOURCE_GROUP": {
   *         "xxx": "yyy"
   *     },
   *     "DI_RESOURCE_GROUP": {
   *         "ccc": "dfdd"
   *     }
   * }
   * ```
   * 
   * @example
   * {"SCHEDULER_RESOURCE_GROUP": {"xxx":"yyy"},"DI_RESOURCE_GROUP":{"ccc":"ddd"}}
   */
  resourceGroupMap?: string;
  /**
   * @remarks
   * The mapping between the prefixes for the names of the source and destination workspaces. When the system performs the import operation, the prefix for the name of the source workspace in the import package is replaced based on the mapping.
   * 
   * @example
   * {"test_workspace_src": "test_workspace_target"}
   */
  workspaceMap?: string;
  static names(): { [key: string]: string } {
    return {
      calculateEngineMap: 'CalculateEngineMap',
      commitRule: 'CommitRule',
      description: 'Description',
      name: 'Name',
      packageFileObject: 'PackageFile',
      packageType: 'PackageType',
      projectId: 'ProjectId',
      resourceGroupMap: 'ResourceGroupMap',
      workspaceMap: 'WorkspaceMap',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calculateEngineMap: 'string',
      commitRule: 'string',
      description: 'string',
      name: 'string',
      packageFileObject: 'Readable',
      packageType: 'string',
      projectId: 'number',
      resourceGroupMap: 'string',
      workspaceMap: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImportMigrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The import task ID. The ID is used as an input parameter if you want the system to run the import task or you want to obtain the running progress of the import task.
   * 
   * @example
   * 123456
   */
  data?: number;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 110001123456
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * test error message
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * ADFASDFASDFA-ADFASDF-ASDFADSDF-AFFADS
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateImportMigrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateImportMigrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateImportMigrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateManualDagRequest extends $tea.Model {
  /**
   * @remarks
   * The data timestamp. The value of the data timestamp must be one or more days before the current date. For example, if the current date is November 11, 2020, set the value to 2020-11-10 00:00:00 or earlier. Configure this parameter in the YYYY-MM-DD 00:00:00 format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-11-11 00:00:00
   */
  bizDate?: string;
  /**
   * @remarks
   * The parameters of the manually triggered workflow, which are synchronized to all the instances in the directed acyclic graph (DAG) of the workflow. If a workflow parameter specified in DagParameters is referenced as a scheduling parameter of a node, the value of the scheduling parameter is replaced with the value of the workflow parameter.
   * 
   * @example
   * {"kaaaa": "vaaaaa", "kbbbb": "vbbbbb"}
   */
  dagParameters?: string;
  /**
   * @remarks
   * The IDs of the nodes that do not need to be run.
   * 
   * @example
   * 123,456
   */
  excludeNodeIds?: string;
  /**
   * @remarks
   * The name of the manually triggered workflow.
   * 
   * This parameter is required.
   * 
   * @example
   * test_workflow
   */
  flowName?: string;
  /**
   * @remarks
   * The IDs of the nodes that you want to run.
   * 
   * @example
   * 74324,74325
   */
  includeNodeIds?: string;
  /**
   * @remarks
   * The parameters transmitted between nodes in the manually triggered workflow. The parameters are in the following JSON format: `{ "<ID of a node in the manually triggered workflow>": "Scheduling parameter settings of the node, which are in the same format as the parameters in the Scheduling Parameter section on the Properties tab of the DataStudio page", "<ID of a node in the manually triggered workflow>": "Scheduling parameter settings of the node, which are in the same format as the parameters in the Scheduling Parameter section on the Properties tab of the DataStudio page" }`
   * 
   * @example
   * {"20000123121": "key1=val2 key2=val2", "20000123124": "kkkk=vvvvv aaaa=bbbb"}
   */
  nodeParameters?: string;
  /**
   * @remarks
   * The environment type of Operation Center. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   */
  projectEnv?: string;
  /**
   * @remarks
   * The name of the workspace to which the manually triggered workflow belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * test_workspace
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      bizDate: 'BizDate',
      dagParameters: 'DagParameters',
      excludeNodeIds: 'ExcludeNodeIds',
      flowName: 'FlowName',
      includeNodeIds: 'IncludeNodeIds',
      nodeParameters: 'NodeParameters',
      projectEnv: 'ProjectEnv',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizDate: 'string',
      dagParameters: 'string',
      excludeNodeIds: 'string',
      flowName: 'string',
      includeNodeIds: 'string',
      nodeParameters: 'string',
      projectEnv: 'string',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateManualDagResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the DAG for the manually triggered workflow. You can call an operation with this parameter as a request parameter to query the details and states of the nodes in the manually triggered workflow.
   * 
   * @example
   * 700000123123141
   */
  dagId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * AASFDFSDFG-DFSDF-DFSDFD-SDFSDF
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateManualDagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateManualDagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateManualDagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetaCategoryRequest extends $tea.Model {
  /**
   * @remarks
   * The remarks of the category.
   * 
   * @example
   * category 1
   */
  comment?: string;
  /**
   * @remarks
   * The name of the category.
   * 
   * This parameter is required.
   * 
   * @example
   * category_name
   */
  name?: string;
  /**
   * @remarks
   * The ID of the parent category.
   * 
   * @example
   * 0
   */
  parentId?: number;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      name: 'Name',
      parentId: 'ParentId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      name: 'string',
      parentId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetaCategoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the category.
   */
  data?: CreateMetaCategoryResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: CreateMetaCategoryResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetaCategoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMetaCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMetaCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetaCollectionRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the collection.
   * 
   * This parameter is required.
   * 
   * @example
   * ALBUM
   */
  collectionType?: string;
  /**
   * @remarks
   * The comment of the collection. The comment must be 1 to 64 characters in length.
   * 
   * @example
   * this is a comment
   */
  comment?: string;
  /**
   * @remarks
   * The name of the collection. The name must be 1 to 32 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * collection_name
   */
  name?: string;
  /**
   * @remarks
   * The unique identifier of the parent collection.
   * 
   * @example
   * album.333508
   */
  parentQualifiedName?: string;
  static names(): { [key: string]: string } {
    return {
      collectionType: 'CollectionType',
      comment: 'Comment',
      name: 'Name',
      parentQualifiedName: 'ParentQualifiedName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      collectionType: 'string',
      comment: 'string',
      name: 'string',
      parentQualifiedName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetaCollectionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * NoPermission
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The unique identifier of the collection.
   * 
   * @example
   * album.11111
   */
  qualifiedName?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      qualifiedName: 'QualifiedName',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'string',
      qualifiedName: 'string',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetaCollectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateMetaCollectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMetaCollectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePermissionApplyOrderRequest extends $tea.Model {
  /**
   * @remarks
   * The objects on which you want to request permissions.
   * 
   * This parameter is required.
   */
  applyObject?: CreatePermissionApplyOrderRequestApplyObject[];
  /**
   * @remarks
   * The reason for your request. The administrator determines whether to approve the request based on the reason.
   * 
   * This parameter is required.
   * 
   * @example
   * I need to use this table
   */
  applyReason?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account for which you want to request permissions. If you want to request permissions for multiple Alibaba Cloud accounts, separate the IDs of the accounts with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * 267842600408993176,267842600408993177
   */
  applyUserIds?: string;
  /**
   * @remarks
   * The expiration time of the permissions that you request. This value is a UNIX timestamp. The default value is January 1, 2065. If LabelSecurity is disabled for the MaxCompute project in which you want to request permissions on the fields of a table, or the security level of the fields is 0 or is lower than or equal to the security level of the Alibaba Cloud account for which you want to request permissions, you can request only permanent permissions. You can go to the Workspace Management page in the DataWorks console, click MaxCompute Management in the left-side navigation pane, and then check whether column-level access control is enabled. You can go to your DataWorks workspace, view the security level of the fields in Data Map, and then view the security level of the Alibaba Cloud account on the User Management page.
   * 
   * @example
   * 1617115071885
   */
  deadline?: number;
  /**
   * @remarks
   * The type of the compute engine in which you want to request permissions on the fields of a table. The parameter value is odps and cannot be changed. This value indicates that you can request permissions only on fields of tables in the MaxCompute compute engine.
   * 
   * @example
   * odps
   */
  engineType?: string;
  /**
   * @remarks
   * The name of the MaxCompute project in which you request permissions on the fields of a table.
   * 
   * This parameter is required.
   * 
   * @example
   * aMaxcomputeProjectName
   */
  maxComputeProjectName?: string;
  /**
   * @remarks
   * The type of the permission request order. The parameter value is 1 and cannot be changed. This value indicates ACL-based authorization.
   * 
   * @example
   * 1
   */
  orderType?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace that is associated with the MaxCompute project in which you want to request permissions on the fields of a table. You can go to the SettingCenter page in the DataWorks console to view the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  workspaceId?: number;
  static names(): { [key: string]: string } {
    return {
      applyObject: 'ApplyObject',
      applyReason: 'ApplyReason',
      applyUserIds: 'ApplyUserIds',
      deadline: 'Deadline',
      engineType: 'EngineType',
      maxComputeProjectName: 'MaxComputeProjectName',
      orderType: 'OrderType',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyObject: { 'type': 'array', 'itemType': CreatePermissionApplyOrderRequestApplyObject },
      applyReason: 'string',
      applyUserIds: 'string',
      deadline: 'number',
      engineType: 'string',
      maxComputeProjectName: 'string',
      orderType: 'number',
      workspaceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePermissionApplyOrderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request order ID.
   */
  flowId?: string[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      flowId: 'FlowId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flowId: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePermissionApplyOrderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePermissionApplyOrderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePermissionApplyOrderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequest extends $tea.Model {
  /**
   * @remarks
   * The client token that is used to ensure the idempotence of the request. This parameter can be left empty.
   * 
   * @example
   * ABFUOEUOTRTRJKE
   */
  clientToken?: string;
  /**
   * @remarks
   * Specifies whether to disable the Develop role. Valid values:
   * 
   * *   **false** (default)
   * *   **true**
   * 
   * @example
   * false
   */
  disableDevelopment?: boolean;
  /**
   * @remarks
   * Specifies whether to allow you to download the query result from DataStudio. Valid values:
   * 
   * *   **1** (default): allows you to download the query result from DataStudio.
   * *   **0**: does not allow you to download the query result from DataStudio.
   * 
   * @example
   * 1
   */
  isAllowDownload?: number;
  /**
   * @remarks
   * The description of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * test_describe
   */
  projectDescription?: string;
  /**
   * @remarks
   * The name of the workspace. The name can contain only letters, digits, and underscores (_) and must start with a letter or digit.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  projectIdentifier?: string;
  /**
   * @remarks
   * The mode of the workspace. For more information about the differences between the modes of workspaces, see [Differences between workspaces in basic mode and workspaces in standard mode](https://help.aliyun.com/document_detail/85772.html).
   * 
   * Valid values:
   * 
   * *   **2** (default): basic mode
   * *   **3**: standard mode
   * 
   * @example
   * 3
   */
  projectMode?: number;
  /**
   * @remarks
   * The display name of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  projectName?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmzbn7pti3****
   */
  resourceManagerResourceGroupId?: string;
  /**
   * @remarks
   * The tags added to the workspace.
   */
  tags?: CreateProjectRequestTags[];
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      disableDevelopment: 'DisableDevelopment',
      isAllowDownload: 'IsAllowDownload',
      projectDescription: 'ProjectDescription',
      projectIdentifier: 'ProjectIdentifier',
      projectMode: 'ProjectMode',
      projectName: 'ProjectName',
      resourceManagerResourceGroupId: 'ResourceManagerResourceGroupId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      disableDevelopment: 'boolean',
      isAllowDownload: 'number',
      projectDescription: 'string',
      projectIdentifier: 'string',
      projectMode: 'number',
      projectName: 'string',
      resourceManagerResourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': CreateProjectRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The client token that is used to ensure the idempotence of the request. This parameter can be left empty.
   * 
   * @example
   * ABFUOEUOTRTRJKE
   */
  clientToken?: string;
  /**
   * @remarks
   * Specifies whether to disable the Develop role. Valid values:
   * 
   * *   **false** (default)
   * *   **true**
   * 
   * @example
   * false
   */
  disableDevelopment?: boolean;
  /**
   * @remarks
   * Specifies whether to allow you to download the query result from DataStudio. Valid values:
   * 
   * *   **1** (default): allows you to download the query result from DataStudio.
   * *   **0**: does not allow you to download the query result from DataStudio.
   * 
   * @example
   * 1
   */
  isAllowDownload?: number;
  /**
   * @remarks
   * The description of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * test_describe
   */
  projectDescription?: string;
  /**
   * @remarks
   * The name of the workspace. The name can contain only letters, digits, and underscores (_) and must start with a letter or digit.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  projectIdentifier?: string;
  /**
   * @remarks
   * The mode of the workspace. For more information about the differences between the modes of workspaces, see [Differences between workspaces in basic mode and workspaces in standard mode](https://help.aliyun.com/document_detail/85772.html).
   * 
   * Valid values:
   * 
   * *   **2** (default): basic mode
   * *   **3**: standard mode
   * 
   * @example
   * 3
   */
  projectMode?: number;
  /**
   * @remarks
   * The display name of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  projectName?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmzbn7pti3****
   */
  resourceManagerResourceGroupId?: string;
  /**
   * @remarks
   * The tags added to the workspace.
   */
  tagsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      disableDevelopment: 'DisableDevelopment',
      isAllowDownload: 'IsAllowDownload',
      projectDescription: 'ProjectDescription',
      projectIdentifier: 'ProjectIdentifier',
      projectMode: 'ProjectMode',
      projectName: 'ProjectName',
      resourceManagerResourceGroupId: 'ResourceManagerResourceGroupId',
      tagsShrink: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      disableDevelopment: 'boolean',
      isAllowDownload: 'number',
      projectDescription: 'string',
      projectIdentifier: 'string',
      projectMode: 'number',
      projectName: 'string',
      resourceManagerResourceGroupId: 'string',
      tagsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 466230
   */
  data?: number;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1AFAE64E-D1BE-432B-A9****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectMemberRequest extends $tea.Model {
  /**
   * @remarks
   * The client token that is used to ensure the idempotence of the request. We recommend that you set this parameter to a UUID.
   * 
   * @example
   * 1AFAE64E-D1BE-432B-A9****
   */
  clientToken?: string;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 27
   */
  projectId?: number;
  /**
   * @remarks
   * The code of the role. This parameter is optional. If you configure the RoleCode parameter, the user is assigned the role.
   * 
   * @example
   * role_project_guest
   */
  roleCode?: string;
  /**
   * @remarks
   * The ID of the user to be added.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      projectId: 'ProjectId',
      roleCode: 'RoleCode',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      projectId: 'number',
      roleCode: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectMemberResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1AFAE64E-D1BE-432B-A9****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateProjectMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateProjectMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateQualityEntityRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * The value 0 indicates that the partition filter expression is at the SQL level, and the system checks data quality after each SQL statement is executed.
   * 
   * * 0
   * * 1
   * 
   * @example
   * 0
   */
  entityLevel?: number;
  /**
   * @remarks
   * The type of the compute engine or data source.
   * 
   * Valid values:
   * 
   * *   odps
   * *   emr
   * *   hadoop
   * *   cdh
   * *   analyticdb_for_mysql
   * *   hybriddb_for_postgresql
   * *   holodb
   * 
   * This parameter is required.
   * 
   * @example
   * ODPS
   */
  envType?: string;
  /**
   * @remarks
   * The partition filter expression.
   * 
   * This parameter is required.
   * 
   * @example
   * dt=$[yyyymmdd]
   */
  matchExpression?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console to query the ID.
   * 
   * @example
   * 123
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine or data source.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * This parameter is required.
   * 
   * @example
   * dual
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      entityLevel: 'EntityLevel',
      envType: 'EnvType',
      matchExpression: 'MatchExpression',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityLevel: 'number',
      envType: 'string',
      matchExpression: 'string',
      projectId: 'number',
      projectName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateQualityEntityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The partition filter expression ID.
   * 
   * @example
   * 12345
   */
  data?: number;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Your project is not relative with your account.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 011e1231u3****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateQualityEntityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateQualityEntityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateQualityEntityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateQualityFollowerRequest extends $tea.Model {
  /**
   * @remarks
   * The notification method. Valid values: 1, 2, 4, 5, 6, 7, 8, and 9. The value 1 indicates that the notification is sent by email. The value 2 indicates that the notification is sent by email and text message. The value 4 indicates that the notification is sent by a DingTalk chatbot. The value 5 indicates that the notification is sent by a DingTalk chatbot to all members in a DingTalk group. The value 6 indicates that the notification is sent by Lark. The value 7 indicates that the notification is sent by WeCom. The value 8 indicates that the notification is sent by webhook. The value 9 indicates that the notification is sent by phone call.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  alarmMode?: number;
  /**
   * @remarks
   * The ID of the partition filter expression.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  entityId?: number;
  /**
   * @remarks
   * The account ID of the subscriber.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  follower?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console to query the ID.
   * 
   * @example
   * 123
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine or data source.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      alarmMode: 'AlarmMode',
      entityId: 'EntityId',
      follower: 'Follower',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmMode: 'number',
      entityId: 'number',
      follower: 'string',
      projectId: 'number',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateQualityFollowerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the subscription relationship.
   * 
   * @example
   * 12345
   */
  data?: number;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ecb967ec-c137-48****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateQualityFollowerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateQualityFollowerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateQualityFollowerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateQualityRelativeNodeRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the compute engine or data source.
   * 
   * This parameter is required.
   * 
   * @example
   * ODPS
   */
  envType?: string;
  /**
   * @remarks
   * The partition filter expression.
   * 
   * This parameter is required.
   * 
   * @example
   * dt=$[yyyymmdd]
   */
  matchExpression?: string;
  /**
   * @remarks
   * The node ID. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12321
   */
  nodeId?: number;
  /**
   * @remarks
   * The workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine or data source.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * This parameter is required.
   * 
   * @example
   * dual
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  targetNodeProjectId?: number;
  /**
   * @remarks
   * The name of the workspace to which the node to be associated with the partition filter expression belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  targetNodeProjectName?: string;
  static names(): { [key: string]: string } {
    return {
      envType: 'EnvType',
      matchExpression: 'MatchExpression',
      nodeId: 'NodeId',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      tableName: 'TableName',
      targetNodeProjectId: 'TargetNodeProjectId',
      targetNodeProjectName: 'TargetNodeProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      envType: 'string',
      matchExpression: 'string',
      nodeId: 'number',
      projectId: 'number',
      projectName: 'string',
      tableName: 'string',
      targetNodeProjectId: 'number',
      targetNodeProjectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateQualityRelativeNodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the node is associated with the partition filter expression.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ecb967ec-c137-48****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateQualityRelativeNodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateQualityRelativeNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateQualityRelativeNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateQualityRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The strength type of the monitoring rule. Valid values: 0 and 1. The value 0 indicates that the monitoring rule is a weak rule. The value 1 indicates that the monitoring rule is a strong rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  blockType?: number;
  /**
   * @remarks
   * The checker ID.
   * 
   * @example
   * 9
   */
  checker?: number;
  /**
   * @remarks
   * The description of the monitoring rule.
   */
  comment?: string;
  /**
   * @remarks
   * The threshold for a critical alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements. If a strong rule is used and a critical alert is triggered, nodes are blocked.
   * 
   * @example
   * 20
   */
  criticalThreshold?: string;
  /**
   * @remarks
   * The ID of the partition filter expression.
   * 
   * This parameter is required.
   * 
   * @example
   * 15224
   */
  entityId?: number;
  /**
   * @remarks
   * The expected value.
   * 
   * @example
   * 0
   */
  expectValue?: string;
  /**
   * @remarks
   * The method used to collect sample data. If you want to use a custom SQL statement as a sampling method, set this parameter to user_defined.
   * 
   * @example
   * count/table_count
   */
  methodName?: string;
  /**
   * @remarks
   * The comparison operator, such as >, >=, =, ≠, <, or <=.
   * 
   * > If you set the Checker parameter to 9, you must configure the Operator parameter.
   * 
   * @example
   * >
   */
  operator?: string;
  /**
   * @remarks
   * Specifies whether the monitoring rule is a dynamic threshold rule. Valid values: 0 and 2. The value 0 indicates that the monitoring rule is not a dynamic threshold rule. The value 2 indicates that the monitoring rule is a dynamic threshold rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  predictType?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine or data source.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The fields that you want to monitor. If you want to monitor all fields in a table and check the table rows, set this parameter to table_count. If you want to monitor all fields in a table and check the table size, set this parameter to table_size.
   * 
   * @example
   * table_id
   */
  property?: string;
  /**
   * @remarks
   * The data type of the fields that you want to monitor. If you want to monitor all fields in a table, set this parameter to table. If you want to monitor only a specific field, set this parameter to bigint.
   * 
   * @example
   * bigint
   */
  propertyType?: string;
  /**
   * @remarks
   * The name of the monitoring rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the monitoring rule. Valid values: 0, 1, and 2. The value 0 indicates that the monitoring rule is created by the system. The value 1 indicates that the monitoring rule is created by a user. The value 2 indicates that the monitoring rule is a workspace-level rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  ruleType?: number;
  /**
   * @remarks
   * The variable settings inserted before the custom rule. Format: x=a,y=b.
   * 
   * @example
   * x=a,y=b
   */
  taskSetting?: string;
  /**
   * @remarks
   * The template ID.
   * 
   * @example
   * 7
   */
  templateId?: number;
  /**
   * @remarks
   * The trend of the monitoring result. Valid values:
   * 
   * *   up: increasing
   * *   down: decreasing
   * *   abs: absolute value
   * 
   * @example
   * abs
   */
  trend?: string;
  /**
   * @remarks
   * The threshold for a warning alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements.
   * 
   * @example
   * 10
   */
  warningThreshold?: string;
  /**
   * @remarks
   * The filter condition or custom SQL statement.
   * 
   * @example
   * table_id>1
   */
  whereCondition?: string;
  static names(): { [key: string]: string } {
    return {
      blockType: 'BlockType',
      checker: 'Checker',
      comment: 'Comment',
      criticalThreshold: 'CriticalThreshold',
      entityId: 'EntityId',
      expectValue: 'ExpectValue',
      methodName: 'MethodName',
      operator: 'Operator',
      predictType: 'PredictType',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      property: 'Property',
      propertyType: 'PropertyType',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      taskSetting: 'TaskSetting',
      templateId: 'TemplateId',
      trend: 'Trend',
      warningThreshold: 'WarningThreshold',
      whereCondition: 'WhereCondition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockType: 'number',
      checker: 'number',
      comment: 'string',
      criticalThreshold: 'string',
      entityId: 'number',
      expectValue: 'string',
      methodName: 'string',
      operator: 'string',
      predictType: 'number',
      projectId: 'number',
      projectName: 'string',
      property: 'string',
      propertyType: 'string',
      ruleName: 'string',
      ruleType: 'number',
      taskSetting: 'string',
      templateId: 'number',
      trend: 'string',
      warningThreshold: 'string',
      whereCondition: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateQualityRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the monitoring rule that you created.
   * 
   * @example
   * 12345
   */
  data?: string;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ecb967ec-c137-48****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateQualityRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateQualityRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateQualityRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRemindRequest extends $tea.Model {
  /**
   * @remarks
   * The minimum interval at which alerts are reported. Unit: seconds. Minimum value: 1200. Default value: 1800.
   * 
   * @example
   * 1800
   */
  alertInterval?: number;
  /**
   * @remarks
   * The notification method. Valid values:
   * 
   * *   MAIL: Alert notifications are sent by email.
   * *   SMS: Alert notifications are sent by text message. Alert notifications can be sent by text message only in the Singapore, Malaysia (Kuala Lumpur), and Germany (Frankfurt) regions.
   * *   WEBHOOKS (WeCom or Lark chatbot): Alert notifications are sent by WeCom or Lark message. If you want to use this notification method, you must configure the Webhooks parameter.
   * 
   * You can specify multiple notification methods. Separate them with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * SMS,MAIL
   */
  alertMethods?: string;
  /**
   * @remarks
   * *   If the AlertUnit parameter is set to OWNER, leave this parameter empty.
   * *   If the AlertUnit parameter is set to OTHER, set this parameter to the ID of the Alibaba Cloud account used by the specified user. You can specify multiple IDs. Separate multiple IDs with commas (,). You can specify a maximum of 10 IDs.
   * 
   * @example
   * 9527952795279527
   */
  alertTargets?: string;
  /**
   * @remarks
   * The recipient of the alert. Valid values: OWNER and OTHER. The value OWNER indicates the node owner. The value OTHER indicates a specified user.
   * 
   * This parameter is required.
   * 
   * @example
   * OWNER
   */
  alertUnit?: string;
  /**
   * @remarks
   * The ID of the baseline to which the custom alert rule is applied. This parameter takes effect when the RemindUnit parameter is set to BASELINE. You can specify multiple IDs. Separate multiple IDs with commas (,). A maximum of five baselines can be specified for a custom alert rule.
   * 
   * @example
   * 1,2,3
   */
  baselineIds?: string;
  /**
   * @remarks
   * The ID of the workflow to which the custom alert rule is applied. This parameter takes effect when the RemindUnit parameter is set to BIZPROCESS. You can specify multiple IDs. Separate multiple IDs with commas (,). A maximum of five workflows can be specified for a custom alert rule.
   * 
   * @example
   * 1,2,3
   */
  bizProcessIds?: string;
  /**
   * @remarks
   * The details of the conditions that trigger an alert.
   * 
   * *   If the RemindType parameter is set to FINISHED, leave this parameter empty.
   * *   If the RemindType parameter is set to UNFINISHED, configure this parameter as key-value pairs. Example: {"hour":23,"minu":59}. Valid values of hour: [0,47]. Valid values of minu: [0,59].
   * *   If the RemindType parameter is set to ERROR, leave this parameter empty.
   * *   If the RemindType parameter is set to CYCLE_UNFINISHED, configure this parameter as key-value pairs. Example: {"1":"05:50","2":"06:50","3":"07:50","4":"08:50","5":"09:50","6":"10:50","7":"11:50","8":"12:50","9":"13:50","10":"14:50","11":"15:50","12":"16:50","13":"17:50","14":"18:50","15":"19:50","16":"20:50","17":"21:50","18":"22:50","19":"23:50","20":"24:50","21":"25:50"}. The key indicates the ID of the cycle. Valid values: [1,288]. The value indicates the timeout period of the node that is running in the cycle. Specify the value in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
   * *   If the RemindType parameter is set to TIMEOUT, set this parameter to the timeout period. Unit: seconds. Example: 1800. This value indicates that an alert is reported if the node has run for more than 30 minutes.
   * 
   * @example
   * {"hour":23,"minu":59}
   */
  detail?: string;
  /**
   * @remarks
   * The end time of the quiet hours. Specify the time in the hh:mm format. Valid values of hh: [0,23]. Valid values of mm: [0,59].
   * 
   * @example
   * 08:00
   */
  dndEnd?: string;
  /**
   * @remarks
   * The maximum number of alerts. Valid values: 1 to 10. Default value: 3.
   * 
   * @example
   * 2
   */
  maxAlertTimes?: number;
  /**
   * @remarks
   * The ID of the node to which the custom alert rule is applied. This parameter takes effect when the RemindUnit parameter is set to NODE. You can specify multiple IDs. Separate multiple IDs with commas (,). A maximum of 50 nodes can be specified for a custom alert rule.
   * 
   * @example
   * 1,2,3
   */
  nodeIds?: string;
  /**
   * @remarks
   * The ID of the workspace to which the custom alert rule is applied. This parameter takes effect when the RemindUnit parameter is set to PROJECT. You can specify only one workspace for a custom alert rule.
   * 
   * @example
   * 9527
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the custom alert rule. The name cannot exceed 128 characters in length.
   * 
   * This parameter is required.
   * 
   * @example
   * test_error_remind
   */
  remindName?: string;
  /**
   * @remarks
   * The conditions that trigger an alert. Valid values: FINISHED, UNFINISHED, ERROR, CYCLE_UNFINISHED, and TIMEOUT.
   * 
   * This parameter is required.
   * 
   * @example
   * FINISHED
   */
  remindType?: string;
  /**
   * @remarks
   * The type of the object to which the custom alert rule is applied. Valid values: NODE, BASELINE, PROJECT, and BIZPROCESS. The value NODE indicates a node. The value BASELINE indicates a baseline. The value PROJECT indicates a workspace. The value BIZPROCESS indicates a workflow.
   * 
   * This parameter is required.
   * 
   * @example
   * NODE
   */
  remindUnit?: string;
  /**
   * @remarks
   * The webhook URL of the DingTalk chatbot. You can specify multiple webhook URLs. Separate multiple webhook URLs with commas (,).
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=******************************
   */
  robotUrls?: string;
  /**
   * @remarks
   * The webhook URL of the WeCom or Lark chatbot. You can specify multiple webhook URLs. Separate multiple webhook URLs with commas (,). You must specify WEBHOOKS for AlertMethods.
   * 
   * Only DataWorks Enterprise Edition supports this parameter. The webhook URL-based alerting feature is supported in the following regions: China (Shanghai), China (Chengdu), China (Zhangjiakou), China (Beijing), China (Hangzhou), China (Shenzhen), China (Hong Kong), Germany (Frankfurt), and Singapore.
   * 
   * @example
   * https://open.feishu.cn/open-apis/bot/v2/hook/*******
   */
  webhooks?: string;
  static names(): { [key: string]: string } {
    return {
      alertInterval: 'AlertInterval',
      alertMethods: 'AlertMethods',
      alertTargets: 'AlertTargets',
      alertUnit: 'AlertUnit',
      baselineIds: 'BaselineIds',
      bizProcessIds: 'BizProcessIds',
      detail: 'Detail',
      dndEnd: 'DndEnd',
      maxAlertTimes: 'MaxAlertTimes',
      nodeIds: 'NodeIds',
      projectId: 'ProjectId',
      remindName: 'RemindName',
      remindType: 'RemindType',
      remindUnit: 'RemindUnit',
      robotUrls: 'RobotUrls',
      webhooks: 'Webhooks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertInterval: 'number',
      alertMethods: 'string',
      alertTargets: 'string',
      alertUnit: 'string',
      baselineIds: 'string',
      bizProcessIds: 'string',
      detail: 'string',
      dndEnd: 'string',
      maxAlertTimes: 'number',
      nodeIds: 'string',
      projectId: 'number',
      remindName: 'string',
      remindType: 'string',
      remindUnit: 'string',
      robotUrls: 'string',
      webhooks: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRemindResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the custom alert rule.
   * 
   * @example
   * 1234
   */
  data?: number;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRemindResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateRemindResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRemindResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceFileRequest extends $tea.Model {
  /**
   * @example
   * SHOW TABLES;
   */
  content?: string;
  fileDescription?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  fileFolderPath?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  fileName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10
   */
  fileType?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * origin_file_name.sql
   */
  originResourceName?: string;
  /**
   * @example
   * 1000000000001
   */
  owner?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * false
   */
  registerToCalcEngine?: boolean;
  /**
   * @example
   * http://bucketname1.oss-cn-shanghai.aliyuncs.com/example
   */
  resourceFile?: string;
  /**
   * @example
   * oss://oss-cn-shanghai.aliyuncs.com/emr-test
   */
  storageURL?: string;
  /**
   * @example
   * false
   */
  uploadMode?: boolean;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      fileDescription: 'FileDescription',
      fileFolderPath: 'FileFolderPath',
      fileName: 'FileName',
      fileType: 'FileType',
      originResourceName: 'OriginResourceName',
      owner: 'Owner',
      projectId: 'ProjectId',
      registerToCalcEngine: 'RegisterToCalcEngine',
      resourceFile: 'ResourceFile',
      storageURL: 'StorageURL',
      uploadMode: 'UploadMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      fileDescription: 'string',
      fileFolderPath: 'string',
      fileName: 'string',
      fileType: 'number',
      originResourceName: 'string',
      owner: 'string',
      projectId: 'number',
      registerToCalcEngine: 'boolean',
      resourceFile: 'string',
      storageURL: 'string',
      uploadMode: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceFileAdvanceRequest extends $tea.Model {
  /**
   * @example
   * SHOW TABLES;
   */
  content?: string;
  fileDescription?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  fileFolderPath?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  fileName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10
   */
  fileType?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * origin_file_name.sql
   */
  originResourceName?: string;
  /**
   * @example
   * 1000000000001
   */
  owner?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * false
   */
  registerToCalcEngine?: boolean;
  /**
   * @example
   * http://bucketname1.oss-cn-shanghai.aliyuncs.com/example
   */
  resourceFileObject?: Readable;
  /**
   * @example
   * oss://oss-cn-shanghai.aliyuncs.com/emr-test
   */
  storageURL?: string;
  /**
   * @example
   * false
   */
  uploadMode?: boolean;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      fileDescription: 'FileDescription',
      fileFolderPath: 'FileFolderPath',
      fileName: 'FileName',
      fileType: 'FileType',
      originResourceName: 'OriginResourceName',
      owner: 'Owner',
      projectId: 'ProjectId',
      registerToCalcEngine: 'RegisterToCalcEngine',
      resourceFileObject: 'ResourceFile',
      storageURL: 'StorageURL',
      uploadMode: 'UploadMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      fileDescription: 'string',
      fileFolderPath: 'string',
      fileName: 'string',
      fileType: 'number',
      originResourceName: 'string',
      owner: 'string',
      projectId: 'number',
      registerToCalcEngine: 'boolean',
      resourceFileObject: 'Readable',
      storageURL: 'string',
      uploadMode: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceFileResponseBody extends $tea.Model {
  /**
   * @example
   * 1000001
   */
  data?: number;
  /**
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateResourceFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateResourceFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateResourceFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTableRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the MaxCompute project. Specify the ID in the odps.{projectName} format.
   * 
   * @example
   * odps.test
   */
  appGuid?: string;
  /**
   * @remarks
   * The ID of the associated category. You can call the [GetMetaCategory](https://help.aliyun.com/document_detail/173932.html) operation to query the IDs of all categories that can be associated.
   * 
   * @example
   * 101
   */
  categoryId?: number;
  /**
   * @remarks
   * A reserved parameter.
   */
  clientToken?: string;
  /**
   * @remarks
   * The list of fields. A maximum of 1,000 fields are supported.
   * 
   * This parameter is required.
   */
  columns?: CreateTableRequestColumns[];
  /**
   * @remarks
   * The comment.
   */
  comment?: string;
  /**
   * @remarks
   * The endpoint of MaxCompute.
   * 
   * @example
   * odps://abc
   */
  endpoint?: string;
  /**
   * @remarks
   * The environment type of the DataWorks workspace. Valid values:
   * 
   * *   0: development environment
   * *   1: production environment
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The storage type of the external table. Valid values:
   * 
   * *   0: Object Storage Service (OSS)
   * *   1: Tablestore
   * *   2: Volume
   * *   3: MySQL
   * 
   * @example
   * 0
   */
  externalTableType?: string;
  /**
   * @remarks
   * Specifies whether to create a MaxCompute partitioned table. Valid values: 1 and 0. The value 1 indicates a partitioned table. The value 0 indicates a non-partitioned table. This parameter is deprecated. Do not use this parameter. The Column.N.isPartitionCol parameter is used to specify whether to create a MaxCompute partitioned table. If the Column.N.isPartitionCol parameter is set to true, a MaxCompute partitioned table is created.
   * 
   * @example
   * 0
   */
  hasPart?: number;
  /**
   * @remarks
   * Specifies whether to create a view or table. Valid values:
   * 
   * *   0: Create a table.
   * *   1: Create a view.
   * 
   * @example
   * 0
   */
  isView?: number;
  /**
   * @remarks
   * The lifecycle of the table. Unit: days. By default, this parameter is left empty, which indicates that the table is permanently stored.
   * 
   * @example
   * 10
   */
  lifeCycle?: number;
  /**
   * @remarks
   * The storage location of the external table.
   * 
   * @example
   * location
   */
  location?: string;
  /**
   * @remarks
   * The ID of the logical level.
   * 
   * @example
   * 101
   */
  logicalLevelId?: number;
  ownerId?: string;
  /**
   * @remarks
   * The ID of the physical level.
   * 
   * @example
   * 101
   */
  physicsLevelId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 23
   */
  projectId?: number;
  /**
   * @remarks
   * The schema information of the table. You need to enter the schema information of the table if you enable the table schema in MaxCompute.
   * 
   * @example
   * default
   * 
   * **if can be null:**
   * true
   */
  schema?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * This parameter is required.
   * 
   * @example
   * tableName1
   */
  tableName?: string;
  /**
   * @remarks
   * The list of themes.
   */
  themes?: CreateTableRequestThemes[];
  /**
   * @remarks
   * Specifies whether the table or workspace is visible. Valid values:
   * 
   * *   0: Both the table and workspace are invisible.
   * *   1: Both the table and workspace are visible.
   * *   2: Only the workspace is visible.
   * 
   * @example
   * 1
   */
  visibility?: number;
  static names(): { [key: string]: string } {
    return {
      appGuid: 'AppGuid',
      categoryId: 'CategoryId',
      clientToken: 'ClientToken',
      columns: 'Columns',
      comment: 'Comment',
      endpoint: 'Endpoint',
      envType: 'EnvType',
      externalTableType: 'ExternalTableType',
      hasPart: 'HasPart',
      isView: 'IsView',
      lifeCycle: 'LifeCycle',
      location: 'Location',
      logicalLevelId: 'LogicalLevelId',
      ownerId: 'OwnerId',
      physicsLevelId: 'PhysicsLevelId',
      projectId: 'ProjectId',
      schema: 'Schema',
      tableName: 'TableName',
      themes: 'Themes',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGuid: 'string',
      categoryId: 'number',
      clientToken: 'string',
      columns: { 'type': 'array', 'itemType': CreateTableRequestColumns },
      comment: 'string',
      endpoint: 'string',
      envType: 'number',
      externalTableType: 'string',
      hasPart: 'number',
      isView: 'number',
      lifeCycle: 'number',
      location: 'string',
      logicalLevelId: 'number',
      ownerId: 'string',
      physicsLevelId: 'number',
      projectId: 'number',
      schema: 'string',
      tableName: 'string',
      themes: { 'type': 'array', 'itemType': CreateTableRequestThemes },
      visibility: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTableResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * abcdef
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the request task. After a request task is submitted, it is divided into multiple subtasks that are run in sequence. After the current subtask is complete, the next subtask starts to run. After all subtasks are complete, the request task is complete.
   * 
   * If a request task is aborted due to one of the following issues, address the issue based on the error code and initiate the request task again:
   * 
   * *   The request task fails to be submitted.
   * *   After the request task is submitted, a subtask fails to run.
   */
  taskInfo?: CreateTableResponseBodyTaskInfo;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskInfo: 'TaskInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskInfo: CreateTableResponseBodyTaskInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTableLevelRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the table level.
   * 
   * @example
   * The HTTP status code returned.
   */
  description?: string;
  /**
   * @remarks
   * The type of the table level. Valid values: 1 and 2. The value 1 indicates the logical level. The value 2 indicates the physical level.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  levelType?: number;
  /**
   * @remarks
   * The name of the table level.
   * 
   * This parameter is required.
   * 
   * @example
   * The description of the table level.
   */
  name?: string;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 123
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      levelType: 'LevelType',
      name: 'Name',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      levelType: 'number',
      name: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTableLevelResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The table level ID.
   * 
   * @example
   * 123
   */
  levelId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * The error message returned.
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      levelId: 'LevelId',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      levelId: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTableLevelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTableLevelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTableLevelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTableThemeRequest extends $tea.Model {
  /**
   * @remarks
   * The level of the table theme. Valid values: 1 and 2. The value 1 indicates the first level. The value 2 indicates the second level.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  level?: number;
  /**
   * @remarks
   * The name of the table theme.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The ID of the level of the parent table theme.
   * 
   * @example
   * 122
   */
  parentId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 123
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      level: 'Level',
      name: 'Name',
      parentId: 'ParentId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      level: 'number',
      name: 'string',
      parentId: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTableThemeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 0
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * success
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ABCd
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The table theme ID.
   * 
   * @example
   * 123
   */
  themeId?: number;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
      themeId: 'ThemeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
      themeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTableThemeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTableThemeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTableThemeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUdfFileRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the class in which the function is defined. This parameter corresponds to the Class Name parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
   * 
   * This parameter is required.
   * 
   * @example
   * com.alibaba.DataWorks.api.udf.StringConcat
   */
  className?: string;
  /**
   * @remarks
   * The syntax used for calling the function. This parameter corresponds to the Expression Syntax parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
   * 
   * @example
   * StringConcat(String... substrs)
   */
  cmdDescription?: string;
  /**
   * @example
   * false
   */
  createFolderIfNotExists?: boolean;
  /**
   * @remarks
   * The example for calling the function. This parameter corresponds to the Example parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
   * 
   * @example
   * StringConcat(\\"a\\", \\"b\\", \\"c\\")
   */
  example?: string;
  /**
   * @remarks
   * The path of the folder in which the file for the function is stored.
   */
  fileFolderPath?: string;
  /**
   * @remarks
   * The name of the file for the function.
   * 
   * This parameter is required.
   * 
   * @example
   * StringConcat
   */
  fileName?: string;
  /**
   * @remarks
   * The type of the function. Valid values: MATH, AGGREGATE, STRING, DATE, ANALYTIC, and OTHER. This parameter corresponds to the Function Type parameter in the Register Function section of the configuration tab of the function on the DataStudio page.
   * 
   * This parameter is required.
   * 
   * @example
   * STRING
   */
  functionType?: string;
  /**
   * @remarks
   * The description of the input parameters of the function. This parameter corresponds to the Parameter Description parameter in the Register Function section of the configuration tab of the function on the DataStudio page.
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace Management page and view the workspace ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The unique identifier of the DataWorks workspace. You can click the identifier in the upper-left corner of the DataStudio page to switch to another workspace.
   * 
   * You must specify either this parameter or the projectId parameter to determine the DataWorks workspace to which the operation is called.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  /**
   * @remarks
   * The names of the resources that are referenced by the function. This parameter corresponds to the Resources parameter in the Register Function section of the configuration tab of the function in the DataWorks console. Multiple resource names are separated by commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * string-concat-1.0.0.jar,commons-lang-2.6.jar
   */
  resources?: string;
  /**
   * @remarks
   * The description of the return value of the function. This parameter corresponds to the Return Value parameter in the Register Function section of the configuration tab of the function on the DataStudio page.
   */
  returnValue?: string;
  /**
   * @remarks
   * The description of the function. This parameter corresponds to the Description parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
   */
  udfDescription?: string;
  static names(): { [key: string]: string } {
    return {
      className: 'ClassName',
      cmdDescription: 'CmdDescription',
      createFolderIfNotExists: 'CreateFolderIfNotExists',
      example: 'Example',
      fileFolderPath: 'FileFolderPath',
      fileName: 'FileName',
      functionType: 'FunctionType',
      parameterDescription: 'ParameterDescription',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
      resources: 'Resources',
      returnValue: 'ReturnValue',
      udfDescription: 'UdfDescription',
    };
  }

  static types(): { [key: string]: any } {
    return {
      className: 'string',
      cmdDescription: 'string',
      createFolderIfNotExists: 'boolean',
      example: 'string',
      fileFolderPath: 'string',
      fileName: 'string',
      functionType: 'string',
      parameterDescription: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
      resources: 'string',
      returnValue: 'string',
      udfDescription: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUdfFileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the file that was created.
   * 
   * @example
   * 100000002
   */
  data?: number;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can troubleshoot issues based on the ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUdfFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateUdfFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateUdfFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBaselineRequest extends $tea.Model {
  /**
   * @remarks
   * The baseline ID. You can call the [ListBaselines](https://help.aliyun.com/document_detail/2261507.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  /**
   * @remarks
   * The ID of the workspace to which the baseline belongs. You can call the ListBaselines operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBaselineResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the deletion was successful.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110000
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Baseline deletion failed with nodes dependent on baseline
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBaselineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteBaselineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteBaselineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBusinessRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the workflow. You can call the [ListBusiness](https://help.aliyun.com/document_detail/173945.html) operation to query the workflow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000001
   */
  businessId?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID. You must specify either this parameter or ProjectIdentifier to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Settings panel to obtain the name. You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      businessId: 'BusinessId',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessId: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBusinessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBusinessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteBusinessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteBusinessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConnectionRequest extends $tea.Model {
  /**
   * @remarks
   * The data source ID. You can call the [ListConnection](https://help.aliyun.com/document_detail/173911.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  connectionId?: number;
  static names(): { [key: string]: string } {
    return {
      connectionId: 'ConnectionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConnectionResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the data source was removed.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1411515937635****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      httpStatusCode: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteConnectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteConnectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDIAlarmRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The alert rule ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 34971
   */
  DIAlarmRuleId?: number;
  static names(): { [key: string]: string } {
    return {
      DIAlarmRuleId: 'DIAlarmRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIAlarmRuleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDIAlarmRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * C99E2BE6-9DEA-5C2E-8F51-1DDCFEADE490
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDIAlarmRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDIAlarmRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDIAlarmRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDIJobRequest extends $tea.Model {
  /**
   * @remarks
   * The task ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11126
   */
  DIJobId?: number;
  static names(): { [key: string]: string } {
    return {
      DIJobId: 'DIJobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDIJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * D33D4A51-5845-579A-B4BA-FAADD0F83D53
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDIJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDIJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDIJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDISyncTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the real-time synchronization task. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  fileId?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
   * 
   * You must configure this parameter to specify the DataWorks workspace to which the operation is applied.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The type of the task. Set the value to DI_REALTIME, which indicates a real-time synchronization task.
   * 
   * This parameter is required.
   * 
   * @example
   * DI_REALTIME
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      projectId: 'ProjectId',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      projectId: 'number',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDISyncTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The deletion result.
   */
  data?: DeleteDISyncTaskResponseBodyData;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DeleteDISyncTaskResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDISyncTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDISyncTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDISyncTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataServiceApiRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API in DataService Studio.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  apiId?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * @example
   * 10002
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataServiceApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the API was deleted.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataServiceApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDataServiceApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDataServiceApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataServiceApiAuthorityRequest extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  apiId?: number;
  /**
   * @remarks
   * The ID of the workspace from which you want to revoke the access permissions on the API.
   * 
   * This parameter is required.
   * 
   * @example
   * 10002
   */
  authorizedProjectId?: number;
  /**
   * @remarks
   * The workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10003
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. This parameter is deprecated.
   * 
   * @example
   * 10004
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      authorizedProjectId: 'AuthorizedProjectId',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      authorizedProjectId: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataServiceApiAuthorityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EF****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataServiceApiAuthorityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDataServiceApiAuthorityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDataServiceApiAuthorityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceRequest extends $tea.Model {
  /**
   * @remarks
   * The data source ID. You can call the [ListDataSources](https://help.aliyun.com/document_detail/211431.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  dataSourceId?: number;
  static names(): { [key: string]: string } {
    return {
      dataSourceId: 'DataSourceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the data source was removed.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1411515937635****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      httpStatusCode: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDataSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileRequest extends $tea.Model {
  /**
   * @remarks
   * The HTTP status code.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000001
   */
  fileId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to view the workspace name.
   * 
   * You must specify one of the ProjectId and ProjectIdentifier parameters to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The ID of the file. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID of the file.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request. You can troubleshoot errors based on the ID.
   * 
   * @example
   * 1000000001
   */
  deploymentId?: number;
  /**
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   true: The request is successful.
   * *   false: The request fails.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the deployment task that deploys the file. If the file has been committed, an asynchronous process is triggered to delete the file in the scheduling system. The value of this parameter is used to call the GetDeployment operation to poll the status of the asynchronous process.
   * 
   * If this parameter is empty, the file is deleted and the polling is not required.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deploymentId: 'DeploymentId',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deploymentId: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFolderRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the folder. You can call the [ListFolders](https://help.aliyun.com/document_detail/173955.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 2eb6f9****
   */
  folderId?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID. You must specify either this parameter or ProjectIdentifier to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Settings panel to obtain the name. You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      folderId: 'FolderId',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folderId: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFolderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFolderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteFolderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteFolderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFromMetaCategoryRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the category.
   * 
   * This parameter is required.
   * 
   * @example
   * 5
   */
  categoryId?: number;
  /**
   * @remarks
   * The GUID of the metatable.
   * 
   * This parameter is required.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  static names(): { [key: string]: string } {
    return {
      categoryId: 'CategoryId',
      tableGuid: 'TableGuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryId: 'number',
      tableGuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFromMetaCategoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the table was removed from the specified category.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFromMetaCategoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteFromMetaCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteFromMetaCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLineageRelationRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the destination entity.
   * 
   * This parameter is required.
   * 
   * @example
   * custom-report.report123
   */
  destEntityQualifiedName?: string;
  /**
   * @remarks
   * The unique identifier of the lineage.
   * 
   * @example
   * dfazcdfdfccdedd
   */
  relationshipGuid?: string;
  relationshipType?: string;
  /**
   * @remarks
   * The unique identifier of the source entity.
   * 
   * This parameter is required.
   * 
   * @example
   * maxcompute-table.project.table
   */
  srcEntityQualifiedName?: string;
  static names(): { [key: string]: string } {
    return {
      destEntityQualifiedName: 'DestEntityQualifiedName',
      relationshipGuid: 'RelationshipGuid',
      relationshipType: 'RelationshipType',
      srcEntityQualifiedName: 'SrcEntityQualifiedName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destEntityQualifiedName: 'string',
      relationshipGuid: 'string',
      relationshipType: 'string',
      srcEntityQualifiedName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLineageRelationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1010040007
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * qualifiedName should be in format as entity-table.entity-guid
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 64B-587A-8CED-969E1973887FXXX-TT
   */
  requestId?: string;
  /**
   * @remarks
   * The result of the operation. Valid values:
   * 
   * true: successful
   * 
   * false: failed
   * 
   * @example
   * true
   */
  status?: boolean;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true
   * 
   * false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      status: 'Status',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      status: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLineageRelationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteLineageRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLineageRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetaCategoryRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the category.
   * 
   * This parameter is required.
   * 
   * @example
   * 23
   */
  categoryId?: number;
  static names(): { [key: string]: string } {
    return {
      categoryId: 'CategoryId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetaCategoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The business data.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetaCategoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMetaCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMetaCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetaCollectionRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the collection.
   * 
   * This parameter is required.
   * 
   * @example
   * album.12333
   */
  qualifiedName?: string;
  static names(): { [key: string]: string } {
    return {
      qualifiedName: 'QualifiedName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qualifiedName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetaCollectionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 999999
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified product does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @remarks
   * The result of the operation. Valid values:
   * 
   * true: succeeded
   * 
   * false: failed
   * 
   * @example
   * true
   */
  status?: boolean;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true
   * 
   * false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      status: 'Status',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      status: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetaCollectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMetaCollectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMetaCollectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetaCollectionEntityRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the collection.
   * 
   * This parameter is required.
   * 
   * @example
   * album.12345
   */
  collectionQualifiedName?: string;
  /**
   * @remarks
   * The unique identifier of the entity.
   * 
   * This parameter is required.
   * 
   * @example
   * maxcompute.projectA.tableB
   */
  entityQualifiedName?: string;
  static names(): { [key: string]: string } {
    return {
      collectionQualifiedName: 'CollectionQualifiedName',
      entityQualifiedName: 'EntityQualifiedName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      collectionQualifiedName: 'string',
      entityQualifiedName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetaCollectionEntityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 999999
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * entity not exist
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @remarks
   * The result of the operation. Valid values:
   * 
   * true: succeeded
   * 
   * false: failed
   * 
   * @example
   * true
   */
  status?: boolean;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true
   * 
   * false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      status: 'Status',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      status: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMetaCollectionEntityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteMetaCollectionEntityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMetaCollectionEntityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectMemberRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 27
   */
  projectId?: number;
  /**
   * @remarks
   * The user ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectMemberResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1AFAE64E-D1BE-432B-A9****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteProjectMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteProjectMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteProjectMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteQualityEntityRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the partition filter expression.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  entityId?: number;
  /**
   * @remarks
   * The type of the compute engine or data source. The following types are supported: E-MapReduce (EMR), Hologres, AnalyticDB for PostgreSQL, CDH, MaxCompute, Kafka, and DataHub.
   * 
   * Valid values:
   * 
   * *   odps
   * *   emr
   * *   hadoop
   * *   cdh
   * *   hybriddb_for_postgresql
   * *   holodb
   * 
   * This parameter is required.
   * 
   * @example
   * ODPS
   */
  envType?: string;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 12345
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine or data source.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      entityId: 'EntityId',
      envType: 'EnvType',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityId: 'number',
      envType: 'string',
      projectId: 'number',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteQualityEntityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned result.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ecb967ec-c137-48****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteQualityEntityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteQualityEntityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteQualityEntityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteQualityFollowerRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the subscription relationship between the partition filter expression and the subscriber. You can call the [GetQualityFollower](https://help.aliyun.com/document_detail/174000.html) operation to obtain the ID of the subscription relationship.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  followerId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console and go to the Workspace page to obtain the workspace ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine or data source for which the partition filter expression is configured. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the rule configuration page of Data Quality page to obtain the name.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      followerId: 'FollowerId',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      followerId: 'number',
      projectId: 'number',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteQualityFollowerResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the subscriber was successfully deleted. Valid values:
   * 
   * *   true: The subscriber was successfully deleted.
   * *   false: The subscriber failed to be deleted. You can troubleshoot errors based on the error message returned.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned when the subscriber failed to be deleted.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can troubleshoot errors based on the ID.
   * 
   * @example
   * 6d739ef6-098a-47****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteQualityFollowerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteQualityFollowerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteQualityFollowerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteQualityRelativeNodeRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the compute engine or data source. Valid values:
   * 
   * *   cdh
   * *   analyticdb_for_mysql
   * *   odps
   * *   emr
   * *   hadoop
   * *   holodb
   * *   hybriddb_for_postgresql
   * 
   * This parameter is required.
   * 
   * @example
   * ODPS
   */
  envType?: string;
  /**
   * @remarks
   * The partition filter expression.
   * 
   * This parameter is required.
   * 
   * @example
   * dt=$[yyyymmdd]
   */
  matchExpression?: string;
  /**
   * @remarks
   * The ID of the node.
   * 
   * This parameter is required.
   * 
   * @example
   * 156234
   */
  nodeId?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine instance or data source.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The name of the table that is generated by the node.
   * 
   * This parameter is required.
   * 
   * @example
   * dual
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node associated with the partition filter expression belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  targetNodeProjectId?: number;
  /**
   * @remarks
   * The name of the workspace to which the node associated with the partition filter expression belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  targetNodeProjectName?: string;
  static names(): { [key: string]: string } {
    return {
      envType: 'EnvType',
      matchExpression: 'MatchExpression',
      nodeId: 'NodeId',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      tableName: 'TableName',
      targetNodeProjectId: 'TargetNodeProjectId',
      targetNodeProjectName: 'TargetNodeProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      envType: 'string',
      matchExpression: 'string',
      nodeId: 'number',
      projectId: 'number',
      projectName: 'string',
      tableName: 'string',
      targetNodeProjectId: 'number',
      targetNodeProjectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteQualityRelativeNodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the node is disassociated from the partition filter expression.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6d739ef6-098a-47****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteQualityRelativeNodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteQualityRelativeNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteQualityRelativeNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteQualityRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console and go to the Workspace page to query the ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine or data source.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The monitoring rule ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
      projectName: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteQualityRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the monitoring rule was deleted.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6d739ef6-098a-47****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteQualityRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteQualityRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteQualityRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRecognizeRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The sensitive field ID. You can call the [QuerySensNodeInfo](https://help.aliyun.com/document_detail/2747189.html) operation to obtain the ID of the sensitive field.
   * 
   * This parameter is required.
   * 
   * @example
   * 27f5f5e2-ec60-4567-b1e4-779ac3681024
   */
  sensitiveId?: string;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * This parameter is required.
   * 
   * @example
   * 10241024
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      sensitiveId: 'SensitiveId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sensitiveId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRecognizeRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data about whether the deletion is successful.
   * 
   * @example
   * {   "HttpStatusCode": 200,   "Success": true }
   */
  data?: any;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9990030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 10000001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRecognizeRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRecognizeRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRecognizeRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRemindRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the custom alert rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  remindId?: number;
  static names(): { [key: string]: string } {
    return {
      remindId: 'RemindId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      remindId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRemindResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the custom alert rule is deleted. Valid values: true and false. The value true indicates that the custom alert rule is deleted. The value false indicates that the custom alert rule fails to be deleted.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteRemindResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteRemindResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteRemindResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTableRequest extends $tea.Model {
  /**
   * @remarks
   * The globally unique identifier (GUID) of the MaxCompute project. Specify the GUID in the odps.{projectName} format.
   * 
   * @example
   * odps.test
   */
  appGuid?: string;
  /**
   * @remarks
   * The type of the compute engine or data source. Valid values:
   * 
   * *   cdh
   * *   analyticdb_for_mysql
   * *   odps
   * *   emr
   * *   hadoop
   * *   holodb
   * *   hybriddb_for_postgresql
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace.
   * 
   * @example
   * 101
   */
  projectId?: number;
  /**
   * @remarks
   * The schema information of the table. You need to enter the schema information of the table if you enable the table schema in MaxCompute.
   * 
   * @example
   * default
   * 
   * **if can be null:**
   * true
   */
  schema?: string;
  /**
   * @remarks
   * The name of the MaxCompute table.
   * 
   * This parameter is required.
   * 
   * @example
   * table1
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      appGuid: 'AppGuid',
      envType: 'EnvType',
      projectId: 'ProjectId',
      schema: 'Schema',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGuid: 'string',
      envType: 'number',
      projectId: 'number',
      schema: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTableResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * abcde
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the task that is used to delete the table.
   */
  taskInfo?: DeleteTableResponseBodyTaskInfo;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskInfo: 'TaskInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskInfo: DeleteTableResponseBodyTaskInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTableLevelRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the table level that you want to delete. You can call the ListTableLevel operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  levelId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      levelId: 'LevelId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      levelId: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTableLevelResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the table level was deleted.
   * 
   * @example
   * true
   */
  deleteResult?: boolean;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * abcde
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      deleteResult: 'DeleteResult',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deleteResult: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTableLevelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTableLevelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTableLevelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTableThemeRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the DataWorks workspace.
   * 
   * @example
   * 123
   */
  projectId?: number;
  /**
   * @remarks
   * The ID of the theme.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  themeId?: number;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
      themeId: 'ThemeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
      themeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTableThemeResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the theme was deleted.
   * 
   * @example
   * true
   */
  deleteResult?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * abcdef
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      deleteResult: 'DeleteResult',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deleteResult: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTableThemeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTableThemeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTableThemeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeployDISyncTaskRequest extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   true: The request is successful.
   * *   false: The request fails.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  fileId?: number;
  /**
   * @remarks
   * The type of the object that you want to deploy. Valid values:
   * 
   * *   DI_REALTIME: real-time synchronization node
   * *   DI_SOLUTION: data synchronization solution
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * *   If you set the TaskType parameter to DI_REALTIME, set the FileId parameter to the ID of the real-time synchronization node that you want to deploy.
   * *   If you set the TaskType parameter to DI_SOLUTION, set the FileId parameter to the ID of the data synchronization solution that you want to deploy.
   * 
   * You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID of the real-time synchronization node or data synchronization solution.
   * 
   * This parameter is required.
   * 
   * @example
   * DI_REALTIME
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      projectId: 'ProjectId',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      projectId: 'number',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeployDISyncTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the real-time synchronization node or data synchronization solution is deployed. Valid values:
   * 
   * *   success: The real-time synchronization node or data synchronization solution is deployed.
   * *   fail: The real-time synchronization node or data synchronization solution fails to be deployed.
   */
  data?: DeployDISyncTaskResponseBodyData;
  /**
   * @remarks
   * The result of deploying the real-time synchronization node or data synchronization solution.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the request. You can query logs and troubleshoot issues based on the ID.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DeployDISyncTaskResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeployDISyncTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeployDISyncTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeployDISyncTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeployFileRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the deployment operation.
   */
  comment?: string;
  /**
   * @remarks
   * The ID of the file. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID.
   * 
   * You must configure either the FileId parameter or the NodeId parameter.
   * 
   * @example
   * 10000001
   */
  fileId?: number;
  /**
   * @remarks
   * The ID of the node in the scheduling system that corresponds to the file that you want to deploy. You must configure either the NodeId parameter or the FileId parameter.
   * 
   * @example
   * 2000001
   */
  nodeId?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace ID. You must configure either this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace name. You must configure either this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      fileId: 'FileId',
      nodeId: 'NodeId',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      fileId: 'number',
      nodeId: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeployFileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the deployment task. The ID is used as the value of a specific request parameter when you call the [GetDeployment](https://help.aliyun.com/document_detail/173950.html) operation to query the details of the deployment task.
   * 
   * @example
   * 30000001
   */
  data?: number;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can troubleshoot issues based on the ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeployFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeployFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeployFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DesensitizeDataRequest extends $tea.Model {
  /**
   * @remarks
   * The data that you want to mask.
   * 
   * This parameter is required.
   * 
   * @example
   * 15365291784
   */
  data?: string;
  /**
   * @remarks
   * The code of the data masking scenario. You can view the code on the Data Masking Management page in Data Security Guard of the DataWorks console.
   * 
   * This parameter is required.
   * 
   * @example
   * _default_scene_code
   */
  sceneCode?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      sceneCode: 'SceneCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      sceneCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DesensitizeDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned after masking.
   * 
   * @example
   * {     "desensData": "**198807120510**"   }
   */
  desensitizeData?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * BCA321BA-46C5-40E9-8A08-6******
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      desensitizeData: 'DesensitizeData',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desensitizeData: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DesensitizeDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DesensitizeDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DesensitizeDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanAddOrUpdateRequest extends $tea.Model {
  /**
   * @remarks
   * A collection of data masking rules that you want to add or modify.
   * 
   * This parameter is required.
   */
  desensRules?: DsgDesensPlanAddOrUpdateRequestDesensRules[];
  static names(): { [key: string]: string } {
    return {
      desensRules: 'DesensRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desensRules: { 'type': 'array', 'itemType': DsgDesensPlanAddOrUpdateRequestDesensRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanAddOrUpdateShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * A collection of data masking rules that you want to add or modify.
   * 
   * This parameter is required.
   */
  desensRulesShrink?: string;
  static names(): { [key: string]: string } {
    return {
      desensRulesShrink: 'DesensRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desensRulesShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanAddOrUpdateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The execution result of adding or modifying a data masking rule.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values: true false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanAddOrUpdateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgDesensPlanAddOrUpdateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgDesensPlanAddOrUpdateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanDeleteRequest extends $tea.Model {
  /**
   * @remarks
   * A collection of data masking rules.
   * 
   * This parameter is required.
   */
  ids?: number[];
  /**
   * @remarks
   * The code of the level-1 data masking scenario to which the rule belongs. Valid values:
   * 
   * *   dataworks_display_desense_code: masking of displayed data in DataStudio and Data Map
   * *   maxcompute_desense_code: data masking at the MaxCompute compute engine layer
   * *   maxcompute_new_desense_code: data masking at the MaxCompute compute engine layer (new)
   * *   hologres_display_desense_code: data masking at the Hologres compute engine layer
   * *   dataworks_data_integration_desense_code: static data masking in Data Integration
   * *   dataworks_analysis_desense_code: masking of displayed data in DataAnalysis
   * 
   * This parameter is required.
   * 
   * @example
   * dataworks_display_desense_code
   */
  sceneCode?: string;
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
      sceneCode: 'SceneCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: { 'type': 'array', 'itemType': 'number' },
      sceneCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanDeleteShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * A collection of data masking rules.
   * 
   * This parameter is required.
   */
  idsShrink?: string;
  /**
   * @remarks
   * The code of the level-1 data masking scenario to which the rule belongs. Valid values:
   * 
   * *   dataworks_display_desense_code: masking of displayed data in DataStudio and Data Map
   * *   maxcompute_desense_code: data masking at the MaxCompute compute engine layer
   * *   maxcompute_new_desense_code: data masking at the MaxCompute compute engine layer (new)
   * *   hologres_display_desense_code: data masking at the Hologres compute engine layer
   * *   dataworks_data_integration_desense_code: static data masking in Data Integration
   * *   dataworks_analysis_desense_code: masking of displayed data in DataAnalysis
   * 
   * This parameter is required.
   * 
   * @example
   * dataworks_display_desense_code
   */
  sceneCode?: string;
  static names(): { [key: string]: string } {
    return {
      idsShrink: 'Ids',
      sceneCode: 'SceneCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      idsShrink: 'string',
      sceneCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanDeleteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation result. Valid values:
   * 
   * *   true: The operation is successful.
   * *   false: The operation fails.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanDeleteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgDesensPlanDeleteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgDesensPlanDeleteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanQueryListRequest extends $tea.Model {
  /**
   * @remarks
   * The owner of the data masking rule.
   * 
   * @example
   * user1
   */
  owner?: string;
  /**
   * @remarks
   * The page number.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The name of the sensitive field.
   * 
   * @example
   * phone
   */
  ruleName?: string;
  /**
   * @remarks
   * The ID of the level-2 data masking scenario. You can call the [DsgSceneQuerySceneListByName](https://help.aliyun.com/document_detail/2786322.html) operation to query the list of IDs.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  sceneId?: number;
  /**
   * @remarks
   * The status of the data masking rule. Valid values:
   * 
   * *   0: expired
   * *   1: effective
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      owner: 'Owner',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      sceneId: 'SceneId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      owner: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      ruleName: 'string',
      sceneId: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanQueryListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The pagination information.
   */
  pageData?: DsgDesensPlanQueryListResponseBodyPageData;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      pageData: 'PageData',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      pageData: DsgDesensPlanQueryListResponseBodyPageData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanQueryListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgDesensPlanQueryListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgDesensPlanQueryListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanUpdateStatusRequest extends $tea.Model {
  /**
   * @remarks
   * A collection of IDs of the data masking rules of which the status you want to modify.
   * 
   * This parameter is required.
   */
  ids?: number[];
  /**
   * @remarks
   * The code of the level-1 data masking scenario to which the rule belongs. Valid values:
   * 
   * *   dataworks_display_desense_code: masking of displayed data in DataStudio and Data Map
   * *   maxcompute_desense_code: data masking at the MaxCompute compute engine layer
   * *   maxcompute_new_desense_code: data masking at the MaxCompute compute engine layer (new)
   * *   hologres_display_desense_code: data masking at the Hologres compute engine layer
   * *   dataworks_data_integration_desense_code: static data masking in Data Integration
   * *   dataworks_analysis_desense_code: masking of displayed data in DataAnalysis
   * 
   * This parameter is required.
   * 
   * @example
   * dataworks_display_desense_code
   */
  sceneCode?: string;
  /**
   * @remarks
   * The status of the data masking rule. Valid values:
   * 
   * *   0: expired
   * *   1: effective
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
      sceneCode: 'SceneCode',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: { 'type': 'array', 'itemType': 'number' },
      sceneCode: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanUpdateStatusShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * A collection of IDs of the data masking rules of which the status you want to modify.
   * 
   * This parameter is required.
   */
  idsShrink?: string;
  /**
   * @remarks
   * The code of the level-1 data masking scenario to which the rule belongs. Valid values:
   * 
   * *   dataworks_display_desense_code: masking of displayed data in DataStudio and Data Map
   * *   maxcompute_desense_code: data masking at the MaxCompute compute engine layer
   * *   maxcompute_new_desense_code: data masking at the MaxCompute compute engine layer (new)
   * *   hologres_display_desense_code: data masking at the Hologres compute engine layer
   * *   dataworks_data_integration_desense_code: static data masking in Data Integration
   * *   dataworks_analysis_desense_code: masking of displayed data in DataAnalysis
   * 
   * This parameter is required.
   * 
   * @example
   * dataworks_display_desense_code
   */
  sceneCode?: string;
  /**
   * @remarks
   * The status of the data masking rule. Valid values:
   * 
   * *   0: expired
   * *   1: effective
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      idsShrink: 'Ids',
      sceneCode: 'SceneCode',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      idsShrink: 'string',
      sceneCode: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanUpdateStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation result. Valid values:
   * 
   * *   true: The operation is successful.
   * *   false: The operation fails.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanUpdateStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgDesensPlanUpdateStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgDesensPlanUpdateStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgPlatformQueryProjectsAndSchemaFromMetaRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the compute engine. Valid values:
   * 
   * *   ODPS.ODPS
   * *   EMR
   * *   HOLO.POSTGRES
   * 
   * This parameter is required.
   * 
   * @example
   * EMR
   */
  engineName?: string;
  static names(): { [key: string]: string } {
    return {
      engineName: 'EngineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      engineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: DsgPlatformQueryProjectsAndSchemaFromMetaResponseBodyData[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DsgPlatformQueryProjectsAndSchemaFromMetaResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgPlatformQueryProjectsAndSchemaFromMetaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgPlatformQueryProjectsAndSchemaFromMetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgQueryDefaultTemplatesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the level-2 data masking scenario. You can call the [DsgSceneQuerySceneListByName](https://help.aliyun.com/document_detail/2786322.html) operation to query the list of IDs.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  sceneId?: number;
  static names(): { [key: string]: string } {
    return {
      sceneId: 'SceneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sceneId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgQueryDefaultTemplatesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: DsgQueryDefaultTemplatesResponseBodyData[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DsgQueryDefaultTemplatesResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgQueryDefaultTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgQueryDefaultTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgQueryDefaultTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgQuerySensResultRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the field.
   * 
   * @example
   * col
   */
  col?: string;
  /**
   * @remarks
   * The type of the database. Valid values:
   * 
   * *   **ODPS.ODPS**
   * *   **HOLO.POSTGRES**
   * *   **EMR**
   * 
   * @example
   * ODPS.ODPS
   */
  dbType?: string;
  /**
   * @remarks
   * The sensitivity level of the field.
   * 
   * @example
   * 3
   */
  level?: string;
  /**
   * @remarks
   * The name of a data category.
   */
  nodeName?: string;
  /**
   * @remarks
   * The sorting method.
   * 
   * *   DESC
   * *   ASC
   * 
   * @example
   * DESC
   */
  order?: string;
  /**
   * @remarks
   * The field used for sorting.
   * 
   * *   gmt_create
   * *   gmt_modified
   * 
   * @example
   * gmt_create
   */
  orderField?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1.
   * 
   * @example
   * 1
   */
  pageNo?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 20.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace name.
   * 
   * @example
   * project
   */
  projectName?: string;
  /**
   * @remarks
   * The name of the schema.
   * 
   * @example
   * schema
   */
  schemaName?: string;
  /**
   * @remarks
   * The sensitivity status of the field.
   * 
   * *   1: indicates sensitive.
   * *   \\-1: indicates non-sensitive.
   * 
   * @example
   * 1
   */
  sensStatus?: string;
  /**
   * @remarks
   * The sensitive field ID.
   * 
   * @example
   * 10241024
   */
  sensitiveId?: string;
  /**
   * @remarks
   * The name of the sensitive field.
   */
  sensitiveName?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * table
   */
  table?: string;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * This parameter is required.
   * 
   * @example
   * 10241024
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      col: 'Col',
      dbType: 'DbType',
      level: 'Level',
      nodeName: 'NodeName',
      order: 'Order',
      orderField: 'OrderField',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      projectName: 'ProjectName',
      schemaName: 'SchemaName',
      sensStatus: 'SensStatus',
      sensitiveId: 'SensitiveId',
      sensitiveName: 'SensitiveName',
      table: 'Table',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      col: 'string',
      dbType: 'string',
      level: 'string',
      nodeName: 'string',
      order: 'string',
      orderField: 'string',
      pageNo: 'number',
      pageSize: 'number',
      projectName: 'string',
      schemaName: 'string',
      sensStatus: 'string',
      sensitiveId: 'string',
      sensitiveName: 'string',
      table: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgQuerySensResultResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   * 
   * @example
   * 1234
   */
  data?: any;
  /**
   * @remarks
   * The error code. The value is the same as that of ErrorCode.
   * 
   * @example
   * 400
   */
  dynamicErrorCode?: string;
  /**
   * @remarks
   * The error message. The value is the same as that of ErrorMessage.
   */
  dynamicErrorMessage?: string;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 400
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 900000001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      dynamicErrorCode: 'DynamicErrorCode',
      dynamicErrorMessage: 'DynamicErrorMessage',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      dynamicErrorCode: 'string',
      dynamicErrorMessage: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgQuerySensResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgQuerySensResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgQuerySensResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgRunSensIdentifyRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters that you need to configure to scan specified metadata.
   */
  esMetaParams?: DsgRunSensIdentifyRequestEsMetaParams[];
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * This parameter is required.
   * 
   * @example
   * 10241024
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      esMetaParams: 'EsMetaParams',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      esMetaParams: { 'type': 'array', 'itemType': DsgRunSensIdentifyRequestEsMetaParams },
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgRunSensIdentifyShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters that you need to configure to scan specified metadata.
   */
  esMetaParamsShrink?: string;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * This parameter is required.
   * 
   * @example
   * 10241024
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      esMetaParamsShrink: 'EsMetaParams',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      esMetaParamsShrink: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgRunSensIdentifyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the generated sensitive data identification task. The value is of the INT 64 type.
   * 
   * @example
   * 1000001
   */
  data?: any;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9990030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 10000001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgRunSensIdentifyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgRunSensIdentifyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgRunSensIdentifyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgSceneAddOrUpdateSceneRequest extends $tea.Model {
  /**
   * @remarks
   * The information about the level-2 data masking scenario.
   * 
   * This parameter is required.
   */
  scenes?: DsgSceneAddOrUpdateSceneRequestScenes[];
  static names(): { [key: string]: string } {
    return {
      scenes: 'scenes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scenes: { 'type': 'array', 'itemType': DsgSceneAddOrUpdateSceneRequestScenes },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgSceneAddOrUpdateSceneShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The information about the level-2 data masking scenario.
   * 
   * This parameter is required.
   */
  scenesShrink?: string;
  static names(): { [key: string]: string } {
    return {
      scenesShrink: 'scenes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scenesShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgSceneAddOrUpdateSceneResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation result.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgSceneAddOrUpdateSceneResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgSceneAddOrUpdateSceneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgSceneAddOrUpdateSceneResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgSceneQuerySceneListByNameRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the data masking scenario. A fuzzy match is performed in the platform based on a keyword to search for the data masking scenario.
   * 
   * @example
   * dev_
   */
  sceneName?: string;
  static names(): { [key: string]: string } {
    return {
      sceneName: 'SceneName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sceneName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgSceneQuerySceneListByNameResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: DsgSceneQuerySceneListByNameResponseBodyData[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DsgSceneQuerySceneListByNameResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgSceneQuerySceneListByNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgSceneQuerySceneListByNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgSceneQuerySceneListByNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgScenedDeleteSceneRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of level-2 data masking scenarios.
   * 
   * This parameter is required.
   */
  ids?: number[];
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgScenedDeleteSceneShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of level-2 data masking scenarios.
   * 
   * This parameter is required.
   */
  idsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      idsShrink: 'Ids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      idsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgScenedDeleteSceneResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation result. Valid values:
   * 
   * *   true: The operation is successful.
   * *   false: The operation failed.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgScenedDeleteSceneResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgScenedDeleteSceneResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgScenedDeleteSceneResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgStopSensIdentifyRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the sensitive data identification task. You can call the [DsgRunSensIdentify](https://help.aliyun.com/document_detail/2744039.html) operation to obtain the task ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000001
   */
  jobId?: number;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * This parameter is required.
   * 
   * @example
   * 10241024
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'number',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgStopSensIdentifyResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data, which is of the Boolean type.
   * 
   * @example
   * true
   */
  data?: any;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9990030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 10000001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgStopSensIdentifyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgStopSensIdentifyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgStopSensIdentifyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupAddOrUpdateRequest extends $tea.Model {
  /**
   * @remarks
   * The information about the user group.
   * 
   * This parameter is required.
   */
  userGroups?: DsgUserGroupAddOrUpdateRequestUserGroups[];
  static names(): { [key: string]: string } {
    return {
      userGroups: 'UserGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userGroups: { 'type': 'array', 'itemType': DsgUserGroupAddOrUpdateRequestUserGroups },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupAddOrUpdateShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The information about the user group.
   * 
   * This parameter is required.
   */
  userGroupsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      userGroupsShrink: 'UserGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userGroupsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupAddOrUpdateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation result. Valid values:
   * 
   * *   true: The operation is successful.
   * *   false: The operation fails.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupAddOrUpdateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgUserGroupAddOrUpdateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgUserGroupAddOrUpdateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupDeleteRequest extends $tea.Model {
  /**
   * @remarks
   * The information about the user group.
   */
  ids?: number[];
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupDeleteShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The information about the user group.
   */
  idsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      idsShrink: 'Ids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      idsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupDeleteResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation result. Valid values:
   * 
   * *   true: The user group is deleted.
   * *   false: The user group fails to be deleted.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupDeleteResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgUserGroupDeleteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgUserGroupDeleteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupGetOdpsRoleGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the MaxCompute project. You can call the [DsgPlatformQueryProjectsAndSchemaFromMeta](https://help.aliyun.com/document_detail/2786303.html) operation to query a list of MaxCompute projects.
   * 
   * This parameter is required.
   * 
   * @example
   * test_project
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupGetOdpsRoleGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: string[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': 'string' },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupGetOdpsRoleGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgUserGroupGetOdpsRoleGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgUserGroupGetOdpsRoleGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupQueryListRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword of the user group name. A fuzzy match is performed based on the keyword to search for the user group.
   * 
   * @example
   * yun_group
   */
  name?: string;
  /**
   * @remarks
   * The owner of the user group.
   * 
   * @example
   * user1
   */
  owner?: string;
  /**
   * @remarks
   * The page number.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The name of the compute engine. If you want to query the information about a MaxCompute user group, you need to configure this parameter.
   * 
   * @example
   * dev_project
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      owner: 'Owner',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      owner: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupQueryListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The pagination information.
   */
  pageData?: DsgUserGroupQueryListResponseBodyPageData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      pageData: 'PageData',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      pageData: DsgUserGroupQueryListResponseBodyPageData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupQueryListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgUserGroupQueryListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgUserGroupQueryListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupQueryUserListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned result.
   */
  data?: DsgUserGroupQueryUserListResponseBodyData[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DsgUserGroupQueryUserListResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupQueryUserListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgUserGroupQueryUserListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgUserGroupQueryUserListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListAddOrUpdateRequest extends $tea.Model {
  /**
   * @remarks
   * A collection of whitelists.
   * 
   * This parameter is required.
   */
  whiteLists?: DsgWhiteListAddOrUpdateRequestWhiteLists[];
  static names(): { [key: string]: string } {
    return {
      whiteLists: 'WhiteLists',
    };
  }

  static types(): { [key: string]: any } {
    return {
      whiteLists: { 'type': 'array', 'itemType': DsgWhiteListAddOrUpdateRequestWhiteLists },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListAddOrUpdateShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * A collection of whitelists.
   * 
   * This parameter is required.
   */
  whiteListsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      whiteListsShrink: 'WhiteLists',
    };
  }

  static types(): { [key: string]: any } {
    return {
      whiteListsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListAddOrUpdateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation result. Valid values:
   * 
   * *   true: The operation is successful.
   * *   false: The operation fails.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListAddOrUpdateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgWhiteListAddOrUpdateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgWhiteListAddOrUpdateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListDeleteListRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the whitelists.
   * 
   * This parameter is required.
   */
  ids?: number[];
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListDeleteListShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The IDs of the whitelists.
   * 
   * This parameter is required.
   */
  idsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      idsShrink: 'Ids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      idsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListDeleteListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The operation result. Valid values:
   * 
   * *   true: The operation is successful.
   * *   false: The operation failed.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListDeleteListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgWhiteListDeleteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgWhiteListDeleteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListQueryListRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword of the sensitive field type.
   * 
   * @example
   * phone
   */
  dataType?: string;
  /**
   * @remarks
   * The page number.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the level-2 data masking scenario. You can call the [DsgSceneQuerySceneListByName](https://help.aliyun.com/document_detail/2786322.html) operation to query the list of IDs.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  sceneId?: number;
  static names(): { [key: string]: string } {
    return {
      dataType: 'DataType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      sceneId: 'SceneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      sceneId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListQueryListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1029030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * param error
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The pagination information.
   */
  pageData?: DsgWhiteListQueryListResponseBodyPageData;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      pageData: 'PageData',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      pageData: DsgWhiteListQueryListResponseBodyPageData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListQueryListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DsgWhiteListQueryListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DsgWhiteListQueryListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditRecognizeRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The Alibaba Cloud account that is used to create the sensitive data identification rule. Enter the username of the Alibaba Cloud account.
   * 
   * This parameter is required.
   * 
   * @example
   * dsg-uat
   */
  accountName?: string;
  /**
   * @remarks
   * Excludes fields. The system does not identify fields that are assigned with values.
   * 
   * *   The value must be in the ${Project name}.${Table name}.${Field name} or ${Project name}.${Schema name}.${Table name}.${Field name} format.
   * *   *Wildcards are supported. For example, the asterisk (\\*) in default.table.column1\\* can be used to match any content following default.table.column1, such as default.table.column10.
   * 
   * @example
   * default.qujian.*6
   */
  colExclude?: string;
  /**
   * @remarks
   * Scans fields. The system identifies only fields that are assigned with values.
   * 
   * *   The value must be in the ${Project name}.${Table name}.${Field name} or ${Project name}.${Schema name}.${Table name}.${Field name} format.
   * *   *Wildcards are supported. For example, the asterisk (\\*) in default.table.column1\\* can be used to match any content following default.table.column1, such as default.table.column10.
   * 
   * @example
   * default.qujian.*
   */
  colScan?: string;
  /**
   * @remarks
   * Scans content. The value is the text of each field comment in your data asset. Fuzzy match is supported.
   * 
   * @example
   * test
   */
  commentScan?: string;
  /**
   * @remarks
   * Identifies content. You can call the [QuerySensNodeInfo](https://help.aliyun.com/document_detail/2747189.html) operation to query the value of the current parameter for a built-in sensitive field.
   * 
   * @example
   * {"_clazz":"com.alipay.dsgclient.sdk.dsg.fastscan.engine.cond.NationalityCond"}
   */
  contentScan?: string;
  /**
   * @remarks
   * The hit ratio threshold. If more than 60%, which is a sample hit ratio threshold, of all sample data records hit the Name Entity Recognition (NER) model, the sensitive field is hit. The value can be an integer from 0 to 100.
   * 
   * @example
   * 50
   */
  hitThreshold?: number;
  /**
   * @remarks
   * The name of the sensitivity level. You can call the [QueryDefaultTemplate](https://help.aliyun.com/document_detail/2743948.html) operation to obtain the name of the sensitivity level in the related template.
   */
  levelName?: string;
  /**
   * @remarks
   * The ID of the data category. You can call the [QuerySensClassification](https://help.aliyun.com/document_detail/2746850.html) operation to query the ID of all data categories. Then, you can select a data category to create a sensitive field. Enter the ID of the selected data category.
   * 
   * This parameter is required.
   * 
   * @example
   * 0ce67949-0810-400f-a24a-cc5ffafe1024
   */
  nodeId?: string;
  /**
   * @remarks
   * The information about the parent data category of the current data category. You can call the [QuerySensClassification](https://help.aliyun.com/document_detail/2746850.html) operation to obtain the ID of a data category.
   * 
   * This parameter is required.
   */
  nodeParent?: string;
  /**
   * @remarks
   * The type of the arithmetic operation. Valid values:
   * 
   * *   0: OR
   * *   1: AND
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  operationType?: number;
  /**
   * @remarks
   * The content of the sensitive data identification rule. You can call the [QuerySensNodeInfo](https://help.aliyun.com/document_detail/2747189.html) operation to query the value of the current parameter for a built-in sensitive field.
   * 
   * @example
   * {"contentRule":{"_clazz":"com.alipay.dsgclient.sdk.dsg.fastscan.engine.cond.GenderCond"},"_clazz":"com.alipay.dsg.dal.model.RuleContent"}
   */
  recognizeRules?: string;
  /**
   * @remarks
   * The type of the sensitive data identification rule. Valid values:
   * 
   * *   1: regular expression
   * *   2: built-in rule
   * *   3: sample library
   * *   4: self-generated data identification model
   * 
   * @example
   * 1
   */
  recognizeRulesType?: string;
  /**
   * @remarks
   * The description of the sensitive field. Enter a string that is less than 128 characters in length.
   */
  sensitiveDescription?: string;
  /**
   * @remarks
   * The sensitive field ID. You can call the [QuerySensNodeInfo](https://help.aliyun.com/document_detail/2747189.html) operation to query the IDs of all sensitive fields. You can also call the [QueryRecognizeRuleDetail](https://help.aliyun.com/document_detail/2766023.html) operation to query the IDs of specific sensitive fields.
   * 
   * This parameter is required.
   * 
   * @example
   * 1a928de7-3962-4e07-93ac-e1973baa1024
   */
  sensitiveId?: string;
  /**
   * @remarks
   * The name of the custom sensitive field. Enter a string that is less than 128 characters in length.
   * 
   * This parameter is required.
   */
  sensitiveName?: string;
  /**
   * @remarks
   * The status of the sensitive field. Valid values:
   * 
   * *   0: draft
   * *   1: effective
   * 
   * @example
   * 0
   */
  status?: number;
  /**
   * @remarks
   * The template ID. You can call the [QueryDefaultTemplate](https://help.aliyun.com/document_detail/2743948.html) operation to obtain the template ID.
   * 
   * This parameter is required.
   * 
   * @example
   * e1970541-6cf5-4d23-b101-d5b66f6e1024
   */
  templateId?: string;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * This parameter is required.
   * 
   * @example
   * 10241024
   */
  tenantId?: string;
  /**
   * @remarks
   * The sensitivity level of the sensitive field. You can select one from all sensitivity levels that are defined in a template as the sensitivity level of the sensitive field, such as level 1 to level 10.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  level?: string;
  static names(): { [key: string]: string } {
    return {
      accountName: 'AccountName',
      colExclude: 'ColExclude',
      colScan: 'ColScan',
      commentScan: 'CommentScan',
      contentScan: 'ContentScan',
      hitThreshold: 'HitThreshold',
      levelName: 'LevelName',
      nodeId: 'NodeId',
      nodeParent: 'NodeParent',
      operationType: 'OperationType',
      recognizeRules: 'RecognizeRules',
      recognizeRulesType: 'RecognizeRulesType',
      sensitiveDescription: 'SensitiveDescription',
      sensitiveId: 'SensitiveId',
      sensitiveName: 'SensitiveName',
      status: 'Status',
      templateId: 'TemplateId',
      tenantId: 'TenantId',
      level: 'level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountName: 'string',
      colExclude: 'string',
      colScan: 'string',
      commentScan: 'string',
      contentScan: 'string',
      hitThreshold: 'number',
      levelName: 'string',
      nodeId: 'string',
      nodeParent: 'string',
      operationType: 'number',
      recognizeRules: 'string',
      recognizeRulesType: 'string',
      sensitiveDescription: 'string',
      sensitiveId: 'string',
      sensitiveName: 'string',
      status: 'number',
      templateId: 'string',
      tenantId: 'string',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditRecognizeRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned result in the JSON format.
   * 
   * @example
   * { "HttpStatusCode": 200, "Success": true }
   */
  data?: any;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9990030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 10000001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EditRecognizeRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EditRecognizeRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EditRecognizeRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EstablishRelationTableToBusinessRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the workflow. You can call the [ListBusiness](https://help.aliyun.com/document_detail/173945.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000001
   */
  businessId?: string;
  /**
   * @remarks
   * The ID of the folder. You can call the [GetFolder](https://help.aliyun.com/document_detail/173952.html) or [ListFolders](https://help.aliyun.com/document_detail/173955.html) operation to query the ID.
   * 
   * @example
   * 2eb6f9****
   */
  folderId?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace Management page and view the workspace ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The unique identifier of the DataWorks workspace. You can click the identifier in the upper-left corner of the DataStudio page to switch to another workspace.
   * 
   * You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw
   */
  projectIdentifier?: string;
  /**
   * @remarks
   * The universally unique identifier (UUID) of the table. You can call the [SearchMetaTables](https://help.aliyun.com/document_detail/173919.html) operation to query the UUID.
   * 
   * This parameter is required.
   * 
   * @example
   * odps.dw_project.tb1
   */
  tableGuid?: string;
  static names(): { [key: string]: string } {
    return {
      businessId: 'BusinessId',
      folderId: 'FolderId',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
      tableGuid: 'TableGuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessId: 'string',
      folderId: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
      tableGuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EstablishRelationTableToBusinessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can troubleshoot issues based on the ID.
   * 
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EstablishRelationTableToBusinessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: EstablishRelationTableToBusinessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EstablishRelationTableToBusinessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportDataSourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the data source. Valid values:
   * 
   * *   odps
   * *   mysql
   * *   rds
   * *   oss
   * *   sqlserver
   * *   polardb
   * *   oracle
   * *   mongodb
   * *   emr
   * *   postgresql
   * *   analyticdb_for_mysql
   * *   hybriddb_for_postgresql
   * *   holo
   * 
   * @example
   * rds
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The environment in which the data source resides. Valid values:
   * 
   * *   0: development environment
   * *   1: production environment
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The keyword contained in the names of the data sources that you want to export. You can specify only one keyword. For example, if you set this parameter to test, you can call the ExportDataSources operation to export all data sources whose names contain test in the workspace.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace to which the data sources belong. You can call the [ListProjects](https://help.aliyun.com/document_detail/178393.html) operation to query the ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The subtype of the data source. This parameter takes effect only when the DataSourceType parameter is set to rds.
   * 
   * If the value of the DataSourceType parameter is rds, the value of this parameter can be mysql, sqlserver, or postgresql.
   * 
   * @example
   * mysql
   */
  subType?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceType: 'DataSourceType',
      envType: 'EnvType',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      subType: 'SubType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceType: 'string',
      envType: 'number',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      subType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportDataSourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the exported data sources.
   */
  data?: ExportDataSourcesResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned. Valid values:
   * 
   * *   200: The request was successful.
   * *   Other values: The request failed. You can troubleshoot issues based on the HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0bc14115159376359****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ExportDataSourcesResponseBodyData,
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportDataSourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ExportDataSourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportDataSourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDISyncTaskConfigForCreatingRequest extends $tea.Model {
  /**
   * @remarks
   * The client token that is used to ensure the idempotence of the request. This parameter is used to prevent repeated operations that are caused by multiple calls.
   * 
   * @example
   * ABFUOEUOTRTRJKE
   */
  clientToken?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the ID.
   * 
   * You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The script for the synchronization task. DataWorks allows you to create the following types of synchronization tasks:
   * 
   * *   Synchronization task that is used to synchronize data from MySQL to MaxCompute
   * *   Synchronization task that is used to synchronize data from MySQL data to Kafka
   * *   Synchronization task that is used to synchronize data from MySQL to Hologres
   * 
   * The SelectedTables parameter is used to specify tables that you want to synchronize from multiple databases. The Tables parameter is used to specify tables that you want to synchronize from a single database.
   * 
   * *   If the script contains the SelectedTables parameter, the system synchronizes data from the tables that you specify in the SelectedTables parameter.
   * *   If the script contains the Tables parameter, the system synchronizes data from the tables that you specify in the Tables parameter.
   * 
   * The following sample code provides a script for data synchronization from MySQL to MaxCompute:
   * 
   *     {
   *       "type": "realtime",
   *       "version": "1.0",
   *       "setting": {
   *         "resourceGroup": "S_res_group_280749521950784_1623033752022",
   *         "taskType": "oneclick_to_odps"
   *       },
   *       "steps": [
   *         {
   *           "stepType": "mysql",
   *           "parameter": {
   *             "connection": [
   *               {
   *                 "datasourceType": "mysql",
   *                 "datasource": "mysql_pub1",
   *                 "selectedTables": [
   *                   {
   *                     "dbName": "mysql_db",
   *                     "schema": [
   *                       {
   *                         "tableInfos": [
   *                           {
   *                             "table": "molin_di_test_in_pk_v4"
   *                           }
   *                         ]
   *                       }
   *                     ]
   *                   }
   *                 ]
   *               }
   *             ]
   *           },
   *           "name": "Reader",
   *           "category": "reader"
   *         },
   *         {
   *           "stepType": "odps",
   *           "parameter": {
   *             "datasource": "odps_source"
   *           },
   *           "name": "Writer",
   *           "category": "writer"
   *         }
   *       ]
   *     }
   * 
   * The following sample code provides a script for data synchronization from MySQL to Kafka:
   * 
   *     {
   *       "type": "realtime",
   *       "version": "1.0",
   *       "setting": {
   *         "resourceGroup": "S_res_group_280749521950784_1623033752022",
   *         "taskType": "oneclick_to_kafka"
   *       },
   *       "steps": [
   *         {
   *           "stepType": "mysql",
   *           "parameter": {
   *             "connection": [
   *               {
   *                 "datasourceType": "mysql",
   *                 "datasource": "pkset_test",
   *                 "selectedTables": [
   *                   {
   *                     "dbName": "mysql_db",
   *                     "schema": [
   *                       {
   *                         "tableInfos": [
   *                           {
   *                             "table": "molin_di_test_in_pk_v4"
   *                           }
   *                         ]
   *                       }
   *                     ]
   *                   }
   *                 ]
   *               }
   *             ]
   *           },
   *           "name": "Reader",
   *           "category": "reader"
   *         },
   *         {
   *           "stepType": "kafka",
   *           "parameter": {
   *             "datasource": "azn_kafka"
   *           },
   *           "name": "Writer",
   *           "category": "writer"
   *         }
   *       ]
   *     }
   * 
   * The following sample code provides a script for data synchronization from MySQL to Hologres:
   * 
   *     {
   *       "type": "realtime",
   *       "version": "1.0",
   *       "setting": {
   *         "resourceGroup": "S_res_group_280749521950784_1623033752022",
   *         "taskType": "oneclick_to_holo"
   *       },
   *       "steps": [
   *         {
   *           "stepType": "mysql",
   *           "parameter": {
   *             "connection": [
   *               {
   *                 "datasourceType": "mysql",
   *                 "datasource": "mysql_pub",
   *                 "selectedTables": [
   *                   {
   *                     "dbName": "mysql_db",
   *                     "schema": [
   *                       {
   *                         "tableInfos": [
   *                           {
   *                             "table": "molin_di_test_in2_pk_v3"
   *                           }
   *                         ]
   *                       }
   *                     ]
   *                   }
   *                 ]
   *               }
   *             ]
   *           },
   *           "name": "Reader",
   *           "category": "reader"
   *         },
   *         {
   *           "stepType": "holo",
   *           "parameter": {
   *             "datasource": "holo"
   *           },
   *           "name": "Writer",
   *           "category": "writer"
   *         }
   *       ]
   *     }
   * 
   * This parameter is required.
   * 
   * @example
   * {    "type": "realtime",     "version": "1.0",        "setting": {       "resourceGroup":       "S_res_group_280749521950784_1623033752022",        "scheduleResgroupId": 30003913,       "name": "openapi_realtime_solution_0813_1739",       "taskType": "oneclick_to_odps"     },     "steps": [         {             "stepType": "mysql",             "parameter": {                 "connection": [                     {                        "datasourceType": "mysql",                         "datasource": "mysql_pub",                         "table": [                             "xyx"                         ]                     }                 ]             },             "name": "Reader",             "category": "reader"         },         {             "stepType": "odps",             "parameter": {                 "datasource": "odps_first"             },             "name": "Writer",             "category": "writer"         }     ] }
   */
  taskParam?: string;
  /**
   * @remarks
   * The type of task that you want to create in Data Integration in asynchronous mode. Valid values:
   * 
   * *   DI_REALTIME: real-time synchronization task
   * *   DI_SOLUTION: another type of synchronization task
   * 
   * DataWorks allows you to create real-time synchronization tasks and other types of synchronization tasks in Data Integration only in asynchronous mode.
   * 
   * *   DI_OFFLINE
   * *   DI_REALTIME
   * *   DI_SOLUTION
   * 
   * This parameter is required.
   * 
   * @example
   * DI_REALTIME
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      projectId: 'ProjectId',
      taskParam: 'TaskParam',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      projectId: 'number',
      taskParam: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDISyncTaskConfigForCreatingResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information returned for the ID of the asynchronous thread.
   */
  data?: GenerateDISyncTaskConfigForCreatingResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GenerateDISyncTaskConfigForCreatingResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDISyncTaskConfigForCreatingResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GenerateDISyncTaskConfigForCreatingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GenerateDISyncTaskConfigForCreatingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDISyncTaskConfigForUpdatingRequest extends $tea.Model {
  /**
   * @remarks
   * The client token that is used to ensure the idempotence of the request. This parameter is used to prevent repeated operations that are caused by multiple calls.
   * 
   * @example
   * ABFUOEUOTRTRJKE
   */
  clientToken?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
   * 
   * You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The task ID.
   * 
   * *   If you set the TaskType parameter to DI_REALTIME, set the TaskId parameter to the value of the FileId parameter for the real-time synchronization task.
   * *   If you set the TaskType parameter to DI_SOLUTION, set the TaskId parameter to the value of the FileId parameter for the synchronization solution.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  taskId?: number;
  /**
   * @remarks
   * The script for updating the real-time synchronization task in Data Integration. DataWorks allows you to add or remove tables for a real-time synchronization task in Data Integration only in asynchronous mode. The following types of real-time synchronization tasks are supported:
   * 
   * *   Synchronization task that is used to synchronize data from MySQL to MaxCompute
   * *   Synchronization task that is used to synchronize data from MySQL data to Kafka
   * *   Synchronization task that is used to synchronize data from MySQL to Hologres
   * 
   * The SelectedTables parameter is used to specify tables that you want to synchronize from multiple databases. The Tables parameter is used to specify tables that you want to synchronize from a single database.
   * 
   * *   If the script contains the SelectedTables parameter, the system synchronizes data from the tables that you specify in the SelectedTables parameter.
   * *   If the script contains the Tables parameter, the system synchronizes data from the tables that you specify in the Tables parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * {      "steps": [         {             "parameter": {                 "connection": [                     {                         "table": [                             "xyx"                         ]                     }                 ]             },             "name": "Reader",             "category": "reader"         }     ] }
   */
  taskParam?: string;
  /**
   * @remarks
   * The type of the object that you want to update in Data Integration in asynchronous mode. Valid values:
   * 
   * *   DI_REALTIME: real-time synchronization task
   * *   DI_SOLUTION: synchronization solution DataWorks allows you to create or update real-time synchronization tasks in Data Integration only in asynchronous mode.
   * 
   * Valid values:
   * 
   * *   DI_OFFLINE
   * *   DI_REALTIME
   * *   DI_SOLUTION
   * 
   * This parameter is required.
   * 
   * @example
   * DI_REALTIME
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      clientToken: 'ClientToken',
      projectId: 'ProjectId',
      taskId: 'TaskId',
      taskParam: 'TaskParam',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientToken: 'string',
      projectId: 'number',
      taskId: 'number',
      taskParam: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDISyncTaskConfigForUpdatingResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information returned for the ID of the asynchronous thread.
   */
  data?: GenerateDISyncTaskConfigForUpdatingResponseBodyData;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GenerateDISyncTaskConfigForUpdatingResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDISyncTaskConfigForUpdatingResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GenerateDISyncTaskConfigForUpdatingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GenerateDISyncTaskConfigForUpdatingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertMessageRequest extends $tea.Model {
  /**
   * @remarks
   * The alert ID. You can all the [ListAlertMessages](https://help.aliyun.com/document_detail/173961.html) operation to obtain the alert ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1421
   */
  alertId?: string;
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertMessageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the returned data.
   */
  data?: GetAlertMessageResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetAlertMessageResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertMessageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAlertMessageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAlertMessageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  baselineId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: GetBaselineResponseBodyData;
  /**
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @example
   * The specified parameters are invalid
   */
  errorMessage?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * ecb967ec-c137-48a5-860****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetBaselineResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetBaselineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetBaselineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The baseline ID. You can call the [GetNode](https://help.aliyun.com/document_detail/173977.html) operation to query the baseline ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the baseline.
   */
  data?: GetBaselineConfigResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 401
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * ecb967ec-c137-48a5-860****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetBaselineConfigResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetBaselineConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetBaselineConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineKeyPathRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the event.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-07-07T00:00:00+0800
   */
  bizdate?: string;
  /**
   * @remarks
   * The ID of the event.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  inGroupId?: number;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      bizdate: 'Bizdate',
      inGroupId: 'InGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      bizdate: 'string',
      inGroupId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineKeyPathResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the key path.
   */
  data?: GetBaselineKeyPathResponseBodyData[];
  /**
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The timestamp when the event was found.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetBaselineKeyPathResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineKeyPathResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetBaselineKeyPathResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetBaselineKeyPathResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the baseline.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  /**
   * @remarks
   * The data timestamp of the baseline instance. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\\"T\\"HH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-07-07T00:00:00+0800
   */
  bizdate?: string;
  /**
   * @remarks
   * The ID of the scheduling cycle of the baseline instance. For a baseline instance that is scheduled by day, the value of this parameter is 1. For a baseline instance that is scheduled by hour, the value of this parameter ranges from 1 to 24.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  inGroupId?: number;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      bizdate: 'Bizdate',
      inGroupId: 'InGroupId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      bizdate: 'string',
      inGroupId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the baseline instance.
   */
  data?: GetBaselineStatusResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetBaselineStatusResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetBaselineStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetBaselineStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBusinessRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the workflow. You can call the [ListBusiness](https://help.aliyun.com/document_detail/173945.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000000001
   */
  businessId?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID. You must specify either this parameter or ProjectIdentifier to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Settings panel to obtain the name. You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      businessId: 'BusinessId',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessId: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBusinessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the workflow.
   */
  data?: GetBusinessResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetBusinessResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBusinessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetBusinessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetBusinessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDDLJobStatusRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the DDL task.
   * 
   * This parameter is required.
   * 
   * @example
   * abc
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDDLJobStatusResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the task.
   */
  data?: GetDDLJobStatusResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * abc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDDLJobStatusResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDDLJobStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDDLJobStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDDLJobStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIAlarmRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The alert rule ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 34994
   */
  DIAlarmRuleId?: number;
  static names(): { [key: string]: string } {
    return {
      DIAlarmRuleId: 'DIAlarmRuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIAlarmRuleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIAlarmRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the alert rule.
   */
  DIAlarmRule?: GetDIAlarmRuleResponseBodyDIAlarmRule;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4A807D85-AC9F-55F7-A58F-998D5249CAD9
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      DIAlarmRule: 'DIAlarmRule',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIAlarmRule: GetDIAlarmRuleResponseBodyDIAlarmRule,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIAlarmRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDIAlarmRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDIAlarmRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the synchronization task.
   * 
   * This parameter is required.
   * 
   * @example
   * 11588
   */
  DIJobId?: number;
  /**
   * @remarks
   * Specifies whether to return detailed configuration information, including TransformationRules, TableMappings, and JobSettings. Valid values: true and false. Default value: true.
   * 
   * @example
   * true
   */
  withDetails?: boolean;
  static names(): { [key: string]: string } {
    return {
      DIJobId: 'DIJobId',
      withDetails: 'WithDetails',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobId: 'number',
      withDetails: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the synchronization task.
   */
  data?: GetDIJobResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDIJobResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDIJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDIJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDISyncInstanceInfoRequest extends $tea.Model {
  /**
   * @remarks
   * *   If you set the TaskType parameter to DI_REALTIME, set the FileId parameter to the ID of the real-time synchronization task that you want to query.
   * *   If you set the TaskType parameter to DI_SOLUTION, set the FileId parameter to the ID of the data synchronization solution that you want to query.
   * 
   * You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID of the real-time synchronization task or data synchronization solution.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  fileId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
   * 
   * You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The type of the object that you want to query. Valid values:
   * 
   * *   DI_REALTIME: real-time synchronization task
   * *   DI_SOLUTION: data synchronization solution
   * 
   * This parameter is required.
   * 
   * @example
   * DI_REALTIME
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      projectId: 'ProjectId',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      projectId: 'number',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDISyncInstanceInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The status of the real-time synchronization task or data synchronization solution.
   */
  data?: GetDISyncInstanceInfoResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDISyncInstanceInfoResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDISyncInstanceInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDISyncInstanceInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDISyncInstanceInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDISyncTaskRequest extends $tea.Model {
  /**
   * @remarks
   * *   If you set TaskType to DI_REALTIME, set this parameter to the ID of the real-time synchronization task that you want to deploy.
   * *   If you set TaskType to DI_SOLUTION, set this parameter to the ID of the data synchronization solution that you want to deploy.
   * 
   * You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID of the real-time synchronization task or data synchronization solution.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  fileId?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
   * 
   * You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The type of the object that you want to query. Valid values:
   * 
   * *   DI_REALTIME: real-time synchronization task
   * *   DI_SOLUTION: data synchronization solution
   * 
   * This parameter is required.
   * 
   * @example
   * DI_REALTIME
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      projectId: 'ProjectId',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      projectId: 'number',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDISyncTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned results.
   */
  data?: GetDISyncTaskResponseBodyData;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   True
   * *   False
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDISyncTaskResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDISyncTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDISyncTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDISyncTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDagRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the DAG. You can use one of the following method to obtain the ID:
   * 
   * *   Call the [RunCycleDagNodes](https://help.aliyun.com/document_detail/2780209.html) operation and obtain the value of the **Data** response parameter.
   * *   Call the [RunSmokeTest](https://help.aliyun.com/document_detail/2780210.html) operation and obtain the value of the **Data** response parameter.
   * *   Call the [RunManualDagNodes](https://help.aliyun.com/document_detail/2780218.html) operation and obtain the value of the **DagId** response parameter.
   * 
   * This parameter is required.
   * 
   * @example
   * 123141452344525
   */
  dagId?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDagResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the DAG.
   */
  data?: GetDagResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 7782a299-b291-4fee-8424-cf8058efa8e8
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDagResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDagResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDagResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDagResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the DataService Studio API.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  apiId?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 10002
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: GetDataServiceApiResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDataServiceApiResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataServiceApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataServiceApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiTestRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 123434
   */
  testId?: number;
  static names(): { [key: string]: string } {
    return {
      testId: 'TestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      testId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiTestResponseBody extends $tea.Model {
  data?: GetDataServiceApiTestResponseBodyData;
  /**
   * @example
   * adssdsewe
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDataServiceApiTestResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiTestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataServiceApiTestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataServiceApiTestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApplicationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the application. You can view the information about the application in the API Gateway console.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  applicationId?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * @example
   * 10002
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApplicationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the application.
   */
  data?: GetDataServiceApplicationResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 0
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Normal
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDataServiceApplicationResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataServiceApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataServiceApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceFolderRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the folder.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  folderId?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10002
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. This parameter is deprecated. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * @example
   * 10003
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      folderId: 'FolderId',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folderId: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceFolderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the folder.
   */
  folder?: GetDataServiceFolderResponseBodyFolder;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EF****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      folder: 'Folder',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folder: GetDataServiceFolderResponseBodyFolder,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceFolderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataServiceFolderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataServiceFolderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceGroupRequest extends $tea.Model {
  /**
   * @remarks
   * The business process ID.
   * 
   * This parameter is required.
   * 
   * @example
   * ds_123abc
   */
  groupId?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. This parameter is deprecated.
   * 
   * @example
   * 10002
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'string',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceGroupResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the business process.
   */
  group?: GetDataServiceGroupResponseBodyGroup;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EF****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      group: 'Group',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      group: GetDataServiceGroupResponseBodyGroup,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceGroupResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataServiceGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataServiceGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  apiId?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10002
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * @example
   * 10003
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The latest information about the API in the published state.
   */
  data?: GetDataServicePublishedApiResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDataServicePublishedApiResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataServicePublishedApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataServicePublishedApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataSourceMetaRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the data source.
   * 
   * This parameter is required.
   * 
   * @example
   * mysql_name
   */
  datasourceName?: string;
  /**
   * @remarks
   * The environment in which the data source resides. Valid values:
   * 
   * *   0: development environment
   * *   1: production environment
   * 
   * @example
   * 1
   */
  envType?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      datasourceName: 'DatasourceName',
      envType: 'EnvType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasourceName: 'string',
      envType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataSourceMetaResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned result.
   */
  data?: GetDataSourceMetaResponseBodyData;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDataSourceMetaResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataSourceMetaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDataSourceMetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDataSourceMetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeploymentRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the deployment task. A deployment task ID is generated when you call the [SubmitFile](https://help.aliyun.com/document_detail/173944.html) or [DeployFile](https://help.aliyun.com/document_detail/173956.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * 3000001
   */
  deploymentId?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace Management page and view the workspace ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The GUID of the DataWorks workspace. You can view the GUID in the upper part of the DataStudio page. You can also select another GUID to switch to another workspace.
   * 
   * You must specify either this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      deploymentId: 'DeploymentId',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deploymentId: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeploymentResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data about the deployment task.
   */
  data?: GetDeploymentResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can troubleshoot errors based on the ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetDeploymentResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeploymentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetDeploymentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetDeploymentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetExtensionRequest extends $tea.Model {
  /**
   * @remarks
   * The unique code of the extension.
   * 
   * This parameter is required.
   * 
   * @example
   * ce4*********086da5
   */
  extensionCode?: string;
  static names(): { [key: string]: string } {
    return {
      extensionCode: 'ExtensionCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extensionCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetExtensionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the extension.
   */
  extension?: GetExtensionResponseBodyExtension;
  /**
   * @remarks
   * The request ID. You can use the request ID to query logs and troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      extension: 'Extension',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extension: GetExtensionResponseBodyExtension,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetExtensionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetExtensionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetExtensionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the file. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to obtain the ID.
   * 
   * @example
   * 100000001
   */
  fileId?: number;
  /**
   * @remarks
   * The ID of the node that is scheduled. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to obtain the node ID.
   * 
   * @example
   * 200000001
   */
  nodeId?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
   * 
   * You must configure this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace name.
   * 
   * You must configure this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      nodeId: 'NodeId',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      nodeId: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the file.
   */
  data?: GetFileResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   true: The request is successful.
   * *   false: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetFileResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileTypeStatisticRequest extends $tea.Model {
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment. The value DEV indicates the development environment.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123465
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      projectEnv: 'ProjectEnv',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectEnv: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileTypeStatisticResponseBody extends $tea.Model {
  /**
   * @remarks
   * An array of node types and quantity.
   */
  programTypeAndCounts?: GetFileTypeStatisticResponseBodyProgramTypeAndCounts[];
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * SDFSDFSDF-SDFSDF-SDFDSF-SDFSDF
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      programTypeAndCounts: 'ProgramTypeAndCounts',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      programTypeAndCounts: { 'type': 'array', 'itemType': GetFileTypeStatisticResponseBodyProgramTypeAndCounts },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileTypeStatisticResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFileTypeStatisticResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileTypeStatisticResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileVersionRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the file. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000001
   */
  fileId?: number;
  /**
   * @remarks
   * The file version whose details you want to query.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  fileVersion?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace Management page and view the workspace ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The unique identifier of the DataWorks workspace. You can click the identifier in the upper-left corner of the DataStudio page to switch to another workspace.
   * 
   * You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      fileVersion: 'FileVersion',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      fileVersion: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileVersionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the file version.
   */
  data?: GetFileVersionResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can troubleshoot issues based on the ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetFileVersionResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileVersionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFileVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFolderRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the folder. You can call the [ListFolders](https://help.aliyun.com/document_detail/173955.html) operation to query the ID.
   * 
   * You must specify either this parameter or the FolderPath parameter.
   * 
   * @example
   * 273****
   */
  folderId?: string;
  /**
   * @remarks
   * The path of the folder. You can call the [ListFolders](https://help.aliyun.com/document_detail/173955.html) operation to query the path.
   * 
   * You must specify either this parameter or the FolderId parameter.
   */
  folderPath?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID. You must specify either this parameter or ProjectIdentifier to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Settings panel to obtain the name. You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      folderId: 'FolderId',
      folderPath: 'FolderPath',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folderId: 'string',
      folderPath: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFolderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the folder.
   */
  data?: GetFolderResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetFolderResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFolderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetFolderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFolderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIDEEventDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The message ID in DataWorks OpenEvent. You can obtain the ID from a received message when an extension point event is triggered.
   * 
   * This parameter is required.
   * 
   * @example
   * 8abcb91f-d266-4073-b907-2ed670378ed1
   */
  messageId?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can obtain the ID from the message.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      messageId: 'MessageId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      messageId: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIDEEventDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data snapshot that is generated when an extension point event is triggered.
   * 
   * The fields contained in data snapshots vary based on the types of the triggered extension point events. For more information, see the description of the fields.
   */
  eventDetail?: GetIDEEventDetailResponseBodyEventDetail;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 8abcb91f-d266-4073-b907-2ed670378ed1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      eventDetail: 'EventDetail',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventDetail: GetIDEEventDetailResponseBodyEventDetail,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIDEEventDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetIDEEventDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetIDEEventDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The instance ID. You can call the [ListInstances](https://help.aliyun.com/document_detail/173982.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  instanceId?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the instance.
   */
  data?: GetInstanceResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 0
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned when the instance fails to be scheduled.
   * 
   * @example
   * test
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetInstanceResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceConsumeTimeRankRequest extends $tea.Model {
  /**
   * @remarks
   * The data timestamp, accurate to the day. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\\"T\\"HH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-09-21T00:00:00+0800
   */
  bizdate?: string;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 100000
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      bizdate: 'Bizdate',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizdate: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceConsumeTimeRankResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ranking record of the running durations of instances.
   */
  instanceConsumeTimeRank?: GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6347364dadsfadf****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceConsumeTimeRank: 'InstanceConsumeTimeRank',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceConsumeTimeRank: GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceConsumeTimeRankResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInstanceConsumeTimeRankResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInstanceConsumeTimeRankResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceCountTrendRequest extends $tea.Model {
  /**
   * @remarks
   * The beginning of the time range to query, accurate to the day. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\\"T\\"HH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-04-02T00:00:00+0800
   */
  beginDate?: string;
  /**
   * @remarks
   * The end of the time range to query, accurate to the day. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\\"T\\"HH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-09-10T00:00:00+0800
   */
  endDate?: string;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      beginDate: 'BeginDate',
      endDate: 'EndDate',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginDate: 'string',
      endDate: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceCountTrendResponseBody extends $tea.Model {
  /**
   * @remarks
   * The quantity trend of instances.
   */
  instanceCounts?: GetInstanceCountTrendResponseBodyInstanceCounts[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 95279527adhfj****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceCounts: 'InstanceCounts',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceCounts: { 'type': 'array', 'itemType': GetInstanceCountTrendResponseBodyInstanceCounts },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceCountTrendResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInstanceCountTrendResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInstanceCountTrendResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceErrorRankRequest extends $tea.Model {
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 9527
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceErrorRankResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ranking data of nodes on which errors occurred.
   */
  instanceErrorRank?: GetInstanceErrorRankResponseBodyInstanceErrorRank;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 952795279527****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceErrorRank: 'InstanceErrorRank',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceErrorRank: GetInstanceErrorRankResponseBodyInstanceErrorRank,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceErrorRankResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInstanceErrorRankResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInstanceErrorRankResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceLogRequest extends $tea.Model {
  /**
   * @remarks
   * The historical record number of the instance. You can call the ListInstanceHistory operation to query the ID.
   * 
   * @example
   * 1
   */
  instanceHistoryId?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  instanceId?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      instanceHistoryId: 'InstanceHistoryId',
      instanceId: 'InstanceId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceHistoryId: 'number',
      instanceId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The content of the logs.
   * 
   * @example
   * log_content
   */
  data?: string;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInstanceLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInstanceLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceStatusCountRequest extends $tea.Model {
  /**
   * @remarks
   * The data timestamp of instances.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-01-01
   */
  bizDate?: string;
  /**
   * @remarks
   * The runtime environment. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      bizDate: 'BizDate',
      projectEnv: 'ProjectEnv',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizDate: 'string',
      projectEnv: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceStatusCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * The statistics of instances.
   */
  statusCount?: GetInstanceStatusCountResponseBodyStatusCount;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      statusCount: 'StatusCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      statusCount: GetInstanceStatusCountResponseBodyStatusCount,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceStatusCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInstanceStatusCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInstanceStatusCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceStatusStatisticRequest extends $tea.Model {
  /**
   * @remarks
   * The date on which the numbers of instances in different states are obtained. Specify the date in the yyyy-MM-dd format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-01-01
   */
  bizDate?: string;
  /**
   * @remarks
   * The type of the directed acyclic graph (DAG). Valid values:
   * 
   * *   MANUAL: DAG for a manually triggered workflow
   * *   SMOKE_TEST: DAG for a smoke testing workflow
   * *   SUPPLY_DATA: DAG for a data backfill instance
   * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
   * 
   * <!---->
   * 
   * *   DAILY
   * *   MANUAL
   * *   SMOKE_TEST
   * *   SUPPLY_DATA
   * *   BUSINESS_PROCESS_DAG
   * 
   * @example
   * MANUAL
   */
  dagType?: string;
  /**
   * @remarks
   * The runtime environment. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console and go to the Workspace page to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The scheduling cycle. Valid values:
   * 
   * *   MINUTE
   * *   HOUR
   * *   DAY
   * *   WEEK
   * *   MONTH
   * 
   * @example
   * DAY
   */
  schedulerPeriod?: string;
  /**
   * @remarks
   * The scheduling type of the node. Valid values:
   * 
   * *   NORMAL: auto triggered node
   * *   MANUAL: manually triggered node
   * *   PAUSE: paused node
   * *   SKIP: dry-run node
   * 
   * @example
   * NORMAL
   */
  schedulerType?: string;
  static names(): { [key: string]: string } {
    return {
      bizDate: 'BizDate',
      dagType: 'DagType',
      projectEnv: 'ProjectEnv',
      projectId: 'ProjectId',
      schedulerPeriod: 'SchedulerPeriod',
      schedulerType: 'SchedulerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizDate: 'string',
      dagType: 'string',
      projectEnv: 'string',
      projectId: 'number',
      schedulerPeriod: 'string',
      schedulerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceStatusStatisticResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * The numbers of instances in different states.
   */
  statusCount?: GetInstanceStatusStatisticResponseBodyStatusCount;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      statusCount: 'StatusCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      statusCount: GetInstanceStatusStatisticResponseBodyStatusCount,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceStatusStatisticResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetInstanceStatusStatisticResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInstanceStatusStatisticResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetManualDagInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the directed acyclic graph (DAG) for the manually triggered workflow. You can call the [CreateManualDag](https://help.aliyun.com/document_detail/189728.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 7000001231241
   */
  dagId?: string;
  /**
   * @remarks
   * The environment of Operation Center. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * RPOD
   */
  projectEnv?: string;
  /**
   * @remarks
   * The name of the workspace to which the manually triggered workflow belongs. You can log on to the DataWorks console and go to the Workspace Settings panel to query the name.
   * 
   * This parameter is required.
   * 
   * @example
   * test_workspace
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      projectEnv: 'ProjectEnv',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'string',
      projectEnv: 'string',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetManualDagInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The instances in the manually triggered workflow.
   */
  instances?: GetManualDagInstancesResponseBodyInstances[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * SDFSDFSDF-SDFSDF-SDFDSF-SDFSDF
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: { 'type': 'array', 'itemType': GetManualDagInstancesResponseBodyInstances },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetManualDagInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetManualDagInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetManualDagInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaCategoryRequest extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The category tree ID.
   * 
   * @example
   * 333
   */
  parentCategoryId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      parentCategoryId: 'ParentCategoryId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNum: 'number',
      pageSize: 'number',
      parentCategoryId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaCategoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The business data.
   */
  data?: GetMetaCategoryResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMetaCategoryResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaCategoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaCollectionDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the collection.
   * 
   * This parameter is required.
   * 
   * @example
   * album.12345
   */
  qualifiedName?: string;
  static names(): { [key: string]: string } {
    return {
      qualifiedName: 'QualifiedName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qualifiedName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaCollectionDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the collection.
   */
  collection?: Collection;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9999
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * album.xxxx does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true
   * 
   * false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      collection: 'Collection',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      collection: Collection,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaCollectionDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaCollectionDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaCollectionDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaColumnLineageRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the E-MapReduce (EMR) cluster. Configure this parameter only when you query data in an EMR compute engine instance.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The unique identifier of the field.
   * 
   * @example
   * odps.engine_name.table_name.column_name
   */
  columnGuid?: string;
  /**
   * @remarks
   * The name of the field.
   * 
   * @example
   * abc
   */
  columnName?: string;
  /**
   * @remarks
   * The type of the data source. Valid values: odps and emr.
   * 
   * @example
   * emr
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * Specifies whether to query the ancestor or descendant lineage of the field. The value up indicates the ancestor lineage. The value down indicates the descendant lineage.
   * 
   * This parameter is required.
   * 
   * @example
   * up
   */
  direction?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The name of the metatable.
   * 
   * @example
   * abc
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      columnGuid: 'ColumnGuid',
      columnName: 'ColumnName',
      dataSourceType: 'DataSourceType',
      databaseName: 'DatabaseName',
      direction: 'Direction',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      columnGuid: 'string',
      columnName: 'string',
      dataSourceType: 'string',
      databaseName: 'string',
      direction: 'string',
      pageNum: 'number',
      pageSize: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaColumnLineageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The business data.
   */
  data?: GetMetaColumnLineageResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMetaColumnLineageResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaColumnLineageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaColumnLineageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaColumnLineageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaDBInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The compute engine instance ID. Specify the ID in the `Engine type.Engine name` format.
   * 
   * @example
   * odps.some_engine_name
   */
  appGuid?: string;
  /**
   * @remarks
   * The E-MapReduce (EMR) cluster ID.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the data source. Valid values: odps and emr.
   * 
   * @example
   * emr
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The name of the metadatabase of the EMR cluster.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  static names(): { [key: string]: string } {
    return {
      appGuid: 'AppGuid',
      clusterId: 'ClusterId',
      dataSourceType: 'DataSourceType',
      databaseName: 'DatabaseName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGuid: 'string',
      clusterId: 'string',
      dataSourceType: 'string',
      databaseName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaDBInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The basic metadata information.
   */
  data?: GetMetaDBInfoResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1411515937****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMetaDBInfoResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaDBInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaDBInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaDBInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaDBTableListRequest extends $tea.Model {
  /**
   * @remarks
   * The GUID of the MaxCompute project. Specify the GUID in the `odps.{projectName}` format. You must configure this parameter only if you set the DataSourceType parameter to odps.
   * 
   * @example
   * odps.testProjectName
   */
  appGuid?: string;
  /**
   * @remarks
   * The E-MapReduce (EMR) cluster ID. You must configure this parameter only if you set the DataSourceType parameter to emr.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the data source. Valid values: odps and emr.
   * 
   * @example
   * odps
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The name of the metadatabase.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      appGuid: 'AppGuid',
      clusterId: 'ClusterId',
      dataSourceType: 'DataSourceType',
      databaseName: 'DatabaseName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGuid: 'string',
      clusterId: 'string',
      dataSourceType: 'string',
      databaseName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaDBTableListResponseBody extends $tea.Model {
  /**
   * @remarks
   * The metatable information in a compute engine instance.
   */
  data?: GetMetaDBTableListResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMetaDBTableListResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaDBTableListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaDBTableListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaDBTableListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableBasicInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
   * 
   * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to query the ID.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the data source. Valid values: odps and emr.
   * 
   * @example
   * emr
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The name of the metadatabase. This parameter is required only if you set the DataSourceType parameter to emr.
   * 
   * You can call the [ListMetaDB](https://help.aliyun.com/document_detail/2780105.html) operation to query the name.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * Specifies whether to include extended fields in query results. The extended fields include ReadCount, FavoriteCount, and ViewCount. This parameter takes effect only if you set the DataSourceType parameter to odps.
   * 
   * @example
   * false
   */
  extension?: boolean;
  /**
   * @remarks
   * The GUID of the MaxCompute table. Specify the GUID in the odps.projectName.tableName format.
   * 
   * > This parameter is optional for E-MapReduce (EMR) tables.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the metatable in the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
   * 
   * You can call the [GetMetaDBTableList](https://help.aliyun.com/document_detail/2780086.html) operation to query the name.
   * 
   * @example
   * abc
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dataSourceType: 'DataSourceType',
      databaseName: 'DatabaseName',
      extension: 'Extension',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dataSourceType: 'string',
      databaseName: 'string',
      extension: 'boolean',
      tableGuid: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableBasicInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The business data.
   */
  data?: GetMetaTableBasicInfoResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1411515937
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMetaTableBasicInfoResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableBasicInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableBasicInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableBasicInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableChangeLogRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the change. Valid values: CREATE_TABLE, ALTER_TABLE, DROP_TABLE, ADD_PARTITION, and DROP_PARTITION.
   * 
   * @example
   * ALTER_TABLE
   */
  changeType?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
   * 
   * *   By default, the system uses the current time as the value of this parameter if the time that you specify is invalid.
   * *   If both the values of the StartDate and EndDate parameters are invalid, the system automatically queries the change logs that are generated within the last 30 days.
   * 
   * @example
   * 2020-06-02 00:00:00
   */
  endDate?: string;
  /**
   * @remarks
   * The entity on which the change is made. Valid values: TABLE and PARTITION.
   * 
   * @example
   * TABLE
   */
  objectType?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
   * 
   * *   By default, the system uses the current time as the value of this parameter if the time that you specify is invalid.
   * *   If both the values of the StartDate and EndDate parameters are invalid, the system automatically queries the change logs that are generated within the last 30 days.
   * 
   * @example
   * 2020-06-01 00:00:00
   */
  startDate?: string;
  /**
   * @remarks
   * The GUID of the table. Specify the GUID in the odps.projectName.tableName format. You can call the [GetMetaDBTableList](https://help.aliyun.com/document_detail/2780086.html) operation to query the GUID.
   * 
   * > To query the change logs of a MaxCompute table, you must call the [GetMetaTableChangeLog](https://help.aliyun.com/document_detail/2780094.html) operation.
   * 
   * This parameter is required.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  static names(): { [key: string]: string } {
    return {
      changeType: 'ChangeType',
      endDate: 'EndDate',
      objectType: 'ObjectType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startDate: 'StartDate',
      tableGuid: 'TableGuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changeType: 'string',
      endDate: 'string',
      objectType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startDate: 'string',
      tableGuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableChangeLogResponseBody extends $tea.Model {
  /**
   * @remarks
   * The business data.
   */
  data?: GetMetaTableChangeLogResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMetaTableChangeLogResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableChangeLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableChangeLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableChangeLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableColumnRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the E-MapReduce (EMR) cluster. You can log on to the EMR console to obtain the ID.
   * 
   * @example
   * C-010A704DA760****
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the data source. Set the value to emr.
   * 
   * @example
   * emr
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The name of the metadatabase of the EMR cluster. You can call the [ListMetaDB](https://help.aliyun.com/document_detail/2780105.html) operation to query the name.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The GUID of the metatable. You can call the [GetMetaDBTableList](https://help.aliyun.com/document_detail/2780086.html) operation to query the GUID.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the metatable in the EMR cluster. You can call the [GetMetaDBTableList](https://help.aliyun.com/document_detail/2780086.html) operation to query the name.
   * 
   * @example
   * abc
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dataSourceType: 'DataSourceType',
      databaseName: 'DatabaseName',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dataSourceType: 'string',
      databaseName: 'string',
      pageNum: 'number',
      pageSize: 'number',
      tableGuid: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableColumnResponseBody extends $tea.Model {
  /**
   * @remarks
   * The business data.
   */
  data?: GetMetaTableColumnResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMetaTableColumnResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableColumnResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableColumnResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableColumnResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableFullInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the E-MapReduce (EMR) cluster. You can log on to the EMR console to obtain the ID of the cluster.
   * 
   * @example
   * C-010A704DA760****
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the data source. Only emr is supported.
   * 
   * @example
   * emr
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The name of the metadatabase of the EMR cluster. You can call the [ListMetaDB](https://help.aliyun.com/document_detail/185662.html) operation to query the name of the metadatabase.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The GUID of the metatable. You can call the [GetMetaDBTableList](https://help.aliyun.com/document_detail/173916.html) operation to query the GUID of the metatable.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the metatable in the EMR cluster. You can call the [GetMetaDBTableList](https://help.aliyun.com/document_detail/173916.html) operation to query the name of the metatable.
   * 
   * @example
   * abc
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dataSourceType: 'DataSourceType',
      databaseName: 'DatabaseName',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dataSourceType: 'string',
      databaseName: 'string',
      pageNum: 'number',
      pageSize: 'number',
      tableGuid: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableFullInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The business data returned.
   */
  data?: GetMetaTableFullInfoResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   * 
   * @example
   * 0bc1411515937****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMetaTableFullInfoResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableFullInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableFullInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableFullInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableIntroWikiRequest extends $tea.Model {
  /**
   * @remarks
   * The GUID of the metatable.
   * 
   * This parameter is required.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  /**
   * @remarks
   * The version of the instructions.
   * 
   * @example
   * 1
   */
  wikiVersion?: number;
  static names(): { [key: string]: string } {
    return {
      tableGuid: 'TableGuid',
      wikiVersion: 'WikiVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tableGuid: 'string',
      wikiVersion: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableIntroWikiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The business data.
   */
  data?: GetMetaTableIntroWikiResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMetaTableIntroWikiResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableIntroWikiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableIntroWikiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableIntroWikiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableLineageRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the E-MapReduce (EMR) cluster. Configure this parameter only if you want to query the lineage of an EMR table.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the data source. Valid values: odps and emr.
   * 
   * @example
   * emr
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * Specifies the ancestor or descendant lineage that you want to query for a field. Valid values: up and down. The value up indicates the ancestor lineage. The value down indicates the descendant lineage.
   * 
   * This parameter is required.
   * 
   * @example
   * up
   */
  direction?: string;
  /**
   * @remarks
   * The logic of paging. Configure this parameter based on the value of the response parameter NextPrimaryKey when the value of the response parameter HasNext is true in the previous request.
   * 
   * @example
   * odps.engine_name.table_name1
   */
  nextPrimaryKey?: string;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The unique identifier of the table.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * abc
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dataSourceType: 'DataSourceType',
      databaseName: 'DatabaseName',
      direction: 'Direction',
      nextPrimaryKey: 'NextPrimaryKey',
      pageSize: 'PageSize',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dataSourceType: 'string',
      databaseName: 'string',
      direction: 'string',
      nextPrimaryKey: 'string',
      pageSize: 'number',
      tableGuid: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableLineageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The business data.
   */
  data?: GetMetaTableLineageResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMetaTableLineageResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableLineageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableLineageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableLineageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableListByCategoryRequest extends $tea.Model {
  /**
   * @remarks
   * The category ID. You can call the [GetMetaCategory](https://help.aliyun.com/document_detail/2780099.html) operation to obtain the ID of the category. Categories allow you to efficiently organize and manage tables by category. You can search for the desired table by category.
   * 
   * This parameter is required.
   * 
   * @example
   * 23
   */
  categoryId?: number;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      categoryId: 'CategoryId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableListByCategoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The business data returned.
   */
  data?: GetMetaTableListByCategoryResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMetaTableListByCategoryResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableListByCategoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableListByCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableListByCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableOutputRequest extends $tea.Model {
  /**
   * @remarks
   * The end date.
   * 
   * This parameter is required.
   * 
   * @example
   * 2022-02-15
   */
  endDate?: string;
  /**
   * @remarks
   * The page number. Valid values: 1 to 30. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The start date.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-02-02
   */
  startDate?: string;
  /**
   * @remarks
   * The GUID of the metatable.
   * 
   * This parameter is required.
   * 
   * @example
   * odps.sample_project.sample_table
   */
  tableGuid?: string;
  /**
   * @remarks
   * The task ID.
   * 
   * @example
   * 1048576
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      startDate: 'StartDate',
      tableGuid: 'TableGuid',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      startDate: 'string',
      tableGuid: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableOutputResponseBody extends $tea.Model {
  /**
   * @remarks
   * The business data.
   */
  data?: GetMetaTableOutputResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 0
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * SUCCESS
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-0000-0000-000
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMetaTableOutputResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableOutputResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableOutputResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableOutputResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTablePartitionRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
   * 
   * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the data source. Valid values: odps and emr.
   * 
   * @example
   * emr
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The name of the database. This parameter is required only if you set the DataSourceType parameter to emr.
   * 
   * You can call the [ListMetaDB](https://help.aliyun.com/document_detail/2780105.html) operation to query the name of the metadatabase.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The logic for sorting partitions in the metatable.
   */
  sortCriterion?: GetMetaTablePartitionRequestSortCriterion;
  /**
   * @remarks
   * The unique identifier of the metatable.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the metatable in the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
   * 
   * You can call the [GetMetaDBTableList](https://help.aliyun.com/document_detail/2780086.html) operation to query the name of the metatable.
   * 
   * @example
   * abc
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dataSourceType: 'DataSourceType',
      databaseName: 'DatabaseName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      sortCriterion: 'SortCriterion',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dataSourceType: 'string',
      databaseName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      sortCriterion: GetMetaTablePartitionRequestSortCriterion,
      tableGuid: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTablePartitionShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
   * 
   * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the data source. Valid values: odps and emr.
   * 
   * @example
   * emr
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The name of the database. This parameter is required only if you set the DataSourceType parameter to emr.
   * 
   * You can call the [ListMetaDB](https://help.aliyun.com/document_detail/2780105.html) operation to query the name of the metadatabase.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The logic for sorting partitions in the metatable.
   */
  sortCriterionShrink?: string;
  /**
   * @remarks
   * The unique identifier of the metatable.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the metatable in the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
   * 
   * You can call the [GetMetaDBTableList](https://help.aliyun.com/document_detail/2780086.html) operation to query the name of the metatable.
   * 
   * @example
   * abc
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dataSourceType: 'DataSourceType',
      databaseName: 'DatabaseName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      sortCriterionShrink: 'SortCriterion',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dataSourceType: 'string',
      databaseName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      sortCriterionShrink: 'string',
      tableGuid: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTablePartitionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned result.
   */
  data?: GetMetaTablePartitionResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMetaTablePartitionResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTablePartitionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTablePartitionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTablePartitionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableProducingTasksRequest extends $tea.Model {
  /**
   * @example
   * C-A_SAMPLE_CLUSTER_ID
   */
  clusterId?: string;
  /**
   * @example
   * odps
   */
  dataSourceType?: string;
  /**
   * @example
   * default
   */
  dbName?: string;
  /**
   * @example
   * myschema
   */
  schemaName?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * odps.sample_project.sample_table
   */
  tableGuid?: string;
  /**
   * @example
   * sample_table
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dataSourceType: 'DataSourceType',
      dbName: 'DbName',
      schemaName: 'SchemaName',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dataSourceType: 'string',
      dbName: 'string',
      schemaName: 'string',
      tableGuid: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableProducingTasksResponseBody extends $tea.Model {
  data?: GetMetaTableProducingTasksResponseBodyData[];
  /**
   * @example
   * "0"
   */
  errorCode?: string;
  /**
   * @example
   * SUCCESS
   */
  errorMessage?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * 00000-00000-00000-00000
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetMetaTableProducingTasksResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableProducingTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableProducingTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableProducingTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableThemeLevelRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the data source. Set the value to odps.
   * 
   * This parameter is required.
   * 
   * @example
   * odps
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The GUID of the metatable. Specify the GUID in the format of odps.${projectName}.${tableName}.
   * 
   * This parameter is required.
   * 
   * @example
   * odps.project1.name1
   */
  tableGuid?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceType: 'DataSourceType',
      tableGuid: 'TableGuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceType: 'string',
      tableGuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableThemeLevelResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  entity?: GetMetaTableThemeLevelResponseBodyEntity;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 0
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * success
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can troubleshoot issues based on the ID.
   * 
   * @example
   * 1324afdsfde
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      entity: 'Entity',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entity: GetMetaTableThemeLevelResponseBodyEntity,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableThemeLevelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMetaTableThemeLevelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMetaTableThemeLevelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMigrationProcessRequest extends $tea.Model {
  /**
   * @remarks
   * The migration package ID. You can call the CreateImportMigration operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  migrationId?: number;
  /**
   * @remarks
   * The workspace ID. You can log on to the DataWorks console and go to the Workspace page to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      migrationId: 'MigrationId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrationId: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMigrationProcessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The progress information of the migration task, including the names of all steps in and status of the migration task.
   */
  data?: GetMigrationProcessResponseBodyData[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 110001123456
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * test error msg
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * SADFSDFSD-SDFSDF-XDXCVX-ESWW
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetMigrationProcessResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMigrationProcessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMigrationProcessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMigrationProcessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMigrationSummaryRequest extends $tea.Model {
  /**
   * @remarks
   * The migration task ID.
   * 
   * You can call the [CreateImportMigration](https://help.aliyun.com/document_detail/2809123.html) operation to obtain the ID of the import task and call the [CreateExportMigration](https://help.aliyun.com/document_detail/3241603.html) operation to obtain the ID of the export task.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  migrationId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      migrationId: 'MigrationId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrationId: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMigrationSummaryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the migration task.
   */
  data?: GetMigrationSummaryResponseBodyData;
  /**
   * @remarks
   * The request ID. You can use the request ID to query logs and troubleshoot issues.
   * 
   * @example
   * 19999A96-71BA-2845-B455-ED620EF4E37F
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetMigrationSummaryResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMigrationSummaryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMigrationSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMigrationSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeRequest extends $tea.Model {
  /**
   * @remarks
   * The interval at which the node is rerun after the node fails to run.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The priority of the node. Valid values: 1, 3, 5, 7, and 8.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the node.
   */
  data?: GetNodeResponseBodyData;
  /**
   * @remarks
   * The ID of the node. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the node ID.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The connection string.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The operation that you want to perform. Set the value to **GetNode**.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * Other parameters.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * The ID of the workflow.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetNodeResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeChildrenRequest extends $tea.Model {
  /**
   * @remarks
   * The node ID. You can go to the Operation Center page in the DataWorks console to query the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456878
   */
  nodeId?: number;
  /**
   * @remarks
   * The environment type of Operation Center. Valid values: PROD and DEV. The value PROD indicates the production environment, and the value DEV indicates the development environment.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeChildrenResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the descendant nodes.
   */
  data?: GetNodeChildrenResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1060010000000
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * err
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to troubleshoot issues.
   * 
   * @example
   * adsfasdf-adf-asdf-asdf-asdfadfasdd
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetNodeChildrenResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeChildrenResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNodeChildrenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNodeChildrenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeCodeRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the node.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeCodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The code of the node.
   * 
   * @example
   * select a;
   */
  data?: string;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNodeCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNodeCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeOnBaselineRequest extends $tea.Model {
  /**
   * @remarks
   * The baseline ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeOnBaselineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of nodes.
   */
  data?: GetNodeOnBaselineResponseBodyData[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetNodeOnBaselineResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeOnBaselineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNodeOnBaselineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNodeOnBaselineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeParentsRequest extends $tea.Model {
  /**
   * @remarks
   * The node ID. You can go to the Operation Center page in the DataWorks console to query the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345456211234
   */
  nodeId?: number;
  /**
   * @remarks
   * The environment type of Operation Center. Valid values: PROD and DEV. The value PROD indicates the production environment, and the value DEV indicates the development environment.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeParentsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the ancestor nodes.
   */
  data?: GetNodeParentsResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1060010000000
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * err
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * asfasdfs-adfasdf-asfas-dfasdf-asdf
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetNodeParentsResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeParentsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNodeParentsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNodeParentsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeTypeListInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the node type. You can log on to the DataWorks console, go to the DataStudio page, and then view the name of a specific node type on the left side of the page. You can view the English or Chinese name of a specific node type, but the language specified to present the name must be the same as the language specified by the Locale parameter. Fuzzy match is supported. If this parameter is not configured, the names of all node types are returned.
   * 
   * @example
   * ODPS SQ
   */
  keyword?: string;
  /**
   * @remarks
   * The language that you use for the query. Valid values: zh-CN and en-US.
   * 
   * @example
   * zh-CN
   */
  locale?: string;
  /**
   * @remarks
   * The page number.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * 50
   */
  pageSize?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace page and query the ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The unique identifier of the DataWorks workspace. You can view the identifier in the upper part of the DataStudio page. You can also select another identifier to switch to another workspace. You must configure either this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      keyword: 'Keyword',
      locale: 'Locale',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      locale: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeTypeListInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of node types.
   */
  nodeTypeInfoList?: GetNodeTypeListInfoResponseBodyNodeTypeInfoList;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      nodeTypeInfoList: 'NodeTypeInfoList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeTypeInfoList: GetNodeTypeListInfoResponseBodyNodeTypeInfoList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeTypeListInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetNodeTypeListInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetNodeTypeListInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpRiskDataRequest extends $tea.Model {
  /**
   * @remarks
   * The date on which access records were generated. Specify the value in the yyyyMMdd format.
   * 
   * This parameter is required.
   * 
   * @example
   * 20210221
   */
  date?: string;
  /**
   * @remarks
   * The parameters that you can configure to query the access records. Valid values:
   * 
   * *   dbType
   * *   instanceName
   * *   databaseName
   * *   projectName
   * *   clusterName
   * 
   * The following example shows the parameters configured to query the access records of the sensitive data in the abc database of the Hologres instance ABC: [ {"dbType":"hologres","instanceName":"ABC","databaseName":"abc"} ]
   * 
   * You must configure the parameters based on the compute engine that you use in your business.
   * 
   * @example
   * [ {"dbType":"hologres","instanceName":"ABC","databaseName":"abc"}, {"dbType":"ODPS.ODPS","projectName":"adbc"} ]
   */
  name?: string;
  /**
   * @remarks
   * The page number. Pages start from 1.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNo?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 1000.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  pageSize?: number;
  /**
   * @remarks
   * The method that you use to identify risks. Valid values:
   * 
   * *   You can manually identify risks.
   * *   You can also use a sensitive data identification rule to identify risks. You can log on to the DataWorks console and go to the Risk Identification Rules page in Data Security Guard to obtain the name of the rule.
   */
  riskType?: string;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      name: 'Name',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      riskType: 'RiskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      name: 'string',
      pageNo: 'number',
      pageSize: 'number',
      riskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpRiskDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the high-risk sensitive data. The information includes totalCount and opRiskDatas. opRiskDatas includes the following parameters:
   * 
   * *   sensType: the type of the sensitive data
   * *   sensLevel: the sensitivity level of the sensitive data
   * *   opType: the type of the operation
   * *   sql: the SQL statement that is executed
   * *   opAccount: the account that is used to perform the operation
   * *   opTime: the time when the operation was performed
   */
  riskData?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      riskData: 'RiskData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      riskData: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpRiskDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOpRiskDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOpRiskDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpSensitiveDataRequest extends $tea.Model {
  /**
   * @remarks
   * The date on which access records were generated. Specify the value in the yyyyMMdd format.
   * 
   * This parameter is required.
   * 
   * @example
   * 20210116
   */
  date?: string;
  /**
   * @remarks
   * The parameters that you can configure to query the access records. Valid values:
   * 
   * *   dbType
   * *   instanceName
   * *   databaseName
   * *   projectName
   * *   clusterName
   * 
   * The following example shows the parameters configured to query the access records of the sensitive data in the abc database of the Hologres instance ABC: [ {"dbType":"hologres","instanceName":"ABC","databaseName":"abc"} ]
   * 
   * You must configure the parameters based on the compute engine that you use in your business.
   * 
   * This parameter is required.
   * 
   * @example
   * [  {"dbType":"hologres","instanceName":"ABC","databaseName":"abc"},  {"dbType":"ODPS.ODPS","projectName":"adbc"}  ]
   */
  name?: string;
  /**
   * @remarks
   * The operation that is performed on the data. Valid values:
   * 
   * *   SQL_SELECT: specifies the data access operation. For example, execute a SELECT statement to query data.
   * *   TUNNEL_DOWNLOAD: specifies the data download operation. For example, run a Tunnel command to download data.
   * 
   * @example
   * SQL_SELECT
   */
  opType?: string;
  /**
   * @remarks
   * The page number. Minimum value: 1. Maximum value: 1000.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  pageNo?: number;
  /**
   * @remarks
   * The number of entries per page. Minimum value: 1. Maximum value: 1000.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      date: 'Date',
      name: 'Name',
      opType: 'OpType',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      date: 'string',
      name: 'string',
      opType: 'string',
      pageNo: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpSensitiveDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the access records of the sensitive data. The information includes totalCount and opRiskDatas. opRiskDatas includes the following parameters:
   * 
   * *   sensType: the type of the sensitive data.
   * *   sensLevel: the sensitivity level of the sensitive data. A larger value indicates a higher sensitivity level.
   * *   opType: the type of the operation.
   * *   sql: the SQL statement that is executed.
   * *   opAccount: the account that is used to perform the operation.
   * *   opTime: the time when the operation was performed.
   */
  opSensitiveData?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      opSensitiveData: 'OpSensitiveData',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      opSensitiveData: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpSensitiveDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOpSensitiveDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOpSensitiveDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOptionValueForProjectRequest extends $tea.Model {
  /**
   * @remarks
   * The unique code of the extension.
   * 
   * @example
   * ce4*********086da5
   */
  extensionCode?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 234
   */
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      extensionCode: 'ExtensionCode',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extensionCode: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOptionValueForProjectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned In the example, cuNumber is a custom key.
   * 
   * @example
   * {"cuNumber":"0"}
   */
  optionValue?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      optionValue: 'OptionValue',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      optionValue: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOptionValueForProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOptionValueForProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOptionValueForProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermissionApplyOrderDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the permission request order. You can call the [ListPermissionApplyOrders](https://help.aliyun.com/document_detail/211008.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 48f36729-05f9-4a40-9286-933fd940f30a
   */
  flowId?: string;
  static names(): { [key: string]: string } {
    return {
      flowId: 'FlowId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flowId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermissionApplyOrderDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the permission request order.
   */
  applyOrderDetail?: GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      applyOrderDetail: 'ApplyOrderDetail',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyOrderDetail: GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermissionApplyOrderDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetPermissionApplyOrderDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPermissionApplyOrderDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can call the [ListProjects](https://help.aliyun.com/document_detail/2780068.html) operation to query the ID.
   * 
   * @example
   * 27
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can call the [ListProjects](https://help.aliyun.com/document_detail/2780068.html) operation to query the name.
   * 
   * @example
   * test_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the workspace.
   */
  data?: GetProjectResponseBodyData;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetProjectResponseBodyData,
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 27
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the workspace.
   */
  data?: GetProjectDetailResponseBodyData;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetProjectDetailResponseBodyData,
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetProjectDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetProjectDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQualityEntityRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the compute engine or data source. Valid values:
   * 
   * *   cdh
   * *   analyticdb_for_mysql
   * *   odps
   * *   emr
   * *   hadoop
   * *   holodb
   * *   hybriddb_for_postgresql
   * 
   * This parameter is required.
   * 
   * @example
   * odps
   */
  envType?: string;
  /**
   * @remarks
   * The partition filter expression.
   * 
   * @example
   * dt=$[yyyymmdd]
   */
  matchExpression?: string;
  /**
   * @example
   * 12345
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine instance or data source. You can obtain the name from data source configurations.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The name of the partitioned table. You can call the [GetMetaTablePartition](https://help.aliyun.com/document_detail/173923.html) operation to obtain the name.
   * 
   * This parameter is required.
   * 
   * @example
   * dual
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      envType: 'EnvType',
      matchExpression: 'MatchExpression',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      envType: 'string',
      matchExpression: 'string',
      projectId: 'number',
      projectName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQualityEntityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the partition filter expression.
   */
  data?: GetQualityEntityResponseBodyData[];
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 6d739ef6-098a-47****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetQualityEntityResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQualityEntityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetQualityEntityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetQualityEntityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQualityFollowerRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  entityId?: number;
  projectId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      entityId: 'EntityId',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityId: 'number',
      projectId: 'number',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQualityFollowerResponseBody extends $tea.Model {
  data?: GetQualityFollowerResponseBodyData[];
  /**
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * 38cbdef0-f6cf-49
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': GetQualityFollowerResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQualityFollowerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetQualityFollowerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetQualityFollowerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQualityRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 12345
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine or data source.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The monitoring rule ID. You can call the [ListQualityRules](https://help.aliyun.com/document_detail/173995.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
      projectName: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQualityRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the monitoring rule.
   */
  data?: GetQualityRuleResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 576b9457-2cf5-4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetQualityRuleResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQualityRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetQualityRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetQualityRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRemindRequest extends $tea.Model {
  /**
   * @remarks
   * The custom alert rule ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  remindId?: number;
  static names(): { [key: string]: string } {
    return {
      remindId: 'RemindId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      remindId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRemindResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the custom alert rule.
   */
  data?: GetRemindResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFGH-IJKLMNOPQ
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetRemindResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRemindResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetRemindResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRemindResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSensitiveDataRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters that you can configure to query the access records. Valid values:
   * 
   * *   dbType
   * *   instanceName
   * *   databaseName
   * *   projectName
   * *   clusterName
   * 
   * The sample value shows the parameters configured to query the access records of the sensitive data in the abc database of the Hologres instance ABC. You must configure the parameters based on the compute engine that you use in your business.
   * 
   * This parameter is required.
   * 
   * @example
   * [ {"dbType":"hologres","instanceName":"ABC","databaseName":"abc"}, {"dbType":"ODPS.ODPS","projectName":"adbc"} ]
   */
  name?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNo?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 1000.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      pageNo: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSensitiveDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the sensitive data returned. The information includes totalCount and sensDatas. sensDatas includes the following parameters:
   * 
   * *   guid: the ID of the metadata of the tenant. For example, the ID of the metadata in the MaxCompute compute engine is in the Project name.Table name.Column name format.
   * *   sensType: the type of the sensitive data.
   * *   sensLevel: the sensitivity level of the sensitive data
   */
  sensitiveData?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      sensitiveData: 'SensitiveData',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      sensitiveData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSensitiveDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSensitiveDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSensitiveDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSuccessInstanceTrendRequest extends $tea.Model {
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 9527
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSuccessInstanceTrendResponseBody extends $tea.Model {
  /**
   * @remarks
   * The trend of statistics on the instance status in different time periods.
   */
  instanceStatusTrend?: GetSuccessInstanceTrendResponseBodyInstanceStatusTrend;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 952795279527ab****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceStatusTrend: 'InstanceStatusTrend',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceStatusTrend: GetSuccessInstanceTrendResponseBodyInstanceStatusTrend,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSuccessInstanceTrendResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetSuccessInstanceTrendResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSuccessInstanceTrendResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTopicRequest extends $tea.Model {
  /**
   * @remarks
   * The event ID. You can call the [ListTopics](https://help.aliyun.com/document_detail/173973.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  topicId?: number;
  static names(): { [key: string]: string } {
    return {
      topicId: 'TopicId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topicId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTopicResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the event.
   */
  data?: GetTopicResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFGH-IJKLMNOPQ
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetTopicResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTopicResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTopicResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTopicResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTopicInfluenceRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  topicId?: number;
  static names(): { [key: string]: string } {
    return {
      topicId: 'TopicId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      topicId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTopicInfluenceResponseBody extends $tea.Model {
  data?: GetTopicInfluenceResponseBodyData;
  /**
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetTopicInfluenceResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTopicInfluenceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTopicInfluenceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTopicInfluenceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDataSourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The configurations of the data sources that you want to import. The Name, DataSourceType, SubType, Description, Content, and EnvType parameters are required. For more information about the parameters, see [CreateDataSource](https://help.aliyun.com/document_detail/211429.html).
   * 
   * This parameter is required.
   * 
   * @example
   * [{"SubType":"","DataSourceType":"mysql","EnvType":1,"Name":"mysql_dms2","Description":"aaa","Content":"{\\"database\\":\\"mysql_chengdu_old\\",\\"password\\":\\"***\\",\\"instanceName\\":\\"rm-2vcrckb37163g7l3w\\",\\"regionId\\":\\"cn-chengdu\\",\\"tag\\":\\"rds\\",\\"rdsOwnerId\\":\\"333\\",\\"username\\":\\"mysql_chengdu2\\"}"},{"SubType":"","DataSourceType":"mysql","EnvType":1,"Name":"mysql_dms2","Description":"aaa","Content":"{\\"database\\":\\"mysql_chengdu_old\\",\\"password\\":\\"***\\",\\"instanceName\\":\\"rm-2vcrckb37163g7l3w\\",\\"regionId\\":\\"cn-chengdu\\",\\"tag\\":\\"rds\\",\\"rdsOwnerId\\":\\"143\\",\\"username\\":\\"mysql_chengdu2\\"}"}]
   */
  dataSources?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      dataSources: 'DataSources',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSources: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDataSourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the imported data sources.
   */
  data?: ImportDataSourcesResponseBodyData;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ImportDataSourcesResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDataSourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ImportDataSourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ImportDataSourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertMessagesRequest extends $tea.Model {
  /**
   * @remarks
   * The notification method. Valid values:
   * 
   * *   MAIL
   * *   SMS Alert notifications can be sent by text message only in the Singapore, Malaysia (Kuala Lumpur), and Germany (Frankfurt) regions.
   * 
   * You can specify multiple notification methods. Separate them with commas (,).
   * 
   * @example
   * SMS,MAIL,PHONE
   */
  alertMethods?: string;
  /**
   * @remarks
   * The type of the alert rule. Valid values: GLOBAL, USER_DEFINE, and OTHER. The value GLOBAL indicates that the alert rule is a global alert rule. The value USER_DEFINE indicates that the alert rule is customized by a user. The value OTHER indicates that the alert rule is a rule of another type. You can specify multiple types. Separate them with commas (,).
   * 
   * @example
   * GLOBAL,USER_DEFINE,OTHER
   */
  alertRuleTypes?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the alert recipient.
   * 
   * @example
   * 123456
   */
  alertUser?: string;
  /**
   * @remarks
   * The baseline ID. This parameter takes effect if the AlertRuleTypes parameter is set to GLOBAL. You can configure either this parameter or the RemindId parameter.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\\"T\\"HH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-04-02T00:00:00+0800
   */
  beginTime?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\\"T\\"HH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-04-04T00:00:00+0800
   */
  endTime?: string;
  /**
   * @remarks
   * The page number. Default value: 1. Minimum value: 1. Maximum value: 30.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The custom alert rule ID. This parameter takes effect if the AlertRuleTypes parameter is set to USER_DEFINE. You can configure either this parameter or the BaselineId parameter.
   * 
   * @example
   * 9527
   */
  remindId?: number;
  static names(): { [key: string]: string } {
    return {
      alertMethods: 'AlertMethods',
      alertRuleTypes: 'AlertRuleTypes',
      alertUser: 'AlertUser',
      baselineId: 'BaselineId',
      beginTime: 'BeginTime',
      endTime: 'EndTime',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      remindId: 'RemindId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertMethods: 'string',
      alertRuleTypes: 'string',
      alertUser: 'string',
      baselineId: 'number',
      beginTime: 'string',
      endTime: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      remindId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertMessagesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about returned alerts.
   */
  data?: ListAlertMessagesResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListAlertMessagesResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertMessagesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListAlertMessagesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAlertMessagesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselineConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the baseline. Valid values: DAILY and HOURLY. Separate multiple baseline types with commas (,).
   * 
   * @example
   * DAILY,HOURLY
   */
  baselineTypes?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the baseline owner.
   * 
   * @example
   * 95279527****
   */
  owner?: string;
  /**
   * @remarks
   * The page number. Valid values: 1 to 30. Default value: 1.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 10.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The priority of the baseline. Valid values: {1,3,5,7,8}. Separate multiple priorities with commas (,).
   * 
   * @example
   * 1,3,5,7,8
   */
  priority?: string;
  /**
   * @remarks
   * The workspace ID. You can call the ListProjects operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The keyword in the baseline name, which is used to search for the baseline.
   */
  searchText?: string;
  /**
   * @remarks
   * Specifies whether to enable the baseline. Valid values: true and false.
   * 
   * @example
   * true
   */
  useflag?: boolean;
  static names(): { [key: string]: string } {
    return {
      baselineTypes: 'BaselineTypes',
      owner: 'Owner',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      priority: 'Priority',
      projectId: 'ProjectId',
      searchText: 'SearchText',
      useflag: 'Useflag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineTypes: 'string',
      owner: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      priority: 'string',
      projectId: 'number',
      searchText: 'string',
      useflag: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselineConfigsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: ListBaselineConfigsResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListBaselineConfigsResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselineConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListBaselineConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListBaselineConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselineStatusesRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the baseline. Valid values: DAILY and HOURLY. The value DAILY indicates that the baseline is scheduled by day. The value HOURLY indicates that the baseline is scheduled by hour. Multiple types are separated by commas (,).
   * 
   * @example
   * DAILY,HOURLY
   */
  baselineTypes?: string;
  /**
   * @remarks
   * The data timestamp of the baseline instance. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\\"T\\"HH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-07-07T00:00:00+0800
   */
  bizdate?: string;
  /**
   * @remarks
   * The status of the baseline instance. Valid values: UNFINISH and FINISH. The value UNFINISH indicates that the baseline instance is still running. The value FINISH indicates that the baseline instance finishes running. Multiple states are separated by commas (,).
   * 
   * @example
   * FINISH,UNFINISH
   */
  finishStatus?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the baseline owner.
   * 
   * @example
   * 9527952795****
   */
  owner?: string;
  /**
   * @remarks
   * The number of the page to return. Valid values: 1 to 30. Default value: 1.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The priority of the baseline. Valid values: 1, 3, 5, 7, and 8. Multiple priorities are separated by commas (,).
   * 
   * @example
   * 1,3,5,7,8
   */
  priority?: string;
  /**
   * @remarks
   * The keyword of the baseline name used to search for the baseline.
   * 
   * @example
   * Keyword of the baseline name
   */
  searchText?: string;
  /**
   * @remarks
   * The status of the baseline. Valid values: ERROR, SAFE, DANGEROUS, and OVER. The value ERROR indicates that no nodes are associated with the baseline, or all nodes associated with the baseline are suspended. The value SAFE indicates that nodes finish running before the alerting time. The value DANGEROUS indicates that nodes are still running after the alerting time but before the committed completion time. The value OVER indicates that nodes are still running after the committed completion time. Multiple states are separated by commas (,).
   * 
   * @example
   * SAFE,DANGROUS,OVER
   */
  status?: string;
  /**
   * @remarks
   * The ID of the event.
   * 
   * @example
   * 1234
   */
  topicId?: number;
  static names(): { [key: string]: string } {
    return {
      baselineTypes: 'BaselineTypes',
      bizdate: 'Bizdate',
      finishStatus: 'FinishStatus',
      owner: 'Owner',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      priority: 'Priority',
      searchText: 'SearchText',
      status: 'Status',
      topicId: 'TopicId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineTypes: 'string',
      bizdate: 'string',
      finishStatus: 'string',
      owner: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      priority: 'string',
      searchText: 'string',
      status: 'string',
      topicId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselineStatusesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: ListBaselineStatusesResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListBaselineStatusesResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselineStatusesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListBaselineStatusesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListBaselineStatusesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselinesRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the baseline. Valid values: DAILY and HOURLY. You can specify multiple types. Separate multiple types with commas (,).
   * 
   * @example
   * DAILY
   */
  baselineTypes?: string;
  /**
   * @remarks
   * Specifies whether to enable the baseline. Valid values: true and false.
   * 
   * @example
   * true
   */
  enable?: boolean;
  /**
   * @remarks
   * The owner.
   * 
   * @example
   * 3726346****
   */
  owner?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1. Maximum value: 30.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  pageSize?: number;
  /**
   * @remarks
   * The priority of the baseline. Valid values: {1,3,5,7,8}.
   * 
   * @example
   * 1
   */
  priority?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  projectId?: number;
  /**
   * @remarks
   * The keyword in the baseline name, which is used to search for the baseline.
   * 
   * @example
   * baselineName
   */
  searchText?: string;
  static names(): { [key: string]: string } {
    return {
      baselineTypes: 'BaselineTypes',
      enable: 'Enable',
      owner: 'Owner',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      priority: 'Priority',
      projectId: 'ProjectId',
      searchText: 'SearchText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineTypes: 'string',
      enable: 'boolean',
      owner: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      priority: 'string',
      projectId: 'number',
      searchText: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselinesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: ListBaselinesResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 103630001
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned if the request failed.
   * 
   * @example
   * The user does not exist. 276571706358178756
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 952795279527ab****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListBaselinesResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselinesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListBaselinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListBaselinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBusinessRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword that is used to perform a fuzzy match.
   * 
   * @example
   * my
   */
  keyword?: string;
  /**
   * @remarks
   * The number of the page to return.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace ID. You must configure either this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace name. You must configure either this parameter or ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      keyword: 'Keyword',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBusinessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the workflows returned.
   */
  data?: ListBusinessResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListBusinessResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBusinessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListBusinessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListBusinessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalcEnginesRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the compute engine. The value of this parameter is not case-sensitive. Valid values:
   * 
   * *   **ODPS**
   * *   **EMR**
   * *   **BLINK**
   * *   **HOLO**
   * *   **MaxGraph**
   * *   **HYBRIDDB_FOR_POSTGRESQL**
   * *   **ADB_MYSQL**
   * *   **HADOOP_CDH**
   * *   **CLICKHOUSE**
   * 
   * This parameter is required.
   * 
   * @example
   * ODPS
   */
  calcEngineType?: string;
  /**
   * @remarks
   * The environment in which the compute engine is used. Valid values:
   * 
   * *   **DEV**
   * *   **PRD**
   * 
   * @example
   * PRD
   */
  envType?: string;
  /**
   * @remarks
   * The name of the compute engine, which must be exactly matched.
   * 
   * @example
   * abc
   */
  name?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace with which the compute engine is associated.
   * 
   * This parameter is required.
   * 
   * @example
   * 27
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      calcEngineType: 'CalcEngineType',
      envType: 'EnvType',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calcEngineType: 'string',
      envType: 'string',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalcEnginesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The query results for compute engines that are returned on multiple pages.
   */
  data?: ListCalcEnginesResponseBodyData;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   **true**
   * *   **false**
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListCalcEnginesResponseBodyData,
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalcEnginesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListCalcEnginesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCalcEnginesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  clusterId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * SPARK_CONF
   */
  configType?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5678
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      configType: 'ConfigType',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'number',
      configType: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterConfigsResponseBody extends $tea.Model {
  clusterConfigs?: ClusterConfig[];
  /**
   * @example
   * 101011005
   */
  errorCode?: string;
  /**
   * @example
   * Invalid.Cluster.ClusterNotFound
   */
  errorMessage?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      clusterConfigs: 'ClusterConfigs',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterConfigs: { 'type': 'array', 'itemType': ClusterConfig },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClusterConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClusterConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * EMR
   */
  clusterType?: string;
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      clusterType: 'ClusterType',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterType: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponseBody extends $tea.Model {
  data?: ListClustersResponseBodyData;
  /**
   * @example
   * 101011005
   */
  errorCode?: string;
  /**
   * @example
   * Invalid.Cluster.ClusterNotFound
   */
  errorMessage?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListClustersResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListClustersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClustersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListConnectionsRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the data source. Valid values:
   * 
   * *   odps
   * *   mysql
   * *   rds
   * *   oss
   * *   sqlserver
   * *   polardb
   * *   oracle
   * *   mongodb
   * *   emr
   * *   postgresql
   * *   analyticdb_for_mysql
   * *   hybriddb_for_postgresql
   * *   holo
   * 
   * @example
   * rds
   */
  connectionType?: string;
  /**
   * @remarks
   * The environment in which the data source is used. Valid values: 0 and 1. The value 0 indicates the development environment. The value 1 indicates the production environment.
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The name of the data source that you want to query.
   * 
   * @example
   * abc
   */
  name?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the workspace to which the data source belongs. You can call the [ListProjects](https://help.aliyun.com/document_detail/178393.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 76086
   */
  projectId?: number;
  /**
   * @remarks
   * The status of the data source. Valid values:
   * 
   * *   ENABLED
   * *   DISABLED
   * 
   * @example
   * 1
   */
  status?: string;
  /**
   * @remarks
   * The subtype of the data source. This parameter is used in scenarios where a type includes subtypes. The following type and subtypes are supported:
   * 
   * *   Type: `rds`
   * *   Subtypes: `mysql`, `sqlserver`, and `postgresql`
   * 
   * @example
   * mysql
   */
  subType?: string;
  static names(): { [key: string]: string } {
    return {
      connectionType: 'ConnectionType',
      envType: 'EnvType',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      status: 'Status',
      subType: 'SubType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionType: 'string',
      envType: 'number',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      status: 'string',
      subType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListConnectionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The query results for data sources that are returned on multiple pages.
   */
  data?: ListConnectionsResponseBodyData;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc14115159376359****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListConnectionsResponseBodyData,
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListConnectionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListConnectionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListConnectionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIAlarmRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the task with which the alert rules are associated.
   * 
   * This parameter is required.
   * 
   * @example
   * 11260
   */
  DIJobId?: number;
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      DIJobId: 'DIJobId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIAlarmRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The pagination information.
   */
  DIAlarmRulePaging?: ListDIAlarmRulesResponseBodyDIAlarmRulePaging;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 74C2FECD-5B3A-554A-BCF5-351A36DE9815
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      DIAlarmRulePaging: 'DIAlarmRulePaging',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIAlarmRulePaging: ListDIAlarmRulesResponseBodyDIAlarmRulePaging,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIAlarmRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDIAlarmRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDIAlarmRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIJobsRequest extends $tea.Model {
  /**
   * @remarks
   * The destination type. If you do not configure this parameter, no limits are imposed on the tasks.
   * 
   * @example
   * Hologres
   */
  destinationDataSourceType?: string;
  /**
   * @remarks
   * The name of the task. Fuzzy match is supported. If you do not configure this parameter, no limits are imposed on the tasks.
   * 
   * @example
   * mysql_to_holo_sync_8772
   */
  jobName?: string;
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 1967
   */
  projectId?: number;
  /**
   * @remarks
   * The source type. If you do not configure this parameter, no limits are imposed on the tasks.
   * 
   * @example
   * MySQL
   */
  sourceDataSourceType?: string;
  static names(): { [key: string]: string } {
    return {
      destinationDataSourceType: 'DestinationDataSourceType',
      jobName: 'JobName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      sourceDataSourceType: 'SourceDataSourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationDataSourceType: 'string',
      jobName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      sourceDataSourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIJobsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The pagination information.
   */
  DIJobPaging?: ListDIJobsResponseBodyDIJobPaging;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 7263E4AC-9D2E-5B29-B8AF-7C5012E92A41
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      DIJobPaging: 'DIJobPaging',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobPaging: ListDIJobsResponseBodyDIJobPaging,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIJobsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDIJobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDIJobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIProjectConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the destinations of the synchronization solutions. This parameter cannot be left empty. Valid values: analyticdb_for_mysql, odps, elasticsearch, holo, mysql, and polardb.
   * 
   * This parameter is required.
   * 
   * @example
   * elasticsearch
   */
  destinationType?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000
   */
  projectId?: number;
  /**
   * @remarks
   * The type of the sources of the synchronization solutions. Valid values: oracle, mysql, polardb, datahub, drds, and analyticdb_for_mysql. If you do not configure this parameter, DataWorks applies the default global configuration to all sources.
   * 
   * @example
   * mysql
   */
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      destinationType: 'DestinationType',
      projectId: 'ProjectId',
      sourceType: 'SourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationType: 'string',
      projectId: 'number',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIProjectConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the query.
   */
  data?: ListDIProjectConfigResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListDIProjectConfigResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIProjectConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDIProjectConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDIProjectConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDagsRequest extends $tea.Model {
  /**
   * @remarks
   * The sequence number that uniquely identifies the data backfill operation. You can call the [GetDag](https://help.aliyun.com/document_detail/189753.html) operation to query the sequence number.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  opSeq?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment, and the value DEV indicates the development environment.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      opSeq: 'OpSeq',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      opSeq: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of DAGs.
   */
  data?: ListDagsResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 7782a299-b291-4fee-8424-cf8058efa8e8
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListDagsResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApiAuthoritiesRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword in the name of the API. The keyword can be used to search for the API whose name contains the keyword.
   * 
   * @example
   * My API name
   */
  apiNameKeyword?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. This parameter is deprecated.
   * 
   * @example
   * 10001
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiNameKeyword: 'ApiNameKeyword',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiNameKeyword: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApiAuthoritiesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The APIs on which other users are granted the access permissions.
   */
  data?: ListDataServiceApiAuthoritiesResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 0
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Normal
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListDataServiceApiAuthoritiesResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApiAuthoritiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataServiceApiAuthoritiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataServiceApiAuthoritiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApiTestRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the DataService Studio API on which tests are performed.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  apiId?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApiTestResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of test records.
   */
  data?: ListDataServiceApiTestResponseBodyData[];
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * ESDAFWEA
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListDataServiceApiTestResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApiTestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataServiceApiTestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataServiceApiTestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword in API names. The keyword is used to search for the APIs whose names contain the keyword.
   */
  apiNameKeyword?: string;
  /**
   * @remarks
   * The keyword in API paths. The keyword is used to search for the APIs whose paths contain the keyword.
   * 
   * @example
   * /test/
   */
  apiPathKeyword?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the creator of the APIs. The ID is used to search for the APIs created by the creator.
   * 
   * @example
   * 12345
   */
  creatorId?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * @example
   * 10001
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiNameKeyword: 'ApiNameKeyword',
      apiPathKeyword: 'ApiPathKeyword',
      creatorId: 'CreatorId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiNameKeyword: 'string',
      apiPathKeyword: 'string',
      creatorId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: ListDataServiceApisResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListDataServiceApisResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataServiceApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataServiceApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApplicationsRequest extends $tea.Model {
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the workspace based on which you want to query the basic information of applications. You can specify multiple IDs. Separate them with commas (,). You must specify at least one workspace ID. You can specify a maximum of 50 workspace IDs.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000,100001
   */
  projectIdList?: string;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * @example
   * 100002
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectIdList: 'ProjectIdList',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      projectIdList: 'string',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApplicationsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: ListDataServiceApplicationsResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 0
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Normal
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG***
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListDataServiceApplicationsResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApplicationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataServiceApplicationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataServiceApplicationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceAuthorizedApisRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword in API names. The keyword is used to search for the APIs whose names contain the keyword.
   * 
   * @example
   * My API Name
   */
  apiNameKeyword?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. This parameter is deprecated.
   * 
   * @example
   * 10001
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiNameKeyword: 'ApiNameKeyword',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiNameKeyword: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceAuthorizedApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the APIs that you are authorized to access.
   */
  data?: ListDataServiceAuthorizedApisResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListDataServiceAuthorizedApisResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceAuthorizedApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataServiceAuthorizedApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataServiceAuthorizedApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceFoldersRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword in folder names. The keyword is used to search for folders whose names contain this keyword.
   * 
   * @example
   * Keyword in folder names
   */
  folderNameKeyword?: string;
  /**
   * @remarks
   * The ID of the business process to which the folders belong.
   * 
   * @example
   * ds_123abc
   */
  groupId?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the page that appears, click the username for the logon in the upper-right corner and click User Info in the Menu section.
   * 
   * @example
   * 10002
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      folderNameKeyword: 'FolderNameKeyword',
      groupId: 'GroupId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folderNameKeyword: 'string',
      groupId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceFoldersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The paging result for the folders.
   */
  folderPagingResult?: ListDataServiceFoldersResponseBodyFolderPagingResult;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EF****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      folderPagingResult: 'FolderPagingResult',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folderPagingResult: ListDataServiceFoldersResponseBodyFolderPagingResult,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceFoldersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataServiceFoldersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataServiceFoldersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword of a business process name. The keyword is used to search for business processes whose names contain this keyword.
   * 
   * @example
   * Test business process
   */
  groupNameKeyword?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. This parameter is deprecated.
   * 
   * @example
   * 10001
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      groupNameKeyword: 'GroupNameKeyword',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupNameKeyword: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The paging result for the business processes.
   */
  groupPagingResult?: ListDataServiceGroupsResponseBodyGroupPagingResult;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EF****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupPagingResult: 'GroupPagingResult',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupPagingResult: ListDataServiceGroupsResponseBodyGroupPagingResult,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataServiceGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataServiceGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisRequest extends $tea.Model {
  /**
   * @remarks
   * The keyword in API names. The keyword is used to search for the APIs whose names contain the keyword.
   */
  apiNameKeyword?: string;
  /**
   * @remarks
   * The keyword in API paths. The keyword is used to search for the APIs whose paths contain the keyword.
   * 
   * @example
   * /test/
   */
  apiPathKeyword?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the creator of the APIs. The ID is used to search for the APIs created by the creator.
   * 
   * @example
   * 12345
   */
  creatorId?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * @example
   * 10001
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiNameKeyword: 'ApiNameKeyword',
      apiPathKeyword: 'ApiPathKeyword',
      creatorId: 'CreatorId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiNameKeyword: 'string',
      apiPathKeyword: 'string',
      creatorId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: ListDataServicePublishedApisResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListDataServicePublishedApisResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataServicePublishedApisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataServicePublishedApisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourcesRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the data source. Valid values:
   * 
   * *   odps
   * *   mysql
   * *   rds
   * *   oss
   * *   sqlserver
   * *   polardb
   * *   oracle
   * *   mongodb
   * *   emr
   * *   postgresql
   * *   analyticdb_for_mysql
   * *   hybriddb_for_postgresql
   * *   holo
   * 
   * @example
   * rds
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The environment in which the data source is used. Valid values: 0 and 1. The value 0 indicates development environment. The value 1 indicates production environment.
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The name of the data source that you want to query.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace to which the data sources belong. You can call the [ListProjects](https://help.aliyun.com/document_detail/2780068.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  projectId?: number;
  /**
   * @remarks
   * The status of the data source. Valid values:
   * 
   * *   ENABLED
   * *   DISABLED
   * 
   * @example
   * ENABLED
   */
  status?: string;
  /**
   * @remarks
   * The subtype of the data source. This parameter takes effect only when the DataSourceType parameter is set to rds.
   * 
   * If the value of the DataSourceType parameter is rds, the value of this parameter can be mysql, sqlserver, or postgresql.
   * 
   * @example
   * mysql
   */
  subType?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceType: 'DataSourceType',
      envType: 'EnvType',
      name: 'Name',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      status: 'Status',
      subType: 'SubType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceType: 'string',
      envType: 'number',
      name: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      status: 'string',
      subType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourcesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The query result returned.
   */
  data?: ListDataSourcesResponseBodyData;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc14115159376359****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListDataSourcesResponseBodyData,
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDataSourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDataSourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeploymentsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the user who creates the deployment packages.
   * 
   * @example
   * 20030****
   */
  creator?: string;
  /**
   * @remarks
   * The time when the deployment packages to be queried are created. This value must be a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1593877765000
   */
  endCreateTime?: number;
  /**
   * @remarks
   * The time when the deployment packages are run. This value must be a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1593877765000
   */
  endExecuteTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the user who runs the deployment packages.
   * 
   * @example
   * 2003****
   */
  executor?: string;
  /**
   * @remarks
   * The keyword that is contained in the names of the deployment packages. A fuzzy search is supported. After you enter a keyword, all deployment packages whose names contain the keyword are displayed.
   * 
   * @example
   * hello
   */
  keyword?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
   * 
   * You must configure either this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace name.
   * 
   * You must configure either this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  /**
   * @remarks
   * The status of the deployment packages. Valid values:
   * 
   * *   0: The deployment packages are ready.
   * *   1: The deployment packages are deployed.
   * *   2: The deployment packages fail to be deployed.
   * *   6: The deployment packages are rejected.
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      creator: 'Creator',
      endCreateTime: 'EndCreateTime',
      endExecuteTime: 'EndExecuteTime',
      executor: 'Executor',
      keyword: 'Keyword',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creator: 'string',
      endCreateTime: 'number',
      endExecuteTime: 'number',
      executor: 'string',
      keyword: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeploymentsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: ListDeploymentsResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListDeploymentsResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeploymentsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListDeploymentsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListDeploymentsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnabledExtensionsForProjectRequest extends $tea.Model {
  /**
   * @remarks
   * The code of the extension point event.
   * 
   * This parameter is required.
   * 
   * @example
   * commit-file
   */
  eventCode?: string;
  /**
   * @remarks
   * The type of the code for the file.
   * 
   * Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3).
   * 
   * You can call the [ListFileType](https://help.aliyun.com/document_detail/212428.html) operation to query the type of the code for the file.
   * 
   * @example
   * 10
   */
  fileType?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console?spm=a2c4g.11186623.0.0.6b4d4941azHd2k) and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      eventCode: 'EventCode',
      fileType: 'FileType',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventCode: 'string',
      fileType: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnabledExtensionsForProjectResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the extension.
   */
  extensions?: ListEnabledExtensionsForProjectResponseBodyExtensions[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4F2CA7ED-27E5-59EA-A8C4-F1F7A1FF0B22
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      extensions: 'Extensions',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extensions: { 'type': 'array', 'itemType': ListEnabledExtensionsForProjectResponseBodyExtensions },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnabledExtensionsForProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEnabledExtensionsForProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEnabledExtensionsForProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEntitiesByTagsRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the entity.
   * 
   * This parameter is required.
   * 
   * @example
   * maxcompute-table
   */
  entityType?: string;
  /**
   * @remarks
   * The pagination token that is used in the next request to retrieve a new page of results.
   * 
   * @example
   * 12345
   */
  nextToken?: string;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Valid values: 1 to 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The tags.
   * 
   * This parameter is required.
   */
  tags?: UserEntityTag[];
  static names(): { [key: string]: string } {
    return {
      entityType: 'EntityType',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityType: 'string',
      nextToken: 'string',
      pageSize: 'number',
      tags: { 'type': 'array', 'itemType': UserEntityTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEntitiesByTagsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the entity.
   * 
   * This parameter is required.
   * 
   * @example
   * maxcompute-table
   */
  entityType?: string;
  /**
   * @remarks
   * The pagination token that is used in the next request to retrieve a new page of results.
   * 
   * @example
   * 12345
   */
  nextToken?: string;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Valid values: 1 to 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The tags.
   * 
   * This parameter is required.
   */
  tagsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      entityType: 'EntityType',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      tagsShrink: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityType: 'string',
      nextToken: 'string',
      pageSize: 'number',
      tagsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEntitiesByTagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: ListEntitiesByTagsResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 101011005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Invalid.Entity.EntityTypeNotSupported
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true\\
   * false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListEntitiesByTagsResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEntitiesByTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEntitiesByTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEntitiesByTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEntityTagsRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the entity. Example: maxcompute-table.projectA.tableA.
   * 
   * This parameter is required.
   * 
   * @example
   * maxcompute-table.projectA.tableA
   */
  qualifiedName?: string;
  static names(): { [key: string]: string } {
    return {
      qualifiedName: 'QualifiedName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qualifiedName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEntityTagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The tags.
   */
  data?: UserEntityTag[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 101011005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Invalid.Entity.EntityTypeNotSupported
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true\\
   * false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': UserEntityTag },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEntityTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListEntityTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListEntityTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExtensionsRequest extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExtensionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The pagination information.
   */
  pagingInfo?: ListExtensionsResponseBodyPagingInfo;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pagingInfo: 'PagingInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pagingInfo: ListExtensionsResponseBodyPagingInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExtensionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListExtensionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListExtensionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileTypeRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the node type. You can log on to the DataWorks console, go to the DataStudio page, and then view the name of a specific node type on the left side of the page. Take note of the following items when you configure this parameter:
   * 
   * *   You can view the name of a specific node type, but the language specified by this parameter to present the name must be the same as the language specified by the Locale parameter.
   * *   Fuzzy match is supported.
   * *   If this parameter is not configured, the names of all node types are returned.
   * 
   * @example
   * ODPS SQL
   */
  keyword?: string;
  /**
   * @remarks
   * The language that you use for the query. Valid values: zh-CN and en-US.
   * 
   * @example
   * zh-CN
   */
  locale?: string;
  /**
   * @remarks
   * The page number.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * 50
   */
  pageSize?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console and go to the Workspace page to view the workspace ID. You must configure either this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace page to view the workspace name. You must configure either this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      keyword: 'Keyword',
      locale: 'Locale',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      keyword: 'string',
      locale: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileTypeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about node types.
   */
  nodeTypeInfoList?: ListFileTypeResponseBodyNodeTypeInfoList;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      nodeTypeInfoList: 'NodeTypeInfoList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeTypeInfoList: ListFileTypeResponseBodyNodeTypeInfoList,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileTypeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListFileTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListFileTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileVersionsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the file. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 100000001
   */
  fileId?: number;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace Management page and view the workspace ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The unique identifier of the DataWorks workspace. You can click the identifier in the upper-left corner of the DataStudio page to switch to another workspace.
   * 
   * You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileVersionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The file versions returned.
   */
  data?: ListFileVersionsResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListFileVersionsResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileVersionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListFileVersionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListFileVersionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFilesRequest extends $tea.Model {
  /**
   * @example
   * ods_create.sql
   */
  exactFileName?: string;
  /**
   * @remarks
   * The path of the files.
   */
  fileFolderPath?: string;
  /**
   * @example
   * 78237,816123
   */
  fileIdIn?: string;
  /**
   * @remarks
   * The types of the code in the files.
   * 
   * Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 97 (PAI), 98 (node group), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1002 (PAI inner node), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), 1106 (for-each), and 1221 (PyODPS 3).
   * 
   * @example
   * 10,23
   */
  fileTypes?: string;
  /**
   * @remarks
   * The keyword in the file names. The keyword is used to perform a fuzzy match. You can specify a keyword to query all files whose names contain the keyword.
   * 
   * @example
   * ods
   */
  keyword?: string;
  /**
   * @example
   * false
   */
  needAbsoluteFolderPath?: boolean;
  /**
   * @example
   * false
   */
  needContent?: boolean;
  /**
   * @remarks
   * The ID of the node that is scheduled. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the ID of the node.
   * 
   * @example
   * 123541234
   */
  nodeId?: number;
  /**
   * @remarks
   * The owner of the files.
   * 
   * @example
   * 3726346****
   */
  owner?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
   * 
   * You must configure either the ProjectId or ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace name.
   * 
   * You must configure either the ProjectId or ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  /**
   * @remarks
   * The module to which the files belong. Valid values:
   * 
   * *   NORMAL: The files are used for DataStudio.
   * *   MANUAL: The files are used for manually triggered nodes.
   * *   MANUAL_BIZ: The files are used for manually triggered workflows.
   * *   SKIP: The files are used for dry-run nodes in DataStudio.
   * *   ADHOCQUERY: The files are used for ad hoc queries.
   * *   COMPONENT: The files are used for snippets.
   * 
   * @example
   * NORMAL
   */
  useType?: string;
  static names(): { [key: string]: string } {
    return {
      exactFileName: 'ExactFileName',
      fileFolderPath: 'FileFolderPath',
      fileIdIn: 'FileIdIn',
      fileTypes: 'FileTypes',
      keyword: 'Keyword',
      needAbsoluteFolderPath: 'NeedAbsoluteFolderPath',
      needContent: 'NeedContent',
      nodeId: 'NodeId',
      owner: 'Owner',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
      useType: 'UseType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exactFileName: 'string',
      fileFolderPath: 'string',
      fileIdIn: 'string',
      fileTypes: 'string',
      keyword: 'string',
      needAbsoluteFolderPath: 'boolean',
      needContent: 'boolean',
      nodeId: 'number',
      owner: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
      useType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFilesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The files returned.
   */
  data?: ListFilesResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can troubleshoot errors based on the ID.
   * 
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   true: The request is successful.
   * *   false: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListFilesResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFilesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFoldersRequest extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The path of the parent folder.
   * 
   * This parameter is required.
   */
  parentFolderPath?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console and go to the Workspace page to obtain the workspace ID. You must configure either this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace page to obtain the workspace name. You must configure either this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      parentFolderPath: 'ParentFolderPath',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      parentFolderPath: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFoldersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the folders.
   */
  data?: ListFoldersResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListFoldersResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFoldersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListFoldersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListFoldersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInnerNodesRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the node to which the inner nodes belong.
   * 
   * @example
   * liux_test_n****
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the node group to which the inner nodes belong.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  outerNodeId?: number;
  /**
   * @remarks
   * The page number. Valid values: 1 to 100.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The type of the node to which the inner nodes belong.
   * 
   * Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 97 (PAI), 98 (node group), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1002 (PAI inner node), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), 1106 (for-each), and 1221 (PyODPS 3). You can call the ListNodes operation to query the type of the node.
   * 
   * @example
   * ODPS_SQL
   */
  programType?: string;
  /**
   * @remarks
   * The environment in which the node is run. Valid values: DEV and PROD. Default value: PROD.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      nodeName: 'NodeName',
      outerNodeId: 'OuterNodeId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      programType: 'ProgramType',
      projectEnv: 'ProjectEnv',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeName: 'string',
      outerNodeId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      programType: 'string',
      projectEnv: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInnerNodesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The pagination information.
   */
  paging?: ListInnerNodesResponseBodyPaging;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      paging: 'Paging',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paging: ListInnerNodesResponseBodyPaging,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInnerNodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInnerNodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInnerNodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceAmountRequest extends $tea.Model {
  /**
   * @remarks
   * The beginning of the time range to query, accurate to the day. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\\"T\\"HH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-13T00:00:00+0800
   */
  beginDate?: string;
  /**
   * @remarks
   * The end of the time range to query, accurate to the day. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\\"T\\"HH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2021-06-16T00:00:00+0800
   */
  endDate?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console and go to the Work space page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      beginDate: 'BeginDate',
      endDate: 'EndDate',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginDate: 'string',
      endDate: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceAmountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The trend of the number of auto triggered node instances within the specified period of time.
   */
  instanceCounts?: ListInstanceAmountResponseBodyInstanceCounts[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 95279527adhfj****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceCounts: 'InstanceCounts',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceCounts: { 'type': 'array', 'itemType': ListInstanceAmountResponseBodyInstanceCounts },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceAmountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstanceAmountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceAmountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceHistoryRequest extends $tea.Model {
  /**
   * @remarks
   * The instance ID. You can call the ListInstances operation to query the instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  instanceId?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV. By default, data of instances in the production environment is queried.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceHistoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The instances.
   */
  instances?: ListInstanceHistoryResponseBodyInstances[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: { 'type': 'array', 'itemType': ListInstanceHistoryResponseBodyInstances },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceHistoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstanceHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceHistoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The parameters related to the node.
   * 
   * @example
   * 2020-02-02 00:00:00
   */
  beginBizdate?: string;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * test_bizName
   */
  bizName?: string;
  /**
   * @remarks
   * The number of entries returned per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 2020-02-02 00:00:00
   */
  bizdate?: string;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment. The value DEV indicates the development environment.
   * 
   * @example
   * 11111
   */
  dagId?: number;
  /**
   * @remarks
   * The ID of the workflow.
   * 
   * @example
   * 2020-02-03 00:00:00
   */
  endBizdate?: string;
  /**
   * @remarks
   * Indicates whether the instance is associated with a monitoring rule in Data Quality. Valid values:
   * 
   * *   0: The instance is associated with a monitoring rule in Data Quality.
   * *   1: The instance is not associated with a monitoring rule in Data Quality.
   * 
   * @example
   * 100000000000
   */
  nodeId?: number;
  /**
   * @remarks
   * Indicates whether the node can be rerun.
   * 
   * @example
   * openmr_8****
   */
  nodeName?: string;
  orderBy?: string;
  /**
   * @remarks
   * The connection string.
   * 
   * @example
   * 193379****
   */
  owner?: string;
  /**
   * @remarks
   * The operation that you want to perform.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The ID of the node.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * ODPS_SQL
   */
  programType?: string;
  /**
   * @remarks
   * The time when the node was last modified.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  /**
   * @remarks
   * The ID of the baseline.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  projectId?: number;
  /**
   * @remarks
   * The time when the instance started to wait to be scheduled.
   * 
   * @example
   * NOT_RUN
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      beginBizdate: 'BeginBizdate',
      bizName: 'BizName',
      bizdate: 'Bizdate',
      dagId: 'DagId',
      endBizdate: 'EndBizdate',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      orderBy: 'OrderBy',
      owner: 'Owner',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      programType: 'ProgramType',
      projectEnv: 'ProjectEnv',
      projectId: 'ProjectId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginBizdate: 'string',
      bizName: 'string',
      bizdate: 'string',
      dagId: 'number',
      endBizdate: 'string',
      nodeId: 'number',
      nodeName: 'string',
      orderBy: 'string',
      owner: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      programType: 'string',
      projectEnv: 'string',
      projectId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the node. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the ID of the node.
   */
  data?: ListInstancesResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * Invalid.Tenant.ProjectNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * The project does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The error message that is returned for the instance.
   * 
   * This parameter is deprecated. You can call the [GetInstanceLog](https://help.aliyun.com/document_detail/173983.html) operation to query the error information related to the node.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListInstancesResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLineageRequest extends $tea.Model {
  /**
   * @remarks
   * The lineage type. Valid values:\\
   * up: ancestor lineage\\
   * down: descendant lineage
   * 
   * This parameter is required.
   * 
   * @example
   * up
   */
  direction?: string;
  /**
   * @remarks
   * The unique identifier of the entity.
   * 
   * This parameter is required.
   * 
   * @example
   * maxcompute-table.project.table
   */
  entityQualifiedName?: string;
  /**
   * @remarks
   * The keyword of the entity name.
   * 
   * @example
   * name-keyword
   */
  keyword?: string;
  /**
   * @remarks
   * The pagination token that is used in the next request to retrieve a new page of results.
   * 
   * @example
   * next-token-from-previous-request
   */
  nextToken?: string;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      direction: 'Direction',
      entityQualifiedName: 'EntityQualifiedName',
      keyword: 'Keyword',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      direction: 'string',
      entityQualifiedName: 'string',
      keyword: 'string',
      nextToken: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLineageResponseBody extends $tea.Model {
  /**
   * @remarks
   * The structure returned.
   */
  data?: ListLineageResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1010040007
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * qualifiedName should be in format as entity-table.entity-guid
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 64B-587A-8CED-969E1973887FXXX-TT
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true
   * 
   * false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListLineageResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLineageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListLineageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListLineageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListManualDagInstancesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the directed acyclic graph (DAG) for the manually triggered workflow. You can call the [RunManualDagNodes](https://help.aliyun.com/document_detail/212830.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 7000001231241
   */
  dagId?: string;
  /**
   * @remarks
   * The environment of Operation Center. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * RPOD
   */
  projectEnv?: string;
  /**
   * @remarks
   * The name of the workspace to which the manually triggered workflow belongs. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the name.
   * 
   * This parameter is required.
   * 
   * @example
   * test_workspace
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      projectEnv: 'ProjectEnv',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'string',
      projectEnv: 'string',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListManualDagInstancesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The instances in the manually triggered workflow.
   */
  instances?: ListManualDagInstancesResponseBodyInstances[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * SDFSDFSDF-SDFSDF-SDFDSF-SDFSDF
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: { 'type': 'array', 'itemType': ListManualDagInstancesResponseBodyInstances },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListManualDagInstancesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListManualDagInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListManualDagInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMeasureDataRequest extends $tea.Model {
  /**
   * @remarks
   * The measurement component.
   * 
   * *   This parameter is set to Count if the DomainCode parameter is set to DideAlarmPhone or DideAlarmSms. In this case, statistics on the number of phone calls or text messages that are used to send alert notifications are collected.
   * 
   * This parameter is required.
   * 
   * @example
   * Count
   */
  componentCode?: string;
  /**
   * @remarks
   * The item to be measured. Valid values:
   * 
   * *   DideAlarmPhone: phone call-based alerts
   * *   DideAlarmSms: text message-based alerts
   * 
   * This parameter is required.
   * 
   * @example
   * DideAlarmPhone
   */
  domainCode?: string;
  /**
   * @remarks
   * The end timestamp of the measurement period, in milliseconds. The measurement period is calculated in days. You can query only the data within the last 30 days.
   * 
   * This parameter is required.
   * 
   * @example
   * 1717430400000
   */
  endTime?: number;
  /**
   * @remarks
   * The start timestamp of the measurement period, in milliseconds. The measurement period is calculated in days. You can query only the data within the last 30 days.
   * 
   * This parameter is required.
   * 
   * @example
   * 1717344000000
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      componentCode: 'ComponentCode',
      domainCode: 'DomainCode',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentCode: 'string',
      domainCode: 'string',
      endTime: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMeasureDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 100001001
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The user is not in tenant.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The measurement results.
   */
  measureDatas?: ListMeasureDataResponseBodyMeasureDatas[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1AFAE64E-D1BE-432B-A9****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      measureDatas: 'MeasureDatas',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      measureDatas: { 'type': 'array', 'itemType': ListMeasureDataResponseBodyMeasureDatas },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMeasureDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMeasureDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMeasureDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMetaCollectionEntitiesRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the collection.
   * 
   * This parameter is required.
   * 
   * @example
   * album.12345
   */
  collectionQualifiedName?: string;
  /**
   * @remarks
   * The type of the entities.
   * 
   * For example, if this parameter is set to maxcompute-table, the entity is a MaxCompute table.
   * 
   * @example
   * maxcompute-table
   */
  entityType?: string;
  /**
   * @remarks
   * The search keyword.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @remarks
   * The pagination token that is used in the next request to retrieve a new page of results.
   * 
   * @example
   * 12222
   */
  nextToken?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      collectionQualifiedName: 'CollectionQualifiedName',
      entityType: 'EntityType',
      keyword: 'Keyword',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      collectionQualifiedName: 'string',
      entityType: 'string',
      keyword: 'string',
      nextToken: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMetaCollectionEntitiesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The response parameters.
   */
  data?: ListMetaCollectionEntitiesResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Collection.NotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * E25887B7-579C-54A5-9C4F-83A0DE367DD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true: The request was successful.
   * 
   * false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListMetaCollectionEntitiesResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMetaCollectionEntitiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMetaCollectionEntitiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMetaCollectionEntitiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMetaCollectionsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the collection administrator.
   * 
   * @example
   * 1200759642363000
   */
  administrator?: string;
  /**
   * @remarks
   * - ALBUM: data album 
   * - ALBUM_CATEGORY: category in a data album
   * 
   * This parameter is required.
   * 
   * @example
   * ALBUM
   */
  collectionType?: string;
  /**
   * @remarks
   * The ID of the collection creator.
   * 
   * @example
   * 1200759642363000
   */
  creator?: string;
  /**
   * @remarks
   * The ID of the collection follower.
   * 
   * @example
   * 1200759642363000
   */
  follower?: string;
  /**
   * @remarks
   * The keyword.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @remarks
   * The pagination token that is used in the next request to retrieve a new page of results.
   * 
   * @example
   * 12345
   */
  nextToken?: string;
  /**
   * @remarks
   * The name of the sorting field.
   * 
   * @example
   * test
   */
  orderBy?: string;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The unique identifier of the parent collection.
   * 
   * @example
   * Album.1234
   */
  parentQualifiedName?: string;
  static names(): { [key: string]: string } {
    return {
      administrator: 'Administrator',
      collectionType: 'CollectionType',
      creator: 'Creator',
      follower: 'Follower',
      keyword: 'Keyword',
      nextToken: 'NextToken',
      orderBy: 'OrderBy',
      pageSize: 'PageSize',
      parentQualifiedName: 'ParentQualifiedName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      administrator: 'string',
      collectionType: 'string',
      creator: 'string',
      follower: 'string',
      keyword: 'string',
      nextToken: 'string',
      orderBy: 'string',
      pageSize: 'number',
      parentQualifiedName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMetaCollectionsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned result.
   */
  data?: ListMetaCollectionsResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Collection.NotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E25887B7-579C-54A5-9C4F-83A0DE367DDE
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListMetaCollectionsResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMetaCollectionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMetaCollectionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMetaCollectionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMetaDBRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the E-MapReduce (EMR) cluster. You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to query the ID.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the data source. Set the value to emr.
   * 
   * This parameter is required.
   * 
   * @example
   * emr
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can call the [ListProjects](https://help.aliyun.com/document_detail/178393.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dataSourceType: 'DataSourceType',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dataSourceType: 'string',
      pageNum: 'number',
      pageSize: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMetaDBResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the metadatabases.
   */
  databaseInfo?: ListMetaDBResponseBodyDatabaseInfo;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * abc
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      databaseInfo: 'DatabaseInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseInfo: ListMetaDBResponseBodyDatabaseInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMetaDBResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMetaDBResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMetaDBResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMigrationsRequest extends $tea.Model {
  /**
   * @remarks
   * The migration task type. Valid values: IMPORT and EXPORT.
   * 
   * This parameter is required.
   * 
   * @example
   * IMPORT
   * 
   * **if can be null:**
   * false
   */
  migrationType?: string;
  /**
   * @remarks
   * The owner ID.
   * 
   * @example
   * 193379****
   */
  owner?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      migrationType: 'MigrationType',
      owner: 'Owner',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrationType: 'string',
      owner: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMigrationsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: ListMigrationsResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * F9198AA3-9010-53D5-9714-DC4461427D3E
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListMigrationsResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMigrationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListMigrationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListMigrationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodeIORequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to query the information about ancestor or descendant nodes of the current node. Valid values: input and output.
   * 
   * This parameter is required.
   * 
   * @example
   * output
   */
  ioType?: string;
  /**
   * @remarks
   * The node ID. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The runtime environment. Valid values: DEV and PROD.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      ioType: 'IoType',
      nodeId: 'NodeId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ioType: 'string',
      nodeId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodeIOResponseBody extends $tea.Model {
  /**
   * @remarks
   * The node information.
   */
  data?: ListNodeIOResponseBodyData[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ProjectNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The project does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListNodeIOResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodeIOResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNodeIOResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNodeIOResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodeInputOrOutputRequest extends $tea.Model {
  /**
   * @remarks
   * The type of node that you want to query. Valid values:
   * 
   * *   input: ancestor node
   * *   output: descendant node
   * 
   * This parameter is required.
   * 
   * @example
   * output
   */
  ioType?: string;
  /**
   * @remarks
   * The node ID. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12314567
   */
  nodeId?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: DEV and PROD.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      ioType: 'IoType',
      nodeId: 'NodeId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ioType: 'string',
      nodeId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodeInputOrOutputResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ancestor or descendant nodes.
   */
  data?: ListNodeInputOrOutputResponseBodyData[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ProjectNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The project does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListNodeInputOrOutputResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodeInputOrOutputResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNodeInputOrOutputResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNodeInputOrOutputResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesRequest extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * test_bizName
   */
  bizName?: string;
  /**
   * @remarks
   * The ID of the baseline with which the node is associated.
   * 
   * @example
   * liux_test_n****
   */
  nodeName?: string;
  /**
   * @remarks
   * The description of the node.
   * 
   * @example
   * 193379****
   */
  owner?: string;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The operation that you want to perform. Set the value to **ListNodes**.
   * 
   * @example
   * ODPS_SQL
   */
  programType?: string;
  /**
   * @remarks
   * The number of entries returned per page. Default value: 10. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  /**
   * @remarks
   * The ID of the owner.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  schedulerType?: string;
  static names(): { [key: string]: string } {
    return {
      bizName: 'BizName',
      nodeName: 'NodeName',
      owner: 'Owner',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      programType: 'ProgramType',
      projectEnv: 'ProjectEnv',
      projectId: 'ProjectId',
      schedulerType: 'SchedulerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizName: 'string',
      nodeName: 'string',
      owner: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      programType: 'string',
      projectEnv: 'string',
      projectId: 'number',
      schedulerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the associated workflow.
   */
  data?: ListNodesResponseBodyData;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The interval at which the node is rerun after the node fails to run.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The list of nodes.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the node can be rerun.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListNodesResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesByBaselineRequest extends $tea.Model {
  /**
   * @remarks
   * The baseline ID. You can call the [ListBaselineConfigs](https://help.aliyun.com/document_detail/173964.html) operation to query the baseline ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesByBaselineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The nodes in the baseline.
   */
  data?: ListNodesByBaselineResponseBodyData[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListNodesByBaselineResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesByBaselineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNodesByBaselineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNodesByBaselineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesByOutputRequest extends $tea.Model {
  /**
   * @remarks
   * The output name of the node. You can specify multiple output names. Separate them with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * aaaaa.1231412_out,bbbb.12313123_out
   */
  outputs?: string;
  /**
   * @remarks
   * The environment of Operation Center. Valid values: PROD and DEV. The value PROD indicates the production environment, and the value DEV indicates the development environment.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      outputs: 'Outputs',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputs: 'string',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesByOutputResponseBody extends $tea.Model {
  /**
   * @remarks
   * The nodes returned.
   */
  data?: ListNodesByOutputResponseBodyData[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * SDFSDFSDF-asdfDFSDF-SDFSDf-SDfSFD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListNodesByOutputResponseBodyData },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesByOutputResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListNodesByOutputResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListNodesByOutputResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPermissionApplyOrdersRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. You can query all the permissions request orders that have been submitted before the time. The parameter value is a UNIX timestamp. If you do not specify the parameter, all permission request orders that are submitted before the current time are queried.
   * 
   * @example
   * 1617200471885
   */
  endTime?: number;
  /**
   * @remarks
   * The type of the compute engine with which the permission request order is associated. The parameter value is odps and cannot be changed. This value indicates that you can request permissions only on fields of tables in the MaxCompute compute engine.
   * 
   * This parameter is required.
   * 
   * @example
   * odps
   */
  engineType?: string;
  /**
   * @remarks
   * The status of the permission request order. Valid values:
   * 
   * *   1: to be processed
   * *   2: approved and authorized
   * *   3: approved but authorization failed
   * *   4: rejected
   * 
   * Valid values:
   * 
   * *   0
   * *   1
   * *   2
   * *   3
   * *   4
   * *   5
   * 
   * @example
   * 1
   */
  flowStatus?: number;
  /**
   * @remarks
   * The name of the MaxCompute project with which the permission request order is associated. If you do not specify the parameter, the permission request orders of all MaxCompute projects are returned.
   * 
   * @example
   * aMaxComputeProject
   */
  maxComputeProjectName?: string;
  /**
   * @remarks
   * The type of the permission request order. The parameter value is 1 and cannot be changed. This value indicates ACL-based authorization.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  orderType?: number;
  /**
   * @remarks
   * The page number. Pages start from page 1. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 100
   */
  pageSize?: number;
  /**
   * @remarks
   * The query type of the permission request order. Valid values:
   * 
   * *   0: The permission request orders you submitted.
   * *   1: The permission request orders you approved.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  queryType?: number;
  /**
   * @remarks
   * The beginning of the time range to query. You can query all the permissions request orders that have been submitted after the time. The parameter value is a UNIX timestamp. If you do not specify the parameter, all permission request orders are queried.
   * 
   * @example
   * 1616200471885
   */
  startTime?: number;
  /**
   * @remarks
   * The name of the table with which the permission request order is associated. If you do not specify the parameter, the permission request orders of all tables are returned.
   * 
   * @example
   * aTableName
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace that is associated with the permission request order. If you do not specify the parameter, the permission request orders of all workspaces are returned. You can go to the Workspace page in the DataWorks console to obtain the workspace ID.
   * 
   * @example
   * 12345
   */
  workspaceId?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      engineType: 'EngineType',
      flowStatus: 'FlowStatus',
      maxComputeProjectName: 'MaxComputeProjectName',
      orderType: 'OrderType',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      queryType: 'QueryType',
      startTime: 'StartTime',
      tableName: 'TableName',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      engineType: 'string',
      flowStatus: 'number',
      maxComputeProjectName: 'string',
      orderType: 'number',
      pageNum: 'number',
      pageSize: 'number',
      queryType: 'number',
      startTime: 'number',
      tableName: 'string',
      workspaceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPermissionApplyOrdersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The query results returned by page.
   */
  applyOrders?: ListPermissionApplyOrdersResponseBodyApplyOrders;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      applyOrders: 'ApplyOrders',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyOrders: ListPermissionApplyOrdersResponseBodyApplyOrders,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPermissionApplyOrdersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListPermissionApplyOrdersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPermissionApplyOrdersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProgramTypeCountRequest extends $tea.Model {
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      projectEnv: 'ProjectEnv',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectEnv: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProgramTypeCountResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of node types and quantity.
   */
  programTypeAndCounts?: ListProgramTypeCountResponseBodyProgramTypeAndCounts[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      programTypeAndCounts: 'ProgramTypeAndCounts',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      programTypeAndCounts: { 'type': 'array', 'itemType': ListProgramTypeCountResponseBodyProgramTypeAndCounts },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProgramTypeCountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProgramTypeCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProgramTypeCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectIdsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the desired Alibaba Cloud account.
   * 
   * You can log on to the [DataWorks](https://workbench.data.aliyun.com/console) console and move the pointer over the profile picture in the upper-right corner to view the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 171111
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectIdsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The IDs of the DataWorks workspaces. The IDs of the workspaces on which the desired Alibaba Cloud account has permissions were returned.
   */
  projectIds?: number[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0b57ff7216278945532771749d****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      projectIds: 'ProjectIds',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectIds: { 'type': 'array', 'itemType': 'number' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectIdsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectIdsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectIdsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersRequest extends $tea.Model {
  /**
   * @remarks
   * The page number. Valid values: 1 to 30. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 27
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned results.
   */
  data?: ListProjectMembersResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1AFAE64E-D1BE-432B-A9****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListProjectMembersResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectRolesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the DataWorks workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 27
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectRolesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The roles in the DataWorks workspace.
   */
  projectRoleList?: ListProjectRolesResponseBodyProjectRoleList[];
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1AFAE64E-D1BE-432B-A9****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      projectRoleList: 'ProjectRoleList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectRoleList: { 'type': 'array', 'itemType': ListProjectRolesResponseBodyProjectRoleList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectRolesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectRolesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectRolesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsRequest extends $tea.Model {
  /**
   * @remarks
   * The page number. Valid values: 1 to 100.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmzbn7pti3zfa
   */
  resourceManagerResourceGroupId?: string;
  /**
   * @remarks
   * The tags to add to the workspace.
   */
  tags?: ListProjectsRequestTags[];
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceManagerResourceGroupId: 'ResourceManagerResourceGroupId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      resourceManagerResourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': ListProjectsRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The page number. Valid values: 1 to 100.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmzbn7pti3zfa
   */
  resourceManagerResourceGroupId?: string;
  /**
   * @remarks
   * The tags to add to the workspace.
   */
  tagsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      resourceManagerResourceGroupId: 'ResourceManagerResourceGroupId',
      tagsShrink: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      resourceManagerResourceGroupId: 'string',
      tagsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The results that are returned.
   */
  pageResult?: ListProjectsResponseBodyPageResult;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 20658801***
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageResult: 'PageResult',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageResult: ListProjectsResponseBodyPageResult,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListProjectsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListProjectsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByEntityRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-09-21 00:00:00
   */
  endDate?: string;
  /**
   * @remarks
   * The ID of the partition filter expression. You can call the [GetQualityEntity](https://help.aliyun.com/document_detail/174003.html) operation to query the ID of the partition filter expression.
   * 
   * This parameter is required.
   * 
   * @example
   * 152322134
   */
  entityId?: number;
  /**
   * @remarks
   * The page number.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 20.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 12345
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine or data source. You can obtain the name from data source configurations.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-09-20 00:00:00
   */
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      entityId: 'EntityId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      startDate: 'StartDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      entityId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      projectName: 'string',
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByEntityResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data structure of the check results.
   */
  data?: ListQualityResultsByEntityResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CBA58543-00D4-41****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListQualityResultsByEntityResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByEntityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListQualityResultsByEntityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListQualityResultsByEntityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
   * 
   * This parameter is used together with the StartDate parameter. The interval between the time specified by this parameter and the time specified by the StartDate parameter cannot exceed 7 days.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-09-22 00:00:00
   */
  endDate?: string;
  /**
   * @remarks
   * The page number.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 12345
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine or data source for which data quality is monitored.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The monitoring rule ID. You can use the ID and information such as a partition filter expression to perform a joint query.
   * 
   * This parameter is required.
   * 
   * @example
   * 152322134
   */
  ruleId?: number;
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
   * 
   * This parameter is used together with the EndDate parameter. The interval between the time specified by this parameter and the time specified by the EndDate parameter cannot exceed 7 days.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-09-20 00:00:00
   */
  startDate?: string;
  static names(): { [key: string]: string } {
    return {
      endDate: 'EndDate',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      ruleId: 'RuleId',
      startDate: 'StartDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endDate: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      projectName: 'string',
      ruleId: 'number',
      startDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data structure of the monitoring results returned.
   */
  data?: ListQualityResultsByRuleResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * CBA58543-00D4-41****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListQualityResultsByRuleResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListQualityResultsByRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListQualityResultsByRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityRulesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the partition filter expression. You can call the [GetQualityEntity](https://help.aliyun.com/document_detail/174003.html) operation to query the ID of the partition filter expression.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  entityId?: number;
  /**
   * @remarks
   * The page number.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 20.
   * 
   * This parameter is required.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 12345
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine or data source. You can obtain the name from data source configurations.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      entityId: 'EntityId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityRulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The list of monitoring rules.
   */
  data?: ListQualityRulesResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can troubleshoot errors based on the ID.
   * 
   * @example
   * 38cbdef0-f6cf-49****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListQualityRulesResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityRulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListQualityRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListQualityRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRefDISyncTasksRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the data source. You can call the [ListDataSources](https://help.aliyun.com/document_detail/211431.html) operation to query the name of the data source.
   * 
   * This parameter is required.
   * 
   * @example
   * mysql_datasource
   */
  datasourceName?: string;
  /**
   * @remarks
   * The page number. Valid values: 1 to 100.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 100
   */
  pageSize?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The condition used to filter synchronization tasks. Valid values:
   * 
   * *   from: queries the synchronization tasks that use the data source as the source.
   * *   to: queries the synchronization tasks that use the data source as the destination.
   * 
   * This parameter is required.
   * 
   * @example
   * from
   */
  refType?: string;
  /**
   * @remarks
   * The type of the synchronization task that you want to query. Valid values:
   * 
   * *   DI_OFFLINE: batch synchronization task
   * *   DI_REALTIME: real-time synchronization task
   * 
   * You can call the ListRefDISyncTasks operation to query only one type of the task.
   * 
   * This parameter is required.
   * 
   * @example
   * DI_OFFLINE
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      datasourceName: 'DatasourceName',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
      refType: 'RefType',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasourceName: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      projectId: 'number',
      refType: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRefDISyncTasksResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned result.
   */
  data?: ListRefDISyncTasksResponseBodyData;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListRefDISyncTasksResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRefDISyncTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRefDISyncTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRefDISyncTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRemindsRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to receive alert notifications.
   * 
   * @example
   * 9527952795****
   */
  alertTarget?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to create the custom alert rules.
   * 
   * @example
   * 9527952795****
   */
  founder?: string;
  /**
   * @remarks
   * The ID of the node to which the custom alert rules are applied. You can use the ID to search for the custom alert rules that are applied to the node.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The number of the page to return. Valid values: 1 to 30. Default value: 1.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The conditions that trigger an alert for the node. Valid values: FINISHED, UNFINISHED, ERROR, CYCLE_UNFINISHED, and TIMEOUT. The value FINISHED indicates that the node finishes running. The value UNFINISHED indicates that the node is still running at the specified point in time. The value ERROR indicates that an error occurs when the node is running. The value CYCLE_UNFINISHED indicates that the node does not finish running in the specified scheduling cycle. The value TIMEOUT indicates that the node times out. You can specify multiple conditions for a custom alert rule. If you specify multiple condition, separate them with commas (,).
   * 
   * @example
   * FINISHED,ERROR
   */
  remindTypes?: string;
  /**
   * @remarks
   * The keyword in a rule name that is used to search for the rule. Fuzzy search is supported.
   * 
   * @example
   * Keyword
   */
  searchText?: string;
  static names(): { [key: string]: string } {
    return {
      alertTarget: 'AlertTarget',
      founder: 'Founder',
      nodeId: 'NodeId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      remindTypes: 'RemindTypes',
      searchText: 'SearchText',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertTarget: 'string',
      founder: 'string',
      nodeId: 'number',
      pageNumber: 'number',
      pageSize: 'number',
      remindTypes: 'string',
      searchText: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRemindsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   */
  data?: ListRemindsResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListRemindsResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRemindsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListRemindsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRemindsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourceGroupsRequest extends $tea.Model {
  /**
   * @remarks
   * The category of the resource group. Valid values:
   * 
   * *   default (default): shared resource group
   * *   single: exclusive resource group
   * 
   * @example
   * default
   */
  bizExtKey?: string;
  /**
   * @remarks
   * The keyword that is used for fuzzy match by resource group name and identifier.
   * 
   * @example
   * abc
   */
  keyword?: string;
  /**
   * @remarks
   * The type of the resource group that you want to query. Valid values:
   * 
   * *   0: DataWorks
   * *   1: scheduling
   * *   2: MaxCompute
   * *   3: Platform for AI (PAI)
   * *   4: Data Integration
   * *   7: exclusive resource group for scheduling (An ID is generated for the purchased resource when you purchase an exclusive resource group for scheduling.)
   * *   9: DataService Studio
   * *   Default value: 1
   * 
   * If the value indicates a compute engine, the resource groups to query are the ones that were created when you purchased the compute engine.
   * 
   * @example
   * 3
   */
  resourceGroupType?: number;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmzbn7pti3zfa
   */
  resourceManagerResourceGroupId?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: ListResourceGroupsRequestTags[];
  static names(): { [key: string]: string } {
    return {
      bizExtKey: 'BizExtKey',
      keyword: 'Keyword',
      resourceGroupType: 'ResourceGroupType',
      resourceManagerResourceGroupId: 'ResourceManagerResourceGroupId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizExtKey: 'string',
      keyword: 'string',
      resourceGroupType: 'number',
      resourceManagerResourceGroupId: 'string',
      tags: { 'type': 'array', 'itemType': ListResourceGroupsRequestTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourceGroupsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The category of the resource group. Valid values:
   * 
   * *   default (default): shared resource group
   * *   single: exclusive resource group
   * 
   * @example
   * default
   */
  bizExtKey?: string;
  /**
   * @remarks
   * The keyword that is used for fuzzy match by resource group name and identifier.
   * 
   * @example
   * abc
   */
  keyword?: string;
  /**
   * @remarks
   * The type of the resource group that you want to query. Valid values:
   * 
   * *   0: DataWorks
   * *   1: scheduling
   * *   2: MaxCompute
   * *   3: Platform for AI (PAI)
   * *   4: Data Integration
   * *   7: exclusive resource group for scheduling (An ID is generated for the purchased resource when you purchase an exclusive resource group for scheduling.)
   * *   9: DataService Studio
   * *   Default value: 1
   * 
   * If the value indicates a compute engine, the resource groups to query are the ones that were created when you purchased the compute engine.
   * 
   * @example
   * 3
   */
  resourceGroupType?: number;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmzbn7pti3zfa
   */
  resourceManagerResourceGroupId?: string;
  /**
   * @remarks
   * The tags.
   */
  tagsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      bizExtKey: 'BizExtKey',
      keyword: 'Keyword',
      resourceGroupType: 'ResourceGroupType',
      resourceManagerResourceGroupId: 'ResourceManagerResourceGroupId',
      tagsShrink: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizExtKey: 'string',
      keyword: 'string',
      resourceGroupType: 'number',
      resourceManagerResourceGroupId: 'string',
      tagsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourceGroupsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The resource groups.
   */
  data?: ListResourceGroupsResponseBodyData[];
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListResourceGroupsResponseBodyData },
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourceGroupsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListResourceGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListResourceGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListShiftPersonnelsRequest extends $tea.Model {
  /**
   * @remarks
   * The time when the on-duty engineer starts a shift. Set the value to a UNIX timestamp.
   * 
   * This parameter is required.
   * 
   * @example
   * 1593950832000
   */
  beginTime?: number;
  /**
   * @remarks
   * The time when the on-duty engineer ends a shift. Set the value to a UNIX timestamp.
   * 
   * This parameter is required.
   * 
   * @example
   * 1593950832000
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account. You can log on to the DataWorks console and move the pointer over the profile picture in the upper-right corner to view the ID.
   * 
   * @example
   * 1933790****551
   */
  shiftPersonUID?: string;
  /**
   * @remarks
   * The unique identifier of the shift schedule.
   * 
   * This parameter is required.
   * 
   * @example
   * 2ab6456ada634b2f938ee******9b45b
   */
  shiftScheduleIdentifier?: string;
  /**
   * @remarks
   * The type of the on-duty engineer that you want to query. Valid values: ALL, PRIMARY, BACKUP, and DESIGNATED_USER.
   * 
   * @example
   * ALL
   */
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      beginTime: 'BeginTime',
      endTime: 'EndTime',
      shiftPersonUID: 'ShiftPersonUID',
      shiftScheduleIdentifier: 'ShiftScheduleIdentifier',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginTime: 'number',
      endTime: 'number',
      shiftPersonUID: 'string',
      shiftScheduleIdentifier: 'string',
      userType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListShiftPersonnelsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The pagination data.
   */
  paging?: ListShiftPersonnelsResponseBodyPaging;
  /**
   * @remarks
   * The request ID. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      paging: 'Paging',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paging: ListShiftPersonnelsResponseBodyPaging,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListShiftPersonnelsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListShiftPersonnelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListShiftPersonnelsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListShiftSchedulesRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of your Alibaba Cloud account. You can log on to the DataWorks console and move the pointer over the profile picture in the upper-right corner to view the ID.
   * 
   * @example
   * 1933790683****
   */
  owner?: string;
  /**
   * @remarks
   * The page number. Minimum value:1. Maximum value: 100. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The keyword used to perform a fuzzy search on shift schedules.
   */
  shiftScheduleName?: string;
  static names(): { [key: string]: string } {
    return {
      owner: 'Owner',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      shiftScheduleName: 'ShiftScheduleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      owner: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      shiftScheduleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListShiftSchedulesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The pagination data.
   */
  paging?: ListShiftSchedulesResponseBodyPaging;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      paging: 'Paging',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paging: ListShiftSchedulesResponseBodyPaging,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListShiftSchedulesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListShiftSchedulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListShiftSchedulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSuccessInstanceAmountRequest extends $tea.Model {
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 9527
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSuccessInstanceAmountResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates the trend of the number of auto triggered node instances that are successfully run every hour on the hour of the current day.
   */
  instanceStatusTrend?: ListSuccessInstanceAmountResponseBodyInstanceStatusTrend;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 952795279527ab****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceStatusTrend: 'InstanceStatusTrend',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceStatusTrend: ListSuccessInstanceAmountResponseBodyInstanceStatusTrend,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSuccessInstanceAmountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListSuccessInstanceAmountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSuccessInstanceAmountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableLevelRequest extends $tea.Model {
  /**
   * @remarks
   * The table level type. Valid values: 1 and 2. The value 1 indicates the logical level. The value 2 indicates the physical level.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  levelType?: number;
  /**
   * @remarks
   * The page number. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the DataWorks console to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      levelType: 'LevelType',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      levelType: 'number',
      pageNum: 'number',
      pageSize: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableLevelResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * abc
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The information about the table levels.
   */
  tableLevelInfo?: ListTableLevelResponseBodyTableLevelInfo;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
      tableLevelInfo: 'TableLevelInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
      tableLevelInfo: ListTableLevelResponseBodyTableLevelInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableLevelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTableLevelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTableLevelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableThemeRequest extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The ID of the parent table theme.
   * 
   * @example
   * 121
   */
  parentId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 123
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      parentId: 'ParentId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNum: 'number',
      pageSize: 'number',
      parentId: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableThemeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned result.
   */
  data?: ListTableThemeResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * abcde
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListTableThemeResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableThemeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTableThemeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTableThemeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * odps
   * emr
   * mysql
   * holo
   */
  dataSourceType?: string;
  /**
   * @example
   * 12222
   */
  nextToken?: string;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      dataSourceType: 'DataSourceType',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceType: 'string',
      nextToken: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data.
   */
  data?: ListTablesResponseBodyData;
  /**
   * @remarks
   * Id of the request
   * 
   * @example
   * E25887B7-579C-54A5-9C4F-83A0DE367DD
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListTablesResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTopicsRequest extends $tea.Model {
  /**
   * @remarks
   * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\\"T\\"HH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2019-03-24T00:00:00+0800
   */
  beginTime?: string;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\\"T\\"HH:mm:ssZ format. The time must be in UTC.
   * 
   * This parameter is required.
   * 
   * @example
   * 2019-03-25T23:00:00+0800
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the node instance that triggers the events. You can configure either this parameter or the NodeId parameter.
   * 
   * @example
   * 12345
   */
  instanceId?: number;
  /**
   * @remarks
   * The ID of the node that triggers the events. You can configure either this parameter or the InstanceId parameter.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the owner of the events.
   * 
   * @example
   * 952795****
   */
  owner?: string;
  /**
   * @remarks
   * The number of the page to return. Valid values: 1 to 30. Default value: 1.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10. Maximum value: 100.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The status of the events. Valid values: IGNORE, NEW, FIXING, and RECOVER. The value IGNORE indicates that the events are ignored. The value NEW indicates that the events are new events. The value FIXING indicates that the events are being processed. The value RECOVER indicates that the events are processed. You can specify multiple states. Separate them with commas (,).
   * 
   * @example
   * IGNORE,NEW,FIXING,RECOVER
   */
  topicStatuses?: string;
  /**
   * @remarks
   * The types of the events. Valid values: SLOW and ERROR. The value SLOW indicates that the running duration of the node in the current scheduling cycle is significantly longer than the average running duration of the node in previous scheduling cycles. The value ERROR indicates that the node fails to run. You can specify multiple types. Separate them with commas (,).
   * 
   * @example
   * ERROR,SLOW
   */
  topicTypes?: string;
  static names(): { [key: string]: string } {
    return {
      beginTime: 'BeginTime',
      endTime: 'EndTime',
      instanceId: 'InstanceId',
      nodeId: 'NodeId',
      owner: 'Owner',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      topicStatuses: 'TopicStatuses',
      topicTypes: 'TopicTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginTime: 'string',
      endTime: 'string',
      instanceId: 'number',
      nodeId: 'number',
      owner: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      topicStatuses: 'string',
      topicTypes: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTopicsResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the events returned.
   */
  data?: ListTopicsResponseBodyData;
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListTopicsResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTopicsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTopicsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTopicsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MountDirectoryRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the directory that you want to add to the left-side navigation pane of DataAnalysis. This parameter is used together with the TargetType parameter. For example, if you set the TargetType parameter to META_ALBUM, you must set the TargetId parameter to the ID of the related data album. You can call the [ListMetaCollections](https://help.aliyun.com/document_detail/469938.html) operation to obtain the ID of the data album. The ID is indicated by the QualifiedName parameter.
   * 
   * @example
   * album.339
   */
  targetId?: string;
  /**
   * @remarks
   * The type of the directory that you want to add to the left-side navigation pane of DataAnalysis. Example: META_ALBUM, which indicates the data album.
   * 
   * @example
   * META_ALBUM
   */
  targetType?: string;
  /**
   * @remarks
   * The ID of the user in the tenant.
   * 
   * *   If you do not configure TargetUserId, the specified directory belongs to you.
   * *   If you configure TargetUserId, the specified directory belongs to the user specified by using TargetUserId.
   * 
   * @example
   * 1234567890
   */
  targetUserId?: string;
  static names(): { [key: string]: string } {
    return {
      targetId: 'TargetId',
      targetType: 'TargetType',
      targetUserId: 'TargetUserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetId: 'string',
      targetType: 'string',
      targetUserId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MountDirectoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of directories that are added. Valid values:
   * 
   * *   0: No directories are added. The left-side navigation pane may contain the specified directory.
   * *   1: One directory is added.
   * 
   * @example
   * 1
   */
  data?: number;
  /**
   * @remarks
   * The error code. The value 200 indicates that the task is successful.
   * 
   * @example
   * 200
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to troubleshoot issues.
   * 
   * @example
   * C27D4FB9-C59B-5E17-BD6C-1099B9D6A381
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class MountDirectoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: MountDirectoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: MountDirectoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OfflineNodeRequest extends $tea.Model {
  /**
   * @remarks
   * The node ID. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to obtain the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can call the [ListProjects](https://help.aliyun.com/document_detail/178393.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 9527
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OfflineNodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID. You can use the request ID to query logs and troubleshoot issues.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OfflineNodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OfflineNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OfflineNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishDataServiceApiRequest extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  apiId?: number;
  /**
   * @remarks
   * The workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * @example
   * 10002
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishDataServiceApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the API was published.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublishDataServiceApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: PublishDataServiceApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublishDataServiceApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDISyncTaskConfigProcessResultRequest extends $tea.Model {
  /**
   * @remarks
   * The asynchronous thread ID. You can call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) or [GenerateDISyncTaskConfigForUpdating](https://help.aliyun.com/document_detail/383464.html) operation to obtain the ID.
   * 
   * *   The GenerateDISyncTaskConfigForCreating operation is used to generate the ID of the asynchronous thread that is used to create a real-time synchronization task in Data Integration.
   * *   The GenerateDISyncTaskConfigForUpdating operation is used to generate the ID of the asynchronous thread that is used to update a real-time synchronization task in Data Integration.
   * 
   * This parameter is required.
   * 
   * @example
   * 10
   */
  asyncProcessId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the ID.
   * 
   * You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The type of the object that you want to create or update in Data Integration in asynchronous mode. Valid values:
   * 
   * *   DI_REALTIME: real-time synchronization task
   * *   DI_SOLUTION: synchronization solution DataWorks allows you to create or update real-time synchronization tasks and synchronization solutions in Data Integration only in asynchronous mode.
   * 
   * Valid values:
   * 
   * *   DI_OFFLINE
   * *   DI_REALTIME
   * *   DI_SOLUTION
   * 
   * This parameter is required.
   * 
   * @example
   * DI_REALTIME
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      asyncProcessId: 'AsyncProcessId',
      projectId: 'ProjectId',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asyncProcessId: 'number',
      projectId: 'number',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDISyncTaskConfigProcessResultResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information returned for the parameters that are asynchronously generated and used to create or update a real-time synchronization task in Data Integration.
   */
  data?: QueryDISyncTaskConfigProcessResultResponseBodyData;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: QueryDISyncTaskConfigProcessResultResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDISyncTaskConfigProcessResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryDISyncTaskConfigProcessResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDISyncTaskConfigProcessResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDefaultTemplateRequest extends $tea.Model {
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * This parameter is required.
   * 
   * @example
   * 10241024
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDefaultTemplateResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data about the default data category and data sensitivity level template. The data is in the JSON array format.
   * 
   * This parameter is required.
   */
  data?: any;
  /**
   * @remarks
   * The error code.
   * 
   * This parameter is required.
   * 
   * @example
   * 9990030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * This parameter is required.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * This parameter is required.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 102400001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * This parameter is required.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDefaultTemplateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryDefaultTemplateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDefaultTemplateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPublicModelEngineRequest extends $tea.Model {
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  projectId?: string;
  /**
   * @remarks
   * The FML statement that is used to query information about objects that are created in Data Modeling. For more information, see [Use FML statements to configure and manage data tables](https://help.aliyun.com/document_detail/298128.html). Only SHOW statements are supported.
   * 
   * This parameter is required.
   * 
   * @example
   * show dim tables
   */
  text?: string;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'string',
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPublicModelEngineResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 4CFB2DED-7D9B-4C42-B4AA-CFF4991DFFF4
   */
  requestId?: string;
  /**
   * @remarks
   * The returned information about objects.
   */
  returnValue?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      returnValue: 'ReturnValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      returnValue: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPublicModelEngineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryPublicModelEngineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryPublicModelEngineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryRecognizeDataByRuleTypeRequest extends $tea.Model {
  /**
   * @remarks
   * The type of a sensitive data identification rule. You can call the [QueryRecognizeRulesType](https://help.aliyun.com/document_detail/2746905.html) operation to obtain the type of the rule.
   * 
   * *   1: regular expression
   * *   2: built-in rule
   * *   3: sample library
   * *   4: self-generated data identification model
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  recognizeRulesType?: string;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * This parameter is required.
   * 
   * @example
   * 10241024
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      recognizeRulesType: 'RecognizeRulesType',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recognizeRulesType: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryRecognizeDataByRuleTypeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned result in the JSON format.
   * 
   * @example
   * [{"custom": false,       "name": "EducationDegree",       "localeName": "EducationDegree",       "templateJsonStr": "{&quot;_clazz&quot;:&quot;com.alipay.dsgclient.sdk.dsg.fastscan.engine.cond.EducationDegreeCond&quot;}",       "desc": ""}]
   */
  data?: any;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9990030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 10000001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryRecognizeDataByRuleTypeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryRecognizeDataByRuleTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryRecognizeDataByRuleTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryRecognizeRuleDetailRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the sensitive field. To obtain the name of the sensitive field, call the [QuerySensNodeInfo](https://help.aliyun.com/document_detail/2747189.html) operation or log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Data Category and Sensitivity Level page.
   * 
   * This parameter is required.
   */
  sensitiveName?: string;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * This parameter is required.
   * 
   * @example
   * 10241024
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      sensitiveName: 'SensitiveName',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sensitiveName: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryRecognizeRuleDetailResponseBody extends $tea.Model {
  /**
   * @remarks
   * The details of the sensitive field in the JSON format.
   */
  data?: any;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9990030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the request ID to query logs and troubleshoot issues.
   * 
   * @example
   * 10000001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryRecognizeRuleDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryRecognizeRuleDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryRecognizeRuleDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryRecognizeRulesTypeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data about the built-in sensitive data identification rule that is used to configure a sensitive field. The data is in the JSON format.
   * 
   * @example
   * {   "HttpStatusCode": 200,   "Data": [     {       "Regular Expression": "1"     },     {       "Recognize Rule": "2"     },     {       "Sample Library": "3"     },     {       "Model": "4"     }   ],   "Success": true }
   */
  data?: any;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9990030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 10000001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryRecognizeRulesTypeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryRecognizeRulesTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryRecognizeRulesTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySensClassificationRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the template defined by Data Security Guard. You can call the [QueryDefaultTemplate](https://help.aliyun.com/document_detail/2743948.html) operation to obtain the template ID.
   * 
   * This parameter is required.
   * 
   * @example
   * e1970541-6cf5-4d23-b101-d5b66f6e1024
   */
  templateId?: string;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * This parameter is required.
   * 
   * @example
   * 10241024
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySensClassificationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data about data categories. The data is in the JSON format.
   * 
   * @example
   * [{         "nodeName": "teset1",         "sensitiveNotNull": true,         "nodeId": "1aac2e35-b437-486b-95c7-a5ae48371024",         "nodeOldId": "1aac2e35-b437-486b-95c7-a5ae48371024",         "parentId": "0"     }]
   */
  data?: any;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9990030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 400
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 10000001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySensClassificationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QuerySensClassificationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySensClassificationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySensLevelRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the template defined by Data Security Guard. You can call the [QueryDefaultTemplate](https://help.aliyun.com/document_detail/2743948.html) operation to obtain the template ID.
   * 
   * This parameter is required.
   * 
   * @example
   * e1970541-6cf5-4d23-b101-d5b66f6e10af
   */
  templateId?: string;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * This parameter is required.
   * 
   * @example
   * 10241024
   */
  tenantId?: string;
  static names(): { [key: string]: string } {
    return {
      templateId: 'TemplateId',
      tenantId: 'tenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      templateId: 'string',
      tenantId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySensLevelResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned data about data sensitivity levels. The data is in the JSON array format.
   * 
   * @example
   * [{"level":1,"isSensitive":false,"levelName":"1level"},{"level":2,"isSensitive":false,"levelName":"2level"}]
   */
  data?: any;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9990030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 10000001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySensLevelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QuerySensLevelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySensLevelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySensNodeInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the data category. You can call the [QuerySensClassification](https://help.aliyun.com/document_detail/2746850.html) operation or log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Data Security Guard page to obtain the ID.
   * 
   * @example
   * 0ce67949-0810-400f-a24a-cc5ffafe1024
   */
  nodeId?: string;
  /**
   * @remarks
   * The page number. Pages start from page 1.
   * 
   * @example
   * 1
   */
  pageNo?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 10 to 1000. The recommended number of entries per page ranges from 10 to 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The name of the sensitive field. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Data Security Guard page to obtain the name.
   */
  sensitiveName?: string;
  /**
   * @remarks
   * The ID of the data category and data sensitivity level template. You can call the [QueryDefaultTemplate](https://help.aliyun.com/document_detail/2743948.html) operation to obtain the template ID.
   * 
   * This parameter is required.
   * 
   * @example
   * e1970541-6cf5-4d23-b101-d5b66f6e1024
   */
  templateId?: string;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * This parameter is required.
   * 
   * @example
   * 10241024
   */
  tenantId?: string;
  /**
   * @remarks
   * The status of the sensitive field. Valid values:
   * 
   * *   0: draft
   * *   1: published
   * 
   * @example
   * 0
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      pageNo: 'PageNo',
      pageSize: 'PageSize',
      sensitiveName: 'SensitiveName',
      templateId: 'TemplateId',
      tenantId: 'TenantId',
      status: 'status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      pageNo: 'number',
      pageSize: 'number',
      sensitiveName: 'string',
      templateId: 'string',
      tenantId: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySensNodeInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned business data in the JSON format.
   */
  data?: any;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9990030003
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 10000001
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'any',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QuerySensNodeInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QuerySensNodeInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QuerySensNodeInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterLineageRelationRequest extends $tea.Model {
  /**
   * @remarks
   * The structure whose lineage you want to register to DataWorks.
   * 
   * This parameter is required.
   */
  lineageRelationRegisterVO?: LineageRelationRegisterVO;
  static names(): { [key: string]: string } {
    return {
      lineageRelationRegisterVO: 'LineageRelationRegisterVO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lineageRelationRegisterVO: LineageRelationRegisterVO,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterLineageRelationShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The structure whose lineage you want to register to DataWorks.
   * 
   * This parameter is required.
   */
  lineageRelationRegisterVOShrink?: string;
  static names(): { [key: string]: string } {
    return {
      lineageRelationRegisterVOShrink: 'LineageRelationRegisterVO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lineageRelationRegisterVOShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterLineageRelationResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1010210001
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The entity of lineage not exist, xxx
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The lineage.
   */
  lineageRelation?: RegisterLineageRelationResponseBodyLineageRelation;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * EE50E05E-028C-182B-9xxx
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      lineageRelation: 'LineageRelation',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      lineageRelation: RegisterLineageRelationResponseBodyLineageRelation,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterLineageRelationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RegisterLineageRelationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RegisterLineageRelationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveEntityTagsRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the entity. Example: maxcompute-table.projectA.tableA.
   * 
   * This parameter is required.
   * 
   * @example
   * maxcompute-table.projectA.tableA
   */
  qualifiedName?: string;
  /**
   * @remarks
   * The tag keys.
   * 
   * This parameter is required.
   */
  tagKeys?: string[];
  static names(): { [key: string]: string } {
    return {
      qualifiedName: 'QualifiedName',
      tagKeys: 'TagKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qualifiedName: 'string',
      tagKeys: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveEntityTagsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the entity. Example: maxcompute-table.projectA.tableA.
   * 
   * This parameter is required.
   * 
   * @example
   * maxcompute-table.projectA.tableA
   */
  qualifiedName?: string;
  /**
   * @remarks
   * The tag keys.
   * 
   * This parameter is required.
   */
  tagKeysShrink?: string;
  static names(): { [key: string]: string } {
    return {
      qualifiedName: 'QualifiedName',
      tagKeysShrink: 'TagKeys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qualifiedName: 'string',
      tagKeysShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveEntityTagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * true\\
   * false
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 101011005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Invalid.Entity.EntityTypeNotSupported
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true\\
   * false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveEntityTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveEntityTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveEntityTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveProjectMemberFromRoleRequest extends $tea.Model {
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 27
   */
  projectId?: number;
  /**
   * @remarks
   * The code of the role in the DataWorks workspace. You can call the ListProjectRoles operation to query the codes of all roles in a DataWorks workspace. Valid values:
   * 
   * *   role_project_owner: workspace owner
   * *   role_project_admin: workspace administrator
   * *   role_project_dev: developer
   * *   role_project_pe: O\\&M engineer
   * *   role_project_deploy: deployment expert
   * *   role_project_guest: visitor
   * *   role_project_security: security administrator
   * *   role_project_tester: experiencer
   * *   role_project_erd: model designer
   * 
   * This parameter is required.
   * 
   * @example
   * role_project_guest
   */
  roleCode?: string;
  /**
   * @remarks
   * The user ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
      roleCode: 'RoleCode',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
      roleCode: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveProjectMemberFromRoleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 1AFAE64E-D1BE-432B-A9****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveProjectMemberFromRoleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RemoveProjectMemberFromRoleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveProjectMemberFromRoleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  instanceId?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * q32ety****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RestartInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RestartInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RestartInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  instanceId?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The result returned.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResumeInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResumeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResumeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeColumnPermissionRequest extends $tea.Model {
  /**
   * @remarks
   * The fields for which you want to revoke permissions from a user. Separate multiple fields with commas (,). You can revoke the permissions on the fields only in MaxCompute tables.
   * 
   * This parameter is required.
   * 
   * @example
   * id,name
   */
  columns?: string;
  /**
   * @remarks
   * The name of the MaxCompute project to which the fields belong. You can log on to the DataWorks console and go to the SettingCenter page to obtain the name of the MaxCompute project that you associate with the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * aMaxcomputeProjectName
   */
  maxComputeProjectName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account of the user from which you want to revoke permissions. You can log on to the DataWorks console and go to the Security Settings page to obtain the ID. You must specify either this parameter or the RevokeUserName parameter. If you specify both this parameter and the RevokeUserName parameter and the parameter values are different, the value of this parameter prevails.
   * 
   * @example
   * 267842600408993176
   */
  revokeUserId?: string;
  /**
   * @remarks
   * The Alibaba Cloud account from which you want to revoke permissions. Specify this parameter in the format that is the same as the format of the account used to access the MaxCompute project.
   * 
   * *   If the account is an Alibaba Cloud account, the value is in the ALIYUN$+Account name format.
   * *   If the account is a RAM user, the value is in the RAM$+Account name format.
   * 
   * You must specify either this parameter or the RevokeUserId parameter. If you specify both this parameter and the RevokeUserId parameter and the parameter values are different, the value of the RevokeUserId parameter prevails.
   * 
   * @example
   * RAM$dataworks_3h1_1:stsramuser
   */
  revokeUserName?: string;
  /**
   * @remarks
   * The name of the MaxCompute table to which the fields belong. You can call the [SearchMetaTables](https://help.aliyun.com/document_detail/173919.html) operation to query the name of the MaxCompute table.
   * 
   * This parameter is required.
   * 
   * @example
   * aTableName
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace with which the MaxCompute project is associated. You can log on to the DataWorks console and go to the Workspace page to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  workspaceId?: number;
  static names(): { [key: string]: string } {
    return {
      columns: 'Columns',
      maxComputeProjectName: 'MaxComputeProjectName',
      revokeUserId: 'RevokeUserId',
      revokeUserName: 'RevokeUserName',
      tableName: 'TableName',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columns: 'string',
      maxComputeProjectName: 'string',
      revokeUserId: 'string',
      revokeUserName: 'string',
      tableName: 'string',
      workspaceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeColumnPermissionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the permissions are revoked.
   * 
   * @example
   * true
   */
  revokeSuccess?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      revokeSuccess: 'RevokeSuccess',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      revokeSuccess: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeColumnPermissionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RevokeColumnPermissionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RevokeColumnPermissionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeTablePermissionRequest extends $tea.Model {
  /**
   * @remarks
   * The permissions that you want to revoke. Separate multiple permissions with commas (,). You can revoke only the SELECT, DESCRIBE, and DOWNLOAD permissions on MaxCompute tables.
   * 
   * This parameter is required.
   * 
   * @example
   * Select,Describe
   */
  actions?: string;
  /**
   * @remarks
   * The name of the MaxCompute project to which the table belongs. You can log on to the DataWorks console and go to the SettingCenter page to obtain the name of the MaxCompute project that you associate with the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * aMaxcomputeProjectName
   */
  maxComputeProjectName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account from which you want to revoke permissions. You can log on to the DataWorks console and go to the Security Settings page to obtain the ID. You must specify either this parameter or the RevokeUserName parameter. If you specify both this parameter and the RevokeUserName parameter and the parameter values are different, the value of this parameter prevails.
   * 
   * @example
   * 267842600408993176
   */
  revokeUserId?: string;
  /**
   * @remarks
   * The Alibaba Cloud account from which you want to revoke permissions. Specify this parameter in the format that is the same as the format of the account used to access the MaxCompute project.
   * 
   * *   If the account is an Alibaba Cloud account, the value is in the ALIYUN$+Account name format.
   * *   If the account is a RAM user, the value is in the RAM$+Account name format.
   * 
   * You must specify either this parameter or the RevokeUserId parameter. If you specify both this parameter and the RevokeUserId parameter and the parameter values are different, the value of the RevokeUserId parameter prevails.
   * 
   * @example
   * RAM$dataworks_3h1_1:stsramuser
   */
  revokeUserName?: string;
  /**
   * @remarks
   * The name of the MaxCompute table. You can call the [SearchMetaTables](https://help.aliyun.com/document_detail/173919.html) operation to query the name of the MaxCompute table.
   * 
   * This parameter is required.
   * 
   * @example
   * aTableName
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace with which the MaxCompute project is associated. You can log on to the DataWorks console and go to the Workspace page to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  workspaceId?: number;
  static names(): { [key: string]: string } {
    return {
      actions: 'Actions',
      maxComputeProjectName: 'MaxComputeProjectName',
      revokeUserId: 'RevokeUserId',
      revokeUserName: 'RevokeUserName',
      tableName: 'TableName',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actions: 'string',
      maxComputeProjectName: 'string',
      revokeUserId: 'string',
      revokeUserName: 'string',
      tableName: 'string',
      workspaceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeTablePermissionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the permissions are revoked.
   * 
   * @example
   * true
   */
  revokeSuccess?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      revokeSuccess: 'RevokeSuccess',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      revokeSuccess: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RevokeTablePermissionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RevokeTablePermissionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RevokeTablePermissionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunCycleDagNodesRequest extends $tea.Model {
  /**
   * @remarks
   * The alert notification method. Valid values:
   * 
   * *   SMS
   * *   MAIL
   * *   SMS_MAIL
   * 
   * @example
   * SMS
   */
  alertNoticeType?: string;
  /**
   * @remarks
   * The alert type. Valid values:
   * 
   * *   SUCCESS: An alert is generated when data backfill succeeds.
   * *   FAILURE: An alert is generated when data backfill fails.
   * *   SUCCESS_FAILURE: An alert is generated regardless of whether data backfill succeeds or fails.
   * 
   * @example
   * FAILURE
   */
  alertType?: string;
  /**
   * @remarks
   * The time when the node starts to run. This parameter is required only for auto triggered nodes that are scheduled by hour. Specify the value in the HH:mm:ss format. Valid values: 00:00:00 to 23:59:59.
   * 
   * @example
   * 00:00:00
   */
  bizBeginTime?: string;
  /**
   * @remarks
   * The time when the node stops running. This parameter is required only for auto triggered nodes that are scheduled by hour. Specify the value in the HH:mm:ss format. Valid values: 00:00:00 to 23:59:59.
   * 
   * @example
   * 01:00:00
   */
  bizEndTime?: string;
  /**
   * @remarks
   * The number of nodes that can run in parallel. Valid values: 2 to 10.
   * 
   * @example
   * 5
   */
  concurrentRuns?: number;
  /**
   * @remarks
   * The data timestamp at which data is no longer backfilled. Specify the value in the yyyy-MM-dd 00:00:00 format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-05-21 00:00:00
   */
  endBizDate?: string;
  /**
   * @remarks
   * The IDs of the nodes for which no data needs to be backfilled. The system generates dry-run instances for all these nodes. After these dry-run instances are scheduled, the statuses of these instances are directly set to successful, but the script is not run.
   * 
   * @example
   * 1234,123465
   */
  excludeNodeIds?: string;
  /**
   * @remarks
   * The ID of the node for which you want to backfill data. If you want to backfill data for multiple nodes, separate the IDs of the nodes with commas (,). You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to obtain the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 74324,74325
   */
  includeNodeIds?: string;
  /**
   * @remarks
   * The name of the workflow.
   * 
   * This parameter is required.
   * 
   * @example
   * xm_test
   */
  name?: string;
  /**
   * @remarks
   * The parameters that need to be configured for the node. Set this parameter to a JSON string. The key indicates the ID of the node, and the value indicates the actual values of the parameters.
   * 
   * @example
   * {74324:"a=123 b=456"}
   */
  nodeParams?: string;
  /**
   * @remarks
   * Specifies whether data can be backfilled for multiple nodes at the same time.
   * 
   * This parameter is required.
   * 
   * @example
   * false
   */
  parallelism?: boolean;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment, and the value DEV indicates the development environment.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  /**
   * @remarks
   * The ID of the node for which data is first backfilled. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to obtain the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  rootNodeId?: number;
  /**
   * @remarks
   * The data timestamp at which data starts to be backfilled. Specify the value in the yyyy-MM-dd 00:00:00 format.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-05-20 00:00:00
   */
  startBizDate?: string;
  /**
   * @remarks
   * Specifies whether to immediately run an instance that is scheduled to run in the future. If you set this parameter to true, the instance that is scheduled to run in the future is run immediately. Otherwise, the instance is run as scheduled.
   * 
   * @example
   * false
   */
  startFutureInstanceImmediately?: boolean;
  static names(): { [key: string]: string } {
    return {
      alertNoticeType: 'AlertNoticeType',
      alertType: 'AlertType',
      bizBeginTime: 'BizBeginTime',
      bizEndTime: 'BizEndTime',
      concurrentRuns: 'ConcurrentRuns',
      endBizDate: 'EndBizDate',
      excludeNodeIds: 'ExcludeNodeIds',
      includeNodeIds: 'IncludeNodeIds',
      name: 'Name',
      nodeParams: 'NodeParams',
      parallelism: 'Parallelism',
      projectEnv: 'ProjectEnv',
      rootNodeId: 'RootNodeId',
      startBizDate: 'StartBizDate',
      startFutureInstanceImmediately: 'StartFutureInstanceImmediately',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertNoticeType: 'string',
      alertType: 'string',
      bizBeginTime: 'string',
      bizEndTime: 'string',
      concurrentRuns: 'number',
      endBizDate: 'string',
      excludeNodeIds: 'string',
      includeNodeIds: 'string',
      name: 'string',
      nodeParams: 'string',
      parallelism: 'boolean',
      projectEnv: 'string',
      rootNodeId: 'number',
      startBizDate: 'string',
      startFutureInstanceImmediately: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunCycleDagNodesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The IDs of the nodes in the workflow. You can query instances based on the IDs.
   */
  data?: number[];
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the request ID to query logs and troubleshoot issues.
   * 
   * @example
   * >E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': 'number' },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunCycleDagNodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RunCycleDagNodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RunCycleDagNodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunManualDagNodesRequest extends $tea.Model {
  /**
   * @remarks
   * The data timestamp. The value of the data timestamp must be one or more days before the current date. For example, if the current date is November 11, 2020, set the value to 2020-11-10 00:00:00 or earlier. Configure this parameter in the YYYY-MM-DD 00:00:00 format. The StartBizDate parameter is used together with the EndBizDate parameter. You can configure only the BizDate parameter or the StartBizDate and EndBizDate parameters.
   * 
   * @example
   * 2020-11-11 00:00:00
   */
  bizDate?: string;
  /**
   * @remarks
   * The parameters are synchronized to all the instances in the directed acyclic graph (DAG) of the workflow. If a workflow parameter specified in DagParameters is referenced as a scheduling parameter of a [node](https://help.aliyun.com/document_detail/147245.html), the value of the scheduling parameter is replaced with the value of the workflow parameter.
   * 
   * @example
   * {"kaaaa": "vaaaaa", "kbbbb": "vbbbbb"}
   */
  dagParameters?: string;
  /**
   * @remarks
   * The end of the time range in which data generated needs to be processed. Configure this parameter in the yyyy-MM-dd HH:mm:ss format. The StartBizDate parameter is used together with the EndBizDate parameter. You can configure only the BizDate parameter or the StartBizDate and EndBizDate parameters.
   * 
   * @example
   * 2020-02-03 00:00:00
   */
  endBizDate?: string;
  /**
   * @remarks
   * The IDs of the nodes that you do not need to run in the manually triggered workflow. DataWorks generates dry-run instances for all these nodes. After the dry-run instances are scheduled, the states of these instances are directly set to successful, but the scripts are not run. Separate multiple node IDs with commas (,). The ExcludeNodeIds parameter must be used together with the IncludeNodeIds parameter. This way, the settings of the ExcludeNodeIds parameter can take effect.
   * 
   * @example
   * 123,456
   */
  excludeNodeIds?: string;
  /**
   * @remarks
   * The name of the manually triggered workflow.
   * 
   * This parameter is required.
   * 
   * @example
   * test_workflow
   */
  flowName?: string;
  /**
   * @remarks
   * The IDs of the nodes that you need to run in the manually triggered workflow. Separate multiple node IDs with commas (,).
   * 
   * @example
   * 74324,74325
   */
  includeNodeIds?: string;
  /**
   * @remarks
   * The scheduling parameters of nodes in the manually triggered workflow. Configure NodeParameters in the following JSON format: {"\\<ID of a node in the manually triggered workflow>": "Scheduling parameter settings of the node, which are in the same format as the parameter settings in the Scheduling Parameter section of the Properties tab on the DataStudio page", "\\<ID of a node in the manually triggered workflow>": "Scheduling parameter settings of the node, which are in the same format as the parameter settings in the Scheduling Parameter section of the Properties tab on the DataStudio page"}.
   * 
   * @example
   * {"20000123121": "key1=val2 key2=val2", "20000123124": "kkkk=vvvvv aaaa=bbbb"}
   */
  nodeParameters?: string;
  /**
   * @remarks
   * The environment type of Operation Center. Valid values: PROD and DEV. The value PROD indicates the production environment. The value DEV indicates the development environment.
   * 
   * This parameter is required.
   */
  projectEnv?: string;
  /**
   * @remarks
   * The ID of the workspace to which the manually triggered workflow belongs.
   * 
   * @example
   * 123
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the workspace to which the manually triggered workflow belongs.
   * 
   * This parameter is required.
   * 
   * @example
   * test_workspace
   */
  projectName?: string;
  /**
   * @remarks
   * The beginning of the time range in which data generated needs to be processed. Configure this parameter in the yyyy-MM-dd HH:mm:ss format. The StartBizDate parameter is used together with the EndBizDate parameter. You can configure only the BizDate parameter or the StartBizDate and EndBizDate parameters.
   * 
   * @example
   * 2020-02-02 00:00:00
   */
  startBizDate?: string;
  static names(): { [key: string]: string } {
    return {
      bizDate: 'BizDate',
      dagParameters: 'DagParameters',
      endBizDate: 'EndBizDate',
      excludeNodeIds: 'ExcludeNodeIds',
      flowName: 'FlowName',
      includeNodeIds: 'IncludeNodeIds',
      nodeParameters: 'NodeParameters',
      projectEnv: 'ProjectEnv',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      startBizDate: 'StartBizDate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizDate: 'string',
      dagParameters: 'string',
      endBizDate: 'string',
      excludeNodeIds: 'string',
      flowName: 'string',
      includeNodeIds: 'string',
      nodeParameters: 'string',
      projectEnv: 'string',
      projectId: 'number',
      projectName: 'string',
      startBizDate: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunManualDagNodesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ID of the DAG for the manually triggered workflow. You can call an operation with this parameter as a request parameter to query the details and states of the nodes in the manually triggered workflow.
   * 
   * @example
   * 700000123123141
   */
  dagId?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * AASFDFSDFG-DFSDF-DFSDFD-SDFSDF
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      dagId: 'DagId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dagId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunManualDagNodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RunManualDagNodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RunManualDagNodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunSmokeTestRequest extends $tea.Model {
  /**
   * @remarks
   * The data timestamp.
   * 
   * This parameter is required.
   * 
   * @example
   * 2020-05-26 00:00:00
   */
  bizdate?: string;
  /**
   * @remarks
   * The name of the workflow.
   * 
   * This parameter is required.
   * 
   * @example
   * xm_create_test
   */
  name?: string;
  /**
   * @remarks
   * The node ID. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The parameters related to the node. Set this parameter to a JSON string. A key in the string indicates a parameter, and a value in the string indicates the value of the related parameter.
   * 
   * @example
   * bizdate=$bizdate tbods=$tbods
   */
  nodeParams?: string;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment, and the value DEV indicates the development environment. A workspace in basic mode does not have a development environment. For more information, see [Differences between workspaces in basic mode and workspaces in standard mode](https://help.aliyun.com/document_detail/85772.html).
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      bizdate: 'Bizdate',
      name: 'Name',
      nodeId: 'NodeId',
      nodeParams: 'NodeParams',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizdate: 'string',
      name: 'string',
      nodeId: 'number',
      nodeParams: 'string',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunSmokeTestResponseBody extends $tea.Model {
  /**
   * @remarks
   * The workflow ID.
   * 
   * @example
   * 3333333
   */
  data?: number;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * false
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunSmokeTestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RunSmokeTestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RunSmokeTestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunTriggerNodeRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the DataWorks workspace to which the manually triggered node belongs. You can call the [ListProjects](https://help.aliyun.com/document_detail/178393.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  appId?: number;
  /**
   * @remarks
   * The data timestamp of the instance that is generated for the manually triggered node.
   * 
   * This parameter is required.
   * 
   * @example
   * 1606200230105
   */
  bizDate?: number;
  /**
   * @remarks
   * The scheduling time to run the manually triggered node. Set the value to a 13-digit timestamp in milliseconds.
   * 
   * This parameter is required.
   * 
   * @example
   * 1606200230105
   */
  cycleTime?: number;
  /**
   * @remarks
   * The ID of the manually triggered node. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000011
   */
  nodeId?: number;
  static names(): { [key: string]: string } {
    return {
      appId: 'AppId',
      bizDate: 'BizDate',
      cycleTime: 'CycleTime',
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appId: 'number',
      bizDate: 'number',
      cycleTime: 'number',
      nodeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunTriggerNodeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 9BA675F1-F848-4752-A6E3-92ABA0616005
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RunTriggerNodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RunTriggerNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RunTriggerNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveDataServiceApiTestResultRequest extends $tea.Model {
  /**
   * @remarks
   * The API ID. You can call the [ListDataServiceApis](https://help.aliyun.com/document_detail/174012.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 417381955954827
   */
  apiId?: number;
  /**
   * @remarks
   * Specifies whether to use the test results generated by the system. If you do not configure the resultSample or failResultSample parameter, the test results generated by the system are used.
   * 
   * @example
   * false
   */
  autoGenerate?: boolean;
  /**
   * @remarks
   * The sample failure response of the API. This parameter is optional.
   */
  failResultSample?: string;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The sample success response of the API. This parameter is optional.
   * 
   * @example
   * {  "data": {    "totalNum": 0,    "pageSize": 10,    "rows": [],    "pageNum": 1  },  "errCode": 0,  "requestId": "0bc14a561678159140664515*****",  "errMsg": "success",  "apiLog": null}
   */
  resultSample?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      autoGenerate: 'AutoGenerate',
      failResultSample: 'FailResultSample',
      projectId: 'ProjectId',
      resultSample: 'ResultSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      autoGenerate: 'boolean',
      failResultSample: 'string',
      projectId: 'number',
      resultSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveDataServiceApiTestResultResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the test results are saved.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveDataServiceApiTestResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SaveDataServiceApiTestResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SaveDataServiceApiTestResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScanSensitiveDataRequest extends $tea.Model {
  /**
   * @remarks
   * The data that you want to check.
   * 
   * This parameter is required.
   * 
   * @example
   * 13900001234
   */
  data?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScanSensitiveDataResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * The check result. sensDatas indicates the rules that are used to check the sensitive data. sensDatas includes the following parameters:
   * 
   * *   hitCount: the number of times that the sensitive data hits the rule.
   * *   ruleName: the name of the rule.
   */
  sensitives?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      sensitives: 'Sensitives',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      sensitives: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ScanSensitiveDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ScanSensitiveDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ScanSensitiveDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMetaTablesRequest extends $tea.Model {
  /**
   * @remarks
   * The GUID of the workspace where the metatables reside.
   * 
   * @example
   * odps.engine_name
   */
  appGuid?: string;
  /**
   * @remarks
   * The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
   * 
   * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the data source. Valid values: odps and emr.
   * 
   * @example
   * emr
   */
  dataSourceType?: string;
  /**
   * @remarks
   * The type of the metatables. Valid values: 0 and 1. The value 0 indicates that tables are queried. The value 1 indicates that views are queried. If you do not configure this parameter, all types of metatables are queried.
   * 
   * @example
   * 0
   */
  entityType?: number;
  /**
   * @remarks
   * The keyword based on which metatables are queried. During the query, the system tokenizes the names of metatables and matches the names with the keyword. If no name is matched, the value null is returned. By default, the system uses underscores (_) to tokenize the names.
   * 
   * This parameter is required.
   * 
   * @example
   * test
   */
  keyword?: string;
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The schema information of the table. You must configure this parameter if you enable the three-layer model of MaxCompute.
   * 
   * @example
   * default
   * 
   * **if can be null:**
   * true
   */
  schema?: string;
  static names(): { [key: string]: string } {
    return {
      appGuid: 'AppGuid',
      clusterId: 'ClusterId',
      dataSourceType: 'DataSourceType',
      entityType: 'EntityType',
      keyword: 'Keyword',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGuid: 'string',
      clusterId: 'string',
      dataSourceType: 'string',
      entityType: 'number',
      keyword: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      schema: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMetaTablesResponseBody extends $tea.Model {
  /**
   * @remarks
   * The search results.
   */
  data?: SearchMetaTablesResponseBodyData;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: SearchMetaTablesResponseBodyData,
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMetaTablesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchMetaTablesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchMetaTablesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchNodesByOutputRequest extends $tea.Model {
  /**
   * @remarks
   * The output names of the node. If you specify multiple output names, separate them with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * aaaaa.1231412_out,bbbb.12313123_out
   */
  outputs?: string;
  /**
   * @remarks
   * The environment of Operation Center. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      outputs: 'Outputs',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      outputs: 'string',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchNodesByOutputResponseBody extends $tea.Model {
  /**
   * @remarks
   * The map returned. The key in the map indicates an output name, and the value in the map indicates the information about the node that generates the output.
   */
  data?: { [key: string]: any };
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * SDFSDFSDF-asdfDFSDF-SDFSDf-SDfSFD
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchNodesByOutputResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SearchNodesByOutputResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SearchNodesByOutputResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDataSourceShareRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the data source that you want to share.
   * 
   * This parameter is required.
   * 
   * @example
   * mysql_name
   */
  datasourceName?: string;
  /**
   * @remarks
   * The environment in which the data source is used. Valid values:
   * 
   * *   0: development environment
   * *   1: production environment
   * 
   * @example
   * 1
   */
  envType?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace to which the data source belongs. You can call the [ListProjects](https://help.aliyun.com/document_detail/178393.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The DataWorks workspace to which you want to share the data source. If you configure this parameter, all members of the specified DataWorks workspace can view and use the data source. The value of this parameter is a JSON array. Example: [{"projectId":1000,"permission":"WRITE","sharedName":"PX_DATAHUB1.shared_name"}], Parameter description:
   * 
   * *   projectId: the ID of the DataWorks workspace to which you want to share the data source.
   * *   permission: the mode in which the data source is shared. Valid values: READ and WRITE. The value READ indicates that all members of the specified workspace can read data from the data source, but cannot modify the data. The value WRITE indicates that all members of the specified workspace can modify the data in the data source.
   * *   sharedName: the name of the data source that you want to share.
   * 
   * @example
   * [{"projectId":1000,"permission":"WRITE","sharedName":"PX_DATAHUB1.shared_name"}]
   */
  projectPermissions?: string;
  /**
   * @remarks
   * The user to whom you want to share the data source. If you configure this parameter, the specified user can view or use the data source. The value of this parameter is a JSON array. Example: [{"projectId":10000,"users":[{"userId":"276184575345452131","permission":"WRITE"}],"sharedName":"PX_DATAHUB1.shared_name"}], Parameter description:
   * 
   * *   projectId: the ID of the DataWorks workspace. If you configure the UserPermissions parameter, the specified user can view or use the data source only in the specified DataWorks workspace.
   * *   userId: the ID of the user to whom you want to share the data source.
   * *   permission: the mode in which the data source is shared. Valid values: READ and WRITE. The value READ indicates that the specified user can read data from the data source, but cannot modify the data. The value WRITE indicates that the specified user can modify the data in the data source.
   * *   sharedName: the name of the data source that you want to share.
   * 
   * If the ProjectPermissions and UserPermissions parameters are both left empty, the specified data source is not shared to any DataWorks workspace or user. If neither of the parameters is left empty, both parameters take effect.
   * 
   * @example
   * [{"projectId":10000,"users":[{"userId":"276184575345452131","permission":"WRITE"}],"sharedName":"PX_DATAHUB1.shared_name"}]
   */
  userPermissions?: string;
  static names(): { [key: string]: string } {
    return {
      datasourceName: 'DatasourceName',
      envType: 'EnvType',
      projectId: 'ProjectId',
      projectPermissions: 'ProjectPermissions',
      userPermissions: 'UserPermissions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasourceName: 'string',
      envType: 'string',
      projectId: 'number',
      projectPermissions: 'string',
      userPermissions: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDataSourceShareResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the sharing operation.
   */
  data?: SetDataSourceShareResponseBodyData;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: SetDataSourceShareResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDataSourceShareResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetDataSourceShareResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetDataSourceShareResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEntityTagsRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the entity. Example: maxcompute-table.projectA.tableA.
   * 
   * This parameter is required.
   * 
   * @example
   * maxcompute-table.projectA.tableA
   */
  qualifiedName?: string;
  /**
   * @remarks
   * The tags.
   */
  tags?: UserEntityTag[];
  static names(): { [key: string]: string } {
    return {
      qualifiedName: 'QualifiedName',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qualifiedName: 'string',
      tags: { 'type': 'array', 'itemType': UserEntityTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEntityTagsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the entity. Example: maxcompute-table.projectA.tableA.
   * 
   * This parameter is required.
   * 
   * @example
   * maxcompute-table.projectA.tableA
   */
  qualifiedName?: string;
  /**
   * @remarks
   * The tags.
   */
  tagsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      qualifiedName: 'QualifiedName',
      tagsShrink: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      qualifiedName: 'string',
      tagsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEntityTagsResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the call was successful. Valid values:
   * 
   * true and false.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 101011005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * Invalid.Entity.EntityTypeNotSupported
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * true and false.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetEntityTagsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetEntityTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetEntityTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetSuccessInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  instanceId?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetSuccessInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether result details are returned.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetSuccessInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SetSuccessInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetSuccessInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDIJobRequest extends $tea.Model {
  /**
   * @remarks
   * The task ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11743
   */
  DIJobId?: number;
  /**
   * @remarks
   * Specifies whether to forcefully rerun all synchronization steps. If you do not configure this parameter, the system does not forcefully rerun the task.
   * 
   * @example
   * true
   */
  forceToRerun?: boolean;
  /**
   * @remarks
   * The settings for the start.
   */
  realtimeStartSettings?: StartDIJobRequestRealtimeStartSettings;
  static names(): { [key: string]: string } {
    return {
      DIJobId: 'DIJobId',
      forceToRerun: 'ForceToRerun',
      realtimeStartSettings: 'RealtimeStartSettings',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobId: 'number',
      forceToRerun: 'boolean',
      realtimeStartSettings: StartDIJobRequestRealtimeStartSettings,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDIJobShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The task ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11743
   */
  DIJobId?: number;
  /**
   * @remarks
   * Specifies whether to forcefully rerun all synchronization steps. If you do not configure this parameter, the system does not forcefully rerun the task.
   * 
   * @example
   * true
   */
  forceToRerun?: boolean;
  /**
   * @remarks
   * The settings for the start.
   */
  realtimeStartSettingsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      DIJobId: 'DIJobId',
      forceToRerun: 'ForceToRerun',
      realtimeStartSettingsShrink: 'RealtimeStartSettings',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobId: 'number',
      forceToRerun: 'boolean',
      realtimeStartSettingsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDIJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 999431B2-6013-577F-B684-36F7433C753B
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDIJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartDIJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartDIJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDISyncInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * *   If you set TaskType to DI_REALTIME, set this parameter to the ID of the real-time synchronization task that you want to start.
   * *   If you set TaskType to DI_SOLUTION, set this parameter to the ID of the data synchronization solution that you want to start.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  fileId?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID. You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * *   If you set TaskType to DI_REALTIME, the StartParam parameter specifies the startup parameters for the real-time synchronization task. The startup parameters include failover-related parameters, the parameter that specifies the number of dirty data records allowed, and the parameters in the data definition language (DDL) statements.
   * *   If you set TaskType to DI_SOLUTION, the StartParam parameter does not take effect.
   * 
   * @example
   * {"failoverLimit":{"count":10,"interval":30},"errorLimit":{"record":0},"ddlMarkMap":{"RENAMECOLUMN":"WARNING","DROPTABLE":"WARNING","CREATETABLE":"IGNORE","MODIFYCOLUMN":"WARNING","TRUNCATETABLE":"NORMAL","DROPCOLUMN":"IGNORE","ADDCOLUMN":"NORMAL","RENAMETABLE":"CRITICAL"}}
   */
  startParam?: string;
  /**
   * @remarks
   * The type of the object that you want to start. Valid values:
   * 
   * *   DI_REALTIME: real-time synchronization task
   * *   DI_SOLUTION: data synchronization solution
   * 
   * This parameter is required.
   * 
   * @example
   * DI_REALTIME
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      projectId: 'ProjectId',
      startParam: 'StartParam',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      projectId: 'number',
      startParam: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDISyncInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The result returned for the start.
   */
  data?: StartDISyncInstanceResponseBodyData;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: StartDISyncInstanceResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDISyncInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartDISyncInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartDISyncInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartMigrationRequest extends $tea.Model {
  /**
   * @remarks
   * The migration package ID. You can call the [CreateImportMigration](https://help.aliyun.com/document_detail/206094.html) operation to query the ID of the import package and call the [CreateExportMigration](https://help.aliyun.com/document_detail/349325.html) operation to query the ID of the export package.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  migrationId?: number;
  /**
   * @remarks
   * The workspace ID. You can log on to the DataWorks console and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123456
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      migrationId: 'MigrationId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrationId: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartMigrationResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the migration task is started. Valid values:
   * 
   * *   true: The migration task is started.
   * *   false: The migration task fails to be started.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 110001123445
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * test error msg
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * FSDFSDF-WERWER-XVCX-DSFSDF
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartMigrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartMigrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartMigrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopDIJobRequest extends $tea.Model {
  /**
   * @remarks
   * The task ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 11668
   */
  DIJobId?: number;
  static names(): { [key: string]: string } {
    return {
      DIJobId: 'DIJobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopDIJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 92F778C7-8F00-53B1-AE1A-B3B17101247D
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopDIJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopDIJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopDIJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopDISyncInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the synchronization task. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  fileId?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
   * 
   * You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The type of the synchronization task that you want to stop. Set the value to DI_REALTIME.
   * 
   * DI_REALTIME indicates a real-time synchronization task.
   * 
   * This parameter is required.
   * 
   * @example
   * DI_REALTIME
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      projectId: 'ProjectId',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      projectId: 'number',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopDISyncInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information returned for the synchronization task.
   */
  data?: StopDISyncInstanceResponseBodyData;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: StopDISyncInstanceResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopDISyncInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopDISyncInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopDISyncInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The instance ID. You can call the [ListInstances](https://help.aliyun.com/document_detail/173982.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  instanceId?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The result returned.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StopInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitDataServiceApiRequest extends $tea.Model {
  /**
   * @remarks
   * The API ID. You can call the [ListDataServiceApis](~~ListDataServiceApis~~) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 12345
   */
  apiId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the DataWorks console. Find your workspace and go to the [DataService Studio](https://ds-cn-shanghai.data.aliyun.com/) page. On the DataService Studio page, click the logon username in the upper-right corner and click User Info in the Menu section.
   * 
   * @example
   * 10001
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitDataServiceApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the API was submitted.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitDataServiceApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SubmitDataServiceApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SubmitDataServiceApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFileRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the commit operation.
   */
  comment?: string;
  /**
   * @remarks
   * The file ID. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the file ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000000
   */
  fileId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console and go to the Workspace page to obtain the workspace ID. You must configure either this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace page to obtain the workspace name. You must configure either this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  /**
   * @remarks
   * Specifies whether to skip the pre-publish check after the file is committed. Valid values:
   * 
   * *   false: indicates that the pre-publish check is not skipped. After the file is committed, the pre-publish check is automatically triggered. The file can be deployed only after the file passes the check.
   * *   true: indicates that the pre-publish check is skipped. After the file is submitted, the pre-publish check process is not triggered. You can directly deploy the file.
   * 
   * @example
   * false
   */
  skipAllDeployFileExtensions?: boolean;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      fileId: 'FileId',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
      skipAllDeployFileExtensions: 'SkipAllDeployFileExtensions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      fileId: 'number',
      projectId: 'number',
      projectIdentifier: 'string',
      skipAllDeployFileExtensions: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The deployment package ID. The ID is used as the value of a specific request parameter when you call the [GetDeployment](https://help.aliyun.com/document_detail/173950.html) operation to query the details of the deployment operation.
   * 
   * @example
   * 3000001
   */
  data?: number;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SubmitFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SubmitFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The instance ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  instanceId?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV.
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      projectEnv: 'ProjectEnv',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      projectEnv: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The data returned.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ProjectNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 0baf87f0159376****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SuspendInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SuspendInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SuspendInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminateDISyncInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the real-time synchronization task.
   * 
   * This parameter is required.
   * 
   * @example
   * 100
   */
  fileId?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
   * 
   * You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The value DI_REALTIME indicates that the task is a real-time synchronization task.
   * 
   * This parameter is required.
   * 
   * @example
   * DI_REALTIME
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      projectId: 'ProjectId',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      projectId: 'number',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminateDISyncInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The returned results.
   */
  data?: TerminateDISyncInstanceResponseBodyData;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: TerminateDISyncInstanceResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminateDISyncInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TerminateDISyncInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TerminateDISyncInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestDataServiceApiRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the DataService Studio API on which the test is performed.
   * 
   * This parameter is required.
   * 
   * @example
   * 12343
   */
  apiId?: number;
  /**
   * @remarks
   * The data of the request body.
   * 
   * @example
   * {"name":"test"}
   */
  bodyContent?: string;
  /**
   * @remarks
   * The request parameters that are contained in the request body.
   */
  bodyParams?: TestDataServiceApiRequestBodyParams[];
  /**
   * @remarks
   * The request parameters that are contained in the request header.
   */
  headParams?: TestDataServiceApiRequestHeadParams[];
  /**
   * @remarks
   * The request parameters that are contained in the request path.
   */
  pathParams?: TestDataServiceApiRequestPathParams[];
  /**
   * @remarks
   * The request parameters that are contained in the query.
   */
  queryParam?: TestDataServiceApiRequestQueryParam[];
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      bodyContent: 'BodyContent',
      bodyParams: 'BodyParams',
      headParams: 'HeadParams',
      pathParams: 'PathParams',
      queryParam: 'QueryParam',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      bodyContent: 'string',
      bodyParams: { 'type': 'array', 'itemType': TestDataServiceApiRequestBodyParams },
      headParams: { 'type': 'array', 'itemType': TestDataServiceApiRequestHeadParams },
      pathParams: { 'type': 'array', 'itemType': TestDataServiceApiRequestPathParams },
      queryParam: { 'type': 'array', 'itemType': TestDataServiceApiRequestQueryParam },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestDataServiceApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the test.
   */
  data?: TestDataServiceApiResponseBodyData;
  /**
   * @remarks
   * The ID of the request.
   * 
   * @example
   * abdsfewe
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: TestDataServiceApiResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestDataServiceApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TestDataServiceApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TestDataServiceApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestNetworkConnectionRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the data source.
   * 
   * This parameter is required.
   * 
   * @example
   * mysql_name
   */
  datasourceName?: string;
  /**
   * @remarks
   * The environment in which the data source resides. Valid values:
   * 
   * *   0: development environment
   * *   1: production environment
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  envType?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace to which the data sources belong. You can call the [ListProjects](https://help.aliyun.com/document_detail/178393.html) operation to query the ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The identifier of the resource group. You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/173913.html) operation to query the identifier of the resource group.
   * 
   * This parameter is required.
   * 
   * @example
   * S_res_group_2XXXX4_1619100XXXXX
   */
  resourceGroup?: string;
  static names(): { [key: string]: string } {
    return {
      datasourceName: 'DatasourceName',
      envType: 'EnvType',
      projectId: 'ProjectId',
      resourceGroup: 'ResourceGroup',
    };
  }

  static types(): { [key: string]: any } {
    return {
      datasourceName: 'string',
      envType: 'string',
      projectId: 'number',
      resourceGroup: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestNetworkConnectionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * The information about the connectivity test.
   */
  taskList?: TestNetworkConnectionResponseBodyTaskList;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
      taskList: 'TaskList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
      taskList: TestNetworkConnectionResponseBodyTaskList,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestNetworkConnectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TestNetworkConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TestNetworkConnectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TopTenElapsedTimeInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 100000
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TopTenElapsedTimeInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ranking record of the running durations of the instances.
   */
  instanceConsumeTimeRank?: TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6347364dadsfadf****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceConsumeTimeRank: 'InstanceConsumeTimeRank',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceConsumeTimeRank: TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TopTenElapsedTimeInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TopTenElapsedTimeInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TopTenElapsedTimeInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TopTenErrorTimesInstanceRequest extends $tea.Model {
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 9527
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TopTenErrorTimesInstanceResponseBody extends $tea.Model {
  /**
   * @remarks
   * The ranking data of nodes on which errors occurred.
   */
  instanceErrorRank?: TopTenErrorTimesInstanceResponseBodyInstanceErrorRank;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 952795279527****
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceErrorRank: 'InstanceErrorRank',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceErrorRank: TopTenErrorTimesInstanceResponseBodyInstanceErrorRank,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TopTenErrorTimesInstanceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TopTenErrorTimesInstanceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TopTenErrorTimesInstanceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UmountDirectoryRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the directory that you want to remove from the left-side navigation pane of DataAnalysis. This parameter is used together with the TargetType parameter. For example, if you set the TargetType parameter to META_ALBUM, you must set the TargetId parameter to the ID of the metadata data album. You can call the [ListMetaCollections](https://help.aliyun.com/document_detail/469938.html) operation to obtain the ID of the data album. The ID is indicated by the QualifiedName parameter.
   * 
   * @example
   * album.339
   */
  targetId?: string;
  /**
   * @remarks
   * The type of the directory that you want to remove from the left-side navigation pane of DataAnalysis. Example: META_ALBUM, which indicates the metadata data album.
   * 
   * @example
   * META_ALBUM
   */
  targetType?: string;
  /**
   * @remarks
   * The ID of the user in the tenant.
   * 
   * *   If you do not configure TargetUserId, the directory belongs to you.
   * *   If you configure TargetUserId, the directory belongs to the user specified by using TargetUserId.
   * 
   * @example
   * 1234567890
   */
  targetUserId?: string;
  static names(): { [key: string]: string } {
    return {
      targetId: 'TargetId',
      targetType: 'TargetType',
      targetUserId: 'TargetUserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetId: 'string',
      targetType: 'string',
      targetUserId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UmountDirectoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * The number of directories that are removed. Valid values:
   * 
   * *   0: No directories are removed. The left-side navigation pane may not contain the specified directory.
   * *   1: One directory is removed.
   * 
   * @example
   * 1
   */
  data?: number;
  /**
   * @remarks
   * The error code. The value 200 indicates that the task is successful.
   * 
   * @example
   * 200
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code. The value 200 indicates that the request was successful.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0bc5aa2716455247597991794e65bd
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UmountDirectoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UmountDirectoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UmountDirectoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBaselineRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to enable the alerting feature. Valid values: true and false.
   * 
   * @example
   * true
   */
  alertEnabled?: boolean;
  /**
   * @remarks
   * The alert margin threshold of the baseline. Unit: minutes.
   * 
   * @example
   * 30
   */
  alertMarginThreshold?: number;
  /**
   * @remarks
   * The alert settings of the baseline.
   */
  alertSettings?: UpdateBaselineRequestAlertSettings[];
  /**
   * @remarks
   * The baseline ID. You can call the [ListBaselines](https://help.aliyun.com/document_detail/2261507.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000010800007
   */
  baselineId?: number;
  /**
   * @remarks
   * The name of the baseline.
   * 
   * @example
   * BaselineName
   */
  baselineName?: string;
  /**
   * @remarks
   * The type of the baseline. Valid values: DAILY and HOURLY.
   * 
   * @example
   * DAILY
   */
  baselineType?: string;
  /**
   * @remarks
   * Specifies whether to enable the baseline. Valid values: true and false.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * The ancestor nodes of nodes in the baseline. Separate the ancestor nodes with commas (,). If a large number of ancestor nodes exist, we recommend that you create a zero load node and configure the zero load node as the descendant node of nodes in the baseline to facilitate node management.
   * 
   * @example
   * 1,2,3
   */
  nodeIds?: string;
  /**
   * @remarks
   * The settings of the committed completion time of the baseline.
   */
  overtimeSettings?: UpdateBaselineRequestOvertimeSettings[];
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the baseline owner.
   * 
   * @example
   * 3726346****
   */
  owner?: string;
  /**
   * @remarks
   * The priority of the baseline. Valid values: {1,3,5,7,8}.
   * 
   * @example
   * 7
   */
  priority?: number;
  /**
   * @remarks
   * The workspace ID. You can call the [ListBaselines](https://help.aliyun.com/document_detail/2261507.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 2043
   */
  projectId?: number;
  /**
   * @remarks
   * The ID of the node that you want to disassociate from the baseline. You can specify multiple node IDs. Separate multiple node IDs with commas (,).
   * 
   * @example
   * 123,456
   */
  removeNodeIds?: string;
  static names(): { [key: string]: string } {
    return {
      alertEnabled: 'AlertEnabled',
      alertMarginThreshold: 'AlertMarginThreshold',
      alertSettings: 'AlertSettings',
      baselineId: 'BaselineId',
      baselineName: 'BaselineName',
      baselineType: 'BaselineType',
      enabled: 'Enabled',
      nodeIds: 'NodeIds',
      overtimeSettings: 'OvertimeSettings',
      owner: 'Owner',
      priority: 'Priority',
      projectId: 'ProjectId',
      removeNodeIds: 'RemoveNodeIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertEnabled: 'boolean',
      alertMarginThreshold: 'number',
      alertSettings: { 'type': 'array', 'itemType': UpdateBaselineRequestAlertSettings },
      baselineId: 'number',
      baselineName: 'string',
      baselineType: 'string',
      enabled: 'boolean',
      nodeIds: 'string',
      overtimeSettings: { 'type': 'array', 'itemType': UpdateBaselineRequestOvertimeSettings },
      owner: 'string',
      priority: 'number',
      projectId: 'number',
      removeNodeIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBaselineShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to enable the alerting feature. Valid values: true and false.
   * 
   * @example
   * true
   */
  alertEnabled?: boolean;
  /**
   * @remarks
   * The alert margin threshold of the baseline. Unit: minutes.
   * 
   * @example
   * 30
   */
  alertMarginThreshold?: number;
  /**
   * @remarks
   * The alert settings of the baseline.
   */
  alertSettingsShrink?: string;
  /**
   * @remarks
   * The baseline ID. You can call the [ListBaselines](https://help.aliyun.com/document_detail/2261507.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000010800007
   */
  baselineId?: number;
  /**
   * @remarks
   * The name of the baseline.
   * 
   * @example
   * BaselineName
   */
  baselineName?: string;
  /**
   * @remarks
   * The type of the baseline. Valid values: DAILY and HOURLY.
   * 
   * @example
   * DAILY
   */
  baselineType?: string;
  /**
   * @remarks
   * Specifies whether to enable the baseline. Valid values: true and false.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * The ancestor nodes of nodes in the baseline. Separate the ancestor nodes with commas (,). If a large number of ancestor nodes exist, we recommend that you create a zero load node and configure the zero load node as the descendant node of nodes in the baseline to facilitate node management.
   * 
   * @example
   * 1,2,3
   */
  nodeIds?: string;
  /**
   * @remarks
   * The settings of the committed completion time of the baseline.
   */
  overtimeSettingsShrink?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the baseline owner.
   * 
   * @example
   * 3726346****
   */
  owner?: string;
  /**
   * @remarks
   * The priority of the baseline. Valid values: {1,3,5,7,8}.
   * 
   * @example
   * 7
   */
  priority?: number;
  /**
   * @remarks
   * The workspace ID. You can call the [ListBaselines](https://help.aliyun.com/document_detail/2261507.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 2043
   */
  projectId?: number;
  /**
   * @remarks
   * The ID of the node that you want to disassociate from the baseline. You can specify multiple node IDs. Separate multiple node IDs with commas (,).
   * 
   * @example
   * 123,456
   */
  removeNodeIds?: string;
  static names(): { [key: string]: string } {
    return {
      alertEnabled: 'AlertEnabled',
      alertMarginThreshold: 'AlertMarginThreshold',
      alertSettingsShrink: 'AlertSettings',
      baselineId: 'BaselineId',
      baselineName: 'BaselineName',
      baselineType: 'BaselineType',
      enabled: 'Enabled',
      nodeIds: 'NodeIds',
      overtimeSettingsShrink: 'OvertimeSettings',
      owner: 'Owner',
      priority: 'Priority',
      projectId: 'ProjectId',
      removeNodeIds: 'RemoveNodeIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertEnabled: 'boolean',
      alertMarginThreshold: 'number',
      alertSettingsShrink: 'string',
      baselineId: 'number',
      baselineName: 'string',
      baselineType: 'string',
      enabled: 'boolean',
      nodeIds: 'string',
      overtimeSettingsShrink: 'string',
      owner: 'string',
      priority: 'number',
      projectId: 'number',
      removeNodeIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBaselineResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the baseline was updated.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 6E07E90B-D9BC-5D6B-896A-82BA41A34AE1
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBaselineResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateBaselineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateBaselineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBusinessRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the workflow. You can call the [ListBusiness](https://help.aliyun.com/document_detail/173945.html) operation to obtain the workflow ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 300000
   */
  businessId?: number;
  /**
   * @remarks
   * The name of the workflow. You can call the [ListBusiness](https://help.aliyun.com/document_detail/173945.html) operation to obtain the workflow name.
   * 
   * @example
   * MyBusiness
   */
  businessName?: string;
  /**
   * @remarks
   * The description of the workflow.
   * 
   * @example
   * modified from my first business
   */
  description?: string;
  /**
   * @remarks
   * The owner of the workflow. You can call the [ListBusiness](https://help.aliyun.com/document_detail/173945.html) operation to obtain the workflow owner.
   * 
   * @example
   * 348428****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace ID. You must configure either this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace name. You must configure either this parameter or ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      businessId: 'BusinessId',
      businessName: 'BusinessName',
      description: 'Description',
      owner: 'Owner',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessId: 'number',
      businessName: 'string',
      description: 'string',
      owner: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBusinessResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBusinessResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateBusinessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateBusinessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateClusterConfigsRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  clusterId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * SPARK_CONF
   */
  configType?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  configValues?: ClusterConfig[];
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5678
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      configType: 'ConfigType',
      configValues: 'ConfigValues',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'number',
      configType: 'string',
      configValues: { 'type': 'array', 'itemType': ClusterConfig },
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateClusterConfigsShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  clusterId?: number;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * SPARK_CONF
   */
  configType?: string;
  /**
   * @remarks
   * This parameter is required.
   */
  configValuesShrink?: string;
  /**
   * @remarks
   * This parameter is required.
   * 
   * @example
   * 5678
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      configType: 'ConfigType',
      configValuesShrink: 'ConfigValues',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'number',
      configType: 'string',
      configValuesShrink: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateClusterConfigsResponseBody extends $tea.Model {
  /**
   * @example
   * true
   */
  data?: boolean;
  /**
   * @example
   * 101011005
   */
  errorCode?: string;
  /**
   * @example
   * Invalid.Cluster.ClusterNotFound
   */
  errorMessage?: string;
  /**
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateClusterConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateClusterConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateClusterConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConnectionRequest extends $tea.Model {
  /**
   * @remarks
   * The data source ID. You can call the [ListConnections](https://help.aliyun.com/document_detail/173911.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  connectionId?: number;
  /**
   * @remarks
   * The details of the data source. Examples of details of some common data sources:
   * 
   * *   odps
   * 
   * <!---->
   * 
   *     {
   *       "accessId": "xssssss",
   *       "accessKey": "xsaxsaxsa",
   *       "authType": 2,
   *       "endpoint": "http://service.odps.aliyun.com/api",
   *       "project": "xsaxsax",
   *       "tag": "public"
   *     }
   * 
   * *   mysql
   * 
   * <!---->
   * 
   *     {
   *       "database": "xsaxsa",
   *       "instanceName": "rm-xsaxsa",
   *       "password": "xsaxsa",
   *       "rdsOwnerId": "xasxsa",
   *       "regionId": "cn-shanghai",
   *       "tag": "rds",
   *       "username": "xsaxsa"
   *     }
   * 
   * *   rds
   * 
   * <!---->
   * 
   *     {
   *       "configType": 1,
   *       "tag": "rds",
   *       "database": "xsaxsa",
   *       "username": "xsaxsa",
   *       "password": "xssaxsa$32050",
   *       "instanceName": "rm-xsaxs",
   *       "rdsOwnerId": "11111111"
   *     }
   * 
   * *   oss
   * 
   * <!---->
   * 
   *     {
   *       "accessId": "sssssxx",
   *       "accessKey": "xsaxaxsaxs",
   *       "bucket": "xsa-xs-xs",
   *       "endpoint": "http://oss-cn-shanghai.aliyuncs.com",
   *       "tag": "public"
   *     }
   * 
   * *   sqlserver
   * 
   * <!---->
   * 
   *     {
   *       "jdbcUrl": "jdbc:sqlserver://xsaxsa-xsaxsa.database.xxx.cn:123;DatabaseName=xsxs-xsxs",
   *       "password": "sdasda$fs",
   *       "tag": "public",
   *       "username": "sxaxacdacdd"
   *     }
   * 
   * *   polardb
   * 
   * <!---->
   * 
   *     {
   *       "clusterId": "pc-sdadsadsa",
   *       "database": "dsadsadsa",
   *       "ownerId": "121212122",
   *       "password": "sdasdafssa",
   *       "region": "cn-shanghai",
   *       "tag": "polardb",
   *       "username": "asdadsads"
   *     }
   * 
   * *   oracle
   * 
   * <!---->
   * 
   *     {
   *       "jdbcUrl": "jdbc:oracle:saaa:@xxxxx:1521:PROD",
   *       "password": "sxasaxsa",
   *       "tag": "public",
   *       "username": "sasfadfa"
   *     }
   * 
   * *   mongodb
   * 
   * <!---->
   * 
   *     {
   *       "address": "[\\"xsaxxsa.mongodb.rds.aliyuncs.com:3717\\"]",
   *       "database": "admin",
   *       "password": "sadsda@",
   *       "tag": "public",
   *       "username": "dsadsadas"
   *     }
   * 
   * *   emr
   * 
   * <!---->
   * 
   *     {
   *       "accessId": "xsaxsa",
   *       "emrClusterId": "C-dsads",
   *       "emrResourceQueueName": "default",
   *       "emrEndpoint": "emr.aliyuncs.com",
   *       "accessKey": "dsadsad",
   *       "emrUserId": "224833315798889783",
   *       "name": "sasdsadsa",
   *       "emrAccessMode": "simple",
   *       "region": "cn-shanghai",
   *       "authType": "2",
   *       "emrProjectId": "FP-sdadsad"
   *     }
   * 
   * *   postgresql
   * 
   * <!---->
   * 
   *     {
   *       "jdbcUrl": "jdbc:postgresql://xxxx:1921/ssss",
   *       "password": "sdadsads",
   *       "tag": "public",
   *       "username": "sdsasda"
   *     }
   * 
   * *   analyticdb_for_mysql
   * 
   * <!---->
   * 
   *     {
   *       "instanceId": "am-sadsada",
   *       "database": "xsxsx",
   *       "username": "xsxsa",
   *       "password": "asdadsa",
   *       "connectionString": "am-xssxsxs.ads.aliyuncs.com:3306"
   *     }
   * 
   * *   hybriddb_for_postgresql
   * 
   * <!---->
   * 
   *     {
   *       "connectionString": "gp-xsaxsaxa-master.gpdbmaster.rds.aliyuncs.com",
   *       "database": "xsaxsaxas",
   *       "password": "xsaxsaxsa@11",
   *       "instanceId": "gp-xsaxsaxsa",
   *       "port": "541132",
   *       "ownerId": "xsaxsaxsas",
   *       "username": "sadsad"
   *     }
   * 
   * *   holo
   * 
   * <!---->
   * 
   *     {
   *       "accessId": "xsaxsaxs",
   *       "accessKey": "xsaxsaxsa",
   *       "database": "xsaxsaxsa",
   *       "instanceId": "xsaxa",
   *       "tag": "aliyun"
   *     }
   * 
   * *   kafka
   * 
   * <!---->
   * 
   *     {
   *       "instanceId": "xsax-cn-xsaxsa",
   *       "regionId": "cn-shanghai",
   *       "tag": "aliyun",
   *       "ownerId": "1212121212112"
   *     }
   * 
   * @example
   * {"database":"dbname","instanceName":"instancename","password":"password","rdsOwnerId":"123","username":"username"}
   */
  content?: string;
  /**
   * @remarks
   * The description of the data source.
   * 
   * @example
   * abc
   */
  description?: string;
  /**
   * @remarks
   * The environment in which the data source is used. Valid values: 0 and 1. The value 0 indicates the development environment. The value 1 indicates the production environment.
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The status of the data source. Valid values: ENABLED and DISABLED. The value ENABLED indicates that the data source is in the normal state. The value DISABLED indicates that the data source is in an abnormal state.
   * 
   * @example
   * ENABLED
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      connectionId: 'ConnectionId',
      content: 'Content',
      description: 'Description',
      envType: 'EnvType',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionId: 'number',
      content: 'string',
      description: 'string',
      envType: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConnectionResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the data source is updated.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc14115159376359****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      httpStatusCode: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateConnectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateConnectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateConnectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIAlarmRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The alert rule ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 34982
   */
  DIAlarmRuleId?: number;
  /**
   * @remarks
   * The description of the alert rule.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to enable the alert rule. By default, the alert rule is disabled.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * The metric type in the alert rule. Valid values:
   * 
   * *   Heartbeat
   * *   FailoverCount
   * *   Delay
   * 
   * This parameter is required.
   * 
   * @example
   * Heartbeat
   */
  metricType?: string;
  /**
   * @remarks
   * The alert notification settings.
   * 
   * This parameter is required.
   */
  notificationSettings?: UpdateDIAlarmRuleRequestNotificationSettings;
  /**
   * @remarks
   * The conditions that can trigger the alert rule.
   * 
   * This parameter is required.
   */
  triggerConditions?: UpdateDIAlarmRuleRequestTriggerConditions[];
  static names(): { [key: string]: string } {
    return {
      DIAlarmRuleId: 'DIAlarmRuleId',
      description: 'Description',
      enabled: 'Enabled',
      metricType: 'MetricType',
      notificationSettings: 'NotificationSettings',
      triggerConditions: 'TriggerConditions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIAlarmRuleId: 'number',
      description: 'string',
      enabled: 'boolean',
      metricType: 'string',
      notificationSettings: UpdateDIAlarmRuleRequestNotificationSettings,
      triggerConditions: { 'type': 'array', 'itemType': UpdateDIAlarmRuleRequestTriggerConditions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIAlarmRuleShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The alert rule ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 34982
   */
  DIAlarmRuleId?: number;
  /**
   * @remarks
   * The description of the alert rule.
   */
  description?: string;
  /**
   * @remarks
   * Specifies whether to enable the alert rule. By default, the alert rule is disabled.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * The metric type in the alert rule. Valid values:
   * 
   * *   Heartbeat
   * *   FailoverCount
   * *   Delay
   * 
   * This parameter is required.
   * 
   * @example
   * Heartbeat
   */
  metricType?: string;
  /**
   * @remarks
   * The alert notification settings.
   * 
   * This parameter is required.
   */
  notificationSettingsShrink?: string;
  /**
   * @remarks
   * The conditions that can trigger the alert rule.
   * 
   * This parameter is required.
   */
  triggerConditionsShrink?: string;
  static names(): { [key: string]: string } {
    return {
      DIAlarmRuleId: 'DIAlarmRuleId',
      description: 'Description',
      enabled: 'Enabled',
      metricType: 'MetricType',
      notificationSettingsShrink: 'NotificationSettings',
      triggerConditionsShrink: 'TriggerConditions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIAlarmRuleId: 'number',
      description: 'string',
      enabled: 'boolean',
      metricType: 'string',
      notificationSettingsShrink: 'string',
      triggerConditionsShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIAlarmRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * A6C6B486-E3A2-5D52-9E76-D9380485D946
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIAlarmRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDIAlarmRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDIAlarmRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the synchronization task.
   * 
   * @example
   * 11588
   */
  DIJobId?: number;
  /**
   * @remarks
   * The description of the synchronization task.
   */
  description?: string;
  /**
   * @remarks
   * The settings for the dimension of the synchronization task. The settings include processing policies for DDL messages, policies for data type mappings between source fields and destination fields, and runtime parameters of the synchronization task.
   */
  jobSettings?: UpdateDIJobRequestJobSettings;
  /**
   * @remarks
   * The resource settings.
   */
  resourceSettings?: UpdateDIJobRequestResourceSettings;
  /**
   * @remarks
   * The list of mappings between rules used to select synchronization objects in the source and transformation rules applied to the selected synchronization objects. Each entry in the list displays a mapping between a rule used to select synchronization objects and a transformation rule applied to the selected synchronization objects.
   */
  tableMappings?: UpdateDIJobRequestTableMappings[];
  /**
   * @remarks
   * The list of transformation rules for objects involved in the synchronization task. Each entry in the list defines a transformation rule.
   */
  transformationRules?: UpdateDIJobRequestTransformationRules[];
  static names(): { [key: string]: string } {
    return {
      DIJobId: 'DIJobId',
      description: 'Description',
      jobSettings: 'JobSettings',
      resourceSettings: 'ResourceSettings',
      tableMappings: 'TableMappings',
      transformationRules: 'TransformationRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobId: 'number',
      description: 'string',
      jobSettings: UpdateDIJobRequestJobSettings,
      resourceSettings: UpdateDIJobRequestResourceSettings,
      tableMappings: { 'type': 'array', 'itemType': UpdateDIJobRequestTableMappings },
      transformationRules: { 'type': 'array', 'itemType': UpdateDIJobRequestTransformationRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobShrinkRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the synchronization task.
   * 
   * @example
   * 11588
   */
  DIJobId?: number;
  /**
   * @remarks
   * The description of the synchronization task.
   */
  description?: string;
  /**
   * @remarks
   * The settings for the dimension of the synchronization task. The settings include processing policies for DDL messages, policies for data type mappings between source fields and destination fields, and runtime parameters of the synchronization task.
   */
  jobSettingsShrink?: string;
  /**
   * @remarks
   * The resource settings.
   */
  resourceSettingsShrink?: string;
  /**
   * @remarks
   * The list of mappings between rules used to select synchronization objects in the source and transformation rules applied to the selected synchronization objects. Each entry in the list displays a mapping between a rule used to select synchronization objects and a transformation rule applied to the selected synchronization objects.
   */
  tableMappingsShrink?: string;
  /**
   * @remarks
   * The list of transformation rules for objects involved in the synchronization task. Each entry in the list defines a transformation rule.
   */
  transformationRulesShrink?: string;
  static names(): { [key: string]: string } {
    return {
      DIJobId: 'DIJobId',
      description: 'Description',
      jobSettingsShrink: 'JobSettings',
      resourceSettingsShrink: 'ResourceSettings',
      tableMappingsShrink: 'TableMappings',
      transformationRulesShrink: 'TransformationRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobId: 'number',
      description: 'string',
      jobSettingsShrink: 'string',
      resourceSettingsShrink: 'string',
      tableMappingsShrink: 'string',
      transformationRulesShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * AAC30B35-820D-5F3E-A42C-E96BB6379325
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDIJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDIJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIProjectConfigRequest extends $tea.Model {
  /**
   * @remarks
   * The type of the destinations of the synchronization solutions. This parameter cannot be left empty. Valid values: analyticdb_for_mysql, odps, elasticsearch, holo, mysql, and polardb.
   * 
   * This parameter is required.
   * 
   * @example
   * odps
   */
  destinationType?: string;
  /**
   * @remarks
   * The new default global configuration of the synchronization solutions. The value indicates the processing rules of different types of DDL messages. The value must be in the JSON format. Example: {"RENAMECOLUMN":"WARNING","DROPTABLE":"WARNING","CREATETABLE":"WARNING","MODIFYCOLUMN":"WARNING","TRUNCATETABLE":"WARNING","DROPCOLUMN":"WARNING","ADDCOLUMN":"WARNING","RENAMETABLE":"WARNING"}.
   * 
   * Field description:
   * 
   * *   RENAMECOLUMN: renames a column.
   * *   DROPTABLE: deletes a table.
   * *   CREATETABLE: creates a table.
   * *   MODIFYCOLUMN: changes the data type of a column.
   * *   TRUNCATETABLE: clears a table.
   * *   DROPCOLUMN: deletes a column.
   * *   ADDCOLUMN: creates a column.
   * *   RENAMETABLE: renames a table.
   * 
   * DataWorks processes a DDL message of a specific type based on the following rules:
   * 
   * *   WARNING: ignores the message and records an alert in real-time synchronization logs. The alert contains information about the situation that the message is ignored because of an execution error.
   * *   IGNORE: discards the message and does not send it to the destination.
   * *   CRITICAL: terminates the real-time synchronization task and sets the node status to Failed.
   * *   NORMAL: sends the message to the destination to process the message. Each destination processes DDL messages based on its own business logic. If DataWorks adopts the NORMAL policy, DataWorks only forwards DDL messages.
   * 
   * This parameter is required.
   * 
   * @example
   * {"RENAMECOLUMN":"WARNING","DROPTABLE":"WARNING","CREATETABLE":"WARNING","MODIFYCOLUMN":"WARNING","TRUNCATETABLE":"WARNING","DROPCOLUMN":"WARNING","ADDCOLUMN":"WARNING","RENAMETABLE":"WARNING"}
   */
  projectConfig?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The type of the sources of the synchronization solutions. Valid values: oracle, mysql, polardb, datahub, drds, and analyticdb_for_mysql. If you do not configure this parameter, DataWorks applies the default global configuration to all sources.
   * 
   * @example
   * mysql
   */
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      destinationType: 'DestinationType',
      projectConfig: 'ProjectConfig',
      projectId: 'ProjectId',
      sourceType: 'SourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationType: 'string',
      projectConfig: 'string',
      projectId: 'number',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIProjectConfigResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information about the modification.
   */
  data?: UpdateDIProjectConfigResponseBodyData;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0000-ABCD-EFG
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: UpdateDIProjectConfigResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIProjectConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDIProjectConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDIProjectConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDISyncTaskRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the data synchronization task. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1000000
   */
  fileId?: number;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the workspace ID. You must configure this parameter to specify the DataWorks workspace to which the API operation is applied.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The updated configurations of the data synchronization task. Calling this API operation to update a data synchronization task is equivalent to updating a data synchronization task by using the code editor in the DataWorks console. For more information, see [Create a synchronization task by using the code editor](https://help.aliyun.com/document_detail/137717.html). You can call the UpdateDISyncTask operation to update only batch synchronization tasks. If you do not need to update the configurations of the data synchronization task, leave this parameter empty.
   * 
   * @example
   * {"type":"job","version":"2.0","steps":[{"stepType":"mysql","parameter":{"envType":1,"datasource":"mysql_pub","column":["id","name","create_time","age","score","t_01"],"connection":[{"datasource":"mysql_pub","table":["u_pk"]}],"where":"","splitPk":"id","encoding":"UTF-8"},"name":"Reader","category":"reader"},{"stepType":"odps","parameter":{"partition":"pt=${bizdate}","truncate":true,"datasource":"odps_first","envType":1,"column":["id","name","create_time","age","score","t_01"],"emptyAsNull":false,"tableComment":"null","table":"u_pk"},"name":"Writer","category":"writer"}],"setting":{"executeMode":null,"errorLimit":{"record":""},"speed":{"concurrent":2,"throttle":false}},"order":{"hops":[{"from":"Reader","to":"Writer"}]}}
   */
  taskContent?: string;
  /**
   * @remarks
   * The setting based on which the resource group used by the data synchronization task is updated. You must configure this parameter in the JSON format.
   * 
   * Only the ResourceGroup field is supported. This field specifies the identifier of the resource group for Data Integration that is used by the data synchronization task. You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/173913.html) operation to query the identifier of the resource group. If you do not need to update the resource group for the data synchronization task, leave this parameter empty.
   * 
   * @example
   * {"ResourceGroup":"S_res_group_XXX_XXXX"}
   */
  taskParam?: string;
  /**
   * @remarks
   * The type of the data synchronization task. Set the value to DI_OFFLINE. You can call the UpdateDISyncTask operation to update only batch synchronization tasks.
   * 
   * This parameter is required.
   * 
   * @example
   * DI_OFFLINE
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      projectId: 'ProjectId',
      taskContent: 'TaskContent',
      taskParam: 'TaskParam',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      projectId: 'number',
      taskContent: 'string',
      taskParam: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDISyncTaskResponseBody extends $tea.Model {
  /**
   * @remarks
   * The information that indicates whether the data synchronization task is updated.
   */
  data?: UpdateDISyncTaskResponseBodyData;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0bc1411515937635973****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: UpdateDISyncTaskResponseBodyData,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDISyncTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDISyncTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDISyncTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDataServiceApiRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * API description
   */
  apiDescription?: string;
  /**
   * @remarks
   * The ID of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  apiId?: number;
  /**
   * @remarks
   * The path of the API.
   * 
   * This parameter is required.
   * 
   * @example
   * /test/2
   */
  apiPath?: string;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The protocol used by the API. Valid values: 0 and 1. The value 0 indicates HTTP. The value 1 indicates HTTPS. You can specify multiple protocols. Separate multiple protocols with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * 0,1
   */
  protocols?: string;
  /**
   * @remarks
   * The details of the API generated by registration. For more information, see the RegistrationDetails parameter returned by the [GetDataServiceApi](https://help.aliyun.com/document_detail/174013.html) operation.
   * 
   * @example
   * {"failedResultSample":"fail","registrationErrorCodes":[{"errorCode":"e1","errorMessage":"msg1","errorSolution":"sol1"},{"errorCode":"e2","errorMessage":"msg2","errorSolution":"sol2"}],"registrationRequestParameters":[{"columnName":"","defaultValue":"","exampleValue":"","isRequiredParameter":true,"parameterDataType":0,"parameterDescription":"","parameterName":"id","parameterOperator":0,"parameterPosition":1},{"columnName":"","defaultValue":"xx","exampleValue":"","isRequiredParameter":true,"parameterDataType":0,"parameterDescription":"","parameterName":"cc","parameterOperator":2,"parameterPosition":2}],"serviceContentType":1,"serviceHost":"http://www.baidu.com","servicePath":"/[uid]","serviceRequestBodyDescription":"body","successfulResultSample":"success"}
   */
  registrationDetails?: string;
  /**
   * @remarks
   * The request method of the API. Valid values: 0, 1, 2, and 3. The value 0 indicates the GET method. The value 1 indicates the POST method. The value 2 indicates the PUT method. The value 3 indicates the DELETE method. APIs generated in wizard or script mode support the GET and POST methods. APIs generated by registration support the GET, POST, PUT, and DELETE methods.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  requestMethod?: number;
  /**
   * @remarks
   * The ID of the exclusive resource group.
   * 
   * @example
   * 3242432423
   */
  resourceGroupId?: number;
  /**
   * @remarks
   * The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  responseContentType?: number;
  /**
   * @remarks
   * The details of the API generated in script mode. For more information, see the ScriptDetails parameter returned by the [GetDataServiceApi](https://help.aliyun.com/document_detail/174013.html) operation.
   * 
   * @example
   * {"isPagedResponse":false,"script":"select id as id1, name as name1 from person where id=${inputid}","scriptConnection":{"connectionId":122786,"tableName":"person"},"scriptRequestParameters":[{"defaultValue":"","exampleValue":"","isRequiredParameter":true,"parameterDataType":0,"parameterDescription":"","parameterName":"inputid","parameterOperator":0,"parameterPosition":1}],"scriptResponseParameters":[{"exampleValue":"","parameterDataType":0,"parameterDescription":"","parameterName":"id1"},{"exampleValue":"","parameterDataType":0,"parameterDescription":"","parameterName":"name1"}]}
   */
  scriptDetails?: string;
  /**
   * @remarks
   * The tenant ID. To obtain the tenant ID, perform the following steps: Log on to the [DataWorks console](https://workbench.data.aliyun.com/console). Find your workspace and go to the DataStudio page. On the DataStudio page, click the username for the logon in the upper-right corner and click User Info in the Menu section.
   * 
   * @example
   * 10001
   */
  tenantId?: number;
  /**
   * @remarks
   * The timeout period of the API request. Unit: milliseconds. Valid values: (0,30000].
   * 
   * This parameter is required.
   * 
   * @example
   * 10000
   */
  timeout?: number;
  /**
   * @remarks
   * The scope in which the API is visible. Valid values: 0 and 1. The value 0 indicates that the API is visible within the workspace. The value 1 indicates that the API is visible only to its owner.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  visibleRange?: number;
  /**
   * @remarks
   * The details of the API generated in wizard mode. For more information, see the WizardDetails parameter returned by the [GetDataServiceApi](https://help.aliyun.com/document_detail/174013.html) operation.
   * 
   * @example
   * {"isPagedResponse":true,"wizardConnection":{"connectionId":122786,"tableName":"person"},"wizardRequestParameters":[{"columnName":"id","defaultValue":"","exampleValue":"1","isRequiredParameter":true,"parameterDataType":2,"parameterDescription":"","parameterName":"id","parameterOperator":0,"parameterPosition":0}],"wizardResponseParameters":[{"columnName":"id","exampleValue":"11","parameterDataType":2,"parameterDescription":"","parameterName":"id"}]}
   */
  wizardDetails?: string;
  static names(): { [key: string]: string } {
    return {
      apiDescription: 'ApiDescription',
      apiId: 'ApiId',
      apiPath: 'ApiPath',
      projectId: 'ProjectId',
      protocols: 'Protocols',
      registrationDetails: 'RegistrationDetails',
      requestMethod: 'RequestMethod',
      resourceGroupId: 'ResourceGroupId',
      responseContentType: 'ResponseContentType',
      scriptDetails: 'ScriptDetails',
      tenantId: 'TenantId',
      timeout: 'Timeout',
      visibleRange: 'VisibleRange',
      wizardDetails: 'WizardDetails',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiDescription: 'string',
      apiId: 'number',
      apiPath: 'string',
      projectId: 'number',
      protocols: 'string',
      registrationDetails: 'string',
      requestMethod: 'number',
      resourceGroupId: 'number',
      responseContentType: 'number',
      scriptDetails: 'string',
      tenantId: 'number',
      timeout: 'number',
      visibleRange: 'number',
      wizardDetails: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDataServiceApiResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the information about the API was updated.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDataServiceApiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDataServiceApiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDataServiceApiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDataSourceRequest extends $tea.Model {
  /**
   * @remarks
   * The details about the data source. You are not allowed to change the type of the data source. For example, you are not allowed to change the data source type from MaxCompute to MySQL. Examples of details of some common data sources:
   * 
   * *   odps
   * 
   *         {
   *           "accessId": "xssssss",
   *           "accessKey": "xsaxsaxsa",
   *           "authType": 2,
   *           "endpoint": "http://service.odps.aliyun.com/api",
   *           "project": "xsaxsax",
   *           "tag": "public"
   *         }
   * 
   * *   mysql
   * 
   *         {
   *           "database": "xsaxsa",
   *           "instanceName": "rm-xsaxsa",
   *           "password": "xsaxsa",
   *           "rdsOwnerId": "xasxsa",
   *           "regionId": "cn-shanghai",
   *           "tag": "rds",
   *           "username": "xsaxsa"
   *         }
   * 
   * *   rds
   * 
   *         {
   *           "configType": 1,
   *           "tag": "rds",
   *           "database": "xsaxsa",
   *           "username": "xsaxsa",
   *           "password": "xssaxsa$32050",
   *           "instanceName": "rm-xsaxs",
   *           "rdsOwnerId": "11111111"
   *         }
   * 
   * *   oss
   * 
   *         {
   *           "accessId": "sssssxx",
   *           "accessKey": "xsaxaxsaxs",
   *           "bucket": "xsa-xs-xs",
   *           "endpoint": "http://oss-cn-shanghai.aliyuncs.com",
   *           "tag": "public"
   *         }
   * 
   * *   sqlserver
   * 
   *         {
   *           "jdbcUrl": "jdbc:sqlserver://xsaxsa-xsaxsa.database.xxx.cn:123;DatabaseName=xsxs-xsxs",
   *           "password": "sdasda$fs",
   *           "tag": "public",
   *           "username": "sxaxacdacdd"
   *         }
   * 
   * *   polardb
   * 
   *         {
   *           "clusterId": "pc-sdadsadsa",
   *           "database": "dsadsadsa",
   *           "ownerId": "121212122",
   *           "password": "sdasdafssa",
   *           "region": "cn-shanghai",
   *           "tag": "polardb",
   *           "username": "asdadsads"
   *         }
   * 
   * *   oracle
   * 
   *         {
   *           "jdbcUrl": "jdbc:oracle:saaa:@xxxxx:1521:PROD",
   *           "password": "sxasaxsa",
   *           "tag": "public",
   *           "username": "sasfadfa"
   *         }
   * 
   * *   mongodb
   * 
   *         {
   *           "address": "[\\"xsaxxsa.mongodb.rds.aliyuncs.com:3717\\"]",
   *           "database": "admin",
   *           "password": "sadsda@",
   *           "tag": "public",
   *           "username": "dsadsadas"
   *         }
   * 
   * *   emr
   * 
   *         {
   *           "accessId": "xsaxsa",
   *           "emrClusterId": "C-dsads",
   *           "emrResourceQueueName": "default",
   *           "emrEndpoint": "emr.aliyuncs.com",
   *           "accessKey": "dsadsad",
   *           "emrUserId": "224833315798889783",
   *           "name": "sasdsadsa",
   *           "emrAccessMode": "simple",
   *           "region": "cn-shanghai",
   *           "authType": "2",
   *           "emrProjectId": "FP-sdadsad"
   *         }
   * 
   * *   postgresql
   * 
   *         {
   *           "jdbcUrl": "jdbc:postgresql://xxxx:1921/ssss",
   *           "password": "sdadsads",
   *           "tag": "public",
   *           "username": "sdsasda"
   *         }
   * 
   * *   analyticdb_for_mysql
   * 
   *         {
   *           "instanceId": "am-sadsada",
   *           "database": "xsxsx",
   *           "username": "xsxsa",
   *           "password": "asdadsa",
   *           "connectionString": "am-xssxsxs.ads.aliyuncs.com:3306"
   *         }
   * 
   * *   hybriddb_for_postgresql
   * 
   *         {
   *           "connectionString": "gp-xsaxsaxa-master.gpdbmaster.rds.aliyuncs.com",
   *           "database": "xsaxsaxas",
   *           "password": "xsaxsaxsa@11",
   *           "instanceId": "gp-xsaxsaxsa",
   *           "port": "541132",
   *           "ownerId": "xsaxsaxsas",
   *           "username": "sadsad"
   *         }
   * 
   * *   holo
   * 
   *         {
   *           "accessId": "xsaxsaxs",
   *           "accessKey": "xsaxsaxsa",
   *           "database": "xsaxsaxsa",
   *           "instanceId": "xsaxa",
   *           "tag": "aliyun"
   *         }
   * 
   * *   kafka
   * 
   *         {
   *           "instanceId": "xsax-cn-xsaxsa",
   *           "regionId": "cn-shanghai",
   *           "tag": "aliyun",
   *           "ownerId": "1212121212112"
   *         }
   * 
   * @example
   * {"accessId":"xssssss","accessKey":"xsaxsaxsa","authType":2,"endpoint":"http://service.odps.aliyun.com/api","project":"xsaxsax","tag":"public"}
   */
  content?: string;
  /**
   * @remarks
   * The ID of the data source. You can call the [ListDataSources](https://help.aliyun.com/document_detail/2780072.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  dataSourceId?: number;
  /**
   * @remarks
   * The description of the data source.
   * 
   * @example
   * xxx
   */
  description?: string;
  /**
   * @remarks
   * The environment in which the data source resides. Valid values:
   * 
   * *   0: development environment
   * *   1: production environment
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The status of the data source. This parameter is deprecated. Do not use this parameter.
   * 
   * @example
   * ENABLED
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      dataSourceId: 'DataSourceId',
      description: 'Description',
      envType: 'EnvType',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      dataSourceId: 'number',
      description: 'string',
      envType: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDataSourceResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the data source is updated.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: string;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc14115159376359****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      httpStatusCode: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDataSourceResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateDataSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateDataSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileRequest extends $tea.Model {
  /**
   * @remarks
   * The advanced configurations of the node.
   * 
   * This parameter is valid only for an EMR Spark Streaming node or an EMR Streaming SQL node. This parameter corresponds to the Advanced Settings tab of the node in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * This parameter is configured in the JSON format.
   * 
   * @example
   * {"queue":"default","SPARK_CONF":"--conf spark.driver.memory=2g"}
   */
  advancedSettings?: string;
  applyScheduleImmediately?: boolean;
  /**
   * @remarks
   * Specifies whether the automatic parsing feature is enabled for the file. Valid values:
   * 
   * *   true: The automatic parsing feature is enabled for the file.
   * *   false: The automatic parsing feature is not enabled for the file.
   * 
   * This parameter corresponds to the Analyze Code parameter that is displayed after Same Cycle is selected in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * true
   */
  autoParsing?: boolean;
  /**
   * @remarks
   * The interval between two consecutive automatic reruns after an error occurs. Unit: milliseconds. Maximum value: 1800000 (30 minutes).
   * 
   * This parameter corresponds to the Rerun Interval parameter that is displayed after the Auto Rerun upon Error check box is selected in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * The interval that you specify in the DataWorks console is measured in minutes. Pay attention to the conversion between the units of time when you call the operation.
   * 
   * @example
   * 120000
   */
  autoRerunIntervalMillis?: number;
  /**
   * @remarks
   * The number of automatic reruns that are allowed after an error occurs.
   * 
   * @example
   * 3
   */
  autoRerunTimes?: number;
  /**
   * @remarks
   * The name of the connected data source that is used to run the node. You can call the [ListDataSources](https://help.aliyun.com/document_detail/211431.html) operation to query the available data sources of the workspace.
   * 
   * @example
   * odps_first
   */
  connectionName?: string;
  /**
   * @remarks
   * The code of the file. The code format varies based on the file type. To view the code format for a specific file type, go to Operation Center, right-click a node of the file type, and then select View Code.
   * 
   * @example
   * SELECT "1";
   */
  content?: string;
  /**
   * @remarks
   * The CRON expression that represents the periodic scheduling policy of the node. This parameter corresponds to the Cron Expression parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console). After you configure the Scheduling Cycle and Run At parameters in the DataWorks console, DataWorks automatically generates a value for the Cron Expression parameter.
   * 
   * Examples:
   * 
   * *   CRON expression for a node that is scheduled to run at 05:30 every day: `00 30 05 * * ?`
   * *   CRON expression for a node that is scheduled to run at the fifteenth minute of each hour: `00 15 * * * ?`
   * *   CRON expression for a node that is scheduled to run every 10 minutes: `00 00/10 * * * ?`
   * *   CRON expression for a node that is scheduled to run every 10 minutes from 08:00 to 17:00 every day: `00 00-59/10 8-23 * * * ?`
   * *   CRON expression for a node that is scheduled to run at 00:20 on the first day of each month: `00 20 00 1 * ?`
   * *   CRON expression for a node that is scheduled to run every three months starting from 00:10 on January 1: `00 10 00 1 1-12/3 ?`
   * *   CRON expression for a node that is scheduled to run at 00:05 every Tuesday and Friday: `00 05 00 * * 2,5`
   * 
   * The scheduling system of DataWorks imposes the following limits on CRON expressions:
   * 
   * *   A node can be scheduled to run at a minimum interval of 5 minutes.
   * *   A node can be scheduled to run at 00:05 every day at the earliest.
   * 
   * @example
   * 00 00-59/5 1-23 * * ?
   */
  cronExpress?: string;
  /**
   * @remarks
   * The type of the scheduling cycle of the node that corresponds to the file. Valid values: NOT_DAY and DAY. The value NOT_DAY indicates that the node is scheduled to run by minute or hour. The value DAY indicates that the node is scheduled to run by day, week, or month.
   * 
   * This parameter corresponds to the Scheduling Cycle parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * NOT_DAY
   */
  cycleType?: string;
  /**
   * @remarks
   * The ID of the node on which the node corresponding to the file depends when the DependentType parameter is set to USER_DEFINE. Multiple IDs are separated by commas (,).
   * 
   * The value of this parameter corresponds to the ID of the node that you specified after you select Previous Cycle and set Depend On to Other Nodes in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * 5,10,15,20
   */
  dependentNodeIdList?: string;
  /**
   * @remarks
   * The type of the cross-cycle scheduling dependency of the node that corresponds to the file. Valid values:
   * 
   * *   SELF: The instance generated for the node in the current cycle depends on the instance generated for the node in the previous cycle.
   * *   CHILD: The instance generated for the node in the current cycle depends on the instances generated for the descendant nodes at the nearest level of the node in the previous cycle.
   * *   USER_DEFINE: The instance generated for the node in the current cycle depends on the instances generated for one or more specified nodes in the previous cycle.
   * *   NONE: No cross-cycle scheduling dependency type is selected for the node.
   * 
   * @example
   * USER_DEFINE
   */
  dependentType?: string;
  /**
   * @remarks
   * The end time of automatic scheduling. Set this parameter to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * This parameter corresponds to the end time specified for the Validity Period parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * 4155787800000
   */
  endEffectDate?: number;
  /**
   * @remarks
   * The description of the file.
   */
  fileDescription?: string;
  /**
   * @remarks
   * The path of the file.
   */
  fileFolderPath?: string;
  /**
   * @remarks
   * The ID of the file. You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to obtain the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 100000001
   */
  fileId?: number;
  /**
   * @remarks
   * The name of the file. You can set the FileName parameter to a new value to change the file name.
   * 
   * You can call the [ListFiles](https://help.aliyun.com/document_detail/173942.html) operation to query the ID of the file whose name you want to change. Then, you can set the FileId parameter to the ID and set the FileName parameter to a new value when you call the [UpdateFile](https://help.aliyun.com/document_detail/173951.html) operation.
   * 
   * @example
   * ods_user_info_d
   */
  fileName?: string;
  /**
   * @example
   * true
   */
  ignoreParentSkipRunningProperty?: boolean;
  /**
   * @remarks
   * The output name of the parent file on which the current file depends. If you specify multiple output names, separate them with commas (,).
   * 
   * This parameter corresponds to the Parent Nodes parameter that is displayed after you select Same Cycle in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * >  You must configure this parameter when you call the CreateDISyncTask or UpdateFile operation to create a batch synchronization task.
   * 
   * @example
   * project_root,project.file1,project.001_out
   */
  inputList?: string;
  /**
   * @remarks
   * The input parameters of the node. This parameter is configured in the JSON format. For more information about the input parameters, refer to the InputContextParameterList parameter in the Response parameters section of the [GetFile](https://help.aliyun.com/document_detail/173954.html) operation.
   * 
   * This parameter corresponds to the Input Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * [{"ValueSource": "project_001.first_node:bizdate_param","ParameterName": "bizdate_input"}]
   */
  inputParameters?: string;
  /**
   * @remarks
   * The output name of the current file.
   * 
   * This parameter corresponds to the Output Name parameter in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * dw_project.ods_user_info_d
   */
  outputList?: string;
  /**
   * @remarks
   * The output parameters of the node. This parameter is configured in the JSON format. For more information about the output parameters, refer to the OutputContextParameterList parameter in the Response parameters section of the [GetFile](https://help.aliyun.com/document_detail/173954.html) operation.
   * 
   * This parameter corresponds to the Output Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * [{"Type": 1,"Value": "${bizdate}","ParameterName": "bizdate_param"}]
   */
  outputParameters?: string;
  /**
   * @remarks
   * The ID of the file owner.
   * 
   * @example
   * 18023848927592
   */
  owner?: string;
  /**
   * @remarks
   * The scheduling parameters of the node.
   * 
   * This parameter corresponds to the Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console). For more information, see [Configure scheduling parameters](https://help.aliyun.com/document_detail/137548.html).
   * 
   * @example
   * x=a y=b z=c
   */
  paraValue?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace name.
   * 
   * You must configure this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  /**
   * @remarks
   * Specifies whether the node that corresponds to the file can be rerun. Valid values:
   * 
   * *   ALL_ALLOWED: The node can be rerun regardless of whether it is successfully run or fails to run.
   * *   FAILURE_ALLOWED: The node can be rerun only after it fails to run.
   * *   ALL_DENIED: The node cannot be rerun regardless of whether it is successfully run or fails to run.
   * 
   * This parameter corresponds to the Rerun parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * ALL_ALLOWED
   */
  rerunMode?: string;
  /**
   * @remarks
   * The identifier of the resource group that is used to run the node. You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/173913.html) operation to query the available resource groups in the workspace.
   * 
   * @example
   * default_group
   */
  resourceGroupIdentifier?: string;
  /**
   * @remarks
   * The scheduling type of the node. Valid values:
   * 
   * *   NORMAL: The node is an auto triggered node.
   * *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered. They correspond to the nodes in the Manually Triggered Workflows pane.
   * *   PAUSE: The node is a paused node.
   * *   SKIP: The inner node is a dry-run node. Dry-run nodes are started as scheduled but the scheduling system sets the status of the nodes to succeeded when the scheduling system starts to run the nodes.
   * 
   * @example
   * NORMAL
   */
  schedulerType?: string;
  /**
   * @remarks
   * The start time of automatic scheduling. Set this parameter to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * This parameter corresponds to the Validity Period parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * 936923400000
   */
  startEffectDate?: number;
  /**
   * @remarks
   * Specifies whether to immediately run a node after the node is deployed to the production environment. Valid values:
   * 
   * *   true: A node is immediately run after the node is deployed to the production environment.
   * *   false: A node is not immediately run after the node is deployed to the production environment.
   * 
   * This parameter is valid only for an EMR Spark Streaming node or an EMR Streaming SQL node. This parameter corresponds to the Start Method parameter in the Schedule section of the Configure tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * true
   */
  startImmediately?: boolean;
  /**
   * @remarks
   * Specifies whether to suspend the scheduling of the node. Valid values:
   * 
   * *   true: suspends the scheduling of the node.
   * *   false: does not suspend the scheduling of the node.
   * 
   * This parameter corresponds to the Recurrence parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * false
   */
  stop?: boolean;
  static names(): { [key: string]: string } {
    return {
      advancedSettings: 'AdvancedSettings',
      applyScheduleImmediately: 'ApplyScheduleImmediately',
      autoParsing: 'AutoParsing',
      autoRerunIntervalMillis: 'AutoRerunIntervalMillis',
      autoRerunTimes: 'AutoRerunTimes',
      connectionName: 'ConnectionName',
      content: 'Content',
      cronExpress: 'CronExpress',
      cycleType: 'CycleType',
      dependentNodeIdList: 'DependentNodeIdList',
      dependentType: 'DependentType',
      endEffectDate: 'EndEffectDate',
      fileDescription: 'FileDescription',
      fileFolderPath: 'FileFolderPath',
      fileId: 'FileId',
      fileName: 'FileName',
      ignoreParentSkipRunningProperty: 'IgnoreParentSkipRunningProperty',
      inputList: 'InputList',
      inputParameters: 'InputParameters',
      outputList: 'OutputList',
      outputParameters: 'OutputParameters',
      owner: 'Owner',
      paraValue: 'ParaValue',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
      rerunMode: 'RerunMode',
      resourceGroupIdentifier: 'ResourceGroupIdentifier',
      schedulerType: 'SchedulerType',
      startEffectDate: 'StartEffectDate',
      startImmediately: 'StartImmediately',
      stop: 'Stop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advancedSettings: 'string',
      applyScheduleImmediately: 'boolean',
      autoParsing: 'boolean',
      autoRerunIntervalMillis: 'number',
      autoRerunTimes: 'number',
      connectionName: 'string',
      content: 'string',
      cronExpress: 'string',
      cycleType: 'string',
      dependentNodeIdList: 'string',
      dependentType: 'string',
      endEffectDate: 'number',
      fileDescription: 'string',
      fileFolderPath: 'string',
      fileId: 'number',
      fileName: 'string',
      ignoreParentSkipRunningProperty: 'boolean',
      inputList: 'string',
      inputParameters: 'string',
      outputList: 'string',
      outputParameters: 'string',
      owner: 'string',
      paraValue: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
      rerunMode: 'string',
      resourceGroupIdentifier: 'string',
      schedulerType: 'string',
      startEffectDate: 'number',
      startImmediately: 'boolean',
      stop: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFGH-IJKLMNOPQ
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful. Valid values:
   * 
   * *   true: The request is successful.
   * *   false: The request fails.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFolderRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the folder. You can call the [ListFolders](https://help.aliyun.com/document_detail/173955.html) operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 2735c2c19d58
   */
  folderId?: string;
  /**
   * @remarks
   * The name of the folder.
   * 
   * This parameter is required.
   * 
   * @example
   * MySecondFolder
   */
  folderName?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID. You must specify either this parameter or ProjectIdentifier to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Settings panel to obtain the name. You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      folderId: 'FolderId',
      folderName: 'FolderName',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folderId: 'string',
      folderName: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFolderResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFolderResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateFolderResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFolderResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIDEEventResultRequest extends $tea.Model {
  /**
   * @remarks
   * The check status of the extension point event. Valid values:
   * 
   * *   OK: The event passes the check.
   * *   FAIL: The event fails to pass the check. You must check and handle the reported error at the earliest opportunity to ensure that your program is run as expected.
   * *   WARN: The event passes the check, but an alert is reported.
   * 
   * @example
   * OK
   */
  checkResult?: string;
  /**
   * @remarks
   * The summary information of the check result. The information is displayed in DataStudio. If an alert is reported or the event fails the check, you can troubleshoot errors based on the information.
   * 
   * @example
   * Succeeded
   */
  checkResultTip?: string;
  /**
   * @remarks
   * The unique identifier of the extension. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Extensions tab of the Open Platform page to view the identifier.
   * 
   * @example
   * 8abcb91f-d266-4073-b907-2ed670378ed1
   */
  extensionCode?: string;
  /**
   * @remarks
   * The message ID. You can obtain the ID from a received message when an extension point event is triggered.
   * 
   * @example
   * 8abcb91f-d266-4073-b907-2ed670378ed1
   */
  messageId?: string;
  static names(): { [key: string]: string } {
    return {
      checkResult: 'CheckResult',
      checkResultTip: 'CheckResultTip',
      extensionCode: 'ExtensionCode',
      messageId: 'MessageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkResult: 'string',
      checkResultTip: 'string',
      extensionCode: 'string',
      messageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIDEEventResultResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 8abcb91f-d266-4073-b907-2ed670378ed1
   */
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateIDEEventResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateIDEEventResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateIDEEventResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetaCategoryRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the category.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  categoryId?: number;
  /**
   * @remarks
   * The remarks of the category.
   * 
   * @example
   * category name
   */
  comment?: string;
  /**
   * @remarks
   * The name of the category.
   * 
   * @example
   * category name
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      categoryId: 'CategoryId',
      comment: 'Comment',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryId: 'number',
      comment: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetaCategoryResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the category is updated.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetaCategoryResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMetaCategoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMetaCategoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetaCollectionRequest extends $tea.Model {
  /**
   * @remarks
   * The comment of the collection. The comment must be 1 to 64 characters in length.
   * 
   * @example
   * this is a comment
   */
  comment?: string;
  /**
   * @remarks
   * The name of the collection.
   * 
   * @example
   * myCollectionName
   */
  name?: string;
  /**
   * @remarks
   * The unique identifier of the collection.
   * 
   * This parameter is required.
   * 
   * @example
   * album.396397
   */
  qualifiedName?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      name: 'Name',
      qualifiedName: 'QualifiedName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      name: 'string',
      qualifiedName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetaCollectionResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 9999
   */
  errorCode?: string;
  /**
   * @remarks
   * The returned message.
   * 
   * @example
   * The specified product does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can locate logs and troubleshoot issues based on the ID.
   * 
   * @example
   * 0000-ABCD-E****
   */
  requestId?: string;
  /**
   * @remarks
   * The result of the operation. Valid values: true false
   * 
   * @example
   * true
   */
  status?: boolean;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true: The request was successful.
   * *   false: The request failed.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      status: 'Status',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      status: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetaCollectionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMetaCollectionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMetaCollectionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetaTableRequest extends $tea.Model {
  /**
   * @remarks
   * The names of the labels that you want to add. Separate the labels with commas (,).
   * 
   * @example
   * a,b,c
   */
  addedLabels?: string;
  /**
   * @remarks
   * The display name of the table.
   * 
   * @example
   * test
   */
  caption?: string;
  /**
   * @remarks
   * The ID of the category that you want to associate.
   * 
   * @example
   * 101
   */
  categoryId?: number;
  /**
   * @remarks
   * The environment of the DataWorks workspace. Valid values: 0 and 1. The value 0 indicates the development environment. The value 1 indicates the production environment.
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The new owner ID. If you leave this parameter empty, the owner ID is not updated.
   * 
   * @example
   * 12345
   */
  newOwnerId?: string;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 101
   */
  projectId?: number;
  /**
   * @remarks
   * The names of labels that you want to remove. Separate the labels with commas (,).
   * 
   * @example
   * a,b,c
   */
  removedLabels?: string;
  /**
   * @remarks
   * The schema information about the table. You must configure this parameter if you enable the three-layer model of MaxCompute.
   * 
   * @example
   * default
   * 
   * **if can be null:**
   * true
   */
  schema?: string;
  /**
   * @remarks
   * The GUID of the table. Specify the GUID in the format of odps.{projectName}.{tableName}.
   * 
   * @example
   * odps.test.table1
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * table1
   */
  tableName?: string;
  /**
   * @remarks
   * The scope in which the table is visible. Valid values: 0, 1, and 2. The value 0 indicates that the table is invisible to all members. The value 1 indicates that the table is visible to all members. The value 2 indicates that the table is visible to workspace members.
   * 
   * @example
   * 1
   */
  visibility?: number;
  static names(): { [key: string]: string } {
    return {
      addedLabels: 'AddedLabels',
      caption: 'Caption',
      categoryId: 'CategoryId',
      envType: 'EnvType',
      newOwnerId: 'NewOwnerId',
      projectId: 'ProjectId',
      removedLabels: 'RemovedLabels',
      schema: 'Schema',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addedLabels: 'string',
      caption: 'string',
      categoryId: 'number',
      envType: 'number',
      newOwnerId: 'string',
      projectId: 'number',
      removedLabels: 'string',
      schema: 'string',
      tableGuid: 'string',
      tableName: 'string',
      visibility: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetaTableResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * abcde
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the metadata information about the table was updated.
   * 
   * @example
   * true
   */
  updateResult?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      updateResult: 'UpdateResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      updateResult: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetaTableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMetaTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMetaTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetaTableIntroWikiRequest extends $tea.Model {
  /**
   * @remarks
   * The details of the instructions on how to use the metatable.
   * 
   * This parameter is required.
   * 
   * @example
   * abc
   */
  content?: string;
  /**
   * @remarks
   * The GUID of the table. Specify the GUID in the odps.{projectName}.{tableName} format.
   * 
   * This parameter is required.
   * 
   * @example
   * odps.test.table1
   */
  tableGuid?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      tableGuid: 'TableGuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      tableGuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetaTableIntroWikiResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID. You can troubleshoot issues based on the ID.
   * 
   * @example
   * abcde
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the instructions on how to use the table are updated.
   * 
   * @example
   * true
   */
  updateResult?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      updateResult: 'UpdateResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      updateResult: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMetaTableIntroWikiResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMetaTableIntroWikiResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMetaTableIntroWikiResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNodeOwnerRequest extends $tea.Model {
  /**
   * @remarks
   * The node ID. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The environment in which the node runs. Valid values: DEV and PROD. The value DEV indicates the development environment, and the value PROD indicates the production environment.
   * 
   * *   PROD
   * *   DEV
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner. You can log on to the DataWorks console and move the pointer over the profile picture in the upper-right corner to view the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 19337906836551
   */
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      projectEnv: 'ProjectEnv',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      projectEnv: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNodeOwnerResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID. You can use the request ID to query logs and troubleshoot issues.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNodeOwnerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateNodeOwnerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateNodeOwnerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNodeRunModeRequest extends $tea.Model {
  /**
   * @remarks
   * The node ID. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the node ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The environment in which the node runs. Valid values: DEV and PROD. The value DEV indicates the development environment, and the value PROD indicates the production environment.
   * 
   * *   PROD
   * *   DEV
   * 
   * This parameter is required.
   * 
   * @example
   * PROD
   */
  projectEnv?: string;
  /**
   * @remarks
   * The operation that you want to perform on the node. Valid values:
   * 
   * *   0: indicates that you want to unfreeze the node.
   * *   2: indicates that you want to freeze the node.
   * 
   * This parameter is required.
   * 
   * @example
   * 0
   */
  schedulerType?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      projectEnv: 'ProjectEnv',
      schedulerType: 'SchedulerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      projectEnv: 'string',
      schedulerType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNodeRunModeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * E6F0DBDD-5AD****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateNodeRunModeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateNodeRunModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateNodeRunModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateQualityFollowerRequest extends $tea.Model {
  /**
   * @remarks
   * The notification method. Valid values: 1, 2, 4, 5, 6, 7, 8, and 9. The value 1 indicates that the notification is sent by email. The value 2 indicates that the notification is sent by email and text message. The value 4 indicates that the notification is sent by a DingTalk chatbot. The value 5 indicates that the notification is sent by a DingTalk chatbot to all members in a DingTalk group. The value 6 indicates that the notification is sent by Lark. The value 7 indicates that the notification is sent by WeCom. The value 8 indicates that the notification is sent by webhook. The value 9 indicates that the notification is sent by phone call.
   * 
   * This parameter is required.
   * 
   * @example
   * 2
   */
  alarmMode?: number;
  /**
   * @remarks
   * The name of the subscriber.
   * 
   * This parameter is required.
   * 
   * @example
   * 1912232****
   */
  follower?: string;
  /**
   * @remarks
   * The ID of the subscription relationship.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  followerId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console to obtain the workspace ID.
   * 
   * @example
   * 123
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine or data source.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      alarmMode: 'AlarmMode',
      follower: 'Follower',
      followerId: 'FollowerId',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmMode: 'number',
      follower: 'string',
      followerId: 'number',
      projectId: 'number',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateQualityFollowerResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the update is successful.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 401
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You have no permission
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 576b9457-2cf5-4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateQualityFollowerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateQualityFollowerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateQualityFollowerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateQualityRuleRequest extends $tea.Model {
  /**
   * @remarks
   * The strength of the monitoring rule. The strength of a monitoring rule indicates the importance of the rule. Valid values:
   * 
   * *   1: The monitoring rule is a strong rule.
   * *   0: The monitoring rule is a weak rule. You can specify the strength of a monitoring rule based on your business requirements. If a monitoring rule is a strong rule and the critical threshold is exceeded, a critical alert is reported and tasks that are associated with the rule are blocked from running.
   * 
   * @example
   * 0
   */
  blockType?: number;
  /**
   * @remarks
   * The checker ID. You can call the [ListQualityRules](https://help.aliyun.com/document_detail/173995.html) operation to obtain the ID of the checker.
   * 
   * This parameter is required.
   * 
   * @example
   * 9
   */
  checker?: number;
  /**
   * @remarks
   * The description of the monitoring rule.
   */
  comment?: string;
  /**
   * @remarks
   * The threshold for a critical alert. The threshold indicates the deviation of the monitoring result from the expected value. You can specify a custom value for the threshold based on your business requirements. If a monitoring rule is a strong rule and the critical threshold is exceeded, a critical alert is reported and tasks that are associated with the rule are blocked from running.
   * 
   * @example
   * 10
   */
  criticalThreshold?: string;
  /**
   * @remarks
   * The ID of the partition filter expression. You can call the [ListQualityRules](https://help.aliyun.com/document_detail/173995.html) operation to obtain the ID of the partition filter expression.
   * 
   * @example
   * 123
   */
  entityId?: number;
  /**
   * @remarks
   * The expected value of the monitoring rule.
   * 
   * @example
   * 300
   */
  expectValue?: string;
  /**
   * @remarks
   * The monitoring rule ID. You can call the [ListQualityRules](https://help.aliyun.com/document_detail/173995.html) operation to query the ID of the monitoring rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  id?: number;
  /**
   * @remarks
   * The method that is used to collect sample data, such as avg, count, sum, min, max, count_distinct, user_defined, table_count, table_size, table_dt_load_count, table_dt_refuseload_count, null_value, null_value/table_count, (table_count-count_distinct)/table_count, or table_count-count_distinct.
   * 
   * This parameter is required.
   * 
   * @example
   * table_count
   */
  methodName?: string;
  /**
   * @remarks
   * Specifies whether to enable the monitoring rule in the production environment. Valid values:
   * 
   * *   true: The monitoring rule is triggered when the associated auto triggered node that generates the output data starts to run.
   * *   false: The monitoring rule is not triggered when the associated auto triggered node that generates the output data starts to run.
   * 
   * @example
   * true
   * 
   * **if can be null:**
   * false
   */
  openSwitch?: boolean;
  /**
   * @remarks
   * The comparison operator, such as >, >=, =, ≠, <, or <=.
   * 
   * @example
   * >
   */
  operator?: string;
  /**
   * @remarks
   * Specifies whether the threshold is a dynamic threshold. Valid values:
   * 
   * *   0: The threshold is not a dynamic threshold.
   * *   2: The threshold is a dynamic threshold.
   * 
   * @example
   * 0
   */
  predictType?: number;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 26
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the compute engine or data source. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to obtain the name of the compute engine or data source.
   * 
   * This parameter is required.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The name of the field.
   * 
   * This parameter is required.
   * 
   * @example
   * id
   */
  property?: string;
  /**
   * @remarks
   * The data type of the field.
   * 
   * @example
   * bigint
   */
  propertyType?: string;
  /**
   * @remarks
   * The name of the monitoring rule.
   * 
   * @example
   * 123
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the monitoring rule. Valid values:
   * 
   * *   0: The monitoring rule is created by the system.
   * *   1: The monitoring rule is created by a user.
   * *   2: The monitoring rule is a workspace-level rule.
   * 
   * @example
   * 0
   */
  ruleType?: number;
  /**
   * @remarks
   * The variable settings inserted before the custom rule. Format: x=a,y=b.
   * 
   * @example
   * x=a,y=b
   */
  taskSetting?: string;
  /**
   * @remarks
   * The ID of the monitoring template. You can call the [ListQualityRules](https://help.aliyun.com/document_detail/173995.html) operation to obtain the ID of the monitoring template.
   * 
   * @example
   * 7
   */
  templateId?: number;
  /**
   * @remarks
   * The trend of the monitoring result. Valid values:
   * 
   * *   up: increasing
   * *   down: decreasing
   * *   abs: absolute value
   * 
   * @example
   * up
   */
  trend?: string;
  /**
   * @remarks
   * The threshold for a warning alert. The threshold specifies the deviation of the monitoring result from the expected value. You can specify a custom value for the threshold based on your business requirements.
   * 
   * @example
   * 5
   */
  warningThreshold?: string;
  /**
   * @remarks
   * The filter condition or custom SQL statement that is used for monitoring.
   * 
   * @example
   * dt=$[yyyymmdd]
   */
  whereCondition?: string;
  static names(): { [key: string]: string } {
    return {
      blockType: 'BlockType',
      checker: 'Checker',
      comment: 'Comment',
      criticalThreshold: 'CriticalThreshold',
      entityId: 'EntityId',
      expectValue: 'ExpectValue',
      id: 'Id',
      methodName: 'MethodName',
      openSwitch: 'OpenSwitch',
      operator: 'Operator',
      predictType: 'PredictType',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      property: 'Property',
      propertyType: 'PropertyType',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      taskSetting: 'TaskSetting',
      templateId: 'TemplateId',
      trend: 'Trend',
      warningThreshold: 'WarningThreshold',
      whereCondition: 'WhereCondition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockType: 'number',
      checker: 'number',
      comment: 'string',
      criticalThreshold: 'string',
      entityId: 'number',
      expectValue: 'string',
      id: 'number',
      methodName: 'string',
      openSwitch: 'boolean',
      operator: 'string',
      predictType: 'number',
      projectId: 'number',
      projectName: 'string',
      property: 'string',
      propertyType: 'string',
      ruleName: 'string',
      ruleType: 'number',
      taskSetting: 'string',
      templateId: 'number',
      trend: 'string',
      warningThreshold: 'string',
      whereCondition: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateQualityRuleResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the monitoring rule is updated.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 0
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * You have no permission.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can troubleshoot issues based on the ID.
   * 
   * @example
   * 576b9457-2cf5-4****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateQualityRuleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateQualityRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateQualityRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRemindRequest extends $tea.Model {
  /**
   * @remarks
   * The intervals at which alert notifications are sent. Unit: seconds. Minimum value: 1200. Default value: 1800.
   * 
   * @example
   * 1800
   */
  alertInterval?: number;
  /**
   * @remarks
   * The notification method. Valid values:
   * 
   * *   MAIL: Alert notifications are sent by email.
   * *   SMS: Alert notifications are sent by text message.
   * *   PHONE: Alert notifications are sent by phone call. You can use this notification method only in DataWorks Professional Edition or more advanced editions.
   * *   DINGROBOTS: Alert notifications are sent by DingTalk message. You can use this notification method only if the RobotUrls parameter is configured.
   * *   WEBHOOKS (WeCom or Lark chatbot): Alert notifications are sent by WeCom or Lark message. You can use this notification method only if the Webhooks parameter is configured.
   * 
   * Multiple notification methods are separated by commas (,).
   * 
   * @example
   * SMS,MAIL
   */
  alertMethods?: string;
  /**
   * @remarks
   * The value format required by this parameter varies based on the value that you specify for the AlertUnit parameter. Take note of the following items:
   * 
   * *   If the AlertUnit parameter is set to OWNER, leave this parameter empty.
   * *   If the AlertUnit parameter is set to OTHER, set this parameter to the unique ID (UID) of the specified user. You can specify multiple UIDs. Separate them with commas (,). A maximum of 10 UIDs can be specified for receiving alert notifications.
   * 
   * @example
   * 9527952795279527
   */
  alertTargets?: string;
  /**
   * @remarks
   * The recipient to whom alert notifications are sent. Valid values: OWNER and OTHER. The value OWNER indicates that alert notifications are sent to the object owner. The value OTHER indicates that alert notifications are sent to a specified user.
   * 
   * @example
   * OWNER
   */
  alertUnit?: string;
  /**
   * @remarks
   * The ID of the baseline to which the custom alert rule is applied. A maximum of 5 baselines can be specified for a custom alert rule. You can specify multiple IDs. Separate multiple IDs with commas (,). This parameter takes effect when you set the RemindUnit parameter to BASELINE.
   * 
   * @example
   * 1,2,3
   */
  baselineIds?: string;
  /**
   * @remarks
   * The ID of the workflow to which the custom alert rule is applied. A maximum of 5 workflows can be specified for a custom alert rule. You can specify multiple IDs. Separate multiple IDs with commas (,). This parameter takes effect when you set the RemindUnit parameter to BIZPROCESS.
   * 
   * @example
   * 1,2,3
   */
  bizProcessIds?: string;
  /**
   * @remarks
   * The details of the conditions that trigger an alert.
   * 
   * *   If the RemindType parameter is set to FINISHED, leave this parameter empty.
   * *   If the RemindType parameter is set to UNFINISHED, set this parameter to key-value pairs. Example: {"hour":23,"minu":59}. Valid values of hour: [0,47]. Valid values of minu: [0,59].
   * *   If the RemindType parameter is set to ERROR, leave this parameter empty.
   * *   If the RemindType parameter is set to CYCLE_UNFINISHED, set this parameter to key-value pairs in the JSON format. Example: {"1":"05:50","2":"06:50","3":"07:50","4":"08:50","5":"09:50","6":"10:50","7":"11:50","8":"12:50","9":"13:50","10":"14:50","11":"15:50","12":"16:50","13":"17:50","14":"18:50","15":"19:50","16":"20:50","17":"21:50","18":"22:50","19":"23:50","20":"24:50","21":"25:50"}. A key in the JSON string indicates the sequence number of a cycle. Valid values of keys: 1 to 288. A value in the JSON string indicates the time in point when a monitored instance times out in the relevant cycle. Values must be in the format of hh:mm. Valid values of hh: [0,47]. Valid values of mm: [0,59].
   * *   If the RemindType parameter is set to TIMEOUT, set this parameter to the timeout period. Unit: seconds. Example: 1800. This indicates that an alert notification is sent if the running duration of a monitored instance exceeds 30 minutes.
   * 
   * @example
   * {"hour":23,"minu":59}
   */
  detail?: string;
  /**
   * @remarks
   * The end of the period during which no alert notifications are sent. Specify the time in the hh:mm format. Valid values of hh: [0,23]. Valid values of mm: [0,59].
   * 
   * @example
   * 08:00
   */
  dndEnd?: string;
  /**
   * @remarks
   * The maximum number of alerts. Valid values: 1 to 10. Default value: 3.
   * 
   * @example
   * 3
   */
  maxAlertTimes?: number;
  /**
   * @remarks
   * The ID of the node to which the custom alert rule is applied. A maximum of 50 nodes can be specified for a custom alert rule. You can specify multiple IDs. Separate multiple IDs with commas (,). This parameter takes effect when you set the RemindUnit parameter to NODE.
   * 
   * @example
   * 1,2,3
   */
  nodeIds?: string;
  /**
   * @remarks
   * The ID of the workspace to which the custom alert rule is applied. You can specify only one workspace for a custom alert rule. This parameter takes effect when you set the RemindUnit parameter to PROJECT.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The custom alert rule ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 1234
   */
  remindId?: number;
  /**
   * @remarks
   * The name of the custom alert rule. The name cannot exceed 128 characters in length.
   * 
   * @example
   * update_remindname
   */
  remindName?: string;
  /**
   * @remarks
   * The condition that triggers the alert rule. Valid values:
   * 
   * *   FINISHED: The system monitors an instance when it starts to run and sends an alert notification after the running of the instance is complete.
   * *   UNFINISHED: The system monitors an instance when it starts to run and sends an alert notification if the instance is still running at the specified point in time.
   * *   ERROR: The system monitors an instance when it starts to run and sends an alert notification if an error occurs.
   * *   CYCLE_UNFINISHED: The system sends an alert notification if a monitored instance is still running at the end of the specified cycle. In most cases, you can configure this trigger condition for node instances that are scheduled to run by hour.
   * *   TIMEOUT: The system monitors an instance when it starts to run and sends an alert notification if the instance is still running after the specified period ends. In most cases, you can configure this trigger condition to monitor the running duration of node instances.
   * 
   * For more information, see [Manage custom alert rules](https://help.aliyun.com/document_detail/138172.html).
   * 
   * @example
   * FINISHED
   */
  remindType?: string;
  /**
   * @remarks
   * The type of the object to which the custom alert rule is applied. Valid values:
   * 
   * *   NODE
   * *   BASELINE
   * *   PROJECT
   * *   BIZPROCESS
   * 
   * @example
   * NODE
   */
  remindUnit?: string;
  /**
   * @remarks
   * The webhook URL of the DingTalk chatbot. You can specify multiple webhook URLs. Separate multiple webhook URLs with commas (,). If this parameter is set to undefined, the specified webhook URLs are cleared.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=******************************
   */
  robotUrls?: string;
  /**
   * @remarks
   * Specifies whether to enable the alert rule. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  useFlag?: boolean;
  /**
   * @remarks
   * The webhook URL of the WeCom or Lark chatbot. You can specify multiple webhook URLs. Separate multiple webhook URLs with commas (,). The value of AlertMethods must include WEBHOOKS. If this parameter is set to undefined, the specified webhook URLs are cleared.
   * 
   * Only DataWorks Enterprise Edition supports this parameter. The webhook URL-based alerting feature is supported in the following regions: China (Shanghai), China (Chengdu), China (Zhangjiakou), China (Beijing), China (Hangzhou), China (Shenzhen), China (Hong Kong), Germany (Frankfurt), and Singapore.
   * 
   * @example
   * https://open.feishu.cn/open-apis/bot/v2/hook/*******
   */
  webhooks?: string;
  static names(): { [key: string]: string } {
    return {
      alertInterval: 'AlertInterval',
      alertMethods: 'AlertMethods',
      alertTargets: 'AlertTargets',
      alertUnit: 'AlertUnit',
      baselineIds: 'BaselineIds',
      bizProcessIds: 'BizProcessIds',
      detail: 'Detail',
      dndEnd: 'DndEnd',
      maxAlertTimes: 'MaxAlertTimes',
      nodeIds: 'NodeIds',
      projectId: 'ProjectId',
      remindId: 'RemindId',
      remindName: 'RemindName',
      remindType: 'RemindType',
      remindUnit: 'RemindUnit',
      robotUrls: 'RobotUrls',
      useFlag: 'UseFlag',
      webhooks: 'Webhooks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertInterval: 'number',
      alertMethods: 'string',
      alertTargets: 'string',
      alertUnit: 'string',
      baselineIds: 'string',
      bizProcessIds: 'string',
      detail: 'string',
      dndEnd: 'string',
      maxAlertTimes: 'number',
      nodeIds: 'string',
      projectId: 'number',
      remindId: 'number',
      remindName: 'string',
      remindType: 'string',
      remindUnit: 'string',
      robotUrls: 'string',
      useFlag: 'boolean',
      webhooks: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRemindResponseBody extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the modification to the custom alert rule succeeds.
   * 
   * @example
   * true
   */
  data?: boolean;
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID. You can use the ID to troubleshoot issues.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateRemindResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateRemindResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateRemindResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableRequest extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the MaxCompute project. Specify the GUID in the odps.{projectName} format.
   * 
   * @example
   * odps.test
   */
  appGuid?: string;
  /**
   * @remarks
   * The ID of the associated category.
   * 
   * @example
   * 101
   */
  categoryId?: number;
  /**
   * @remarks
   * The list of fields.
   */
  columns?: UpdateTableRequestColumns[];
  /**
   * @remarks
   * The comment.
   */
  comment?: string;
  /**
   * @remarks
   * Specifies whether the table exists. Valid values:
   * 
   * *   true: The table exists.
   * *   false: The table does not exist.
   * 
   * This parameter is deprecated. Do not use this parameter.
   * 
   * @example
   * true
   */
  createIfNotExists?: boolean;
  /**
   * @remarks
   * The endpoint of MaxCompute. If you do not specify this parameter, the endpoint of the MaxCompute project is used.
   * 
   * @example
   * odps://
   */
  endpoint?: string;
  /**
   * @remarks
   * The environment of the DataWorks workspace. Valid values: 0 and 1. The value 0 indicates the development environment. The value 1 indicates the production environment.
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The type of the external table. Valid values: 0, 1, 2, and 3. The value 0 indicates that the external table is an OSS external table. The value 1 indicates that the external table is a Tablestore external table. The value 2 indicates that the external table is a volume external table. The value 3 indicates that the external table is a MySQL external table. This parameter is deprecated. Do not use this parameter.
   * 
   * @example
   * 1
   */
  externalTableType?: string;
  /**
   * @remarks
   * Specifies whether the table that you want to update is a partitioned table. Valid values: 0 and 1. The value 0 indicates that the table is not a partitioned table. The value 1 indicates that the table is a partitioned table. This parameter is deprecated. Do not use this parameter. The Column.N.isPartitionCol parameter is used instead of the HasPart parameter to specify whether the MaxCompute table is a partitioned table. If the Column.N.isPartitionCol parameter is set to 1, the MaxCompute table is a partitioned table.
   * 
   * @example
   * 0
   */
  hasPart?: number;
  /**
   * @remarks
   * Specifies whether the table is a view. Valid values: 0 and 1. The value 0 indicates that the table is not a view. The value 1 indicates that the table is a view. This parameter is deprecated. Do not use this parameter.
   * 
   * @example
   * 0
   */
  isView?: number;
  /**
   * @remarks
   * The lifecycle of the table. Unit: days. If this parameter is left empty, the table is permanently stored.
   * 
   * @example
   * 10
   */
  lifeCycle?: number;
  /**
   * @remarks
   * The storage location of the external table. This parameter is deprecated. Do not use this parameter.
   * 
   * @example
   * location
   */
  location?: string;
  /**
   * @remarks
   * The ID of the logical level.
   * 
   * @example
   * 101
   */
  logicalLevelId?: number;
  ownerId?: string;
  /**
   * @remarks
   * The ID of the physical layer.
   * 
   * @example
   * 101
   */
  physicsLevelId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID. You can log on to the DataWorks console to obtain the ID of the DataWorks workspace.
   * 
   * @example
   * 101
   */
  projectId?: number;
  /**
   * @remarks
   * The schema information of the table. You need to enter the schema information of the table if you enable the table schema in MaxCompute.
   * 
   * @example
   * default
   * 
   * **if can be null:**
   * true
   */
  schema?: string;
  /**
   * @remarks
   * The name of the MaxCompute table.
   * 
   * This parameter is required.
   * 
   * @example
   * abc
   */
  tableName?: string;
  /**
   * @remarks
   * The list of fields.
   */
  themes?: UpdateTableRequestThemes[];
  /**
   * @remarks
   * The scope in which the table is visible. Valid values: 0, 1, and 2. The value 0 indicates that the table is invisible to all workspace members. The value 1 indicates that the table is visible to all workspace members. The value 2 indicates that the table is visible to workspace members.
   * 
   * @example
   * 1
   */
  visibility?: number;
  static names(): { [key: string]: string } {
    return {
      appGuid: 'AppGuid',
      categoryId: 'CategoryId',
      columns: 'Columns',
      comment: 'Comment',
      createIfNotExists: 'CreateIfNotExists',
      endpoint: 'Endpoint',
      envType: 'EnvType',
      externalTableType: 'ExternalTableType',
      hasPart: 'HasPart',
      isView: 'IsView',
      lifeCycle: 'LifeCycle',
      location: 'Location',
      logicalLevelId: 'LogicalLevelId',
      ownerId: 'OwnerId',
      physicsLevelId: 'PhysicsLevelId',
      projectId: 'ProjectId',
      schema: 'Schema',
      tableName: 'TableName',
      themes: 'Themes',
      visibility: 'Visibility',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGuid: 'string',
      categoryId: 'number',
      columns: { 'type': 'array', 'itemType': UpdateTableRequestColumns },
      comment: 'string',
      createIfNotExists: 'boolean',
      endpoint: 'string',
      envType: 'number',
      externalTableType: 'string',
      hasPart: 'number',
      isView: 'number',
      lifeCycle: 'number',
      location: 'string',
      logicalLevelId: 'number',
      ownerId: 'string',
      physicsLevelId: 'number',
      projectId: 'number',
      schema: 'string',
      tableName: 'string',
      themes: { 'type': 'array', 'itemType': UpdateTableRequestThemes },
      visibility: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * abcde
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the request task. After a request task is submitted, it is divided into multiple subtasks that are run in sequence. After the current subtask is complete, the next subtask starts to run. After all subtasks are complete, the request task is complete. If a request task is terminated due to one of the following issues, address the issue based on the error code and initiate the request task again:
   * 
   * *   The request task fails to be submitted.
   * *   After the request task is submitted, a subtask fails to run.
   */
  taskInfo?: UpdateTableResponseBodyTaskInfo;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskInfo: 'TaskInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskInfo: UpdateTableResponseBodyTaskInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableAddColumnRequest extends $tea.Model {
  /**
   * @remarks
   * The list of fields.
   * 
   * This parameter is required.
   */
  column?: UpdateTableAddColumnRequestColumn[];
  /**
   * @remarks
   * The globally unique identifier (GUID) of the MaxCompute table. Specify the GUID in the odps.projectName.tableName format.
   * 
   * This parameter is required.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  static names(): { [key: string]: string } {
    return {
      column: 'Column',
      tableGuid: 'TableGuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      column: { 'type': 'array', 'itemType': UpdateTableAddColumnRequestColumn },
      tableGuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableAddColumnResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * abc
   */
  requestId?: string;
  /**
   * @remarks
   * The information about the request task. After a request task is submitted, it is divided into multiple subtasks that are run in sequence. After the current subtask is complete, the next subtask starts to run. After all subtasks are complete, the request task is complete. If a request task is aborted due to one of the following issues, address the issue based on the error code and initiate the request task again:
   * 
   * *   The request task fails to be submitted.
   * *   After the request task is submitted, a subtask fails to run.
   */
  taskInfo?: UpdateTableAddColumnResponseBodyTaskInfo;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskInfo: 'TaskInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskInfo: UpdateTableAddColumnResponseBodyTaskInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableAddColumnResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTableAddColumnResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTableAddColumnResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableLevelRequest extends $tea.Model {
  /**
   * @remarks
   * The description of the table level.
   * 
   * @example
   * level description
   */
  description?: string;
  /**
   * @remarks
   * The ID of the table level. You can call the ListTableLevel operation to query the ID.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  levelId?: number;
  /**
   * @remarks
   * The table level type. Valid values: 1 and 2. The value 1 indicates the logical level. The value 2 indicates the physical level.
   * 
   * @example
   * 1
   */
  levelType?: number;
  /**
   * @remarks
   * The name of the table level.
   * 
   * @example
   * level name
   */
  name?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      levelId: 'LevelId',
      levelType: 'LevelType',
      name: 'Name',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      levelId: 'number',
      levelType: 'number',
      name: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableLevelResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * abcde
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * Indicates whether the table level is updated.
   * 
   * @example
   * true
   */
  updateResult?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
      updateResult: 'UpdateResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
      updateResult: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableLevelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTableLevelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTableLevelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableModelInfoRequest extends $tea.Model {
  /**
   * @remarks
   * The ID of the first-level table folder.
   * 
   * @example
   * 101
   */
  firstLevelThemeId?: number;
  /**
   * @remarks
   * The table level ID.
   * 
   * @example
   * 101
   */
  levelId?: number;
  /**
   * @remarks
   * The type of the table level. Valid values: 1 and 2. The value 1 indicates the logical level. The value 2 indicates the physical level.
   * 
   * @example
   * 1
   */
  levelType?: number;
  /**
   * @remarks
   * The ID of the second-level table folder.
   * 
   * @example
   * 101
   */
  secondLevelThemeId?: number;
  /**
   * @remarks
   * The GUID of the table. Specify the GUID in the odps.{projectName}.{tableName} format.
   * 
   * This parameter is required.
   * 
   * @example
   * odps.test.table1
   */
  tableGuid?: string;
  static names(): { [key: string]: string } {
    return {
      firstLevelThemeId: 'FirstLevelThemeId',
      levelId: 'LevelId',
      levelType: 'LevelType',
      secondLevelThemeId: 'SecondLevelThemeId',
      tableGuid: 'TableGuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firstLevelThemeId: 'number',
      levelId: 'number',
      levelType: 'number',
      secondLevelThemeId: 'number',
      tableGuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableModelInfoResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * abcde
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  updateResult?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      updateResult: 'UpdateResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      updateResult: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableModelInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTableModelInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTableModelInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableThemeRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the theme.
   * 
   * This parameter is required.
   * 
   * @example
   * table folder name
   */
  name?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 123
   */
  projectId?: number;
  /**
   * @remarks
   * The ID of the theme.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  themeId?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      projectId: 'ProjectId',
      themeId: 'ThemeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      projectId: 'number',
      themeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableThemeResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1031203110005
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The specified parameters are invalid.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * abcd
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  success?: boolean;
  /**
   * @remarks
   * Indicates whether the update result is returned. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  updateResult?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
      updateResult: 'UpdateResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
      updateResult: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableThemeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateTableThemeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateTableThemeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUdfFileRequest extends $tea.Model {
  /**
   * @remarks
   * The name of the class in which the function is defined. This parameter corresponds to the Class Name parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
   * 
   * This parameter is required.
   * 
   * @example
   * com.alibaba.DataWorks.api.udf.StringConcat
   */
  className?: string;
  /**
   * @remarks
   * The syntax used for calling the function. This parameter corresponds to the Expression Syntax parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
   * 
   * @example
   * StringConcat(String... substrs)
   */
  cmdDescription?: string;
  /**
   * @remarks
   * The example for calling the function. This parameter corresponds to the Example parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
   * 
   * @example
   * StringConcat(\\"a\\", \\"b\\", \\"c\\")
   */
  example?: string;
  /**
   * @remarks
   * The path of the folder in which the function file is stored.
   */
  fileFolderPath?: string;
  /**
   * @remarks
   * The ID of the file.
   * 
   * This parameter is required.
   * 
   * @example
   * 10000001
   */
  fileId?: string;
  /**
   * @remarks
   * The type of the function. Valid values: MATH, AGGREGATE, STRING, DATE, ANALYTIC, and OTHER. This parameter corresponds to the Function Type parameter in the Register Function section of the configuration tab of the function on the DataStudio page.
   * 
   * This parameter is required.
   * 
   * @example
   * STRING
   */
  functionType?: string;
  /**
   * @remarks
   * The description of the input parameters of the function. This parameter corresponds to the Parameter Description parameter in the Register Function section of the configuration tab of the function on the DataStudio page.
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace Management page and view the workspace ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The unique identifier of the DataWorks workspace. You can click the identifier in the upper-left corner of the DataStudio page to switch to another workspace.
   * 
   * You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
   * 
   * @example
   * dw_project
   */
  projectIdentifier?: string;
  /**
   * @remarks
   * The names of the resources that are referenced by the function. This parameter corresponds to the Resources parameter in the Register Function section of the configuration tab of the function in the DataWorks console. Separate multiple resource names with commas (,).
   * 
   * This parameter is required.
   * 
   * @example
   * string-concat-1.0.0.jar,commons-lang-2.6.jar
   */
  resources?: string;
  /**
   * @remarks
   * The description of the return value of the function. This parameter corresponds to the Return Value parameter in the Register Function section of the configuration tab of the function on the DataStudio page.
   */
  returnValue?: string;
  /**
   * @remarks
   * The description of the function. This parameter corresponds to the Description parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
   */
  udfDescription?: string;
  static names(): { [key: string]: string } {
    return {
      className: 'ClassName',
      cmdDescription: 'CmdDescription',
      example: 'Example',
      fileFolderPath: 'FileFolderPath',
      fileId: 'FileId',
      functionType: 'FunctionType',
      parameterDescription: 'ParameterDescription',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
      resources: 'Resources',
      returnValue: 'ReturnValue',
      udfDescription: 'UdfDescription',
    };
  }

  static types(): { [key: string]: any } {
    return {
      className: 'string',
      cmdDescription: 'string',
      example: 'string',
      fileFolderPath: 'string',
      fileId: 'string',
      functionType: 'string',
      parameterDescription: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
      resources: 'string',
      returnValue: 'string',
      udfDescription: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUdfFileResponseBody extends $tea.Model {
  /**
   * @remarks
   * The error code returned.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 200
   */
  httpStatusCode?: number;
  /**
   * @remarks
   * The ID of the request. You can troubleshoot issues based on the ID.
   * 
   * @example
   * 0000-ABCD-EFG****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request is successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateUdfFileResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateUdfFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateUdfFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkbenchEventResultRequest extends $tea.Model {
  /**
   * @remarks
   * The check result of the extension point event. Valid values: OK and Fail.
   * 
   * This parameter is required.
   * 
   * @example
   * FAIL
   */
  checkResult?: string;
  /**
   * @remarks
   * The cause of the check failure.
   * 
   * @example
   * 注意节点有效期
   */
  checkResultTip?: string;
  /**
   * @remarks
   * The code of the extension.
   * 
   * This parameter is required.
   * 
   * @example
   * 58e95e2acd6f408e8707f1bf2591f9e9
   */
  extensionCode?: string;
  /**
   * @remarks
   * The ID of the message received when the related extension point event is triggered after you enable message subscription by using the OpenEvent module.
   * 
   * This parameter is required.
   * 
   * @example
   * 03400b03-b721-4c34-8727-2d6884077091
   */
  messageId?: string;
  static names(): { [key: string]: string } {
    return {
      checkResult: 'CheckResult',
      checkResultTip: 'CheckResultTip',
      extensionCode: 'ExtensionCode',
      messageId: 'MessageId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkResult: 'string',
      checkResultTip: 'string',
      extensionCode: 'string',
      messageId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkbenchEventResultResponseBody extends $tea.Model {
  /**
   * @remarks
   * The request ID.
   * 
   * @example
   * 0bc1ec92159376****
   */
  requestId?: string;
  /**
   * @remarks
   * Indicates whether the request was successful.
   * 
   * @example
   * true
   */
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateWorkbenchEventResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateWorkbenchEventResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateWorkbenchEventResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBaselineRequestOvertimeSettings extends $tea.Model {
  /**
   * @remarks
   * The cycle that corresponds to the committed completion time. For a day-level baseline, set this parameter to 1. For an hour-level baseline, set this parameter to a value that is no more than 24.
   * 
   * @example
   * 1
   */
  cycle?: number;
  /**
   * @remarks
   * The committed completion time in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
   * 
   * @example
   * 00:00
   */
  time?: string;
  static names(): { [key: string]: string } {
    return {
      cycle: 'Cycle',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycle: 'number',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels extends $tea.Model {
  /**
   * @remarks
   * The alert notification methods.
   */
  channels?: string[];
  /**
   * @remarks
   * The severity level.
   * 
   * Valid values:
   * 
   * *   Warning
   * *   Critical
   * 
   * @example
   * Warning
   */
  severity?: string;
  static names(): { [key: string]: string } {
    return {
      channels: 'Channels',
      severity: 'Severity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channels: { 'type': 'array', 'itemType': 'string' },
      severity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers extends $tea.Model {
  /**
   * @remarks
   * The recipient type.
   * 
   * *   If the alert notification method is Mail, Phone, or Sms, the recipient type is Alibaba Cloud account ID.
   * *   If the alert notification method is Ding, the recipient type is DingTalk chatbot token.
   * 
   * @example
   * DingToken
   */
  receiverType?: string;
  /**
   * @remarks
   * The recipients.
   */
  receiverValues?: string[];
  static names(): { [key: string]: string } {
    return {
      receiverType: 'ReceiverType',
      receiverValues: 'ReceiverValues',
    };
  }

  static types(): { [key: string]: any } {
    return {
      receiverType: 'string',
      receiverValues: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIAlarmRuleRequestNotificationSettings extends $tea.Model {
  /**
   * @remarks
   * The duration of the alert suppression interval. Default value: 5. Unit: minutes.
   * 
   * @example
   * 5
   */
  inhibitionInterval?: number;
  /**
   * @remarks
   * The alert notification methods.
   * 
   * This parameter is required.
   */
  notificationChannels?: CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels[];
  /**
   * @remarks
   * The alert notification recipients.
   * 
   * This parameter is required.
   */
  notificationReceivers?: CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers[];
  static names(): { [key: string]: string } {
    return {
      inhibitionInterval: 'InhibitionInterval',
      notificationChannels: 'NotificationChannels',
      notificationReceivers: 'NotificationReceivers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inhibitionInterval: 'number',
      notificationChannels: { 'type': 'array', 'itemType': CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels },
      notificationReceivers: { 'type': 'array', 'itemType': CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIAlarmRuleRequestTriggerConditions extends $tea.Model {
  /**
   * @remarks
   * The time interval for alert calculation. Unit: minutes.
   * 
   * @example
   * 15
   */
  duration?: number;
  /**
   * @remarks
   * The severity level. Valid values:
   * 
   * *   Warning
   * *   Critical
   * 
   * @example
   * Warning
   */
  severity?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * *   If the alert rule is for task status, you do not need to specify a threshold.
   * *   If the alert rule is for failovers, specify the number of failovers.
   * *   If the alert rule is for latency, the threshold is the latency duration, in seconds.
   * 
   * @example
   * 5
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      severity: 'Severity',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      severity: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestDestinationDataSourceSettings extends $tea.Model {
  /**
   * @remarks
   * The name of the data source.
   * 
   * @example
   * holo_datasource_1
   */
  dataSourceName?: string;
  /**
   * @remarks
   * The properties of the data source.
   */
  dataSourceProperties?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      dataSourceName: 'DataSourceName',
      dataSourceProperties: 'DataSourceProperties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceName: 'string',
      dataSourceProperties: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestJobSettingsColumnDataTypeSettings extends $tea.Model {
  /**
   * @remarks
   * The data type of a destination field.
   * 
   * @example
   * text
   */
  destinationDataType?: string;
  /**
   * @remarks
   * The data type of a source field.
   * 
   * @example
   * bigint
   */
  sourceDataType?: string;
  static names(): { [key: string]: string } {
    return {
      destinationDataType: 'DestinationDataType',
      sourceDataType: 'SourceDataType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationDataType: 'string',
      sourceDataType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestJobSettingsCycleScheduleSettings extends $tea.Model {
  /**
   * @remarks
   * The synchronization type that requires periodic scheduling. Valid values:
   * 
   * *   Full: full synchronization
   * *   OfflineIncremental: batch incremental synchronization
   * 
   * @example
   * Full
   */
  cycleMigrationType?: string;
  /**
   * @remarks
   * The scheduling parameters.
   * 
   * @example
   * bizdate=$bizdate
   */
  scheduleParameters?: string;
  static names(): { [key: string]: string } {
    return {
      cycleMigrationType: 'CycleMigrationType',
      scheduleParameters: 'ScheduleParameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycleMigrationType: 'string',
      scheduleParameters: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestJobSettingsDdlHandlingSettings extends $tea.Model {
  /**
   * @remarks
   * The processing policy for DDL messages. Valid values:
   * 
   * *   Ignore: ignores a DDL message.
   * *   Critical: reports an error for a DDL message.
   * *   Normal: normally processes a DDL message.
   * 
   * @example
   * Critical
   */
  action?: string;
  /**
   * @remarks
   * The type of the DDL operation. Valid values:
   * 
   * *   RenameColumn
   * *   ModifyColumn
   * *   CreateTable
   * *   TruncateTable
   * *   DropTable
   * *   DropColumn
   * *   AddColumn
   * 
   * @example
   * AddColumn
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestJobSettingsImportRuleSettings extends $tea.Model {
  /**
   * @remarks
   * The ID of the task to be imported.
   * 
   * @example
   * 10000
   */
  fileId?: string;
  /**
   * @remarks
   * The import source of the task. Set the value to Datastudio, which indicates synchronization tasks created in DataStudio.
   * 
   * @example
   * Datastudio
   */
  source?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'string',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestJobSettingsRuntimeSettings extends $tea.Model {
  /**
   * @remarks
   * The name of the configuration item. Valid values:
   * 
   * *   runtime.offline.speed.limit.mb: indicates the maximum transmission rate that is allowed for a batch synchronization task. This configuration item takes effect only when runtime.offline.speed.limit.enable is set to true.
   * *   runtime.offline.speed.limit.enable: indicates whether throttling is enabled for a batch synchronization task.
   * *   dst.offline.connection.max: indicates the maximum number of connections that are allowed for writing data to the destination of a batch synchronization task.
   * *   runtime.offline.concurrent: indicates the maximum number of parallel threads that are allowed for a batch synchronization task.
   * *   dst.realtime.connection.max: indicates the maximum number of connections that are allowed for writing data to the destination of a real-time synchronization task.
   * *   runtime.enable.auto.create.schema: indicates whether schemas are automatically created in the destination of a synchronization task.
   * *   src.offline.datasource.max.connection: indicates the maximum number of connections that are allowed for reading data from the source of a batch synchronization task.
   * *   runtime.realtime.concurrent: indicates the maximum number of parallel threads that are allowed for a real-time synchronization task.
   * 
   * @example
   * runtime.offline.concurrent
   */
  name?: string;
  /**
   * @remarks
   * The value of the configuration item.
   * 
   * @example
   * 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestJobSettings extends $tea.Model {
  /**
   * @remarks
   * The channel control settings for the synchronization task. The value of this parameter must be a JSON string.
   * 
   * @example
   * {"structInfo":"MANAGED","storageType":"TEXTFILE","writeMode":"APPEND","partitionColumns":[{"columnName":"pt","columnType":"STRING","comment":""}],"fieldDelimiter":""}
   */
  channelSettings?: string;
  /**
   * @remarks
   * The settings for data type mappings between source fields and destination fields. The value of this parameter must be an array.
   */
  columnDataTypeSettings?: CreateDIJobRequestJobSettingsColumnDataTypeSettings[];
  /**
   * @remarks
   * The settings for periodic scheduling.
   */
  cycleScheduleSettings?: CreateDIJobRequestJobSettingsCycleScheduleSettings;
  /**
   * @remarks
   * The processing settings for DDL messages.
   */
  ddlHandlingSettings?: CreateDIJobRequestJobSettingsDdlHandlingSettings[];
  /**
   * @remarks
   * The import settings for the synchronization task.
   */
  importRuleSettings?: CreateDIJobRequestJobSettingsImportRuleSettings;
  /**
   * @remarks
   * The runtime settings. The value of this parameter must be an array.
   */
  runtimeSettings?: CreateDIJobRequestJobSettingsRuntimeSettings[];
  static names(): { [key: string]: string } {
    return {
      channelSettings: 'ChannelSettings',
      columnDataTypeSettings: 'ColumnDataTypeSettings',
      cycleScheduleSettings: 'CycleScheduleSettings',
      ddlHandlingSettings: 'DdlHandlingSettings',
      importRuleSettings: 'ImportRuleSettings',
      runtimeSettings: 'RuntimeSettings',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelSettings: 'string',
      columnDataTypeSettings: { 'type': 'array', 'itemType': CreateDIJobRequestJobSettingsColumnDataTypeSettings },
      cycleScheduleSettings: CreateDIJobRequestJobSettingsCycleScheduleSettings,
      ddlHandlingSettings: { 'type': 'array', 'itemType': CreateDIJobRequestJobSettingsDdlHandlingSettings },
      importRuleSettings: CreateDIJobRequestJobSettingsImportRuleSettings,
      runtimeSettings: { 'type': 'array', 'itemType': CreateDIJobRequestJobSettingsRuntimeSettings },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestResourceSettingsOfflineResourceSettings extends $tea.Model {
  /**
   * @remarks
   * The identifier of the resource group for Data Integration used for batch synchronization.
   * 
   * @example
   * S_res_group_111_222
   */
  resourceGroupIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupIdentifier: 'ResourceGroupIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestResourceSettingsRealtimeResourceSettings extends $tea.Model {
  /**
   * @remarks
   * The identifier of the resource group for Data Integration used for real-time synchronization.
   * 
   * @example
   * S_res_group_111_222
   */
  resourceGroupIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupIdentifier: 'ResourceGroupIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestResourceSettings extends $tea.Model {
  /**
   * @remarks
   * The resource used for batch synchronization.
   */
  offlineResourceSettings?: CreateDIJobRequestResourceSettingsOfflineResourceSettings;
  /**
   * @remarks
   * The resource used for real-time synchronization.
   */
  realtimeResourceSettings?: CreateDIJobRequestResourceSettingsRealtimeResourceSettings;
  requestedCu?: number;
  static names(): { [key: string]: string } {
    return {
      offlineResourceSettings: 'OfflineResourceSettings',
      realtimeResourceSettings: 'RealtimeResourceSettings',
      requestedCu: 'RequestedCu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      offlineResourceSettings: CreateDIJobRequestResourceSettingsOfflineResourceSettings,
      realtimeResourceSettings: CreateDIJobRequestResourceSettingsRealtimeResourceSettings,
      requestedCu: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestSourceDataSourceSettings extends $tea.Model {
  /**
   * @remarks
   * The name of the data source.
   * 
   * @example
   * mysql_datasource_1
   */
  dataSourceName?: string;
  /**
   * @remarks
   * The properties of the data source.
   */
  dataSourceProperties?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      dataSourceName: 'DataSourceName',
      dataSourceProperties: 'DataSourceProperties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceName: 'string',
      dataSourceProperties: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestTableMappingsSourceObjectSelectionRules extends $tea.Model {
  /**
   * @remarks
   * The expression.
   * 
   * @example
   * mysql_table_1
   */
  expression?: string;
  /**
   * @remarks
   * The type of the object. Valid values:
   * 
   * *   Table
   * *   Database
   * 
   * @example
   * Table
   */
  objectType?: string;
  static names(): { [key: string]: string } {
    return {
      expression: 'Expression',
      objectType: 'ObjectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expression: 'string',
      objectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestTableMappingsTransformationRules extends $tea.Model {
  /**
   * @remarks
   * The type of the action. Valid values:
   * 
   * *   DefinePrimaryKey
   * *   Rename
   * *   AddColumn
   * *   HandleDml
   * *   DefineIncrementalCondition
   * *   DefineCycleScheduleSettings
   * *   DefineRuntimeSettings
   * *   DefinePartitionKey
   * 
   * @example
   * Rename
   */
  ruleActionType?: string;
  /**
   * @remarks
   * The name of the rule. If the values of the RuleActionType parameter and the RuleTargetType parameter are the same for multiple transformation rules, you must make sure that the transformation rule names are unique.
   * 
   * @example
   * rename_rule_1
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the object on which you want to perform the action. Valid values:
   * 
   * *   Table
   * *   Schema
   * 
   * @example
   * Table
   */
  ruleTargetType?: string;
  static names(): { [key: string]: string } {
    return {
      ruleActionType: 'RuleActionType',
      ruleName: 'RuleName',
      ruleTargetType: 'RuleTargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleActionType: 'string',
      ruleName: 'string',
      ruleTargetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestTableMappings extends $tea.Model {
  /**
   * @remarks
   * The rule used to select synchronization objects in the source. You can configure multiple rules.
   */
  sourceObjectSelectionRules?: CreateDIJobRequestTableMappingsSourceObjectSelectionRules[];
  /**
   * @remarks
   * The transformation rules applied to the selected synchronization objects.
   */
  transformationRules?: CreateDIJobRequestTableMappingsTransformationRules[];
  static names(): { [key: string]: string } {
    return {
      sourceObjectSelectionRules: 'SourceObjectSelectionRules',
      transformationRules: 'TransformationRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceObjectSelectionRules: { 'type': 'array', 'itemType': CreateDIJobRequestTableMappingsSourceObjectSelectionRules },
      transformationRules: { 'type': 'array', 'itemType': CreateDIJobRequestTableMappingsTransformationRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDIJobRequestTransformationRules extends $tea.Model {
  /**
   * @remarks
   * The type of the action. Valid values:
   * 
   * *   DefinePrimaryKey
   * *   Rename
   * *   AddColumn
   * *   HandleDml
   * *   DefineIncrementalCondition
   * *   DefineCycleScheduleSettings
   * *   DefineRuntimeSettings
   * *   DefinePartitionKey
   * 
   * @example
   * Rename
   */
  ruleActionType?: string;
  /**
   * @remarks
   * The expression of the rule. An expression must be a JSON string.
   * 
   * Example of a renaming rule: {"expression":"${srcDatasourceName}_${srcDatabaseName}_0922","variables":[{"variableName":"srcDatabaseName","variableRules":[{"from":"fromdb","to":"todb"}]}]}
   * 
   * *   expression: the expression of the renaming rule. You can use the following variables in an expression: ${srcDatasourceName}, ${srcDatabaseName}, and ${srcTableName}. ${srcDatasourceName} indicates the name of the source. ${srcDatabaseName} indicates the name of a source database. ${srcTableName} indicates the name of a source table.
   * *   variables: the generation rule for a variable used in the expression of the renaming rule. The default value of the specified variable is the original value of the object indicated by the variable. You can define a group of string replacement rules to change the original values based on your business requirements. variableName: the name of the variable. Do not enclose the variable name in ${}. variableRules: the string replacement rules for variables. The system runs the string replacement rules in sequence for string replacement. from specifies the original string. to specifies the new string.
   * 
   * Example of a rule used to add a specific field to the destination and assign a value to the field: {"columns":[{"columnName":"my_add_column","columnValueType":"Constant","columnValue":"123"}]}
   * 
   * *   If you do not configure such a rule, no fields are added to the destination and no values are assigned by default.
   * *   columnName: the name of the field that you want to add.
   * *   columnValueType: the type of the value of the field. Valid values: Constant and Variable.
   * *   columnValue: the value of the field that you want to add. If you set the valueType parameter to Constant, set the columnValue parameter to a custom constant of the STRING type. If you set the valueType parameter to Variable, set the columnValue to a built-in variable. The following built-in variables are supported: EXECUTE_TIME (LONG data type), DB_NAME_SRC (STRING data type), DATASOURCE_NAME_SRC (STRING data type), TABLE_NAME_SRC (STRING data type), DB_NAME_DEST (STRING data type), DATASOURCE_NAME_DEST (STRING data type), TABLE_NAME_DEST (STRING data type), and DB_NAME_SRC_TRANSED (STRING data type). EXECUTE_TIME specifies the execution time. DB_NAME_SRC specifies the name of a source database. DATASOURCE_NAME_SRC specifies the name of the source. TABLE_NAME_SRC specifies the name of a source table. DB_NAME_DEST specifies the name of a destination database. DATASOURCE_NAME_DEST specifies the name of the destination. TABLE_NAME_DEST specifies the name of a destination table. DB_NAME_SRC_TRANSED specifies the database name obtained after a transformation.
   * 
   * Example of a rule used to specify primary key fields for a destination table: {"columns":["ukcolumn1","ukcolumn2"]}
   * 
   * *   If you do not configure such a rule, the primary key fields in the mapped source table are used for the destination table by default.
   * *   If the destination table is an existing table, Data Integration does not modify the schema of the destination table. If the specified primary key fields do not exist in the destination table, an error is reported when the synchronization task starts to run.
   * *   If the destination table is automatically created by the system, Data Integration automatically creates the schema of the destination table. The schema contains the primary key fields that you specify. If the specified primary key fields do not exist in the destination table, an error is reported when the synchronization task starts to run.
   * 
   * Example of a rule used to process DML messages: {"dmlPolicies":[{"dmlType":"Delete","dmlAction":"Filter","filterCondition":"id > 1"}]}
   * 
   * *   If you do not configure such a rule, the default processing policy for messages generated for insert, update, and delete operations is Normal.
   * *   dmlType: the DML operation. Valid values: Insert, Update, and Delete.
   * *   dmlAction: the processing policy for DML messages. Valid values: Normal, Ignore, Filter, and LogicalDelete. Filter indicates conditional processing. You can set the dmlAction parameter to Filter only when the dmlType parameter is set to Update or Delete.
   * *   filterCondition: the condition used to filter DML messages. This parameter is required only when the dmlAction parameter is set to Filter.
   * 
   * @example
   * {"expression":"${srcDatasoureName}_${srcDatabaseName}"}
   */
  ruleExpression?: string;
  /**
   * @remarks
   * The name of the rule. If the values of the RuleActionType parameter and the RuleTargetType parameter are the same for multiple transformation rules, you must make sure that the transformation rule names are unique.
   * 
   * @example
   * rename_rule_1
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the object on which you want to perform the action. Valid values:
   * 
   * *   Table
   * *   Schema
   * 
   * @example
   * Table
   */
  ruleTargetType?: string;
  static names(): { [key: string]: string } {
    return {
      ruleActionType: 'RuleActionType',
      ruleExpression: 'RuleExpression',
      ruleName: 'RuleName',
      ruleTargetType: 'RuleTargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleActionType: 'string',
      ruleExpression: 'string',
      ruleName: 'string',
      ruleTargetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateDISyncTaskResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the data synchronization task that is created.
   * 
   * @example
   * 1000001
   */
  fileId?: number;
  /**
   * @remarks
   * The error message that is returned if the data synchronization task fails to be created. If the data synchronization task is successfully created, this parameter is not returned. If the data synchronization task fails to be created, an error message in the "Invalid path: Workflow/xxxx/Data Integration" format is returned.
   * 
   * @example
   * Invalid path: Business Flow/xxxx/Data Integration
   */
  message?: string;
  /**
   * @remarks
   * The creation status of the data synchronization task. Valid values:
   * 
   * *   success
   * *   fail
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      message: 'Message',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      message: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMetaCategoryResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The category ID.
   * 
   * @example
   * 223
   */
  categoryId?: number;
  static names(): { [key: string]: string } {
    return {
      categoryId: 'CategoryId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePermissionApplyOrderRequestApplyObjectColumnMetaList extends $tea.Model {
  /**
   * @remarks
   * The field on which you want to request permissions. If you want to request permissions on an entire table, enter all fields in the table. You can request permissions on specific fields of a table in a MaxCompute project only after LabelSecurity is enabled for this project. If LabelSecurity is disabled, you can request permissions only on an entire table.
   * 
   * This parameter is required.
   * 
   * @example
   * aColumnName
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePermissionApplyOrderRequestApplyObject extends $tea.Model {
  /**
   * @remarks
   * The permission that you want to request. If you want to request multiple permissions at the same time, separate them with commas (,). You can request only the following permissions: Select, Describe, Drop, Alter, Update, and Download.
   * 
   * This parameter is required.
   * 
   * @example
   * Select,Describe
   */
  actions?: string;
  /**
   * @remarks
   * The fields on which you want to request permissions.
   * 
   * This parameter is required.
   */
  columnMetaList?: CreatePermissionApplyOrderRequestApplyObjectColumnMetaList[];
  /**
   * @remarks
   * The name of the object on which you want to request permissions. You can request permissions only on MaxCompute tables. Set this parameter to the name of the table on which you want to request permissions.
   * 
   * This parameter is required.
   * 
   * @example
   * aTableName
   */
  name?: string;
  static names(): { [key: string]: string } {
    return {
      actions: 'Actions',
      columnMetaList: 'ColumnMetaList',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actions: 'string',
      columnMetaList: { 'type': 'array', 'itemType': CreatePermissionApplyOrderRequestApplyObjectColumnMetaList },
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateProjectRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * This parameter is required.
   * 
   * @example
   * key
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * This parameter is required.
   * 
   * @example
   * value
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTableRequestColumns extends $tea.Model {
  /**
   * @remarks
   * The name of the field. You can configure a maximum of 1,000 fields when you call the CreateTable operation to create a table.
   * 
   * This parameter is required.
   * 
   * @example
   * columnName1
   */
  columnName?: string;
  /**
   * @remarks
   * The display name of the field.
   */
  columnNameCn?: string;
  /**
   * @remarks
   * The data type of the field. For information about supported data types, see [Data type editions](https://help.aliyun.com/document_detail/27821.html) in MaxCompute documentation.
   * 
   * This parameter is required.
   * 
   * @example
   * string
   */
  columnType?: string;
  /**
   * @remarks
   * The comment of the field.
   */
  comment?: string;
  /**
   * @remarks
   * Specifies whether the field is a partition field.
   * 
   * @example
   * true
   */
  isPartitionCol?: boolean;
  /**
   * @remarks
   * The length of the field. For more information, see [MaxCompute data type editions](https://help.aliyun.com/document_detail/159541.html).
   * 
   * @example
   * 10
   */
  length?: number;
  /**
   * @remarks
   * The sequence number of the field. You can use this parameter to specify how fields are sorted in a table. By default, fields are sorted based on the order in which requests are created. If the field is a partition field, this parameter is not supported.
   * 
   * @example
   * 1
   */
  seqNumber?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      columnNameCn: 'ColumnNameCn',
      columnType: 'ColumnType',
      comment: 'Comment',
      isPartitionCol: 'IsPartitionCol',
      length: 'Length',
      seqNumber: 'SeqNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      columnNameCn: 'string',
      columnType: 'string',
      comment: 'string',
      isPartitionCol: 'boolean',
      length: 'number',
      seqNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTableRequestThemes extends $tea.Model {
  /**
   * @remarks
   * The theme ID.
   * 
   * @example
   * 101
   */
  themeId?: number;
  /**
   * @remarks
   * The level that corresponds to the theme ID.
   * 
   * @example
   * 101
   */
  themeLevel?: number;
  static names(): { [key: string]: string } {
    return {
      themeId: 'ThemeId',
      themeLevel: 'ThemeLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      themeId: 'number',
      themeLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTableResponseBodyTaskInfo extends $tea.Model {
  /**
   * @remarks
   * The details about the status of the current subtask.
   * 
   * *   If the current subtask is successful, success is returned.
   * *   If the current subtask fails, the error details are displayed.
   * 
   * @example
   * success
   */
  content?: string;
  /**
   * @remarks
   * The ID of the subtask that you want to run. If this parameter is left empty, all subtasks are complete.
   * 
   * @example
   * abc1
   */
  nextTaskId?: string;
  /**
   * @remarks
   * The status of the current subtask. Valid values:
   * 
   * *   operating: The subtask is running.
   * *   success: The subtask succeeds.
   * *   failure: The subtask fails to run. For more information about the error details, see the Content parameter.
   * 
   * @example
   * success
   */
  status?: string;
  /**
   * @remarks
   * The ID of the current subtask.
   * 
   * @example
   * abc
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      nextTaskId: 'NextTaskId',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      nextTaskId: 'string',
      status: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteDISyncTaskResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The reason why the synchronization task fails to be deleted. If the synchronization task is deleted, the value null is returned for this parameter.
   * 
   * @example
   * fileId:[100] is invalid.
   */
  message?: string;
  /**
   * @remarks
   * Indicates whether the synchronization task is deleted. Valid values:
   * 
   * *   success: The synchronization task is deleted.
   * *   fail: The synchronization task fails to be deleted. You can troubleshoot the issue based on the failure reason.
   * 
   * @example
   * fail
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTableResponseBodyTaskInfo extends $tea.Model {
  /**
   * @remarks
   * The content of the task.
   * 
   * @example
   * success
   */
  content?: string;
  /**
   * @remarks
   * The ID of the task that is running.
   * 
   * @example
   * abc1
   */
  nextTaskId?: string;
  /**
   * @remarks
   * The status of the task that is complete.
   * 
   * @example
   * success
   */
  status?: string;
  /**
   * @remarks
   * The ID of the task that is complete.
   * 
   * @example
   * abc
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      nextTaskId: 'NextTaskId',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      nextTaskId: 'string',
      status: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeployDISyncTaskResponseBodyData extends $tea.Model {
  /**
   * @example
   * submit and deploy fail.
   */
  message?: string;
  /**
   * @remarks
   * The cause of the failure to deploy the real-time synchronization node or data synchronization solution.
   * 
   * If the real-time synchronization node or data synchronization solution is deployed, the value null is returned.
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanAddOrUpdateRequestDesensRulesDesensPlan extends $tea.Model {
  /**
   * @remarks
   * The masking method configured in the data masking rule. Valid values:
   * 
   * *   hash
   * *   mapping
   * *   mask
   * *   charreplacement
   * *   intervalselect
   * *   decimalpoint
   * *   emptydesens
   * 
   * This parameter is required.
   * 
   * @example
   * hash
   */
  desensPlanType?: string;
  /**
   * @remarks
   * The parameters for the data masking rule.
   */
  extParam?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      desensPlanType: 'DesensPlanType',
      extParam: 'ExtParam',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desensPlanType: 'string',
      extParam: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanAddOrUpdateRequestDesensRules extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to add a watermark. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  checkWatermark?: boolean;
  /**
   * @remarks
   * The sensitive field type.
   * 
   * This parameter is required.
   * 
   * @example
   * phone
   */
  dataType?: string;
  /**
   * @remarks
   * The data masking rule.
   * 
   * This parameter is required.
   */
  desensPlan?: DsgDesensPlanAddOrUpdateRequestDesensRulesDesensPlan;
  /**
   * @remarks
   * The ID of the data masking rule. You can call the [DsgDesensPlanQueryList](https://help.aliyun.com/document_detail/2786578.html) operation to query the ID of the data masking rule.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The owner of the data masking rule.
   * 
   * This parameter is required.
   * 
   * @example
   * test_user
   */
  owner?: string;
  /**
   * @remarks
   * The name of the data masking rule.
   * 
   * This parameter is required.
   * 
   * @example
   * phone_hash
   */
  ruleName?: string;
  /**
   * @remarks
   * The level-2 data masking scenario.
   * 
   * This parameter is required.
   */
  sceneIds?: number[];
  /**
   * @remarks
   * The status of the data masking rule. Valid values:
   * 
   * *   0: expired
   * *   1: effective
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      checkWatermark: 'CheckWatermark',
      dataType: 'DataType',
      desensPlan: 'DesensPlan',
      id: 'Id',
      owner: 'Owner',
      ruleName: 'RuleName',
      sceneIds: 'SceneIds',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkWatermark: 'boolean',
      dataType: 'string',
      desensPlan: DsgDesensPlanAddOrUpdateRequestDesensRulesDesensPlan,
      id: 'number',
      owner: 'string',
      ruleName: 'string',
      sceneIds: { 'type': 'array', 'itemType': 'number' },
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanQueryListResponseBodyPageDataDataDesensPlan extends $tea.Model {
  /**
   * @remarks
   * The type of the data masking rule.
   * 
   * @example
   * hash
   */
  desensPlanType?: string;
  /**
   * @remarks
   * The parameters for the data masking rule. For more information about the parameters, see the [DsgDesensPlanAddOrUpdate](https://help.aliyun.com/document_detail/2786295.html) API reference.
   */
  extParam?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      desensPlanType: 'DesensPlanType',
      extParam: 'ExtParam',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desensPlanType: 'string',
      extParam: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanQueryListResponseBodyPageDataData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether a watermark is added. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  checkWatermark?: boolean;
  /**
   * @remarks
   * The sensitive field type.
   * 
   * @example
   * phone
   */
  dataType?: string;
  /**
   * @remarks
   * The type of the data masking method.
   * 
   * @example
   * HASH
   */
  desenMode?: string;
  /**
   * @remarks
   * The details of the data masking rule.
   */
  desensPlan?: DsgDesensPlanQueryListResponseBodyPageDataDataDesensPlan;
  /**
   * @remarks
   * The data masking rule.
   * 
   * @example
   * HASH
   */
  desensRule?: string;
  /**
   * @remarks
   * The data masking method.
   * 
   * @example
   * HASH
   */
  desensWay?: string;
  /**
   * @remarks
   * The time when the data masking rule was created.
   * 
   * @example
   * 2024-05-09 15:46:20
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the data masking rule was modified.
   * 
   * @example
   * 2024-05-09 15:46:20
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the data masking rule.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The owner of the data masking rule.
   * 
   * @example
   * user1
   */
  owner?: string;
  /**
   * @remarks
   * The name of the data masking rule.
   * 
   * @example
   * phone_hash
   */
  ruleName?: string;
  /**
   * @remarks
   * The code of the level-1 data masking scenario to which the rule belongs. Valid values:
   * 
   * *   dataworks_display_desense_code: masking of displayed data in DataStudio and Data Map
   * *   maxcompute_desense_code: data masking at the MaxCompute compute engine layer
   * *   maxcompute_new_desense_code: data masking at the MaxCompute compute engine layer (new)
   * *   hologres_display_desense_code: data masking at the Hologres compute engine layer
   * *   dataworks_data_integration_desense_code: static data masking in Data Integration
   * *   dataworks_analysis_desense_code: masking of displayed data in DataAnalysis
   * 
   * @example
   * dataworks_display_desense_code
   */
  sceneCode?: string;
  /**
   * @remarks
   * The name of the level-2 data masking scenario to which the data masking rule belongs.
   * 
   * @example
   * test_scene
   */
  sceneName?: string;
  /**
   * @remarks
   * The status of the data masking rule. Valid values:
   * 
   * *   0: expired
   * *   1: effective
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      checkWatermark: 'CheckWatermark',
      dataType: 'DataType',
      desenMode: 'DesenMode',
      desensPlan: 'DesensPlan',
      desensRule: 'DesensRule',
      desensWay: 'DesensWay',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      owner: 'Owner',
      ruleName: 'RuleName',
      sceneCode: 'SceneCode',
      sceneName: 'SceneName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkWatermark: 'boolean',
      dataType: 'string',
      desenMode: 'string',
      desensPlan: DsgDesensPlanQueryListResponseBodyPageDataDataDesensPlan,
      desensRule: 'string',
      desensWay: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      owner: 'string',
      ruleName: 'string',
      sceneCode: 'string',
      sceneName: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgDesensPlanQueryListResponseBodyPageData extends $tea.Model {
  /**
   * @remarks
   * The information about the data masking rule.
   */
  data?: DsgDesensPlanQueryListResponseBodyPageDataData[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The number of data masking rules.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DsgDesensPlanQueryListResponseBodyPageDataData },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgPlatformQueryProjectsAndSchemaFromMetaResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the EMR cluster. This parameter is generated only when the request parameter EngineName is set to EMR.
   * 
   * @example
   * c-12345
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the compute engine.
   * 
   * @example
   * emr_test_project
   */
  project?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      project: 'Project',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      project: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgQueryDefaultTemplatesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The sensitive field type.
   * 
   * @example
   * phone
   */
  dataType?: string;
  /**
   * @remarks
   * The supported data masking methods and parameter descriptions.
   */
  desensPlanTemplate?: { [key: string]: DataDesensPlanTemplateValue[] };
  static names(): { [key: string]: string } {
    return {
      dataType: 'DataType',
      desensPlanTemplate: 'DesensPlanTemplate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataType: 'string',
      desensPlanTemplate: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DataDesensPlanTemplateValue } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgRunSensIdentifyRequestEsMetaParams extends $tea.Model {
  /**
   * @remarks
   * The cluster ID. You can obtain the ID based on the data source you use.
   * 
   * @example
   * 101010
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the data source. Valid values:
   * 
   * *   ODPS.ODPS
   * *   EMR
   * *   HOLO.POSTGRES
   * 
   * @example
   * ODPS.ODPS
   */
  dbType?: string;
  /**
   * @remarks
   * The instance ID. You can obtain the ID based on the data source you use.
   * 
   * @example
   * hgprecn-cn-9lb37k181024
   */
  instanceId?: number;
  /**
   * @remarks
   * The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace page to query the name.
   * 
   * @example
   * 1666676756691024
   */
  projectName?: string;
  /**
   * @remarks
   * The name of the schema.
   * 
   * @example
   * default
   */
  schemaName?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * table1
   */
  tableName?: string;
  /**
   * @remarks
   * The names of the tables.
   */
  tableNameList?: string[];
  /**
   * @remarks
   * The username of the operator. We recommend that you enter the username of your Alibaba Cloud account.
   * 
   * @example
   * xxx-uat
   */
  user?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dbType: 'DbType',
      instanceId: 'InstanceId',
      projectName: 'ProjectName',
      schemaName: 'SchemaName',
      tableName: 'TableName',
      tableNameList: 'TableNameList',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dbType: 'string',
      instanceId: 'number',
      projectName: 'string',
      schemaName: 'string',
      tableName: 'string',
      tableNameList: { 'type': 'array', 'itemType': 'string' },
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgSceneAddOrUpdateSceneRequestScenesProjects extends $tea.Model {
  /**
   * @remarks
   * If the data masking scenario takes effect for an E-MapReduce (EMR) compute engine, enter the ID of an EMR cluster. This parameter is required only when you use an EMR compute engine.
   * 
   * @example
   * c-1234
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the compute engine for which the data masking scenario takes effect. Valid values:
   * 
   * *   ODPS: ODPS.ODPS
   * *   HOLO: HOLO.POSTGRES
   * *   EMR: EMR
   * 
   * @example
   * ODPS.ODPS
   */
  dbType?: string;
  /**
   * @remarks
   * The name of the compute engine instance for which the data masking scenario takes effect.
   * 
   * @example
   * dev_project
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'clusterId',
      dbType: 'dbType',
      projectName: 'projectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dbType: 'string',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgSceneAddOrUpdateSceneRequestScenes extends $tea.Model {
  /**
   * @remarks
   * The description.
   */
  desc?: string;
  /**
   * @remarks
   * The ID of the level-2 data masking scenario.
   * 
   * *   If you do not configure this parameter, the current operation is to add a level-2 data masking scenario.
   * *   If you configure this parameter, the current operation is to modify a level-2 data masking scenario. You can call the [DsgSceneQuerySceneListByName](https://help.aliyun.com/document_detail/2786322.html) operation to query the ID of the level-2 data masking scenario.
   * 
   * @example
   * 123
   */
  id?: string;
  /**
   * @remarks
   * The information about the compute engine for which the data masking scenario takes effect.
   */
  projects?: DsgSceneAddOrUpdateSceneRequestScenesProjects[];
  /**
   * @remarks
   * The code of the level-1 data masking scenario to which the level-2 data masking scenario belongs. Valid values:
   * 
   * *   dataworks_display_desense_code: masking of displayed data in DataStudio and Data Map
   * *   maxcompute_desense_code: data masking at the MaxCompute compute engine layer
   * *   maxcompute_new_desense_code: data masking at the MaxCompute compute engine layer (new)
   * *   dataworks_analysis_desense_code: masking of displayed data in DataAnalysis
   * 
   * This parameter is required.
   * 
   * @example
   * dataworks_display_desense_code
   */
  sceneCode?: string;
  /**
   * @remarks
   * The name of the level-2 data masking scenario.
   * 
   * This parameter is required.
   * 
   * @example
   * dev_scene
   */
  sceneName?: string;
  /**
   * @remarks
   * The information about the user group for which the data masking scenario takes effect.
   */
  userGroupIds?: number[];
  static names(): { [key: string]: string } {
    return {
      desc: 'desc',
      id: 'id',
      projects: 'projects',
      sceneCode: 'sceneCode',
      sceneName: 'sceneName',
      userGroupIds: 'userGroupIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      desc: 'string',
      id: 'string',
      projects: { 'type': 'array', 'itemType': DsgSceneAddOrUpdateSceneRequestScenesProjects },
      sceneCode: 'string',
      sceneName: 'string',
      userGroupIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgSceneQuerySceneListByNameResponseBodyDataProjects extends $tea.Model {
  /**
   * @remarks
   * The ID of the EMR cluster. This parameter is returned only when the data scope that takes effect in the data masking scenario is an EMR compute engine.
   * 
   * @example
   * c-1234
   */
  clusterId?: string;
  /**
   * @remarks
   * The type of the compute engine. Valid values:
   * 
   * *   ODPS: ODPS.ODPS
   * *   HOLO: HOLO.POSTGRES
   * *   EMR: EMR
   * 
   * @example
   * ODPS.ODPS
   */
  dbType?: string;
  /**
   * @remarks
   * The name of the compute engine.
   * 
   * @example
   * dev_project
   */
  projectName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dbType: 'DbType',
      projectName: 'ProjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dbType: 'string',
      projectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgSceneQuerySceneListByNameResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The information about multiple levels of data masking scenarios.
   */
  children?: any[];
  /**
   * @remarks
   * The description of the data masking scenario.
   */
  desc?: string;
  /**
   * @remarks
   * The ID of the data masking scenario.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The information about the compute engine for which the data masking scenario takes effect.
   */
  projects?: DsgSceneQuerySceneListByNameResponseBodyDataProjects[];
  /**
   * @remarks
   * The code of the level-1 data masking scenario. Valid values:
   * 
   * *   dataworks_display_desense_code: masking of displayed data in DataStudio and Data Map
   * *   maxcompute_desense_code: data masking at the MaxCompute compute engine layer
   * *   maxcompute_new_desense_code: data masking at the MaxCompute compute engine layer (new)
   * *   hologres_display_desense_code: data masking at the Hologres compute engine layer
   * *   dataworks_data_integration_desense_code: static data masking in Data Integration
   * *   dataworks_analysis_desense_code: masking of displayed data in DataAnalysis
   * 
   * @example
   * dataworks_display_desense_code
   */
  sceneCode?: string;
  /**
   * @remarks
   * The level of the data masking scenario. Valid values:
   * 
   * *   0: level-1 data masking scenario
   * *   1: level-2 data masking scenario
   * 
   * @example
   * 1
   */
  sceneLevel?: number;
  /**
   * @remarks
   * The name of the data masking scenario.
   * 
   * @example
   * test_scene
   */
  sceneName?: string;
  /**
   * @remarks
   * The list of user groups in the data masking scenario. Separate user groups with commas (,).
   * 
   * @example
   * user1,user2
   */
  userGroups?: string;
  static names(): { [key: string]: string } {
    return {
      children: 'Children',
      desc: 'Desc',
      id: 'Id',
      projects: 'Projects',
      sceneCode: 'SceneCode',
      sceneLevel: 'SceneLevel',
      sceneName: 'SceneName',
      userGroups: 'UserGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      children: { 'type': 'array', 'itemType': 'any' },
      desc: 'string',
      id: 'number',
      projects: { 'type': 'array', 'itemType': DsgSceneQuerySceneListByNameResponseBodyDataProjects },
      sceneCode: 'string',
      sceneLevel: 'number',
      sceneName: 'string',
      userGroups: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupAddOrUpdateRequestUserGroups extends $tea.Model {
  /**
   * @remarks
   * The users in the group.
   * 
   * *   If a user group is created by using an Alibaba Cloud account and a RAM role, you can call the [DsgUserGroupQueryUserList](https://help.aliyun.com/document_detail/2786445.html) operation to query the users in the group.
   * *   If a user group is created by using a MaxCompute role, you can call the [DsgUserGroupQueryUserList](https://help.aliyun.com/document_detail/2785695.html) operation to query the users in the group.
   * 
   * This parameter is required.
   */
  accounts?: string[];
  /**
   * @remarks
   * The user group ID.
   * 
   * *   If you do not configure this parameter, the current operation is to add a user group.
   * *   If you configure this parameter, the current operation is to modify a user group. You can call the [DsgUserGroupQueryList](https://help.aliyun.com/document_detail/2786441.html) operation to query the user group ID.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The name of the user group.
   * 
   * This parameter is required.
   * 
   * @example
   * yun_group
   */
  name?: string;
  /**
   * @remarks
   * The owner of the user group.
   * 
   * This parameter is required.
   * 
   * @example
   * user1
   */
  owner?: string;
  /**
   * @remarks
   * The name of the MaxCompute project. You must configure this parameter when you create a MaxCompute user group.
   * 
   * @example
   * dev_project
   */
  projectName?: string;
  /**
   * @remarks
   * The type of the user group. Valid values:
   * 
   * *   1: Alibaba Cloud account
   * *   2: RAM role
   * *   3: MaxCompute role
   * 
   * This parameter is required.
   * 
   * @example
   * 1
   */
  userGroupType?: number;
  static names(): { [key: string]: string } {
    return {
      accounts: 'Accounts',
      id: 'Id',
      name: 'Name',
      owner: 'Owner',
      projectName: 'ProjectName',
      userGroupType: 'UserGroupType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accounts: { 'type': 'array', 'itemType': 'string' },
      id: 'number',
      name: 'string',
      owner: 'string',
      projectName: 'string',
      userGroupType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupQueryListResponseBodyPageDataData extends $tea.Model {
  /**
   * @remarks
   * The usernames in the user group.
   */
  accounts?: string[];
  /**
   * @remarks
   * The time when the user group was created.
   * 
   * @example
   * 2024-05-10 17:14:44
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the user group was modified.
   * 
   * @example
   * 2024-05-10 17:14:44
   */
  gmtModified?: string;
  /**
   * @remarks
   * The user group ID.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The name of the user group.
   * 
   * @example
   * test_group
   */
  name?: string;
  /**
   * @remarks
   * The owner of the user group.
   * 
   * @example
   * user1
   */
  owner?: string;
  static names(): { [key: string]: string } {
    return {
      accounts: 'Accounts',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      owner: 'Owner',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accounts: { 'type': 'array', 'itemType': 'string' },
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      name: 'string',
      owner: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupQueryListResponseBodyPageData extends $tea.Model {
  /**
   * @remarks
   * The user groups.
   */
  data?: DsgUserGroupQueryListResponseBodyPageDataData[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of user groups returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DsgUserGroupQueryListResponseBodyPageDataData },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgUserGroupQueryUserListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the user.
   * 
   * @example
   * user1
   */
  accountName?: string;
  /**
   * @remarks
   * The type of the user. Valid values:
   * 
   * *   1 to 5: Alibaba Cloud account
   * *   6: RAM role
   * 
   * @example
   * 2
   */
  accountType?: number;
  /**
   * @remarks
   * The user ID or role ID.
   * 
   * @example
   * 234
   */
  baseId?: string;
  /**
   * @remarks
   * The parent user ID. This parameter is required if a RAM user is used.
   * 
   * @example
   * 123
   */
  parentAccountId?: string;
  /**
   * @remarks
   * The name of the Alibaba Cloud account or RAM role. The return value of this parameter must be used if the user group is created by using an Alibaba Cloud account or a RAM role.
   * 
   * @example
   * user:user1
   */
  yunAccount?: string;
  static names(): { [key: string]: string } {
    return {
      accountName: 'AccountName',
      accountType: 'AccountType',
      baseId: 'BaseId',
      parentAccountId: 'ParentAccountId',
      yunAccount: 'YunAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountName: 'string',
      accountType: 'number',
      baseId: 'string',
      parentAccountId: 'string',
      yunAccount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListAddOrUpdateRequestWhiteLists extends $tea.Model {
  /**
   * @remarks
   * The end of the time range to query. If you enter null, the whitelist is valid permanently.
   * 
   * @example
   * null
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the data masking whitelist.
   * 
   * *   If you do not configure this parameter, the current operation is to add a data masking whitelist.
   * *   If you configure this parameter, the current operation is to modify a data masking whitelist. You can call the [DsgWhiteListQueryList](https://help.aliyun.com/document_detail/2786508.html) operation to query the whitelist ID.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The ID of the data masking rule. You can call the [DsgDesensPlanQueryList](https://help.aliyun.com/document_detail/2786578.html) operation to query the ID of the data masking rule.
   * 
   * This parameter is required.
   * 
   * @example
   * 123
   */
  ruleId?: number;
  /**
   * @remarks
   * The beginning of the time range to query.
   * 
   * This parameter is required.
   * 
   * @example
   * 2024-04-10 00:00:00
   */
  startTime?: string;
  /**
   * @remarks
   * A collection of user group IDs.
   * 
   * This parameter is required.
   */
  userGroupIds?: number[];
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      id: 'Id',
      ruleId: 'RuleId',
      startTime: 'StartTime',
      userGroupIds: 'UserGroupIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      id: 'number',
      ruleId: 'number',
      startTime: 'string',
      userGroupIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListQueryListResponseBodyPageDataData extends $tea.Model {
  /**
   * @remarks
   * The expiration time of the data masking whitelist cannot be earlier than the time when the data masking whitelist takes effect. Unit: days.
   * 
   * @example
   * 2024-05-10 15:46:20
   */
  endTime?: string;
  /**
   * @remarks
   * The time when the whitelist was created.
   * 
   * @example
   * 2024-05-09 15:46:20
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the whitelist was modified.
   * 
   * @example
   * 2024-05-09 15:46:20
   */
  gmtModified?: string;
  /**
   * @remarks
   * The ID of the data masking whitelist.
   * 
   * @example
   * 123
   */
  id?: number;
  /**
   * @remarks
   * The ID of the data masking rule.
   * 
   * @example
   * 123
   */
  ruleId?: number;
  /**
   * @remarks
   * The ID of the level-2 data masking scenario.
   * 
   * @example
   * 123
   */
  sceneId?: number;
  /**
   * @remarks
   * The time when the data masking whitelist takes effect cannot be earlier than the current time. Unit: days.
   * 
   * @example
   * 2024-05-09 15:46:20
   */
  startTime?: string;
  /**
   * @remarks
   * The sensitive field type.
   * 
   * @example
   * phone
   */
  type?: string;
  /**
   * @remarks
   * A collection of user group names.
   */
  userGroups?: string[];
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      ruleId: 'RuleId',
      sceneId: 'SceneId',
      startTime: 'StartTime',
      type: 'Type',
      userGroups: 'UserGroups',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      ruleId: 'number',
      sceneId: 'number',
      startTime: 'string',
      type: 'string',
      userGroups: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DsgWhiteListQueryListResponseBodyPageData extends $tea.Model {
  /**
   * @remarks
   * A collection of whitelists.
   */
  data?: DsgWhiteListQueryListResponseBodyPageDataData[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of data masking whitelists.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DsgWhiteListQueryListResponseBodyPageDataData },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportDataSourcesResponseBodyDataDataSources extends $tea.Model {
  /**
   * @remarks
   * The ID of the compute engine that is added as the data source.
   * 
   * @example
   * 123
   */
  bindingCalcEngineId?: number;
  /**
   * @remarks
   * Indicates whether the data source is connected to an exclusive resource group. Valid values:
   * 
   * *   1: The data source is connected to at least one exclusive resource group.
   * *   0: The data source is not connected to any exclusive resource group.
   * 
   * @example
   * 1
   */
  connectStatus?: number;
  /**
   * @remarks
   * The configuration of the data source.
   * 
   * @example
   * {"pubEndpoint":"http://service.cn.maxcompute.aliyun.com/api","accessId":"TMP.3KecGjvzy3i8MYfn2BGHgF7EHGyBFZcHm7GgngrABVRyvvKQrfF5kskR36xP361C3dqwbGo7SGYptAeGyiTwHXqLaBUvYC","securityToken":null,"endpoint":"http://service.cn.maxcompute.aliyun-inc.com/api","accessKey":"***","name":"PRE_PROJECT_A_engine","project":"PRE_PROJECT_A","vpcEndpoint":"http://service.cn.maxcompute.aliyun-inc.com/api","region":"cn-shanghai","authType":"2"}
   */
  content?: string;
  /**
   * @remarks
   * The type of the data source. Valid values:
   * 
   * *   odps
   * *   mysql
   * *   rds
   * *   oss
   * *   sqlserver
   * *   polardb
   * *   oracle
   * *   mongodb
   * *   emr
   * *   postgresql
   * *   analyticdb_for_mysql
   * *   hybriddb_for_postgresql
   * *   holo
   * 
   * @example
   * rds
   */
  dataSourceType?: string;
  /**
   * @remarks
   * Indicates whether the compute engine that is added as the data source is the default compute engine. Valid values:
   * 
   * *   true: The compute engine is the default compute engine.
   * *   false: The compute engine is not the default compute engine.
   * 
   * @example
   * false
   */
  defaultEngine?: boolean;
  /**
   * @remarks
   * The description of the data source.
   * 
   * @example
   * a connection
   */
  description?: string;
  /**
   * @remarks
   * The environment in which the data source resides. Valid values:
   * 
   * *   0: development environment
   * *   1: production environment
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The time when the data source was created. Example: Mar 17, 2021 4:09:32 PM.
   * 
   * @example
   * Mar 17, 2021 4:09:32 PM
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the data source was last modified. Example: Mar 17, 2021 4:09:32 PM.
   * 
   * @example
   * Mar 17, 2021 4:09:32 PM
   */
  gmtModified?: string;
  /**
   * @remarks
   * The data source ID.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The name of the data source.
   * 
   * @example
   * abc
   */
  name?: string;
  /**
   * @remarks
   * The ID of the user who exported the data source.
   * 
   * @example
   * 193543050****
   */
  operator?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace to which the data source belongs.
   * 
   * @example
   * 123
   */
  projectId?: number;
  /**
   * @remarks
   * The sequence number of the data source.
   * 
   * @example
   * 300
   */
  sequence?: number;
  /**
   * @remarks
   * Indicates whether the data source can be shared. Valid values:
   * 
   * *   true: The data source can be shared.
   * *   false: The data source cannot be shared.
   * 
   * @example
   * false
   */
  shared?: boolean;
  /**
   * @remarks
   * Indicates whether the data source is available. Valid values:
   * 
   * *   1: The data source is available.
   * *   0: The data source is unavailable.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The subtype of the data source. This parameter takes effect only when the DataSourceType parameter is set to rds.
   * 
   * If the value of the DataSourceType parameter is rds, the value of this parameter can be mysql, sqlserver, or postgresql.
   * 
   * @example
   * mysql
   */
  subType?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account to which the data source belongs.
   * 
   * @example
   * 1234567
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      bindingCalcEngineId: 'BindingCalcEngineId',
      connectStatus: 'ConnectStatus',
      content: 'Content',
      dataSourceType: 'DataSourceType',
      defaultEngine: 'DefaultEngine',
      description: 'Description',
      envType: 'EnvType',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      operator: 'Operator',
      projectId: 'ProjectId',
      sequence: 'Sequence',
      shared: 'Shared',
      status: 'Status',
      subType: 'SubType',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindingCalcEngineId: 'number',
      connectStatus: 'number',
      content: 'string',
      dataSourceType: 'string',
      defaultEngine: 'boolean',
      description: 'string',
      envType: 'number',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      name: 'string',
      operator: 'string',
      projectId: 'number',
      sequence: 'number',
      shared: 'boolean',
      status: 'number',
      subType: 'string',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportDataSourcesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The details of the exported data sources. The value is an array. The following parameters are the elements in the array. The sample values of these parameters show the details of a sample data source.
   */
  dataSources?: ExportDataSourcesResponseBodyDataDataSources[];
  /**
   * @remarks
   * The page number. Pages start from page 1.
   * 
   * @example
   * 10
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataSources: 'DataSources',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSources: { 'type': 'array', 'itemType': ExportDataSourcesResponseBodyDataDataSources },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDISyncTaskConfigForCreatingResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The reason why the ID of the asynchronous thread fails to be generated. If the ID is successfully generated, no value is returned for this parameter.
   * 
   * @example
   * XXX is invalid.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the asynchronous thread. You can call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. The parameters are used to create a synchronization task in Data Integration.
   * 
   * @example
   * 10
   */
  processId?: number;
  /**
   * @remarks
   * Indicates whether the ID of the asynchronous thread is generated. Valid values: Valid values:
   * 
   * *   success: indicates that the ID of the asynchronous thread is generated.
   * *   fail: indicates that the ID of the asynchronous thread fails to be generated. You can view the reason for the failure and troubleshoot the issue based on the reason.
   * 
   * @example
   * true
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      processId: 'ProcessId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      processId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateDISyncTaskConfigForUpdatingResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The reason why the ID of the asynchronous thread fails to be generated. If the ID is successfully generated, no value is returned for this parameter.
   * 
   * @example
   * XXX is invalid.
   */
  message?: string;
  /**
   * @remarks
   * The ID of the asynchronous thread. You can call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. The parameters are used to update a real-time synchronization task in Data Integration.
   * 
   * @example
   * 10
   */
  processId?: number;
  /**
   * @remarks
   * Indicates whether the ID of the asynchronous thread is generated. Valid values:
   * 
   * *   success: indicates that the ID of the asynchronous thread is generated.
   * *   fail: indicates that the ID of the asynchronous thread fails to be generated. You can view the reason for the failure and troubleshoot the issue based on the reason.
   * 
   * @example
   * true
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      processId: 'ProcessId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      processId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertMessageResponseBodyDataInstances extends $tea.Model {
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * 12312312
   */
  instanceId?: number;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The status of the instance. Valid values:
   * 
   * *   NOT_RUN
   * *   WAIT_TIME
   * *   WAIT_RESOURCE
   * *   RUNNING
   * *   CHECKING
   * *   CHECKING_CONDITION
   * *   FAILURE
   * *   SUCCESS
   * 
   * @example
   * NOT_RUN
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      projectId: 'ProjectId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      nodeId: 'number',
      nodeName: 'string',
      projectId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertMessageResponseBodyDataNodes extends $tea.Model {
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 95279527952****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      owner: 'Owner',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      nodeName: 'string',
      owner: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertMessageResponseBodyDataSlaAlert extends $tea.Model {
  /**
   * @remarks
   * The baseline ID.
   * 
   * @example
   * 15142123
   */
  baselineId?: number;
  /**
   * @remarks
   * The name of the baseline.
   */
  baselineName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the baseline owner. Multiple IDs are separated by commas (,).
   * 
   * @example
   * 952795279****
   */
  baselineOwner?: string;
  /**
   * @remarks
   * The data timestamp of the baseline instance.
   * 
   * @example
   * 1553443200000
   */
  bizdate?: number;
  /**
   * @remarks
   * The ID of the cycle of the baseline instance. Valid values of the ID of an hour-level cycle: [1,24]. The ID of a day-level cycle is 1.
   * 
   * @example
   * 1
   */
  inGroupId?: number;
  /**
   * @remarks
   * The ID of the workspace to which the baseline belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The status of the baseline. Valid values:
   * 
   * *   ERROR
   * *   SAFE
   * *   DANGEROUS
   * *   OVER
   * 
   * @example
   * SAFE
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      baselineName: 'BaselineName',
      baselineOwner: 'BaselineOwner',
      bizdate: 'Bizdate',
      inGroupId: 'InGroupId',
      projectId: 'ProjectId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      baselineName: 'string',
      baselineOwner: 'string',
      bizdate: 'number',
      inGroupId: 'number',
      projectId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertMessageResponseBodyDataTopics extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance that triggered the event.
   * 
   * @example
   * 12345
   */
  instanceId?: number;
  /**
   * @remarks
   * The ID of the node that triggered the event.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The event ID.
   * 
   * @example
   * 412431
   */
  topicId?: number;
  /**
   * @remarks
   * The name of the event.
   */
  topicName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the event owner.
   * 
   * @example
   * 9527952795****
   */
  topicOwner?: string;
  /**
   * @remarks
   * The status of the event. Valid values:
   * 
   * *   IGNORE
   * *   NEW
   * *   FIXING
   * *   RECOVER
   * 
   * @example
   * FIXING
   */
  topicStatus?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      nodeId: 'NodeId',
      topicId: 'TopicId',
      topicName: 'TopicName',
      topicOwner: 'TopicOwner',
      topicStatus: 'TopicStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      nodeId: 'number',
      topicId: 'number',
      topicName: 'string',
      topicOwner: 'string',
      topicStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlertMessageResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The alert ID.
   * 
   * @example
   * 123
   */
  alertId?: number;
  /**
   * @remarks
   * The sending status of the notification. Valid values:
   * 
   * *   READY_TO_SEND: The notification is waiting to be sent.
   * *   SEND_FAIL: The notification fails to be sent.
   * *   SEND_SUCCESS: The notification is sent.
   * *   SEND_OVERLIMIT: The number of notifications that are sent exceeds the upper limit.
   * 
   * @example
   * READY_TO_SEND
   */
  alertMessageStatus?: string;
  /**
   * @remarks
   * The notification method. Valid values:
   * 
   * *   MAIL.
   * *   SMS.
   * *   PHONE. Only DataWorks Professional Edition and more advanced editions support the PHONE notification method.
   * 
   * @example
   * SMS
   */
  alertMethod?: string;
  /**
   * @remarks
   * The time when the alert was reported.
   * 
   * @example
   * 1553524393000
   */
  alertTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the alert recipient.
   * 
   * @example
   * 9527952795****
   */
  alertUser?: string;
  /**
   * @remarks
   * The content of the alert.
   */
  content?: string;
  /**
   * @remarks
   * The instances that triggered the custom alert rule. This parameter is returned if the value of the Source parameter is REMIND_ALERT. This parameter is left empty if the value of the Source parameter is not REMIND_ALERT.
   */
  instances?: GetAlertMessageResponseBodyDataInstances[];
  /**
   * @remarks
   * The nodes returned for different alert sources. The nodes that form a loop are returned if the value of the Source parameter is NODE_CYCLE_ALERT. The nodes that are isolated are returned if the value of the Source parameter is NODE_LONELY_ALERT.
   */
  nodes?: GetAlertMessageResponseBodyDataNodes[];
  /**
   * @remarks
   * The ID of the custom alert rule that was triggered. This parameter is returned if the value of the Source parameter is REMIND_ALERT.
   * 
   * @example
   * 1234
   */
  remindId?: number;
  /**
   * @remarks
   * The name of the custom alert rule that was triggered. This parameter is returned if the value of the Source parameter is REMIND_ALERT.
   */
  remindName?: string;
  /**
   * @remarks
   * The basic information about the baseline instance that triggered an alert. This parameter is returned if the value of the Source parameter is SLA_ALERT. This parameter is left empty if the value of the Source parameter is not SLA_ALERT.
   */
  slaAlert?: GetAlertMessageResponseBodyDataSlaAlert;
  /**
   * @remarks
   * The type of the alert. Valid values:
   * 
   * *   REMIND_ALERT: The alert is a custom alert.
   * *   TOPIC_ALERT: The alert is an event alert.
   * *   SLA_ALERT: The alert is a baseline alert.
   * *   NODE_CYCLE_ALERT: The alert is reported for a node dependency loop.
   * *   NODE_LONELY_ALERT: The alert is reported for isolated nodes.
   * 
   * @example
   * REMIND_ALERT
   */
  source?: string;
  /**
   * @remarks
   * The events that triggered alerts. This parameter is returned if the value of the Source parameter is TOPIC_ALERT. This parameter is left empty if the value of the Source parameter is not TOPIC_ALERT.
   */
  topics?: GetAlertMessageResponseBodyDataTopics[];
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      alertMessageStatus: 'AlertMessageStatus',
      alertMethod: 'AlertMethod',
      alertTime: 'AlertTime',
      alertUser: 'AlertUser',
      content: 'Content',
      instances: 'Instances',
      nodes: 'Nodes',
      remindId: 'RemindId',
      remindName: 'RemindName',
      slaAlert: 'SlaAlert',
      source: 'Source',
      topics: 'Topics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      alertMessageStatus: 'string',
      alertMethod: 'string',
      alertTime: 'number',
      alertUser: 'string',
      content: 'string',
      instances: { 'type': 'array', 'itemType': GetAlertMessageResponseBodyDataInstances },
      nodes: { 'type': 'array', 'itemType': GetAlertMessageResponseBodyDataNodes },
      remindId: 'number',
      remindName: 'string',
      slaAlert: GetAlertMessageResponseBodyDataSlaAlert,
      source: 'string',
      topics: { 'type': 'array', 'itemType': GetAlertMessageResponseBodyDataTopics },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineResponseBodyDataAlertSettingsDingRobots extends $tea.Model {
  /**
   * @remarks
   * Indicates whether all members were reminded by using the at sign (@).
   * 
   * @example
   * true
   */
  atAll?: boolean;
  /**
   * @remarks
   * The webhook URL of the DingTalk chatbot.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=xxx
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      atAll: 'AtAll',
      webUrl: 'WebUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      atAll: 'boolean',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineResponseBodyDataAlertSettings extends $tea.Model {
  /**
   * @remarks
   * The interval at which an event alert notification is sent. Unit: seconds.
   * 
   * @example
   * 900
   */
  alertInterval?: number;
  /**
   * @remarks
   * The maximum number of times an event alert notification is sent.
   * 
   * @example
   * 1
   */
  alertMaximum?: number;
  /**
   * @remarks
   * The alert notification methods.
   */
  alertMethods?: string[];
  /**
   * @remarks
   * The details of the alert recipient.
   * 
   * *   If the value of AlertRecipientType is OWNER, this parameter is left empty.
   * *   If the value of AlertRecipientType is SHIFT_SCHEDULE, the value of this parameter is the ID of a shift schedule.
   * *   If the value of AlertRecipientType is OTHER, the value of this parameter is the UIDs of specified personnel. Multiple UIDs are separated by commas (,).
   * 
   * @example
   * 123123
   */
  alertRecipient?: string;
  /**
   * @remarks
   * The type of the alert recipient. Valid values:
   * 
   * *   OWNER: indicates the node owner.
   * *   OTHER: indicates specified personnel.
   * *   SHIFT_SCHEDULE: indicates personnel in a shift schedule.
   * 
   * @example
   * OWNER
   */
  alertRecipientType?: string;
  /**
   * @remarks
   * The type of the alert. Valid values:
   * 
   * *   BASELINE: indicates a baseline alert.
   * *   TOPIC: indicates an event alert.
   * 
   * @example
   * BASELINE
   */
  alertType?: string;
  /**
   * @remarks
   * Indicates whether the baseline alerting feature is enabled. The feature is specific to baselines. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  baselineAlertEnabled?: boolean;
  /**
   * @remarks
   * The DingTalk chatbots.
   */
  dingRobots?: GetBaselineResponseBodyDataAlertSettingsDingRobots[];
  /**
   * @remarks
   * The end of the time range for silence. The time is in the HH:mm:ss format.
   * 
   * @example
   * 00:00:00
   */
  silenceEndTime?: string;
  /**
   * @remarks
   * The beginning of the time range for silence. The time is in the HH:mm:ss format.
   * 
   * @example
   * 00:00:00
   */
  silenceStartTime?: string;
  /**
   * @remarks
   * The types of event alerts, which are event-specific configurations.
   */
  topicTypes?: string[];
  /**
   * @remarks
   * The webhook URLs.
   */
  webhooks?: string[];
  static names(): { [key: string]: string } {
    return {
      alertInterval: 'AlertInterval',
      alertMaximum: 'AlertMaximum',
      alertMethods: 'AlertMethods',
      alertRecipient: 'AlertRecipient',
      alertRecipientType: 'AlertRecipientType',
      alertType: 'AlertType',
      baselineAlertEnabled: 'BaselineAlertEnabled',
      dingRobots: 'DingRobots',
      silenceEndTime: 'SilenceEndTime',
      silenceStartTime: 'SilenceStartTime',
      topicTypes: 'TopicTypes',
      webhooks: 'Webhooks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertInterval: 'number',
      alertMaximum: 'number',
      alertMethods: { 'type': 'array', 'itemType': 'string' },
      alertRecipient: 'string',
      alertRecipientType: 'string',
      alertType: 'string',
      baselineAlertEnabled: 'boolean',
      dingRobots: { 'type': 'array', 'itemType': GetBaselineResponseBodyDataAlertSettingsDingRobots },
      silenceEndTime: 'string',
      silenceStartTime: 'string',
      topicTypes: { 'type': 'array', 'itemType': 'string' },
      webhooks: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineResponseBodyDataOverTimeSettings extends $tea.Model {
  /**
   * @remarks
   * The cycle that corresponds to the committed completion time. For a day-level baseline, the value of this parameter is 1. For an hour-level baseline, the value of this parameter cannot exceed 24.
   * 
   * @example
   * 1
   */
  cycle?: number;
  /**
   * @remarks
   * The committed completion time in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
   * 
   * @example
   * 00:00
   */
  time?: string;
  static names(): { [key: string]: string } {
    return {
      cycle: 'Cycle',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycle: 'number',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineResponseBodyData extends $tea.Model {
  /**
   * @example
   * true
   */
  alertEnabled?: boolean;
  /**
   * @example
   * 60
   */
  alertMarginThreshold?: number;
  /**
   * @remarks
   * The alert settings.
   */
  alertSettings?: GetBaselineResponseBodyDataAlertSettings[];
  /**
   * @example
   * 1001
   */
  baselineId?: number;
  baselineName?: string;
  /**
   * @example
   * DAILY
   */
  baselineType?: string;
  /**
   * @example
   * true
   */
  enabled?: boolean;
  nodeIds?: number[];
  overTimeSettings?: GetBaselineResponseBodyDataOverTimeSettings[];
  /**
   * @example
   * 9527952****
   */
  owner?: string;
  /**
   * @example
   * 1
   */
  priority?: number;
  /**
   * @example
   * 10000
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      alertEnabled: 'AlertEnabled',
      alertMarginThreshold: 'AlertMarginThreshold',
      alertSettings: 'AlertSettings',
      baselineId: 'BaselineId',
      baselineName: 'BaselineName',
      baselineType: 'BaselineType',
      enabled: 'Enabled',
      nodeIds: 'NodeIds',
      overTimeSettings: 'OverTimeSettings',
      owner: 'Owner',
      priority: 'Priority',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertEnabled: 'boolean',
      alertMarginThreshold: 'number',
      alertSettings: { 'type': 'array', 'itemType': GetBaselineResponseBodyDataAlertSettings },
      baselineId: 'number',
      baselineName: 'string',
      baselineType: 'string',
      enabled: 'boolean',
      nodeIds: { 'type': 'array', 'itemType': 'number' },
      overTimeSettings: { 'type': 'array', 'itemType': GetBaselineResponseBodyDataOverTimeSettings },
      owner: 'string',
      priority: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineConfigResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The baseline ID.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  /**
   * @remarks
   * The name of the baseline.
   */
  baselineName?: string;
  /**
   * @remarks
   * The type of the baseline. Valid values: DAILY and HOURLY.
   * 
   * @example
   * DAILY
   */
  baselineType?: string;
  /**
   * @remarks
   * The hour in the alerting time of the day-level baseline. Valid values: [0, 47].
   * 
   * @example
   * 7
   */
  expHour?: number;
  /**
   * @remarks
   * The minute in the alerting time of the day-level baseline. Valid values: [0, 59].
   * 
   * @example
   * 30
   */
  expMinu?: number;
  /**
   * @remarks
   * The alerting time of the hour-level baseline. This parameter is presented as key-value pairs in the JSON format. The key indicates the ID of the cycle, and the value is presented in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
   * 
   * @example
   * {"1":"03:28","2":"04:28","3":"05:28","4":"06:28","5":"07:28","6":"08:28","7":"09:28","8":"10:28","9":"11:28","10":"12:28","11":"13:28","12":"14:28","13":"15:28","14":"16:28","15":"17:28","16":"18:28","17":"19:28","18":"20:28","19":"21:28","20":"22:28","21":"23:28","22":"24:28","23":"25:28","24":"26:28"}
   */
  hourExpDetail?: string;
  /**
   * @remarks
   * The committed completion time of the hour-level baseline. This parameter is presented as key-value pairs in the JSON format. The key indicates the ID of the cycle, and the value is presented in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
   * 
   * @example
   * {"1":"03:58","2":"04:58","3":"05:58","4":"06:58","5":"07:58","6":"08:58","7":"09:58","8":"10:58","9":"11:58","10":"12:58","11":"13:58","12":"14:58","13":"15:58","14":"16:58","15":"17:58","16":"18:58","17":"19:58","18":"20:58","19":"21:58","20":"22:58","21":"23:58","22":"24:58","23":"25:58","24":"26:58"}
   */
  hourSlaDetail?: string;
  /**
   * @remarks
   * Indicates whether the baseline is a default baseline of the workspace. Valid values: true and false.
   * 
   * @example
   * true
   */
  isDefault?: boolean;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the baseline owner. Multiple IDs can be specified. The IDs are separated by commas (,).
   * 
   * @example
   * 9527952****
   */
  owner?: string;
  /**
   * @remarks
   * The priority of the baseline. Valid values: {1,3,5,7,8}.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The hour in the committed completion time of the day-level baseline. Valid values: [0, 47].
   * 
   * @example
   * 9
   */
  slaHour?: number;
  /**
   * @remarks
   * The minute in the committed completion time of the day-level baseline. Valid values: [0, 59].
   * 
   * @example
   * 30
   */
  slaMinu?: number;
  /**
   * @remarks
   * Indicates whether the baseline is enabled. Valid values: true and false.
   * 
   * @example
   * true
   */
  useFlag?: boolean;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      baselineName: 'BaselineName',
      baselineType: 'BaselineType',
      expHour: 'ExpHour',
      expMinu: 'ExpMinu',
      hourExpDetail: 'HourExpDetail',
      hourSlaDetail: 'HourSlaDetail',
      isDefault: 'IsDefault',
      owner: 'Owner',
      priority: 'Priority',
      projectId: 'ProjectId',
      slaHour: 'SlaHour',
      slaMinu: 'SlaMinu',
      useFlag: 'UseFlag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      baselineName: 'string',
      baselineType: 'string',
      expHour: 'number',
      expMinu: 'number',
      hourExpDetail: 'string',
      hourSlaDetail: 'string',
      isDefault: 'boolean',
      owner: 'string',
      priority: 'number',
      projectId: 'number',
      slaHour: 'number',
      slaMinu: 'number',
      useFlag: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineKeyPathResponseBodyDataRuns extends $tea.Model {
  /**
   * @remarks
   * The timestamp obtained by adding the predicted time when the instance started to run to the historical average running duration of the instance.
   * 
   * @example
   * 1553531402000
   */
  absTime?: number;
  /**
   * @remarks
   * The timestamp of the predicted time when the instance started to run.
   * 
   * @example
   * 1553531686000
   */
  beginCast?: number;
  /**
   * @remarks
   * The timestamp of the actual time when the instance started to run.
   * 
   * @example
   * 1553531401000
   */
  beginRunningTime?: number;
  /**
   * @remarks
   * The timestamp when the instance started to wait for resources.
   * 
   * @example
   * 1553531401000
   */
  beginWaitResTime?: number;
  /**
   * @remarks
   * The timestamp when the instance started to wait for the scheduling time.
   * 
   * @example
   * 1553531400000
   */
  beginWaitTimeTime?: number;
  /**
   * @remarks
   * The timestamp of the predicted time when the instance finished running.
   * 
   * @example
   * 1553531687000
   */
  endCast?: number;
  /**
   * @remarks
   * The timestamp of the actual time when the instance finished running.
   * 
   * @example
   * 1553531401000
   */
  finishTime?: number;
  /**
   * @remarks
   * The status of the instance. Valid values: NOT_RUN, WAIT_TIME, WAIT_RESOURCE, RUNNING, CHECKING, CHECKING_CONDITION, FAILURE, and SUCCESS. The value NOT_RUN indicates that the instance is not run. The value WAIT_TIME indicates that the instance is waiting to be run. The value WAIT_RESOURCE indicates that the instance is waiting for resources. The value RUNNING indicates that the instance is running. The value CHECKING indicates that data quality is being checked for the instance. The value CHECKING_CONDITION indicates that branch conditions are being checked for the instance. The value FAILURE indicates that the instance fails to run. The value SUCCESS indicates that the instance is run.
   * 
   * @example
   * SUCCESS
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      absTime: 'AbsTime',
      beginCast: 'BeginCast',
      beginRunningTime: 'BeginRunningTime',
      beginWaitResTime: 'BeginWaitResTime',
      beginWaitTimeTime: 'BeginWaitTimeTime',
      endCast: 'EndCast',
      finishTime: 'FinishTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      absTime: 'number',
      beginCast: 'number',
      beginRunningTime: 'number',
      beginWaitResTime: 'number',
      beginWaitTimeTime: 'number',
      endCast: 'number',
      finishTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineKeyPathResponseBodyDataTopics extends $tea.Model {
  /**
   * @remarks
   * The timestamp when the event was found.
   * 
   * @example
   * 1553531401000
   */
  addTime?: number;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * 1234
   */
  instanceId?: number;
  /**
   * @remarks
   * The event ID.
   * 
   * @example
   * 1234
   */
  topicId?: number;
  /**
   * @remarks
   * The name of the event.
   * 
   * @example
   * 1234
   */
  topicName?: string;
  static names(): { [key: string]: string } {
    return {
      addTime: 'AddTime',
      instanceId: 'InstanceId',
      topicId: 'TopicId',
      topicName: 'TopicName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addTime: 'number',
      instanceId: 'number',
      topicId: 'number',
      topicName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineKeyPathResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The data timestamp of the instance.
   * 
   * @example
   * 1553443200000
   */
  bizdate?: number;
  /**
   * @remarks
   * The ID of the scheduling cycle of the instance. Valid values: 1 to 288.
   * 
   * @example
   * 1
   */
  inGroupId?: number;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * 12345
   */
  instanceId?: number;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 9527952****
   */
  owner?: string;
  /**
   * @remarks
   * The type of the node. Valid values: 23, 10, 6, and 99. The value 23 indicates that the node is a Data Integration node. The value 10 indicates that the node is a MaxCompute SQL node. The value 6 indicates that the node is a Shell node. The value 99 indicates that the node is a zero load node.
   * 
   * @example
   * 10
   */
  prgType?: number;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The running records of the instance.
   */
  runs?: GetBaselineKeyPathResponseBodyDataRuns[];
  /**
   * @remarks
   * The information about the events that are associated with the instance.
   */
  topics?: GetBaselineKeyPathResponseBodyDataTopics[];
  static names(): { [key: string]: string } {
    return {
      bizdate: 'Bizdate',
      inGroupId: 'InGroupId',
      instanceId: 'InstanceId',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      owner: 'Owner',
      prgType: 'PrgType',
      projectId: 'ProjectId',
      runs: 'Runs',
      topics: 'Topics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizdate: 'number',
      inGroupId: 'number',
      instanceId: 'number',
      nodeId: 'number',
      nodeName: 'string',
      owner: 'string',
      prgType: 'number',
      projectId: 'number',
      runs: { 'type': 'array', 'itemType': GetBaselineKeyPathResponseBodyDataRuns },
      topics: { 'type': 'array', 'itemType': GetBaselineKeyPathResponseBodyDataTopics },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineStatusResponseBodyDataBlockInstance extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the predicted time when the instance finished running.
   * 
   * @example
   * 1553443200000
   */
  endCast?: number;
  /**
   * @remarks
   * The timestamp of the actual time when the instance finished running.
   * 
   * @example
   * 1553443200000
   */
  finishTime?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 12345
   */
  instanceId?: number;
  /**
   * @remarks
   * The ID of the node.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * Node name
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 9527952795****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The status of the instance. Valid values: NOT_RUN, WAIT_TIME, WAIT_RESOURCE, RUNNING, CHECKING, CHECKING_CONDITION, FAILURE, and SUCCESS. The value NOT_RUN indicates that the instance is not run. The value WAIT_TIME indicates that the instance is waiting to be run. The value WAIT_RESOURCE indicates that the instance is waiting for resources. The value RUNNING indicates that the instance is running. The value CHECKING indicates that data quality is being checked for the instance. The value CHECKING_CONDITION indicates that branch conditions are being checked for the instance. The value FAILURE indicates that the instance fails to run. The value SUCCESS indicates that the instance is run.
   * 
   * @example
   * SUCCESS
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      endCast: 'EndCast',
      finishTime: 'FinishTime',
      instanceId: 'InstanceId',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      owner: 'Owner',
      projectId: 'ProjectId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endCast: 'number',
      finishTime: 'number',
      instanceId: 'number',
      nodeId: 'number',
      nodeName: 'string',
      owner: 'string',
      projectId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineStatusResponseBodyDataLastInstance extends $tea.Model {
  /**
   * @remarks
   * The timestamp of the predicted time when the instance finished running.
   * 
   * @example
   * 1553443200000
   */
  endCast?: number;
  /**
   * @remarks
   * The timestamp of the actual time when the instance finished running.
   * 
   * @example
   * 1553443200000
   */
  finishTime?: number;
  /**
   * @remarks
   * The ID of the instance.
   * 
   * @example
   * 12345
   */
  instanceId?: number;
  /**
   * @remarks
   * The ID of the node.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * Node name
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 9527952795****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The status of the instance. Valid values: NOT_RUN, WAIT_TIME, WAIT_RESOURCE, RUNNING, CHECKING, CHECKING_CONDITION, FAILURE, and SUCCESS. The value NOT_RUN indicates that the instance is not run. The value WAIT_TIME indicates that the instance is waiting to be run. The value WAIT_RESOURCE indicates that the instance is waiting for resources. The value RUNNING indicates that the instance is running. The value CHECKING indicates that data quality is being checked for the instance. The value CHECKING_CONDITION indicates that branch conditions are being checked for the instance. The value FAILURE indicates that the instance fails to run. The value SUCCESS indicates that the instance is run.
   * 
   * @example
   * SUCCESS
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      endCast: 'EndCast',
      finishTime: 'FinishTime',
      instanceId: 'InstanceId',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      owner: 'Owner',
      projectId: 'ProjectId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endCast: 'number',
      finishTime: 'number',
      instanceId: 'number',
      nodeId: 'number',
      nodeName: 'string',
      owner: 'string',
      projectId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBaselineStatusResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the baseline.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  /**
   * @remarks
   * The name of the baseline.
   * 
   * @example
   * Baseline name
   */
  baselineName?: string;
  /**
   * @remarks
   * The data timestamp of the baseline instance.
   * 
   * @example
   * 1553443200000
   */
  bizdate?: number;
  /**
   * @remarks
   * The information about the key instance.
   */
  blockInstance?: GetBaselineStatusResponseBodyDataBlockInstance;
  /**
   * @remarks
   * The margin of the baseline instance. Unit: seconds.
   * 
   * @example
   * 1200
   */
  buffer?: number;
  /**
   * @remarks
   * The timestamp of the predicted time when the baseline instance finished running.
   * 
   * @example
   * 1553443200000
   */
  endCast?: number;
  /**
   * @remarks
   * The timestamp of the alerting time of the baseline instance.
   * 
   * @example
   * 1553443200000
   */
  expTime?: number;
  /**
   * @remarks
   * The status of the baseline instance. Valid values: UNFINISH and FINISH. The value UNFINISH indicates that the baseline instance is still running. The value FINISH indicates that the baseline instance finishes running.
   * 
   * @example
   * UNFINISH
   */
  finishStatus?: string;
  /**
   * @remarks
   * The timestamp of the actual time when the baseline instance finished running. This parameter is returned if the value of the FinishStatus parameter is FINISH.
   * 
   * @example
   * 1553443200000
   */
  finishTime?: number;
  /**
   * @remarks
   * The ID of the scheduling cycle of the baseline instance. For a baseline instance that is scheduled by day, the value of this parameter is 1. For a baseline instance that is scheduled by hour, the value of this parameter ranges from 1 to 24.
   * 
   * @example
   * 1
   */
  inGroupId?: number;
  /**
   * @remarks
   * The information about the last generated instance.
   */
  lastInstance?: GetBaselineStatusResponseBodyDataLastInstance;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the baseline owner. Multiple IDs are separated by commas (,).
   * 
   * @example
   * 9527952795****
   */
  owner?: string;
  /**
   * @remarks
   * The priority of the baseline. Valid values: 1, 2, 5, 7, and 8.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The ID of the workspace to which the baseline belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The timestamp of the committed completion time of the baseline instance.
   * 
   * @example
   * 1553443200000
   */
  slaTime?: number;
  /**
   * @remarks
   * The status of the baseline. Valid values: ERROR, SAFE, DANGEROUS, and OVER. The value ERROR indicates that no nodes are associated with the baseline, or all nodes associated with the baseline are suspended. The value SAFE indicates that nodes finish running before the alerting time. The value DANGEROUS indicates that nodes are still running after the alerting time but before the committed completion time. The value OVER indicates that nodes are still running after the committed completion time.
   * 
   * @example
   * SAFE
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      baselineName: 'BaselineName',
      bizdate: 'Bizdate',
      blockInstance: 'BlockInstance',
      buffer: 'Buffer',
      endCast: 'EndCast',
      expTime: 'ExpTime',
      finishStatus: 'FinishStatus',
      finishTime: 'FinishTime',
      inGroupId: 'InGroupId',
      lastInstance: 'LastInstance',
      owner: 'Owner',
      priority: 'Priority',
      projectId: 'ProjectId',
      slaTime: 'SlaTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      baselineName: 'string',
      bizdate: 'number',
      blockInstance: GetBaselineStatusResponseBodyDataBlockInstance,
      buffer: 'number',
      endCast: 'number',
      expTime: 'number',
      finishStatus: 'string',
      finishTime: 'number',
      inGroupId: 'number',
      lastInstance: GetBaselineStatusResponseBodyDataLastInstance,
      owner: 'string',
      priority: 'number',
      projectId: 'number',
      slaTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBusinessResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the workflow.
   * 
   * @example
   * 1000001
   */
  businessId?: number;
  /**
   * @remarks
   * The name of the workflow.
   */
  businessName?: string;
  /**
   * @remarks
   * The description of the workflow.
   */
  description?: string;
  /**
   * @remarks
   * The Alibaba Cloud account ID of the workflow owner.
   * 
   * @example
   * 20000****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the workspace to which the workflow belongs.
   * 
   * @example
   * 10000
   */
  projectId?: string;
  /**
   * @remarks
   * The module to which the workflow belongs. Valid values: NORMAL and MANUAL_BIZ.
   * 
   * @example
   * NORMAL
   */
  useType?: string;
  static names(): { [key: string]: string } {
    return {
      businessId: 'BusinessId',
      businessName: 'BusinessName',
      description: 'Description',
      owner: 'Owner',
      projectId: 'ProjectId',
      useType: 'UseType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessId: 'number',
      businessName: 'string',
      description: 'string',
      owner: 'string',
      projectId: 'string',
      useType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDDLJobStatusResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The content of the task.
   * 
   * @example
   * success
   */
  content?: string;
  /**
   * @remarks
   * The ID of the ongoing task. If no value is returned for this parameter, all subtasks are complete.
   * 
   * @example
   * abc1
   */
  nextTaskId?: string;
  /**
   * @remarks
   * The status of the task.
   * 
   * @example
   * success
   */
  status?: string;
  /**
   * @remarks
   * The task ID.
   * 
   * @example
   * abc
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      nextTaskId: 'NextTaskId',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      nextTaskId: 'string',
      status: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationChannels extends $tea.Model {
  /**
   * @remarks
   * The alert notification methods.
   */
  channels?: string[];
  /**
   * @remarks
   * The severity level. Valid values:
   * 
   * *   Warning
   * *   Critical
   * 
   * @example
   * Warning
   */
  severity?: string;
  static names(): { [key: string]: string } {
    return {
      channels: 'Channels',
      severity: 'Severity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channels: { 'type': 'array', 'itemType': 'string' },
      severity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationReceivers extends $tea.Model {
  /**
   * @remarks
   * The recipient type.
   * 
   * *   If the alert notification method is Mail, Phone, or Sms, the recipient type is Alibaba Cloud account ID.
   * *   If the alert notification method is Ding, the recipient type is DingTalk chatbot token.
   * 
   * @example
   * DingToken
   */
  receiverType?: string;
  /**
   * @remarks
   * The recipients.
   */
  receiverValues?: string[];
  static names(): { [key: string]: string } {
    return {
      receiverType: 'ReceiverType',
      receiverValues: 'ReceiverValues',
    };
  }

  static types(): { [key: string]: any } {
    return {
      receiverType: 'string',
      receiverValues: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings extends $tea.Model {
  /**
   * @remarks
   * The duration of the alert suppression interval. Unit: minutes.
   * 
   * @example
   * 5
   */
  inhibitionInterval?: number;
  /**
   * @remarks
   * The alert notification methods.
   */
  notificationChannels?: GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationChannels[];
  /**
   * @remarks
   * The alert notification recipients.
   */
  notificationReceivers?: GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationReceivers[];
  static names(): { [key: string]: string } {
    return {
      inhibitionInterval: 'InhibitionInterval',
      notificationChannels: 'NotificationChannels',
      notificationReceivers: 'NotificationReceivers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inhibitionInterval: 'number',
      notificationChannels: { 'type': 'array', 'itemType': GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationChannels },
      notificationReceivers: { 'type': 'array', 'itemType': GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationReceivers },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions extends $tea.Model {
  /**
   * @remarks
   * The time interval for alert calculation. Unit: minutes.
   * 
   * @example
   * 15
   */
  duration?: number;
  /**
   * @remarks
   * The severity level. Valid values:
   * 
   * *   Warning
   * *   Critical
   * 
   * @example
   * Warning
   */
  severity?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * *   If the alert rule is for task status, no threshold is used.
   * *   If the alert rule is for failovers, specify the number of failovers.
   * *   If the alert rule is for latency, the threshold is the latency duration, in seconds.
   * 
   * @example
   * 5
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      severity: 'Severity',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      severity: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIAlarmRuleResponseBodyDIAlarmRule extends $tea.Model {
  /**
   * @remarks
   * The timestamp when the alert rule was created. Unit: seconds.
   * 
   * @example
   * 1663573162
   */
  createdTime?: number;
  /**
   * @remarks
   * The ID of the user who creates the alert rule.
   * 
   * @example
   * 10000001
   */
  createdUid?: string;
  /**
   * @remarks
   * The alert rule ID.
   * 
   * @example
   * 34988
   */
  DIAlarmRuleId?: number;
  /**
   * @remarks
   * The ID of the task with which the alert rule is associated.
   * 
   * @example
   * 11170
   */
  DIJobId?: number;
  /**
   * @remarks
   * The description of the alert rule.
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether the alert rule is enabled.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * The metric type in the alert rule. Valid values:
   * 
   * *   Heartbeat
   * *   FailoverCount
   * *   Delay
   * 
   * @example
   * Heartbeat
   */
  metricType?: string;
  /**
   * @remarks
   * The alert notification settings.
   */
  notificationSettings?: GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings;
  /**
   * @remarks
   * The conditions that can trigger the alert rule.
   */
  triggerConditions?: GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions[];
  /**
   * @remarks
   * The timestamp when the alert rule was last updated. Unit: seconds.
   * 
   * @example
   * 1663573163
   */
  updatedTime?: number;
  /**
   * @remarks
   * The ID of the user who last updates the alert rule.
   * 
   * @example
   * 10000001
   */
  updatedUid?: string;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      createdUid: 'CreatedUid',
      DIAlarmRuleId: 'DIAlarmRuleId',
      DIJobId: 'DIJobId',
      description: 'Description',
      enabled: 'Enabled',
      metricType: 'MetricType',
      notificationSettings: 'NotificationSettings',
      triggerConditions: 'TriggerConditions',
      updatedTime: 'UpdatedTime',
      updatedUid: 'UpdatedUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'number',
      createdUid: 'string',
      DIAlarmRuleId: 'number',
      DIJobId: 'number',
      description: 'string',
      enabled: 'boolean',
      metricType: 'string',
      notificationSettings: GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings,
      triggerConditions: { 'type': 'array', 'itemType': GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions },
      updatedTime: 'number',
      updatedUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataDestinationDataSourceSettings extends $tea.Model {
  /**
   * @remarks
   * The name of the data source.
   * 
   * @example
   * holo_datasource_1
   */
  dataSourceName?: string;
  /**
   * @remarks
   * The properties of the data source.
   */
  dataSourceProperties?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      dataSourceName: 'DataSourceName',
      dataSourceProperties: 'DataSourceProperties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceName: 'string',
      dataSourceProperties: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataJobSettingsColumnDataTypeSettings extends $tea.Model {
  /**
   * @remarks
   * The data type of a destination field.
   * 
   * @example
   * text
   */
  destinationDataType?: string;
  /**
   * @remarks
   * The data type of a source field.
   * 
   * @example
   * bigint
   */
  sourceDataType?: string;
  static names(): { [key: string]: string } {
    return {
      destinationDataType: 'DestinationDataType',
      sourceDataType: 'SourceDataType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationDataType: 'string',
      sourceDataType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataJobSettingsCycleScheduleSettings extends $tea.Model {
  /**
   * @example
   * Full
   */
  cycleMigrationType?: string;
  /**
   * @example
   * bizdate=$bizdate
   */
  scheduleParameters?: string;
  static names(): { [key: string]: string } {
    return {
      cycleMigrationType: 'CycleMigrationType',
      scheduleParameters: 'ScheduleParameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycleMigrationType: 'string',
      scheduleParameters: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataJobSettingsDdlHandlingSettings extends $tea.Model {
  /**
   * @remarks
   * The processing policy for DDL messages. Valid values:
   * 
   * *   Ignore: ignores a DDL message.
   * *   Critical: reports an error for a DDL message.
   * *   Normal: normally processes a DDL message.
   * 
   * @example
   * Critical
   */
  action?: string;
  /**
   * @remarks
   * The type of the DDL operation. Valid values:
   * 
   * *   RenameColumn
   * *   ModifyColumn
   * *   CreateTable
   * *   TruncateTable
   * *   DropTable
   * *   DropColumn
   * *   AddColumn
   * 
   * @example
   * AddColumn
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataJobSettingsRuntimeSettings extends $tea.Model {
  /**
   * @remarks
   * The name of the configuration item. Valid values:
   * 
   * *   runtime.offline.speed.limit.mb: indicates the maximum transmission rate that is allowed for a batch synchronization task. This configuration item takes effect only when runtime.offline.speed.limit.enable is set to true.
   * *   runtime.offline.speed.limit.enable: indicates whether throttling is enabled for a batch synchronization task.
   * *   dst.offline.connection.max: indicates the maximum number of connections that are allowed for writing data to the destination of a batch synchronization task.
   * *   runtime.offline.concurrent: indicates the maximum number of parallel threads that are allowed for a batch synchronization task.
   * *   dst.realtime.connection.max: indicates the maximum number of connections that are allowed for writing data to the destination of a real-time synchronization task.
   * *   runtime.enable.auto.create.schema: indicates whether schemas are automatically created in the destination of a synchronization task.
   * *   src.offline.datasource.max.connection: indicates the maximum number of connections that are allowed for reading data from the source of a batch synchronization task.
   * *   runtime.realtime.concurrent: indicates the maximum number of parallel threads that are allowed for a real-time synchronization task.
   * 
   * @example
   * runtime.offline.concurrent
   */
  name?: string;
  /**
   * @remarks
   * The value of the configuration item.
   * 
   * @example
   * 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataJobSettings extends $tea.Model {
  /**
   * @example
   * {"structInfo":"MANAGED","storageType":"TEXTFILE","writeMode":"APPEND","partitionColumns":[{"columnName":"pt","columnType":"STRING","comment":""}],"fieldDelimiter":""}
   */
  channelSettings?: string;
  /**
   * @remarks
   * The settings for data type mappings between source fields and destination fields. The value of this parameter is an array.
   */
  columnDataTypeSettings?: GetDIJobResponseBodyDataJobSettingsColumnDataTypeSettings[];
  cycleScheduleSettings?: GetDIJobResponseBodyDataJobSettingsCycleScheduleSettings;
  /**
   * @remarks
   * The settings for processing DDL messages. The value of this parameter is an array.
   */
  ddlHandlingSettings?: GetDIJobResponseBodyDataJobSettingsDdlHandlingSettings[];
  /**
   * @remarks
   * The runtime settings. The value of this parameter is an array.
   */
  runtimeSettings?: GetDIJobResponseBodyDataJobSettingsRuntimeSettings[];
  static names(): { [key: string]: string } {
    return {
      channelSettings: 'ChannelSettings',
      columnDataTypeSettings: 'ColumnDataTypeSettings',
      cycleScheduleSettings: 'CycleScheduleSettings',
      ddlHandlingSettings: 'DdlHandlingSettings',
      runtimeSettings: 'RuntimeSettings',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelSettings: 'string',
      columnDataTypeSettings: { 'type': 'array', 'itemType': GetDIJobResponseBodyDataJobSettingsColumnDataTypeSettings },
      cycleScheduleSettings: GetDIJobResponseBodyDataJobSettingsCycleScheduleSettings,
      ddlHandlingSettings: { 'type': 'array', 'itemType': GetDIJobResponseBodyDataJobSettingsDdlHandlingSettings },
      runtimeSettings: { 'type': 'array', 'itemType': GetDIJobResponseBodyDataJobSettingsRuntimeSettings },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataResourceSettingsOfflineResourceSettings extends $tea.Model {
  /**
   * @remarks
   * The identifier of the resource group for Data Integration used for batch synchronization.
   * 
   * @example
   * S_res_group_111_222
   */
  resourceGroupIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupIdentifier: 'ResourceGroupIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataResourceSettingsRealtimeResourceSettings extends $tea.Model {
  /**
   * @remarks
   * The identifier of the resource group for Data Integration used for real-time synchronization.
   * 
   * @example
   * S_res_group_111_222
   */
  resourceGroupIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupIdentifier: 'ResourceGroupIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataResourceSettings extends $tea.Model {
  /**
   * @remarks
   * The resource used for batch synchronization.
   */
  offlineResourceSettings?: GetDIJobResponseBodyDataResourceSettingsOfflineResourceSettings;
  /**
   * @remarks
   * The resource used for real-time synchronization.
   */
  realtimeResourceSettings?: GetDIJobResponseBodyDataResourceSettingsRealtimeResourceSettings;
  requestedCu?: number;
  static names(): { [key: string]: string } {
    return {
      offlineResourceSettings: 'OfflineResourceSettings',
      realtimeResourceSettings: 'RealtimeResourceSettings',
      requestedCu: 'RequestedCu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      offlineResourceSettings: GetDIJobResponseBodyDataResourceSettingsOfflineResourceSettings,
      realtimeResourceSettings: GetDIJobResponseBodyDataResourceSettingsRealtimeResourceSettings,
      requestedCu: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataSourceDataSourceSettings extends $tea.Model {
  /**
   * @remarks
   * The name of the data source.
   * 
   * @example
   * mysql_datasource_1
   */
  dataSourceName?: string;
  /**
   * @remarks
   * The properties of the data source.
   */
  dataSourceProperties?: { [key: string]: string };
  static names(): { [key: string]: string } {
    return {
      dataSourceName: 'DataSourceName',
      dataSourceProperties: 'DataSourceProperties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceName: 'string',
      dataSourceProperties: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataTableMappingsSourceObjectSelectionRules extends $tea.Model {
  /**
   * @remarks
   * The expression.
   * 
   * @example
   * mysql_table_1
   */
  expression?: string;
  /**
   * @remarks
   * The type of the object. Valid values:
   * 
   * *   Table
   * *   Database
   * 
   * @example
   * Table
   */
  objectType?: string;
  static names(): { [key: string]: string } {
    return {
      expression: 'Expression',
      objectType: 'ObjectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expression: 'string',
      objectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataTableMappingsTransformationRules extends $tea.Model {
  /**
   * @remarks
   * The type of the action. Valid values:
   * 
   * *   DefinePrimaryKey
   * *   Rename
   * *   AddColumn
   * *   HandleDml
   * 
   * @example
   * Rename
   */
  ruleActionType?: string;
  /**
   * @remarks
   * The name of the rule. If the values of the RuleActionType parameter and the RuleTargetType parameter are the same for multiple transformation rules, you must make sure that the transformation rule names are unique.
   * 
   * @example
   * rename_rule_1
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the object on which the action is performed. Valid values:
   * 
   * *   Table
   * *   Schema
   * 
   * @example
   * Table
   */
  ruleTargetType?: string;
  static names(): { [key: string]: string } {
    return {
      ruleActionType: 'RuleActionType',
      ruleName: 'RuleName',
      ruleTargetType: 'RuleTargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleActionType: 'string',
      ruleName: 'string',
      ruleTargetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataTableMappings extends $tea.Model {
  /**
   * @remarks
   * The rule used to select synchronization objects in the source. Multiple rules may be returned.
   */
  sourceObjectSelectionRules?: GetDIJobResponseBodyDataTableMappingsSourceObjectSelectionRules[];
  /**
   * @remarks
   * The transformation rules that are applied to the selected synchronization objects.
   */
  transformationRules?: GetDIJobResponseBodyDataTableMappingsTransformationRules[];
  static names(): { [key: string]: string } {
    return {
      sourceObjectSelectionRules: 'SourceObjectSelectionRules',
      transformationRules: 'TransformationRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceObjectSelectionRules: { 'type': 'array', 'itemType': GetDIJobResponseBodyDataTableMappingsSourceObjectSelectionRules },
      transformationRules: { 'type': 'array', 'itemType': GetDIJobResponseBodyDataTableMappingsTransformationRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyDataTransformationRules extends $tea.Model {
  /**
   * @remarks
   * The type of the action. Valid values:
   * 
   * *   DefinePrimaryKey
   * *   Rename
   * *   AddColumn
   * *   HandleDml
   * 
   * @example
   * Rename
   */
  ruleActionType?: string;
  /**
   * @remarks
   * The expression of the rule. The expression is a JSON string.
   * 
   * Example of a renaming rule: {"expression":"${srcDatasourceName}_${srcDatabaseName}_0922","variables":[{"variableName":"srcDatabaseName","variableRules":[{"from":"fromdb","to":"todb"}]}]}
   * 
   * expression: the expression of the renaming rule. The expression may contain the following variables: ${srcDatasourceName}, ${srcDatabaseName}, and ${srcTableName}. ${srcDatasourceName} indicates the name of the source. ${srcDatabaseName} indicates the name of a source database. ${srcTableName} indicates the name of a source table. variables: the generation rule for a variable used in the expression of the renaming rule. The default value of the specified variable is the original value of the object indicated by the variable. A group of string replacement rules used to change the original values may be returned. variableName: the name of the variable. The variable name is not enclosed in ${}. variableRules: the string replacement rules for variables. The system runs the string replacement rules in sequence for string replacement. from indicates the original string. to indicates the new string. Example of a rule used to add a specific field to the destination and assign a value to the field: {"columns":[{"columnName":"my_add_column","columnValueType":"Constant","columnValue":"123"}]}
   * 
   * If no rule of this type is configured, no fields are added to the destination and no values are assigned by default. columnName: the name of the field that is added. columnValueType: the value type of the field. Valid values: Constant and Variable. columnValue: the value of the field that is added. If the valueType parameter is set to Constant, the value of the columnValue parameter must be a constant of the STRING type. If the valueType parameter is set to Variable, the value of the columnValue parameter must be a built-in variable. The following built-in variables are supported: EXECUTE_TIME (LONG data type), DB_NAME_SRC (STRING data type), DATASOURCE_NAME_SRC (STRING data type), TABLE_NAME_SRC (STRING data type), DB_NAME_DEST (STRING data type), DATASOURCE_NAME_DEST (STRING data type), TABLE_NAME_DEST (STRING data type), and DB_NAME_SRC_TRANSED (STRING data type). EXECUTE_TIME indicates the execution time. DB_NAME_SRC indicates the name of a source database. DATASOURCE_NAME_SRC indicates the name of the source. TABLE_NAME_SRC indicates the name of a source table. DB_NAME_DEST indicates the name of a destination database. DATASOURCE_NAME_DEST indicates the name of the destination. TABLE_NAME_DEST indicates the name of a destination table. DB_NAME_SRC_TRANSED indicates the database name obtained after a transformation. Example of a rule used to specify primary key fields for a destination table: {"columns":["ukcolumn1","ukcolumn2"]}
   * 
   * If no rule of this type is configured, the primary key fields in the mapped source table are used for the destination table by default. If the destination table is an existing table, Data Integration does not modify the schema of the destination table. If the specified primary key fields do not exist in the destination table, an error is reported when the synchronization task starts to run. If the destination table is automatically created by the system, Data Integration automatically creates the schema of the destination table. The schema contains the primary key fields that you specify. If the specified primary key fields do not exist in the destination table, an error is reported when the synchronization task starts to run. Example of a rule used to process DML messages: {"dmlPolicies":[{"dmlType":"Delete","dmlAction":"Filter","filterCondition":"id > 1"}]}
   * 
   * If no rule of this type is configured, the default processing policy for messages generated for insert, update, and delete operations is Normal. dmlType: the DML operation. Valid values: Insert, Update, and Delete. dmlAction: the processing policy for DML messages. Valid values: Normal, Ignore, Filter, and LogicalDelete. Filter indicates conditional processing. The value Filter is returned for the dmlAction parameter only when the dmlType parameter is set to Update or Delete. filterCondition: the condition used to filter DML messages. This parameter is returned only when the dmlAction parameter is set to Filter.
   * 
   * @example
   * {"expression":"${srcDatasoureName}_${srcDatabaseName}"}
   */
  ruleExpression?: string;
  /**
   * @remarks
   * The name of the rule. If the values of the RuleActionType parameter and the RuleTargetType parameter are the same for multiple transformation rules, you must make sure that the transformation rule names are unique.
   * 
   * @example
   * rename_rule_1
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the object on which the action is performed. Valid values:
   * 
   * *   Table
   * *   Schema
   * 
   * @example
   * Table
   */
  ruleTargetType?: string;
  static names(): { [key: string]: string } {
    return {
      ruleActionType: 'RuleActionType',
      ruleExpression: 'RuleExpression',
      ruleName: 'RuleName',
      ruleTargetType: 'RuleTargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleActionType: 'string',
      ruleExpression: 'string',
      ruleName: 'string',
      ruleTargetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDIJobResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The timestamp when the synchronization task was created. The timestamp is accurate to the second.
   * 
   * @example
   * 1671516776
   */
  createdTime?: number;
  /**
   * @remarks
   * The ID of the user who creates the synchronization task.
   * 
   * @example
   * 100000001
   */
  createdUid?: string;
  /**
   * @remarks
   * The ID of the synchronization task.
   * 
   * @example
   * 11588
   */
  DIJobId?: number;
  /**
   * @remarks
   * The description of the synchronization task.
   */
  description?: string;
  /**
   * @remarks
   * The settings of the destination. Only a single destination is supported.
   */
  destinationDataSourceSettings?: GetDIJobResponseBodyDataDestinationDataSourceSettings[];
  /**
   * @remarks
   * The type of the destination. The value Hologres is returned.
   * 
   * @example
   * Hologres
   */
  destinationDataSourceType?: string;
  /**
   * @remarks
   * The error message returned if the value of the JobStatus parameter is Failed.
   * 
   * @example
   * error details xxx
   */
  errorMessage?: string;
  /**
   * @remarks
   * The name of the synchronization task.
   * 
   * @example
   * mysql_to_holo_sync_445
   */
  jobName?: string;
  /**
   * @remarks
   * The settings for the dimension of the synchronization task. The settings include processing policies for DDL messages, policies for data type mappings between source fields and destination fields, and runtime parameters of the synchronization task.
   */
  jobSettings?: GetDIJobResponseBodyDataJobSettings;
  /**
   * @remarks
   * The task status. Valid values:
   * 
   * *   Finished
   * *   Initialized
   * *   Stopped
   * *   Failed
   * *   Running
   * *   Stopping
   * 
   * @example
   * Finished
   */
  jobStatus?: string;
  /**
   * @remarks
   * The synchronization type. Valid values:
   * 
   * *   FullAndRealtimeIncremental: one-time full synchronization and real-time incremental synchronization
   * *   RealtimeIncremental: real-time incremental synchronization
   * *   Full: one-time full synchronization
   * 
   * @example
   * FullAndRealtimeIncremental
   */
  migrationType?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 22
   */
  projectId?: number;
  /**
   * @remarks
   * The resource settings.
   */
  resourceSettings?: GetDIJobResponseBodyDataResourceSettings;
  /**
   * @remarks
   * The information about the running of the synchronization task.
   */
  runStats?: { [key: string]: string };
  /**
   * @remarks
   * The settings of the source. Only a single source is supported.
   */
  sourceDataSourceSettings?: GetDIJobResponseBodyDataSourceDataSourceSettings[];
  /**
   * @remarks
   * The type of the source. The value MySQL is returned.
   * 
   * @example
   * MySQL
   */
  sourceDataSourceType?: string;
  /**
   * @remarks
   * The timestamp when the synchronization task was last started. The timestamp is accurate to the second.
   * 
   * @example
   * 1673859999
   */
  startedTime?: number;
  /**
   * @remarks
   * The ID of the user who last starts the synchronization task.
   * 
   * @example
   * 100000001
   */
  startedUid?: string;
  /**
   * @remarks
   * The list of mappings between rules used to select synchronization objects in the source and transformation rules applied to the selected synchronization objects. Each entry in the list displays a mapping between a rule used to select synchronization objects and a transformation rule applied to the selected synchronization objects.
   */
  tableMappings?: GetDIJobResponseBodyDataTableMappings[];
  /**
   * @remarks
   * The list of transformation rules for objects involved in the synchronization task. Each entry in the list defines a transformation rule.
   */
  transformationRules?: GetDIJobResponseBodyDataTransformationRules[];
  /**
   * @remarks
   * The timestamp when the synchronization task was last modified. The timestamp is accurate to the second.
   * 
   * @example
   * 1673859985
   */
  updatedTime?: number;
  /**
   * @remarks
   * The ID of the user who last modifies the synchronization task.
   * 
   * @example
   * 100000001
   */
  updatedUid?: string;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      createdUid: 'CreatedUid',
      DIJobId: 'DIJobId',
      description: 'Description',
      destinationDataSourceSettings: 'DestinationDataSourceSettings',
      destinationDataSourceType: 'DestinationDataSourceType',
      errorMessage: 'ErrorMessage',
      jobName: 'JobName',
      jobSettings: 'JobSettings',
      jobStatus: 'JobStatus',
      migrationType: 'MigrationType',
      projectId: 'ProjectId',
      resourceSettings: 'ResourceSettings',
      runStats: 'RunStats',
      sourceDataSourceSettings: 'SourceDataSourceSettings',
      sourceDataSourceType: 'SourceDataSourceType',
      startedTime: 'StartedTime',
      startedUid: 'StartedUid',
      tableMappings: 'TableMappings',
      transformationRules: 'TransformationRules',
      updatedTime: 'UpdatedTime',
      updatedUid: 'UpdatedUid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'number',
      createdUid: 'string',
      DIJobId: 'number',
      description: 'string',
      destinationDataSourceSettings: { 'type': 'array', 'itemType': GetDIJobResponseBodyDataDestinationDataSourceSettings },
      destinationDataSourceType: 'string',
      errorMessage: 'string',
      jobName: 'string',
      jobSettings: GetDIJobResponseBodyDataJobSettings,
      jobStatus: 'string',
      migrationType: 'string',
      projectId: 'number',
      resourceSettings: GetDIJobResponseBodyDataResourceSettings,
      runStats: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      sourceDataSourceSettings: { 'type': 'array', 'itemType': GetDIJobResponseBodyDataSourceDataSourceSettings },
      sourceDataSourceType: 'string',
      startedTime: 'number',
      startedUid: 'string',
      tableMappings: { 'type': 'array', 'itemType': GetDIJobResponseBodyDataTableMappings },
      transformationRules: { 'type': 'array', 'itemType': GetDIJobResponseBodyDataTransformationRules },
      updatedTime: 'number',
      updatedUid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail extends $tea.Model {
  /**
   * @remarks
   * The information of the data synchronization solution.
   */
  info?: string;
  /**
   * @remarks
   * The status of the step in the data synchronization solution.
   * 
   * @example
   * success
   */
  status?: string;
  /**
   * @remarks
   * The ID of the step in the data synchronization solution.
   * 
   * @example
   * 1
   */
  stepId?: number;
  /**
   * @remarks
   * The name of the step in the data synchronization solution.
   */
  stepName?: string;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      status: 'Status',
      stepId: 'StepId',
      stepName: 'StepName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: 'string',
      status: 'string',
      stepId: 'number',
      stepName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDISyncInstanceInfoResponseBodyDataSolutionInfo extends $tea.Model {
  /**
   * @remarks
   * The creator of the data synchronization solution.
   * 
   * @example
   * dataworks_3h1
   */
  creatorName?: string;
  /**
   * @remarks
   * The ID of the data synchronization solution.
   * 
   * @example
   * 100
   */
  id?: number;
  /**
   * @remarks
   * The status of the data synchronization solution.
   * 
   * @example
   * run
   */
  status?: string;
  /**
   * @remarks
   * The step details of the data synchronization solution.
   */
  stepDetail?: GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail[];
  static names(): { [key: string]: string } {
    return {
      creatorName: 'CreatorName',
      id: 'Id',
      status: 'Status',
      stepDetail: 'StepDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorName: 'string',
      id: 'number',
      status: 'string',
      stepDetail: { 'type': 'array', 'itemType': GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDISyncInstanceInfoResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The cause of the failure to obtain the status of the real-time synchronization task or data synchronization solution. If the status of the real-time synchronization task or data synchronization solution is obtained, the value null is returned.
   * 
   * @example
   * fileId[100] is invalid
   */
  message?: string;
  /**
   * @remarks
   * *   If the TaskType parameter is set to DI_REALTIME, the Name parameter indicates the name of the real-time synchronization task.
   * *   If the TaskType parameter is set to DI_SOLUTION, the value null is returned.
   * 
   * @example
   * streamx_name
   */
  name?: string;
  /**
   * @remarks
   * *   If the TaskType parameter is set to DI_REALTIME, the value null is returned.
   * *   If the TaskType parameter is set to DI_SOLUTION, the SolutionInfo parameter indicates the details of the data synchronization solution.
   */
  solutionInfo?: GetDISyncInstanceInfoResponseBodyDataSolutionInfo;
  /**
   * @remarks
   * *   If the TaskType parameter is set to DI_REALTIME, the Status parameter indicates the status of the real-time synchronization task. Valid values: PAUSE, NORUN, RUN, KILLING, and WAIT.
   * *   If the TaskType parameter is set to DI_SOLUTION, the Status parameter indicates the status of the data synchronization solution. Valid values: success and fail.
   * 
   * @example
   * RUN
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      name: 'Name',
      solutionInfo: 'SolutionInfo',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      name: 'string',
      solutionInfo: GetDISyncInstanceInfoResponseBodyDataSolutionInfo,
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDISyncTaskResponseBodyDataSolutionDetail extends $tea.Model {
  /**
   * @remarks
   * The creator of the data synchronization solution.
   * 
   * @example
   * dataworks_di
   */
  creatorName?: string;
  /**
   * @remarks
   * The ID of the data synchronization solution.
   * 
   * @example
   * 100
   */
  id?: number;
  /**
   * @remarks
   * The name of the data synchronization solution.
   * 
   * @example
   * holo_20211206161025
   */
  name?: string;
  /**
   * @remarks
   * The configuration details of the data synchronization solution.
   * 
   * @example
   * {"holoDatasource":"holo","offlineSyncConfig":{"nodeNameRule":"oneclick_holo_di_${db_table_name_src}_to_${db_table_name_dest}","resourceGroup":"group_219193793999490"},"processRuleId":1007,"readerConcurrent":10,"realtimeSyncConfig":{"content":{"order":{"hops":[{"from":"reader","to":"writer"}]},"setting":{"speed":{"readerConcurrent":10}},"steps":[{"stepType":"mysql","name":"reader","category":"reader","parameter":{"connection":[{"datasource":"mm","datasourceType":"mysql","table":[]}]}},{"stepType":"holo","name":"writer","category":"writer","parameter":{"datasource":"holo","writeMode":"replay","datasourceSchema":"public","tableMappingRule":{"datasource":[{"tableRule":[],"srcDatasourceName":"mm"}]}}}]},"extend":{"mode":"migration_holo","resourceGroup":"group_219193793999490"}},"setting":{"autoCreateWorkflow":true,"userDefinedFileNameExpression":"oneclick"},"srcType":"mysql","tableMappingRuleFromRealtimeSyncConfig":{"datasource":[{"srcDatasourceName":"mm","tableRule":[]}]}}
   */
  processContent?: string;
  /**
   * @remarks
   * The additional parameters of the data synchronization solution.
   * 
   * @example
   * {"processType":"new","tableNum":300}
   */
  processExtra?: string;
  /**
   * @remarks
   * The ID of the project to which the data synchronization solution belongs.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The type of the source of the data synchronization solution.
   * 
   * @example
   * mysql
   */
  sourceType?: string;
  /**
   * @remarks
   * The start time of the data synchronization solution.
   * 
   * @example
   * 2021-12-07 14:40:51
   */
  startTime?: string;
  /**
   * @remarks
   * The status of the data synchronization solution. Valid values:
   * 
   * *   0: successful
   * *   1: not running
   * *   2: running
   * *   3: failed
   * *   4: committed
   * *   5: pending manual confirmation
   * *   6: manually confirmed
   * *   7: others
   * *   8: waiting
   * *   9: deleted
   * 
   * @example
   * 0
   */
  status?: string;
  /**
   * @remarks
   * The time when the data synchronization solution was committed.
   * 
   * @example
   * 2021-12-07 14:40:51
   */
  submitTime?: string;
  /**
   * @remarks
   * The type of the data synchronization solution.
   * 
   * @example
   * holo
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      creatorName: 'CreatorName',
      id: 'Id',
      name: 'Name',
      processContent: 'ProcessContent',
      processExtra: 'ProcessExtra',
      projectId: 'ProjectId',
      sourceType: 'SourceType',
      startTime: 'StartTime',
      status: 'Status',
      submitTime: 'SubmitTime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      creatorName: 'string',
      id: 'number',
      name: 'string',
      processContent: 'string',
      processExtra: 'string',
      projectId: 'number',
      sourceType: 'string',
      startTime: 'string',
      status: 'string',
      submitTime: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDISyncTaskResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * *   If the TaskType parameter is set to DI_REALTIME, the details of the real-time synchronization task are returned.
   * *   If the TaskType parameter is set to DI_SOLUTION, the value null is returned.
   * 
   * @example
   * {"extend":{"mode":"wizard","resourceGroup":"S_res_group_287114642182658_1560324290517"},"nodeDef":{},"order":{"hops":[{"from":"datahub_8htXSsfiS2vtZCVG","to":"datahub_CRHBAyGfhSaLmv2f"}]},"setting":{"errorLimit":{},"jvmOption":""},"steps":[{"stepType":"datahub","category":"writer","displayName":"DataHub1","parameter":{"batchSize":1000,"datasource":"datahub_cloud_dev_test","topic":"dwd_tfc_opt_speed_rid_amap_rt"},"name":"datahub_CRHBAyGfhSaLmv2f","gui":{"x":262,"y":325}},{"stepType":"datahub","displayName":"DataHub2","parameter":{"datasource":"datahub_uric_test","topic":"dwd_tfc_opt_speed_rid_amap_rt_330000","batchSize":1000},"name":"datahub_8htXSsfiS2vtZCVG","gui":{"x":268,"y":160.5},"category":"writer"}]}
   */
  code?: string;
  /**
   * @remarks
   * The cause of the failure to obtain the details of the real-time synchronization task or data synchronization solution.
   * 
   * If the details of the real-time synchronization task or data synchronization solution are obtained, the value null is returned.
   * 
   * @example
   * fileId:[100] is invalid.
   */
  message?: string;
  /**
   * @remarks
   * *   If the TaskType parameter is set to DI_REALTIME, the value null is returned.
   * *   If the TaskType parameter is set to DI_SOLUTION, the details of the data synchronization solution are returned.
   */
  solutionDetail?: GetDISyncTaskResponseBodyDataSolutionDetail;
  /**
   * @remarks
   * Indicates whether the details of the real-time synchronization task or data synchronization solution are obtained. Valid values:
   * 
   * success: The details are obtained. fail: The details fail to be obtained.
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      solutionDetail: 'SolutionDetail',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      solutionDetail: GetDISyncTaskResponseBodyDataSolutionDetail,
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDagResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The data timestamp.
   * 
   * @example
   * 1605052800000
   */
  bizdate?: number;
  /**
   * @remarks
   * The time when the DAG was created.
   * 
   * @example
   * 1605052800000
   */
  createTime?: number;
  /**
   * @remarks
   * The creator.
   * 
   * @example
   * 1736629400048545
   */
  createUser?: string;
  /**
   * @remarks
   * The DAG ID.
   * 
   * @example
   * 351249682
   */
  dagId?: number;
  /**
   * @remarks
   * The time when the DAG finished running.
   * 
   * @example
   * 1605052800000
   */
  finishTime?: number;
  /**
   * @remarks
   * The time when the DAG was scheduled to run.
   * 
   * @example
   * 1605052800000
   */
  gmtdate?: number;
  /**
   * @remarks
   * The time when the DAG was last modified.
   * 
   * @example
   * 1605052800000
   */
  modifyTime?: number;
  /**
   * @remarks
   * The name of the DAG.
   * 
   * @example
   * test_dag
   */
  name?: string;
  /**
   * @remarks
   * The sequence number of the operation.
   * 
   * @example
   * 123
   */
  opSeq?: number;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 112345
   */
  projectId?: number;
  /**
   * @remarks
   * The time when the DAG started to run.
   * 
   * @example
   * 1605052800000
   */
  startTime?: number;
  /**
   * @remarks
   * The status of the DAG. Valid values: CREATED, RUNNING, FAILURE, and SUCCESS.
   * 
   * @example
   * FAILURE
   */
  status?: string;
  /**
   * @remarks
   * The type of the DAG. Valid values: MANUAL, SMOKE_TEST, SUPPLY_DATA, and BUSINESS_PROCESS_DAG. The value MANUAL indicates the DAG for a manually triggered workflow. The value SMOKE_TEST indicates the DAG for a smoke testing workflow. The value SUPPLY_DATA indicates the DAG for a data backfill instance. The value BUSINESS_PROCESS_DAG indicates the DAG for a one-time workflow.
   * 
   * @example
   * MANUAL_FLOW
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bizdate: 'Bizdate',
      createTime: 'CreateTime',
      createUser: 'CreateUser',
      dagId: 'DagId',
      finishTime: 'FinishTime',
      gmtdate: 'Gmtdate',
      modifyTime: 'ModifyTime',
      name: 'Name',
      opSeq: 'OpSeq',
      projectId: 'ProjectId',
      startTime: 'StartTime',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizdate: 'number',
      createTime: 'number',
      createUser: 'string',
      dagId: 'number',
      finishTime: 'number',
      gmtdate: 'number',
      modifyTime: 'number',
      name: 'string',
      opSeq: 'number',
      projectId: 'number',
      startTime: 'number',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1001
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * fail to call
   */
  errorMessage?: string;
  /**
   * @remarks
   * The solution used to fix the error.
   * 
   * @example
   * retry
   */
  errorSolution?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      errorSolution: 'ErrorSolution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      errorSolution: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
   * 
   * @example
   * column1
   */
  columnName?: string;
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * default1
   */
  defaultValue?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example1
   */
  exampleValue?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required.
   * 
   * @example
   * true
   */
  isRequiredParameter?: boolean;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description1
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * name1
   */
  parameterName?: string;
  /**
   * @remarks
   * The operator used for the value of the parameter. Valid values:
   * 
   * *   0: Equal
   * *   1: Like
   * *   2: Const
   * *   3: In
   * 
   * APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
   * 
   * @example
   * 0
   */
  parameterOperator?: number;
  /**
   * @remarks
   * The position of the parameter. Valid values:
   * 
   * *   0: indicates that the parameter is in the URL path of the request.
   * *   1: indicates that the parameter is in the Query parameter of the request URL.
   * *   2: indicates that the parameter is in the request header.
   * *   3: indicates that the parameter is in the request body.
   * 
   * APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
   * 
   * @example
   * 0
   */
  parameterPosition?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      defaultValue: 'DefaultValue',
      exampleValue: 'ExampleValue',
      isRequiredParameter: 'IsRequiredParameter',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
      parameterOperator: 'ParameterOperator',
      parameterPosition: 'ParameterPosition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      defaultValue: 'string',
      exampleValue: 'string',
      isRequiredParameter: 'boolean',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
      parameterOperator: 'number',
      parameterPosition: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponseBodyDataRegistrationDetails extends $tea.Model {
  /**
   * @remarks
   * The sample error response of the API.
   * 
   * @example
   * {"success": false}
   */
  failedResultSample?: string;
  /**
   * @remarks
   * The error codes returned for the API generated by registration.
   */
  registrationErrorCodes?: GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes[];
  /**
   * @remarks
   * The request parameters of the API generated by registration.
   */
  registrationRequestParameters?: GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters[];
  /**
   * @remarks
   * The format in which the response of the API request is returned. Valid values:
   * 
   * *   0: indicates the JSON format.
   * *   1: indicates the XML format.
   * 
   * APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
   * 
   * @example
   * 0
   */
  serviceContentType?: number;
  /**
   * @remarks
   * The address of the backend service.
   * 
   * @example
   * http://example.aliyundoc.com
   */
  serviceHost?: string;
  /**
   * @remarks
   * The path of the backend service.
   * 
   * @example
   * /index
   */
  servicePath?: string;
  /**
   * @remarks
   * The description of the request body initiated to call the backend service.
   * 
   * @example
   * {"abc":1}
   */
  serviceRequestBodyDescription?: string;
  /**
   * @remarks
   * Sample success responses
   * 
   * @example
   * {"success": true}
   */
  successfulResultSample?: string;
  static names(): { [key: string]: string } {
    return {
      failedResultSample: 'FailedResultSample',
      registrationErrorCodes: 'RegistrationErrorCodes',
      registrationRequestParameters: 'RegistrationRequestParameters',
      serviceContentType: 'ServiceContentType',
      serviceHost: 'ServiceHost',
      servicePath: 'ServicePath',
      serviceRequestBodyDescription: 'ServiceRequestBodyDescription',
      successfulResultSample: 'SuccessfulResultSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedResultSample: 'string',
      registrationErrorCodes: { 'type': 'array', 'itemType': GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes },
      registrationRequestParameters: { 'type': 'array', 'itemType': GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters },
      serviceContentType: 'number',
      serviceHost: 'string',
      servicePath: 'string',
      serviceRequestBodyDescription: 'string',
      successfulResultSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection extends $tea.Model {
  /**
   * @remarks
   * The ID of the data source.
   * 
   * @example
   * 123
   */
  connectionId?: number;
  /**
   * @remarks
   * The name of the table in the data source.
   * 
   * @example
   * t
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      connectionId: 'ConnectionId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionId: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
   * 
   * @example
   * column1
   */
  columnName?: string;
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * default1
   */
  defaultValue?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example1
   */
  exampleValue?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required.
   * 
   * @example
   * true
   */
  isRequiredParameter?: boolean;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description1
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param1
   */
  parameterName?: string;
  /**
   * @remarks
   * The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates the Equal operator. The value 1 indicates the Like operator. The value 2 indicates the Const operator. The value 3 indicates the In operator. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
   * 
   * @example
   * 0
   */
  parameterOperator?: number;
  /**
   * @remarks
   * The position of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the parameter is in the URL path of the request. The value 1 indicates that the parameter is in the Query parameter of the request URL. The value 2 indicates that the parameter is in the request header. The value 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
   * 
   * @example
   * 0
   */
  parameterPosition?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      defaultValue: 'DefaultValue',
      exampleValue: 'ExampleValue',
      isRequiredParameter: 'IsRequiredParameter',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
      parameterOperator: 'ParameterOperator',
      parameterPosition: 'ParameterPosition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      defaultValue: 'string',
      exampleValue: 'string',
      isRequiredParameter: 'boolean',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
      parameterOperator: 'number',
      parameterPosition: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
   * 
   * @example
   * column2
   */
  columnName?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example2
   */
  exampleValue?: string;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description2
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param2
   */
  parameterName?: string;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      exampleValue: 'ExampleValue',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      exampleValue: 'string',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponseBodyDataScriptDetails extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the entries were returned by page.
   * 
   * @example
   * true
   */
  isPagedResponse?: boolean;
  /**
   * @remarks
   * The SQL script.
   * 
   * @example
   * select a from t
   */
  script?: string;
  /**
   * @remarks
   * The data source information of the API generated in script mode.
   */
  scriptConnection?: GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection;
  /**
   * @remarks
   * The request parameters of the API generated in script mode.
   */
  scriptRequestParameters?: GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters[];
  /**
   * @remarks
   * The response parameters of the API generated in script mode.
   */
  scriptResponseParameters?: GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters[];
  static names(): { [key: string]: string } {
    return {
      isPagedResponse: 'IsPagedResponse',
      script: 'Script',
      scriptConnection: 'ScriptConnection',
      scriptRequestParameters: 'ScriptRequestParameters',
      scriptResponseParameters: 'ScriptResponseParameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isPagedResponse: 'boolean',
      script: 'string',
      scriptConnection: GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection,
      scriptRequestParameters: { 'type': 'array', 'itemType': GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters },
      scriptResponseParameters: { 'type': 'array', 'itemType': GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection extends $tea.Model {
  /**
   * @remarks
   * The ID of the data source.
   * 
   * @example
   * 123
   */
  connectionId?: number;
  /**
   * @remarks
   * The name of the table in the data source.
   * 
   * @example
   * t
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      connectionId: 'ConnectionId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionId: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
   * 
   * @example
   * column1
   */
  columnName?: string;
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * default1
   */
  defaultValue?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example1
   */
  exampleValue?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required.
   * 
   * @example
   * true
   */
  isRequiredParameter?: boolean;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description1
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param1
   */
  parameterName?: string;
  /**
   * @remarks
   * The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates the Equal operator. The value 1 indicates the Like operator. The value 2 indicates the Const operator. The value 3 indicates the In operator. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
   * 
   * @example
   * 0
   */
  parameterOperator?: number;
  /**
   * @remarks
   * The position of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the parameter is in the URL path of the request. The value 1 indicates that the parameter is in the Query parameter of the request URL. The value 2 indicates that the parameter is in the request header. The value 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
   * 
   * @example
   * 0
   */
  parameterPosition?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      defaultValue: 'DefaultValue',
      exampleValue: 'ExampleValue',
      isRequiredParameter: 'IsRequiredParameter',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
      parameterOperator: 'ParameterOperator',
      parameterPosition: 'ParameterPosition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      defaultValue: 'string',
      exampleValue: 'string',
      isRequiredParameter: 'boolean',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
      parameterOperator: 'number',
      parameterPosition: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
   * 
   * @example
   * column2
   */
  columnName?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example2
   */
  exampleValue?: string;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description2
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param2
   */
  parameterName?: string;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      exampleValue: 'ExampleValue',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      exampleValue: 'string',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponseBodyDataWizardDetails extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the entries were returned by page.
   * 
   * @example
   * true
   */
  isPagedResponse?: boolean;
  /**
   * @remarks
   * The data source information of the API generated in wizard mode.
   */
  wizardConnection?: GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection;
  /**
   * @remarks
   * The request parameters of the API generated in wizard mode.
   */
  wizardRequestParameters?: GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters[];
  /**
   * @remarks
   * The response parameters of the API generated in wizard mode.
   */
  wizardResponseParameters?: GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters[];
  static names(): { [key: string]: string } {
    return {
      isPagedResponse: 'IsPagedResponse',
      wizardConnection: 'WizardConnection',
      wizardRequestParameters: 'WizardRequestParameters',
      wizardResponseParameters: 'WizardResponseParameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isPagedResponse: 'boolean',
      wizardConnection: GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection,
      wizardRequestParameters: { 'type': 'array', 'itemType': GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters },
      wizardResponseParameters: { 'type': 'array', 'itemType': GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the DataService Studio API.
   * 
   * @example
   * 10000
   */
  apiId?: number;
  /**
   * @remarks
   * The type of the API. Valid values: 0, 1, and 2. The value 0 indicates that the API is generated in wizard mode. The value 1 indicates that the API is generated in script mode. The value 2 indicates that the API is generated by registration.
   * 
   * @example
   * 0
   */
  apiMode?: number;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * Name of the test API
   */
  apiName?: string;
  /**
   * @remarks
   * The path of the API.
   * 
   * @example
   * /test/1
   */
  apiPath?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  createdTime?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the creator of the API.
   * 
   * @example
   * 1234567
   */
  creatorId?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * Description of the test API
   */
  description?: string;
  /**
   * @remarks
   * The ID of the folder.
   * 
   * @example
   * 0
   */
  folderId?: number;
  /**
   * @remarks
   * The ID of the group.
   * 
   * @example
   * ab123****
   */
  groupId?: string;
  /**
   * @remarks
   * The time when the API was last modified.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the user who last modified the API.
   * 
   * @example
   * 2345678
   */
  operatorId?: string;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The list of fields.
   */
  protocols?: number[];
  /**
   * @remarks
   * The details of the API generated by registration. This parameter is returned only if the API is generated by registration.
   */
  registrationDetails?: GetDataServiceApiResponseBodyDataRegistrationDetails;
  /**
   * @remarks
   * The request method of the API. Valid values: 0, 1, 2, and 3. The value 0 indicates the GET method. The value 1 indicates the POST method. The value 2 indicates the PUT method. The value 3 indicates the DELETE method. APIs generated in wizard or script mode support the GET and POST methods. APIs generated by registration support the GET, POST, PUT, and DELETE methods.
   * 
   * @example
   * 0
   */
  requestMethod?: number;
  /**
   * @remarks
   * The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
   * 
   * @example
   * 0
   */
  responseContentType?: number;
  /**
   * @remarks
   * The details of the API generated in script mode. This parameter is returned only if the API is generated in script mode.
   */
  scriptDetails?: GetDataServiceApiResponseBodyDataScriptDetails;
  /**
   * @remarks
   * The status of the API. Valid values: 0 and 1. The value 0 indicates that the API is not published. The value 1 indicates that the API is published.
   * 
   * @example
   * 0
   */
  status?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 10002
   */
  tenantId?: number;
  /**
   * @remarks
   * The timeout period of the API request. Unit: milliseconds.
   * 
   * @example
   * 10000
   */
  timeout?: number;
  /**
   * @remarks
   * The scope in which the API is visible. Valid values: 0 and 1. The value 0 indicates that the API is visible to the members in a specific workspace. The value 1 indicates that the API is visible only to the API creator.
   * 
   * @example
   * 0
   */
  visibleRange?: number;
  /**
   * @remarks
   * The details of the API generated in wizard mode. This parameter is returned only if the API is generated in wizard mode.
   */
  wizardDetails?: GetDataServiceApiResponseBodyDataWizardDetails;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiMode: 'ApiMode',
      apiName: 'ApiName',
      apiPath: 'ApiPath',
      createdTime: 'CreatedTime',
      creatorId: 'CreatorId',
      description: 'Description',
      folderId: 'FolderId',
      groupId: 'GroupId',
      modifiedTime: 'ModifiedTime',
      operatorId: 'OperatorId',
      projectId: 'ProjectId',
      protocols: 'Protocols',
      registrationDetails: 'RegistrationDetails',
      requestMethod: 'RequestMethod',
      responseContentType: 'ResponseContentType',
      scriptDetails: 'ScriptDetails',
      status: 'Status',
      tenantId: 'TenantId',
      timeout: 'Timeout',
      visibleRange: 'VisibleRange',
      wizardDetails: 'WizardDetails',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      apiMode: 'number',
      apiName: 'string',
      apiPath: 'string',
      createdTime: 'string',
      creatorId: 'string',
      description: 'string',
      folderId: 'number',
      groupId: 'string',
      modifiedTime: 'string',
      operatorId: 'string',
      projectId: 'number',
      protocols: { 'type': 'array', 'itemType': 'number' },
      registrationDetails: GetDataServiceApiResponseBodyDataRegistrationDetails,
      requestMethod: 'number',
      responseContentType: 'number',
      scriptDetails: GetDataServiceApiResponseBodyDataScriptDetails,
      status: 'number',
      tenantId: 'number',
      timeout: 'number',
      visibleRange: 'number',
      wizardDetails: GetDataServiceApiResponseBodyDataWizardDetails,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApiTestResponseBodyData extends $tea.Model {
  /**
   * @example
   * 12343
   */
  apiId?: number;
  /**
   * @example
   * 10
   */
  costTime?: string;
  /**
   * @example
   * [<span style=\\"color: #92D581;\\">INFO</span>] [16:15:13.240] resource group is 498774069027041[<span style=\\"color: #92D581;\\">INFO</span>]
   */
  debugInfo?: string;
  /**
   * @example
   * [<span style=\\"color: #92D581;\\">INFO</span>] [16:15:13.240] resource group is 498774069027041[<span style=\\"color: #92D581;\\">INFO</span>]
   */
  nodesDebugInfo?: string;
  /**
   * @example
   * {"name":"test"}
   */
  paramMap?: string;
  /**
   * @example
   * 0
   */
  retCode?: number;
  /**
   * @example
   * {"id":2}
   */
  retResult?: string;
  /**
   * @example
   * FINISHED
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      costTime: 'CostTime',
      debugInfo: 'DebugInfo',
      nodesDebugInfo: 'NodesDebugInfo',
      paramMap: 'ParamMap',
      retCode: 'RetCode',
      retResult: 'RetResult',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      costTime: 'string',
      debugInfo: 'string',
      nodesDebugInfo: 'string',
      paramMap: 'string',
      retCode: 'number',
      retResult: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceApplicationResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The AppCode for simple authentication. You can select simple authentication or signature authentication when you call an API operation.
   * 
   * @example
   * CODE123
   */
  applicationCode?: string;
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * 10000
   */
  applicationId?: number;
  /**
   * @remarks
   * The AppKey for signature authentication. You can select simple authentication or signature authentication when you call an API operation.
   * 
   * @example
   * KEY123
   */
  applicationKey?: string;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * Test application
   */
  applicationName?: string;
  /**
   * @remarks
   * The AppSecret for signature authentication. You can select simple authentication or signature authentication when you call an API operation.
   * 
   * @example
   * SECRET123
   */
  applicationSecret?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      applicationCode: 'ApplicationCode',
      applicationId: 'ApplicationId',
      applicationKey: 'ApplicationKey',
      applicationName: 'ApplicationName',
      applicationSecret: 'ApplicationSecret',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationCode: 'string',
      applicationId: 'number',
      applicationKey: 'string',
      applicationName: 'string',
      applicationSecret: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceFolderResponseBodyFolder extends $tea.Model {
  /**
   * @remarks
   * The time when the folder was created.
   * 
   * @example
   * 2020-09-24T18:37:51+0800
   */
  createdTime?: string;
  /**
   * @remarks
   * The folder ID.
   * 
   * @example
   * 11
   */
  folderId?: number;
  /**
   * @remarks
   * The name of the folder.
   * 
   * @example
   * test1
   */
  folderName?: string;
  /**
   * @remarks
   * The ID of the business process to which the folder belongs.
   * 
   * @example
   * ds_1234
   */
  groupId?: string;
  /**
   * @remarks
   * The time when the folder was last modified.
   * 
   * @example
   * 2020-09-24T18:37:51+0800
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The parent folder ID. The ID of the root folder in a business process is 0, and the ID of a folder created by a user in a business process is greater than 0.
   * 
   * @example
   * 0
   */
  parentId?: number;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 10002
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      folderId: 'FolderId',
      folderName: 'FolderName',
      groupId: 'GroupId',
      modifiedTime: 'ModifiedTime',
      parentId: 'ParentId',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      folderId: 'number',
      folderName: 'string',
      groupId: 'string',
      modifiedTime: 'string',
      parentId: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServiceGroupResponseBodyGroup extends $tea.Model {
  /**
   * @remarks
   * The ID of the API group that is associated with the business process in the API Gateway console.
   * 
   * @example
   * 100abc
   */
  apiGatewayGroupId?: string;
  /**
   * @remarks
   * The time when the business process was created.
   * 
   * @example
   * 2020-09-24T18:37:51+0800
   */
  createdTime?: string;
  /**
   * @remarks
   * The user identifier (UID) of the creator of the business process. The value of this parameter may be empty for creators of some existing business processes.
   * 
   * @example
   * 10001
   */
  creatorId?: string;
  /**
   * @remarks
   * The description of the business process.
   * 
   * @example
   * Test
   */
  description?: string;
  /**
   * @remarks
   * The business process ID.
   * 
   * @example
   * ds_123abc
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the business process.
   * 
   * @example
   * Test
   */
  groupName?: string;
  /**
   * @remarks
   * The time when the business process was last modified.
   * 
   * @example
   * 2020-09-24T18:37:51+0800
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 10002
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 10003
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiGatewayGroupId: 'ApiGatewayGroupId',
      createdTime: 'CreatedTime',
      creatorId: 'CreatorId',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      modifiedTime: 'ModifiedTime',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiGatewayGroupId: 'string',
      createdTime: 'string',
      creatorId: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      modifiedTime: 'string',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * Invalid.Tenant.ConnectionNotExists
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * The connection does not exist.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The solution used to fix the error.
   * 
   * @example
   * retry
   */
  errorSolution?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      errorSolution: 'ErrorSolution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      errorSolution: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters extends $tea.Model {
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * default1
   */
  defaultValue?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example1
   */
  exampleValue?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required.
   * 
   * @example
   * true
   */
  isRequiredParameter?: boolean;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description1
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * name1
   */
  parameterName?: string;
  /**
   * @remarks
   * The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates the Equal operator. The value 1 indicates the Like operator. The value 2 indicates the Const operator. The value 3 indicates the In operator. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
   * 
   * @example
   * 0
   */
  parameterOperator?: number;
  /**
   * @remarks
   * The position of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the parameter is in the URL path of the request. The value 1 indicates that the parameter is in the Query parameter of the request URL. The value 2 indicates that the parameter is in the request header. The value 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
   * 
   * @example
   * 0
   */
  parameterPosition?: number;
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      exampleValue: 'ExampleValue',
      isRequiredParameter: 'IsRequiredParameter',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
      parameterOperator: 'ParameterOperator',
      parameterPosition: 'ParameterPosition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'string',
      exampleValue: 'string',
      isRequiredParameter: 'boolean',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
      parameterOperator: 'number',
      parameterPosition: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyDataRegistrationDetails extends $tea.Model {
  /**
   * @remarks
   * The sample error response of the API.
   * 
   * @example
   * {"success": false}
   */
  failedResultSample?: string;
  /**
   * @remarks
   * The error codes returned for the API generated by registration.
   */
  registrationErrorCodes?: GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes[];
  /**
   * @remarks
   * The request parameters of the API generated by registration.
   */
  registrationRequestParameters?: GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters[];
  /**
   * @remarks
   * The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
   * 
   * @example
   * 0
   */
  serviceContentType?: number;
  /**
   * @remarks
   * The URL of the backend service.
   * 
   * @example
   * http://example.aliyundoc.com
   */
  serviceHost?: string;
  /**
   * @remarks
   * The path of the backend service.
   * 
   * @example
   * /index
   */
  servicePath?: string;
  /**
   * @remarks
   * The description of the request body initiated to call the backend service.
   * 
   * @example
   * {"abc":1}
   */
  serviceRequestBodyDescription?: string;
  /**
   * @remarks
   * The sample success response of the API.
   * 
   * @example
   * {"success": true}
   */
  successfulResultSample?: string;
  static names(): { [key: string]: string } {
    return {
      failedResultSample: 'FailedResultSample',
      registrationErrorCodes: 'RegistrationErrorCodes',
      registrationRequestParameters: 'RegistrationRequestParameters',
      serviceContentType: 'ServiceContentType',
      serviceHost: 'ServiceHost',
      servicePath: 'ServicePath',
      serviceRequestBodyDescription: 'ServiceRequestBodyDescription',
      successfulResultSample: 'SuccessfulResultSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedResultSample: 'string',
      registrationErrorCodes: { 'type': 'array', 'itemType': GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes },
      registrationRequestParameters: { 'type': 'array', 'itemType': GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters },
      serviceContentType: 'number',
      serviceHost: 'string',
      servicePath: 'string',
      serviceRequestBodyDescription: 'string',
      successfulResultSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection extends $tea.Model {
  /**
   * @remarks
   * The ID of the data source.
   * 
   * @example
   * 123
   */
  connectionId?: number;
  /**
   * @remarks
   * The name of the table in the data source.
   * 
   * @example
   * t
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      connectionId: 'ConnectionId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionId: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1001
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * fail to call
   */
  errorMessage?: string;
  /**
   * @remarks
   * The solution used to fix the error.
   * 
   * @example
   * retry
   */
  errorSolution?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      errorSolution: 'ErrorSolution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      errorSolution: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters extends $tea.Model {
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * default1
   */
  defaultValue?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example1
   */
  exampleValue?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required.
   * 
   * @example
   * true
   */
  isRequiredParameter?: boolean;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description1
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param1
   */
  parameterName?: string;
  /**
   * @remarks
   * The operator used for the value of the parameter. Valid values:
   * 
   * *   0: Equal
   * *   1: Like
   * *   2: Const
   * *   3: In
   * 
   * APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
   * 
   * @example
   * 0
   */
  parameterOperator?: number;
  /**
   * @remarks
   * The position of the parameter. Valid values:
   * 
   * *   0: indicates that the parameter is in the URL path of the request.
   * *   1: indicates that the parameter is in the Query parameter of the request URL.
   * *   2: indicates that the parameter is in the request header.
   * *   3: indicates that the parameter is in the request body.
   * 
   * APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
   * 
   * @example
   * 0
   */
  parameterPosition?: number;
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      exampleValue: 'ExampleValue',
      isRequiredParameter: 'IsRequiredParameter',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
      parameterOperator: 'ParameterOperator',
      parameterPosition: 'ParameterPosition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'string',
      exampleValue: 'string',
      isRequiredParameter: 'boolean',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
      parameterOperator: 'number',
      parameterPosition: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters extends $tea.Model {
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example2
   */
  exampleValue?: string;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description2
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param2
   */
  parameterName?: string;
  static names(): { [key: string]: string } {
    return {
      exampleValue: 'ExampleValue',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exampleValue: 'string',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyDataScriptDetails extends $tea.Model {
  /**
   * @remarks
   * The sample error response of the API.
   * 
   * @example
   * {"success": false}
   */
  failedResultSample?: string;
  /**
   * @remarks
   * Indicates whether the entries were returned by page.
   * 
   * @example
   * true
   */
  isPagedResponse?: boolean;
  /**
   * @remarks
   * The SQL script.
   * 
   * @example
   * select a from t
   */
  script?: string;
  /**
   * @remarks
   * The data source information of the API generated in script mode.
   */
  scriptConnection?: GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection;
  /**
   * @remarks
   * The error codes returned for the API generated in script mode.
   */
  scriptErrorCodes?: GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes[];
  /**
   * @remarks
   * The request parameters of the API generated in script mode.
   */
  scriptRequestParameters?: GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters[];
  /**
   * @remarks
   * The response parameters of the API generated in script mode.
   */
  scriptResponseParameters?: GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters[];
  /**
   * @remarks
   * The sample success response of the API.
   * 
   * @example
   * {"success": true}
   */
  successfulResultSample?: string;
  static names(): { [key: string]: string } {
    return {
      failedResultSample: 'FailedResultSample',
      isPagedResponse: 'IsPagedResponse',
      script: 'Script',
      scriptConnection: 'ScriptConnection',
      scriptErrorCodes: 'ScriptErrorCodes',
      scriptRequestParameters: 'ScriptRequestParameters',
      scriptResponseParameters: 'ScriptResponseParameters',
      successfulResultSample: 'SuccessfulResultSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedResultSample: 'string',
      isPagedResponse: 'boolean',
      script: 'string',
      scriptConnection: GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection,
      scriptErrorCodes: { 'type': 'array', 'itemType': GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes },
      scriptRequestParameters: { 'type': 'array', 'itemType': GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters },
      scriptResponseParameters: { 'type': 'array', 'itemType': GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters },
      successfulResultSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection extends $tea.Model {
  /**
   * @remarks
   * The ID of the data source.
   * 
   * @example
   * 123
   */
  connectionId?: number;
  /**
   * @remarks
   * The name of the table in the data source.
   * 
   * @example
   * t
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      connectionId: 'ConnectionId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionId: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1001
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * fail to call
   */
  errorMessage?: string;
  /**
   * @remarks
   * The solution used to fix the error.
   * 
   * @example
   * retry
   */
  errorSolution?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      errorSolution: 'ErrorSolution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      errorSolution: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters extends $tea.Model {
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * default1
   */
  defaultValue?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example1
   */
  exampleValue?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required.
   * 
   * @example
   * true
   */
  isRequiredParameter?: boolean;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description1
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param1
   */
  parameterName?: string;
  /**
   * @remarks
   * The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates the Equal operator. The value 1 indicates the Like operator. The value 2 indicates the Const operator. The value 3 indicates the In operator. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
   * 
   * @example
   * 0
   */
  parameterOperator?: number;
  /**
   * @remarks
   * The position of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the parameter is in the URL path of the request. The value 1 indicates that the parameter is in the Query parameter of the request URL. The value 2 indicates that the parameter is in the request header. The value 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
   * 
   * @example
   * 0
   */
  parameterPosition?: number;
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      exampleValue: 'ExampleValue',
      isRequiredParameter: 'IsRequiredParameter',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
      parameterOperator: 'ParameterOperator',
      parameterPosition: 'ParameterPosition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'string',
      exampleValue: 'string',
      isRequiredParameter: 'boolean',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
      parameterOperator: 'number',
      parameterPosition: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters extends $tea.Model {
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example2
   */
  exampleValue?: string;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description2
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param2
   */
  parameterName?: string;
  static names(): { [key: string]: string } {
    return {
      exampleValue: 'ExampleValue',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exampleValue: 'string',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyDataWizardDetails extends $tea.Model {
  /**
   * @remarks
   * The sample error response of the API.
   * 
   * @example
   * {"success": false}
   */
  failedResultSample?: string;
  /**
   * @remarks
   * Indicates whether the entries were returned by page.
   * 
   * @example
   * true
   */
  isPagedResponse?: boolean;
  /**
   * @remarks
   * The sample success response of the API.
   * 
   * @example
   * {"success": true}
   */
  successfulResultSample?: string;
  /**
   * @remarks
   * The data source information of the API generated in wizard mode.
   */
  wizardConnection?: GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection;
  /**
   * @remarks
   * The error codes returned for the API generated in wizard mode.
   */
  wizardErrorCodes?: GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes[];
  /**
   * @remarks
   * The request parameters of the API generated in wizard mode.
   */
  wizardRequestParameters?: GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters[];
  /**
   * @remarks
   * The response parameters of the API generated in wizard mode.
   */
  wizardResponseParameters?: GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters[];
  static names(): { [key: string]: string } {
    return {
      failedResultSample: 'FailedResultSample',
      isPagedResponse: 'IsPagedResponse',
      successfulResultSample: 'SuccessfulResultSample',
      wizardConnection: 'WizardConnection',
      wizardErrorCodes: 'WizardErrorCodes',
      wizardRequestParameters: 'WizardRequestParameters',
      wizardResponseParameters: 'WizardResponseParameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedResultSample: 'string',
      isPagedResponse: 'boolean',
      successfulResultSample: 'string',
      wizardConnection: GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection,
      wizardErrorCodes: { 'type': 'array', 'itemType': GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes },
      wizardRequestParameters: { 'type': 'array', 'itemType': GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters },
      wizardResponseParameters: { 'type': 'array', 'itemType': GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataServicePublishedApiResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the DataService Studio API.
   * 
   * @example
   * 10000
   */
  apiId?: number;
  /**
   * @remarks
   * The type of the API. Valid values: 0, 1, and 2. The value 0 indicates that the API is generated in wizard mode. The value 1 indicates that the API is generated in script mode. The value 2 indicates that the API is generated by registration.
   * 
   * @example
   * 0
   */
  apiMode?: number;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * Name of the test API
   */
  apiName?: string;
  /**
   * @remarks
   * The path of the API.
   * 
   * @example
   * /test/1
   */
  apiPath?: string;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  createdTime?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the creator of the API.
   * 
   * @example
   * 1234567
   */
  creatorId?: string;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * Description of the test API
   */
  description?: string;
  /**
   * @remarks
   * The ID of the group.
   * 
   * @example
   * ab12**
   */
  groupId?: string;
  /**
   * @remarks
   * The time when the API was last modified.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the user who last modified the API.
   * 
   * @example
   * 2345678
   */
  operatorId?: string;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The protocol used by the API. Valid values: 0 and 1. The value 0 indicates HTTP. The value 1 indicates HTTPS. Multiple protocols are presented in a list.
   */
  protocols?: number[];
  /**
   * @remarks
   * The details of the API generated by registration. This parameter is returned only if the API is generated by registration.
   */
  registrationDetails?: GetDataServicePublishedApiResponseBodyDataRegistrationDetails;
  /**
   * @remarks
   * The request method of the API. Valid values: 0, 1, 2, and 3. The value 0 indicates the GET method, the value 1 indicates the POST method, the value 2 indicates the PUT method, and the value 3 indicates the DELETE method. APIs generated in wizard or script mode support the GET and POST methods. APIs generated by registration support the GET, POST, PUT, and DELETE methods.
   * 
   * @example
   * 0
   */
  requestMethod?: number;
  /**
   * @remarks
   * The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
   * 
   * @example
   * 0
   */
  responseContentType?: number;
  /**
   * @remarks
   * The details of the API generated in script mode. This parameter is returned only if the API is generated in script mode.
   */
  scriptDetails?: GetDataServicePublishedApiResponseBodyDataScriptDetails;
  /**
   * @remarks
   * The status of the API. Valid values: 0 and 1. The value 0 indicates that the API is not published. The value 1 indicates that the API is published.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 10001
   */
  tenantId?: number;
  /**
   * @remarks
   * The timeout period of the API request. Unit: milliseconds.
   * 
   * @example
   * 10000
   */
  timeout?: number;
  /**
   * @remarks
   * The scope in which the API is visible. Valid values: 0 and 1. The value 0 indicates that the API is visible to the members in a specific workspace. The value 1 indicates that the API is visible only to the API creator.
   * 
   * @example
   * 0
   */
  visibleRange?: number;
  /**
   * @remarks
   * The details of the API generated in wizard mode. This parameter is returned only if the API is generated in wizard mode.
   */
  wizardDetails?: GetDataServicePublishedApiResponseBodyDataWizardDetails;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiMode: 'ApiMode',
      apiName: 'ApiName',
      apiPath: 'ApiPath',
      createdTime: 'CreatedTime',
      creatorId: 'CreatorId',
      description: 'Description',
      groupId: 'GroupId',
      modifiedTime: 'ModifiedTime',
      operatorId: 'OperatorId',
      projectId: 'ProjectId',
      protocols: 'Protocols',
      registrationDetails: 'RegistrationDetails',
      requestMethod: 'RequestMethod',
      responseContentType: 'ResponseContentType',
      scriptDetails: 'ScriptDetails',
      status: 'Status',
      tenantId: 'TenantId',
      timeout: 'Timeout',
      visibleRange: 'VisibleRange',
      wizardDetails: 'WizardDetails',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      apiMode: 'number',
      apiName: 'string',
      apiPath: 'string',
      createdTime: 'string',
      creatorId: 'string',
      description: 'string',
      groupId: 'string',
      modifiedTime: 'string',
      operatorId: 'string',
      projectId: 'number',
      protocols: { 'type': 'array', 'itemType': 'number' },
      registrationDetails: GetDataServicePublishedApiResponseBodyDataRegistrationDetails,
      requestMethod: 'number',
      responseContentType: 'number',
      scriptDetails: GetDataServicePublishedApiResponseBodyDataScriptDetails,
      status: 'number',
      tenantId: 'number',
      timeout: 'number',
      visibleRange: 'number',
      wizardDetails: GetDataServicePublishedApiResponseBodyDataWizardDetails,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDataSourceMetaResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The reason why the metadata of the data source fails to be obtained. If the metadata of the data source is obtained, no value is returned for this parameter.
   * 
   * @example
   * read datasource time out
   */
  message?: string;
  /**
   * @remarks
   * The returned metadata of the data source. The returned metadata is in the JSON format.
   * 
   * `{"dbTables":[{"dbName":"testdb","schema":[{"tableInfos":[{"dbName":"testdb","enable":true,"table":"table1","tableName":"table1"}]},{"tableInfos":[{"dbName":"testdb","enable":true,"table":"table2","tableName":"table2"}]}]}]}`
   * 
   * Parameter description:
   * 
   * *   dbName: the name of the database in which the data source resides.
   * *   schema: the schema of the database.
   * *   enable: indicates whether the database is available. The valid values are true and false. The value true indicates that the database is available. The value false indicates that the database is unavailable.
   * *   tableName: the name of the table in the database.
   * *   tableInfos: the information about the table in the database.
   * 
   * @example
   * {"dbTables":[{"dbName":"testdb","schema":[{"tableInfos":[{"dbName":"testdb","enable":true,"table":"table1","tableName":"table1"}]},{"tableInfos":[{"dbName":"testdb","enable":true,"table":"table2","tableName":"table2"}]}]}]}
   */
  meta?: string;
  /**
   * @remarks
   * Indicates whether the metadata of the data source is obtained. Valid values:
   * 
   * *   success: The metadata of the data source is obtained.
   * *   fail: The metadata of the data source failed to be obtained. You can troubleshoot issues based on the Message parameter.
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      meta: 'Meta',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      meta: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeploymentResponseBodyDataDeployedItems extends $tea.Model {
  /**
   * @example
   * 507642378
   */
  fileId?: number;
  /**
   * @example
   * 7
   */
  fileVersion?: number;
  /**
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      fileVersion: 'FileVersion',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'number',
      fileVersion: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeploymentResponseBodyDataDeployment extends $tea.Model {
  /**
   * @remarks
   * The check status of one or more files in the deployment task. If the value of the ToEnvironment parameter is 1, the files can be deployed to the production environment only when the value of the Status parameter is 1 and the CheckingStatus parameter is empty. Valid values:
   * 
   * *   7: The file failed the check.
   * *   8: The file is being checked.
   * 
   * @example
   * 7
   */
  checkingStatus?: number;
  /**
   * @remarks
   * The time when the deployment task was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1593877765000
   */
  createTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the user who created the deployment task.
   * 
   * @example
   * 20030****
   */
  creatorId?: string;
  /**
   * @remarks
   * The error message that was returned when the deployment task failed. In this case, the value of the Status parameter is 2.
   */
  errorMessage?: string;
  /**
   * @remarks
   * The time when the deployment task was run. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1593877765000
   */
  executeTime?: number;
  /**
   * @remarks
   * The environment in which the deployment task was run. Valid values: 0 and 1. A value of 0 indicates the on-premises environment. A value of 1 indicates the development environment.
   * 
   * @example
   * 0
   */
  fromEnvironment?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the user who ran the deployment task.
   * 
   * @example
   * 2003****
   */
  handlerId?: string;
  /**
   * @remarks
   * The name of the deployment task. The value is the same as the name of the specific deployment task that is displayed on the Release Package page in the Deploy module.
   * 
   * @example
   * ods_user_info_d-2020-07-04_20030****
   */
  name?: string;
  /**
   * @remarks
   * The status of the deployment task. Valid values: 0, 1, and 2. A value of 0 indicates that the task is ready. A value of 1 indicates that the task was successful. A value of 2 indicates that the task failed.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The environment to which the file was deployed. Valid values: 1 and 2. A value of 1 indicates the development environment. A value of 2 indicates the production environment.
   * 
   * @example
   * 1
   */
  toEnvironment?: number;
  static names(): { [key: string]: string } {
    return {
      checkingStatus: 'CheckingStatus',
      createTime: 'CreateTime',
      creatorId: 'CreatorId',
      errorMessage: 'ErrorMessage',
      executeTime: 'ExecuteTime',
      fromEnvironment: 'FromEnvironment',
      handlerId: 'HandlerId',
      name: 'Name',
      status: 'Status',
      toEnvironment: 'ToEnvironment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkingStatus: 'number',
      createTime: 'number',
      creatorId: 'string',
      errorMessage: 'string',
      executeTime: 'number',
      fromEnvironment: 'number',
      handlerId: 'string',
      name: 'string',
      status: 'number',
      toEnvironment: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetDeploymentResponseBodyData extends $tea.Model {
  deployedItems?: GetDeploymentResponseBodyDataDeployedItems[];
  /**
   * @remarks
   * The details of the deployment task.
   */
  deployment?: GetDeploymentResponseBodyDataDeployment;
  static names(): { [key: string]: string } {
    return {
      deployedItems: 'DeployedItems',
      deployment: 'Deployment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployedItems: { 'type': 'array', 'itemType': GetDeploymentResponseBodyDataDeployedItems },
      deployment: GetDeploymentResponseBodyDataDeployment,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetExtensionResponseBodyExtensionBindEventList extends $tea.Model {
  /**
   * @remarks
   * The code of the extension point event.
   * 
   * @example
   * commit-file
   */
  eventCode?: string;
  /**
   * @remarks
   * The name of the extension point event.
   */
  eventName?: string;
  static names(): { [key: string]: string } {
    return {
      eventCode: 'EventCode',
      eventName: 'EventName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventCode: 'string',
      eventName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetExtensionResponseBodyExtensionEventCategoryList extends $tea.Model {
  /**
   * @remarks
   * The code of the event type.
   * 
   * @example
   * file-change
   */
  categoryCode?: string;
  /**
   * @remarks
   * The name of the event type.
   */
  categoryName?: string;
  static names(): { [key: string]: string } {
    return {
      categoryCode: 'CategoryCode',
      categoryName: 'CategoryName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryCode: 'string',
      categoryName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetExtensionResponseBodyExtension extends $tea.Model {
  /**
   * @remarks
   * The list of extension points.
   */
  bindEventList?: GetExtensionResponseBodyExtensionBindEventList[];
  /**
   * @remarks
   * The URL of the extension details page, on which users can view the details of the process blocked by the extension.
   * 
   * @example
   * https://www.aliyun.com/
   */
  detailUrl?: string;
  /**
   * @remarks
   * The list of event types.
   */
  eventCategoryList?: GetExtensionResponseBodyExtensionEventCategoryList[];
  /**
   * @remarks
   * The unique code of the extension.
   * 
   * @example
   * ce4*********086da5
   */
  extensionCode?: string;
  /**
   * @remarks
   * The description of the extension.
   */
  extensionDesc?: string;
  /**
   * @remarks
   * The name of the extension.
   */
  extensionName?: string;
  /**
   * @remarks
   * The URL of the help documentation of the extension.
   * 
   * @example
   * https://www.aliyun.com/
   */
  helpDocUrl?: string;
  /**
   * @remarks
   * The options defined for the extension.
   */
  optionSetting?: string;
  /**
   * @remarks
   * The parameter settings of the extension. For more information, see [Configure extension parameters](https://help.aliyun.com/document_detail/405354.html).
   * 
   * @example
   * extension.project.disabled=projectId1,projectId2,projectId3
   */
  parameterSetting?: string;
  /**
   * @remarks
   * The workspace for testing. If the extension is being tested, the extension can be used only in the workspace for testing.
   * 
   * @example
   * 13552
   */
  projectTesting?: number;
  /**
   * @remarks
   * The state of the extension. 0: Testing, 1: Publishing, 3: Disabled, 4: Processing, 5: Approved, 6: Approve Failed
   * 
   * @example
   * 0
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      bindEventList: 'BindEventList',
      detailUrl: 'DetailUrl',
      eventCategoryList: 'EventCategoryList',
      extensionCode: 'ExtensionCode',
      extensionDesc: 'ExtensionDesc',
      extensionName: 'ExtensionName',
      helpDocUrl: 'HelpDocUrl',
      optionSetting: 'OptionSetting',
      parameterSetting: 'ParameterSetting',
      projectTesting: 'ProjectTesting',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindEventList: { 'type': 'array', 'itemType': GetExtensionResponseBodyExtensionBindEventList },
      detailUrl: 'string',
      eventCategoryList: { 'type': 'array', 'itemType': GetExtensionResponseBodyExtensionEventCategoryList },
      extensionCode: 'string',
      extensionDesc: 'string',
      extensionName: 'string',
      helpDocUrl: 'string',
      optionSetting: 'string',
      parameterSetting: 'string',
      projectTesting: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileResponseBodyDataFile extends $tea.Model {
  /**
   * @remarks
   * The advanced configurations of the node.
   * 
   * This parameter is valid for an EMR node. This parameter corresponds to the Advanced Settings tab in the right-side navigation pane on the configuration tab of the node in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * >  You cannot configure advanced parameters for EMR Shell nodes.
   * 
   * For information about the advanced parameters of each type of EMR node, see [Develop EMR tasks](https://help.aliyun.com/document_detail/473077.html).
   * 
   * @example
   * {"queue":"default","SPARK_CONF":"--conf spark.driver.memory=2g"}
   */
  advancedSettings?: string;
  /**
   * @remarks
   * Indicates whether the automatic parsing feature is enabled for the file. Valid values:
   * 
   * *   true: The automatic parsing feature is enabled for the file.
   * *   false: The automatic parsing feature is not enabled for the file.
   * 
   * This parameter corresponds to the Analyze Code parameter that is displayed after Same Cycle is selected in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * true
   */
  autoParsing?: boolean;
  /**
   * @remarks
   * The ID of the workflow to which the file belongs. This parameter is deprecated and replaced by the BusinessId parameter.
   * 
   * @example
   * 1000001
   */
  bizId?: number;
  /**
   * @remarks
   * The ID of the workflow to which the file belongs.
   * 
   * @example
   * 1000001
   */
  businessId?: number;
  /**
   * @remarks
   * Indicates whether the latest code in the file is committed. Valid values: 0 and 1. The value 0 indicates that the latest code in the file is not committed. The value 1 indicates that the latest code in the file is committed.
   * 
   * @example
   * 0
   */
  commitStatus?: number;
  /**
   * @remarks
   * The ID of the compute engine instance that is used to run the node that corresponds to the file.
   * 
   * @example
   * odps_first
   */
  connectionName?: string;
  /**
   * @remarks
   * The code in the file.
   * 
   * @example
   * SHOW TABLES;
   */
  content?: string;
  /**
   * @remarks
   * The time when the file was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1593879116000
   */
  createTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used to create the file.
   * 
   * @example
   * 424732****
   */
  createUser?: string;
  /**
   * @remarks
   * The latest version number of the file.
   * 
   * @example
   * 3
   */
  currentVersion?: number;
  /**
   * @remarks
   * The status of the file. Valid values:
   * 
   * *   NORMAL: The file is not deleted.
   * *   RECYCLE_BIN: The file is stored in the recycle bin.
   * *   DELETED: The file is deleted.
   * 
   * @example
   * RECYCLE
   */
  deletedStatus?: string;
  /**
   * @remarks
   * The description of the file.
   */
  fileDescription?: string;
  /**
   * @remarks
   * The ID of the folder to which the file belongs.
   * 
   * @example
   * 2735c2****
   */
  fileFolderId?: string;
  /**
   * @example
   * 100000001
   */
  fileId?: number;
  /**
   * @remarks
   * The name of the file.
   * 
   * @example
   * ods_user_info_d
   */
  fileName?: string;
  /**
   * @remarks
   * The type of the code for the file. Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3).
   * 
   * @example
   * 10
   */
  fileType?: number;
  /**
   * @remarks
   * Indicates whether the file needs to be uploaded to MaxCompute.
   * 
   * This parameter is returned only if the file is a MaxCompute resource file.
   * 
   * @example
   * true
   */
  isMaxCompute?: boolean;
  /**
   * @remarks
   * The time when the file was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1593879116000
   */
  lastEditTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used to last modify the file.
   * 
   * @example
   * 62465892****
   */
  lastEditUser?: string;
  /**
   * @remarks
   * The ID of the auto triggered node that is generated in the scheduling system after the file is committed.
   * 
   * @example
   * 300001
   */
  nodeId?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the file owner.
   * 
   * @example
   * 7775674356****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the node group file to which the current file belongs. This parameter is returned only if the current file is an inner file of the node group file.
   * 
   * @example
   * -1
   */
  parentId?: number;
  /**
   * @remarks
   * The module to which the file belongs. Valid values:
   * 
   * *   NORMAL: The file is used for DataStudio.
   * *   MANUAL: The file is used for a manually triggered node.
   * *   MANUAL_BIZ: The file is used for a manually triggered workflow.
   * *   SKIP: The file is used for a dry-run DataStudio node.
   * *   ADHOCQUERY: The file is used for an ad hoc query.
   * *   COMPONENT: The file is used for a snippet.
   * 
   * @example
   * NORMAL
   */
  useType?: string;
  static names(): { [key: string]: string } {
    return {
      advancedSettings: 'AdvancedSettings',
      autoParsing: 'AutoParsing',
      bizId: 'BizId',
      businessId: 'BusinessId',
      commitStatus: 'CommitStatus',
      connectionName: 'ConnectionName',
      content: 'Content',
      createTime: 'CreateTime',
      createUser: 'CreateUser',
      currentVersion: 'CurrentVersion',
      deletedStatus: 'DeletedStatus',
      fileDescription: 'FileDescription',
      fileFolderId: 'FileFolderId',
      fileId: 'FileId',
      fileName: 'FileName',
      fileType: 'FileType',
      isMaxCompute: 'IsMaxCompute',
      lastEditTime: 'LastEditTime',
      lastEditUser: 'LastEditUser',
      nodeId: 'NodeId',
      owner: 'Owner',
      parentId: 'ParentId',
      useType: 'UseType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advancedSettings: 'string',
      autoParsing: 'boolean',
      bizId: 'number',
      businessId: 'number',
      commitStatus: 'number',
      connectionName: 'string',
      content: 'string',
      createTime: 'number',
      createUser: 'string',
      currentVersion: 'number',
      deletedStatus: 'string',
      fileDescription: 'string',
      fileFolderId: 'string',
      fileId: 'number',
      fileName: 'string',
      fileType: 'number',
      isMaxCompute: 'boolean',
      lastEditTime: 'number',
      lastEditUser: 'string',
      nodeId: 'number',
      owner: 'string',
      parentId: 'number',
      useType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileResponseBodyDataNodeConfigurationInputList extends $tea.Model {
  /**
   * @remarks
   * The output name of the parent file on which the current file depends.
   * 
   * This parameter corresponds to the Output Name of Ancestor Node parameter under Parent Nodes after Same Cycle is selected in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * project.001_out
   */
  input?: string;
  /**
   * @remarks
   * The mode of the configuration file dependency. Valid values:
   * 
   * *   MANUAL: Scheduling dependencies are manually configured.
   * *   AUTO: Scheduling dependencies are automatically parsed.
   * 
   * @example
   * MANUAL
   */
  parseType?: string;
  static names(): { [key: string]: string } {
    return {
      input: 'Input',
      parseType: 'ParseType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      input: 'string',
      parseType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileResponseBodyDataNodeConfigurationInputParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the input parameter of the node. In the code, you can use the ${...} method to reference the input parameter of the node.
   * 
   * This parameter corresponds to the Parameter Name parameter in the Input Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * input
   */
  parameterName?: string;
  /**
   * @remarks
   * The value source of the input parameter of the node.
   * 
   * This parameter corresponds to the Value Source parameter in the Input Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * project_001.parent_node:outputs
   */
  valueSource?: string;
  static names(): { [key: string]: string } {
    return {
      parameterName: 'ParameterName',
      valueSource: 'ValueSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      parameterName: 'string',
      valueSource: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileResponseBodyDataNodeConfigurationOutputList extends $tea.Model {
  /**
   * @remarks
   * The output name of the current file.
   * 
   * This parameter corresponds to the Output Name parameter under Output after Same Cycle is selected in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * dw_project.002_out
   */
  output?: string;
  /**
   * @remarks
   * The output table name of the current file.
   * 
   * This parameter corresponds to the Output Table Name parameter under Output after Same Cycle is selected in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * ods_user_info_d
   */
  refTableName?: string;
  static names(): { [key: string]: string } {
    return {
      output: 'Output',
      refTableName: 'RefTableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      output: 'string',
      refTableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileResponseBodyDataNodeConfigurationOutputParameters extends $tea.Model {
  /**
   * @remarks
   * The description of the output parameter of the node.
   * 
   * @example
   * It\\"s a context output parameter.
   */
  description?: string;
  /**
   * @remarks
   * The name of the output parameter of the node.
   * 
   * This parameter corresponds to the Parameter Name parameter in the Output Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * output
   */
  parameterName?: string;
  /**
   * @remarks
   * The type of the output parameter of the node. Valid values:
   * 
   * *   1: indicates a constant.
   * *   2: indicates a variable.
   * *   3: indicates a pass-through variable.
   * 
   * This parameter corresponds to the Type parameter in the Output Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * 1
   */
  type?: string;
  /**
   * @remarks
   * The value of the output parameter of the node.
   * 
   * This parameter corresponds to the Value parameter in the Output Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * ${bizdate}
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      parameterName: 'ParameterName',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      parameterName: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileResponseBodyDataNodeConfiguration extends $tea.Model {
  /**
   * @remarks
   * Indicates whether scheduling configurations immediately take effect after the deployment.
   * 
   * @example
   * true
   */
  applyScheduleImmediately?: string;
  /**
   * @remarks
   * The interval between automatic reruns after an error occurs. Unit: milliseconds.
   * 
   * This parameter corresponds to the Rerun Interval parameter that is displayed after the Auto Rerun upon Error check box is selected in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * The interval that you specify in the DataWorks console is measured in minutes. Pay attention to the conversion between the units of time when you call the operation.
   * 
   * @example
   * 120000
   */
  autoRerunIntervalMillis?: number;
  /**
   * @remarks
   * The number of automatic reruns that are allowed after an error occurs.
   * 
   * @example
   * 3
   */
  autoRerunTimes?: number;
  /**
   * @remarks
   * The CRON expression that represents the periodic scheduling policy of the node.
   * 
   * @example
   * 00 05 00 * * ?
   */
  cronExpress?: string;
  /**
   * @remarks
   * The type of the scheduling cycle. Valid values: NOT_DAY and DAY. The value NOT_DAY indicates that the node is scheduled to run by minute or hour. The value DAY indicates that the node is scheduled to run by day, week, or month.
   * 
   * This parameter corresponds to the Scheduling Cycle parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * DAY
   */
  cycleType?: string;
  /**
   * @remarks
   * The ID of the node on which the node corresponding to the file depends when the DependentType parameter is set to USER_DEFINE. Multiple IDs are separated by commas (,).
   * 
   * The value of this parameter is equivalent to the ID of the node that you specified after you select Previous Cycle and set Depend On to Other Nodes in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * 5,10,15,20
   */
  dependentNodeIdList?: string;
  /**
   * @remarks
   * The type of the cross-cycle scheduling dependency of the node. Valid values:
   * 
   * *   SELF: The instance generated for the node in the current cycle depends on the instance generated for the node in the previous cycle.
   * *   CHILD: The instance generated for the node in the current cycle depends on the instances generated for the descendant nodes at the nearest level of the node in the previous cycle.
   * *   USER_DEFINE: The instance generated for the node in the current cycle depends on the instances generated for one or more specified nodes in the previous cycle.
   * *   NONE: No cross-cycle scheduling dependency type is selected for the node.
   * 
   * @example
   * USER_DEFINE
   */
  dependentType?: string;
  /**
   * @remarks
   * The end time of automatic scheduling. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * This parameter corresponds to the Validity Period parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * 4155787800000
   */
  endEffectDate?: number;
  /**
   * @remarks
   * The output names of the parent files on which the current file depends.
   */
  inputList?: GetFileResponseBodyDataNodeConfigurationInputList[];
  /**
   * @remarks
   * Input parameters of the node.
   * 
   * This parameter corresponds to the Input Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   */
  inputParameters?: GetFileResponseBodyDataNodeConfigurationInputParameters[];
  /**
   * @remarks
   * The output names of the current file.
   * 
   * This parameter corresponds to the Output Name parameter under Output after Same Cycle is selected in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   */
  outputList?: GetFileResponseBodyDataNodeConfigurationOutputList[];
  /**
   * @remarks
   * Output parameters of the node.
   * 
   * This parameter corresponds to the Output Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   */
  outputParameters?: GetFileResponseBodyDataNodeConfigurationOutputParameters[];
  /**
   * @remarks
   * The scheduling parameters of the node.
   * 
   * This parameter corresponds to the Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console). For more information about the configurations of the scheduling parameters, see [Configure scheduling parameters](https://help.aliyun.com/document_detail/137548.html).
   * 
   * @example
   * a=x b=y
   */
  paraValue?: string;
  /**
   * @remarks
   * Indicates whether the node that corresponds to the file can be rerun. Valid values:
   * 
   * *   ALL_ALLOWED: The node can be rerun regardless of whether it is successfully run or fails to run.
   * *   FAILURE_ALLOWED: The node can be rerun only after it fails to run.
   * *   ALL_DENIED: The node cannot be rerun regardless of whether it is successfully run or fails to run.
   * 
   * This parameter corresponds to the Rerun parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * ALL_ALLOWED
   */
  rerunMode?: string;
  /**
   * @remarks
   * The ID of the resource group that is used to run the node. You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/173913.html) operation to query the available resource groups in the workspace.
   * 
   * @example
   * 375827434852437
   */
  resourceGroupId?: number;
  /**
   * @remarks
   * The scheduling type of the node. Valid values:
   * 
   * *   NORMAL: The node is an auto triggered node.
   * *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered. They correspond to the nodes in the Manually Triggered Workflows pane.
   * *   PAUSE: The node is a paused node.
   * *   SKIP: The node is a dry-run node. Dry-run nodes are started as scheduled but the system sets the status of the nodes to successful when it starts to run them.
   * 
   * @example
   * NORMAL
   */
  schedulerType?: string;
  /**
   * @remarks
   * The start time of automatic scheduling. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * This parameter corresponds to the Validity Period parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * 936923400000
   */
  startEffectDate?: number;
  /**
   * @remarks
   * Indicates whether a node is immediately run after the node is deployed to the production environment.
   * 
   * This parameter is valid only for an EMR Spark Streaming node or an EMR Streaming SQL node. This parameter corresponds to the Start Method parameter in the Schedule section of the Configure tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * true
   */
  startImmediately?: boolean;
  /**
   * @remarks
   * Indicates whether the scheduling for the node is suspended Valid values:
   * 
   * *   true: The scheduling for the node is suspended.
   * *   false: The scheduling for the node is not suspended.
   * 
   * This parameter corresponds to the Recurrence parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * false
   */
  stop?: boolean;
  static names(): { [key: string]: string } {
    return {
      applyScheduleImmediately: 'ApplyScheduleImmediately',
      autoRerunIntervalMillis: 'AutoRerunIntervalMillis',
      autoRerunTimes: 'AutoRerunTimes',
      cronExpress: 'CronExpress',
      cycleType: 'CycleType',
      dependentNodeIdList: 'DependentNodeIdList',
      dependentType: 'DependentType',
      endEffectDate: 'EndEffectDate',
      inputList: 'InputList',
      inputParameters: 'InputParameters',
      outputList: 'OutputList',
      outputParameters: 'OutputParameters',
      paraValue: 'ParaValue',
      rerunMode: 'RerunMode',
      resourceGroupId: 'ResourceGroupId',
      schedulerType: 'SchedulerType',
      startEffectDate: 'StartEffectDate',
      startImmediately: 'StartImmediately',
      stop: 'Stop',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyScheduleImmediately: 'string',
      autoRerunIntervalMillis: 'number',
      autoRerunTimes: 'number',
      cronExpress: 'string',
      cycleType: 'string',
      dependentNodeIdList: 'string',
      dependentType: 'string',
      endEffectDate: 'number',
      inputList: { 'type': 'array', 'itemType': GetFileResponseBodyDataNodeConfigurationInputList },
      inputParameters: { 'type': 'array', 'itemType': GetFileResponseBodyDataNodeConfigurationInputParameters },
      outputList: { 'type': 'array', 'itemType': GetFileResponseBodyDataNodeConfigurationOutputList },
      outputParameters: { 'type': 'array', 'itemType': GetFileResponseBodyDataNodeConfigurationOutputParameters },
      paraValue: 'string',
      rerunMode: 'string',
      resourceGroupId: 'number',
      schedulerType: 'string',
      startEffectDate: 'number',
      startImmediately: 'boolean',
      stop: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileResponseBodyDataResourceDownloadLink extends $tea.Model {
  downloadLink?: string;
  static names(): { [key: string]: string } {
    return {
      downloadLink: 'downloadLink',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadLink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The basic information about the file.
   */
  file?: GetFileResponseBodyDataFile;
  /**
   * @remarks
   * The scheduling configurations of the file.
   */
  nodeConfiguration?: GetFileResponseBodyDataNodeConfiguration;
  resourceDownloadLink?: GetFileResponseBodyDataResourceDownloadLink;
  static names(): { [key: string]: string } {
    return {
      file: 'File',
      nodeConfiguration: 'NodeConfiguration',
      resourceDownloadLink: 'ResourceDownloadLink',
    };
  }

  static types(): { [key: string]: any } {
    return {
      file: GetFileResponseBodyDataFile,
      nodeConfiguration: GetFileResponseBodyDataNodeConfiguration,
      resourceDownloadLink: GetFileResponseBodyDataResourceDownloadLink,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileTypeStatisticResponseBodyProgramTypeAndCounts extends $tea.Model {
  /**
   * @remarks
   * The number of nodes.
   * 
   * @example
   * 1
   */
  count?: number;
  /**
   * @remarks
   * The type of the node.
   * 
   * Valid values:
   * 
   * 6 (Shell node), 10 (ODPS SQL node), 11 (ODPS MR node), 23 (Data Integration node), 24 (ODPS Script node), 99 (zero load node), 221 (PyODPS 2 node), 225 (ODPS Spark node), 227 (EMR Hive node), 228 (EMR Spark node), 229 (EMR Spark SQL node), 230 (EMR MR node), 239 (OSS object inspection node), 257 (EMR Shell node), 258 (EMR Spark Shell node), 259 (EMR Presto node), 260 (EMR Impala node), 900 (real-time data synchronization node), 1089 (cross-tenant collaboration node), 1091 (Hologres development node), 1093 (Hologres SQL node), 1100 (assignment node), and 1221 (PyODPS 3 node).
   * 
   * @example
   * ODPS_SQL
   */
  programType?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      programType: 'ProgramType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      programType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileVersionResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The change type of the file version. Valid values: CREATE, UPDATE, and DELETE.
   * 
   * @example
   * UPDATE
   */
  changeType?: string;
  /**
   * @remarks
   * The description of the file version.
   */
  comment?: string;
  /**
   * @remarks
   * The time when the version was generated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1593881265000
   */
  commitTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to create the file version.
   * 
   * @example
   * 7384234****
   */
  commitUser?: string;
  /**
   * @remarks
   * The file code.
   * 
   * @example
   * SHOW TABLES;
   */
  fileContent?: string;
  /**
   * @remarks
   * The file name.
   * 
   * @example
   * ods_user_info_d
   */
  fileName?: string;
  /**
   * @remarks
   * The basic information about the file.
   * 
   * @example
   * {"fileName":"ods_user_info_d","fileType":10}
   */
  filePropertyContent?: string;
  /**
   * @remarks
   * The file version.
   * 
   * @example
   * 2
   */
  fileVersion?: number;
  /**
   * @remarks
   * Indicates whether the version is the latest version in the production environment.
   * 
   * @example
   * true
   */
  isCurrentProd?: boolean;
  /**
   * @remarks
   * The scheduling configurations of the node that corresponds to the file version.
   * 
   * @example
   * {"cycleType":0,"cronExpress":"00 05 00 * * ?"}
   */
  nodeContent?: string;
  /**
   * @remarks
   * The ID of the node that corresponds to the file version.
   * 
   * @example
   * 3000001
   */
  nodeId?: number;
  /**
   * @remarks
   * The status of the file version. Valid values: COMMITTING, COMMITTED, CHECK_OK, PACKAGED, DEPLOYING, DEPLOYED, and CANCELLED. The value CHECK_OK is equivalent to the value COMMITTED.
   * 
   * @example
   * COMMITTED
   */
  status?: string;
  /**
   * @remarks
   * The functional module to which the file belongs. Valid values: NORMAL, MANUAL, MANUAL_BIZ, SKIP, ADHOCQUERY, and COMPONENT. The value NORMAL indicates DataStudio. The value MANUAL indicates a manually triggered node. The value MANUAL_BIZ indicates a manually triggered workflow. The value SKIP indicates a dry-run DataStudio node. The value ADHOCQUERY indicates an ad hoc query. The value COMPONENT indicates snippets.
   * 
   * @example
   * NORMAL
   */
  useType?: string;
  static names(): { [key: string]: string } {
    return {
      changeType: 'ChangeType',
      comment: 'Comment',
      commitTime: 'CommitTime',
      commitUser: 'CommitUser',
      fileContent: 'FileContent',
      fileName: 'FileName',
      filePropertyContent: 'FilePropertyContent',
      fileVersion: 'FileVersion',
      isCurrentProd: 'IsCurrentProd',
      nodeContent: 'NodeContent',
      nodeId: 'NodeId',
      status: 'Status',
      useType: 'UseType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changeType: 'string',
      comment: 'string',
      commitTime: 'number',
      commitUser: 'string',
      fileContent: 'string',
      fileName: 'string',
      filePropertyContent: 'string',
      fileVersion: 'number',
      isCurrentProd: 'boolean',
      nodeContent: 'string',
      nodeId: 'number',
      status: 'string',
      useType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFolderResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the folder.
   * 
   * @example
   * 2735****
   */
  folderId?: string;
  /**
   * @remarks
   * The path of the folder.
   */
  folderPath?: string;
  static names(): { [key: string]: string } {
    return {
      folderId: 'FolderId',
      folderPath: 'FolderPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folderId: 'string',
      folderPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent extends $tea.Model {
  /**
   * @remarks
   * The ID of the workflow to which the file belongs.
   * 
   * @example
   * 74328
   */
  businessId?: number;
  /**
   * @remarks
   * The latest version number of the file.
   * 
   * @example
   * 1
   */
  currentVersion?: number;
  /**
   * @remarks
   * The name of the data source with which the file is associated.
   * 
   * @example
   * odps_first
   */
  dataSourceName?: string;
  /**
   * @remarks
   * The ID of the folder to which the file belongs. You can call the [GetFolder](https://help.aliyun.com/document_detail/173952.html) operation to query the details of the file based on the folder ID.
   * 
   * @example
   * aldurie78l2falure
   */
  folderId?: string;
  /**
   * @remarks
   * The file owner.
   * 
   * @example
   * 7384234****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the do-while node or for-each node that corresponds to the file.
   * 
   * @example
   * 1234122
   */
  parentFileId?: number;
  static names(): { [key: string]: string } {
    return {
      businessId: 'BusinessId',
      currentVersion: 'CurrentVersion',
      dataSourceName: 'DataSourceName',
      folderId: 'FolderId',
      owner: 'Owner',
      parentFileId: 'ParentFileId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessId: 'number',
      currentVersion: 'number',
      dataSourceName: 'string',
      folderId: 'string',
      owner: 'string',
      parentFileId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList extends $tea.Model {
  /**
   * @remarks
   * The output name of the parent file on which the current file depends.
   * 
   * This parameter corresponds to the Output Name of Ancestor Node parameter under Parent Nodes in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * dw_project_root
   */
  input?: string;
  /**
   * @remarks
   * The mode of the configuration file dependency. Valid values:
   * 
   * *   MANUAL: Scheduling dependencies are manually configured.
   * *   AUTO: Scheduling dependencies are automatically parsed.
   * 
   * @example
   * MANUAL
   */
  parseType?: string;
  static names(): { [key: string]: string } {
    return {
      input: 'Input',
      parseType: 'ParseType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      input: 'string',
      parseType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList extends $tea.Model {
  /**
   * @remarks
   * The output name of the current file.
   * 
   * This parameter corresponds to the Output Name parameter under Output Name of Current Node in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * dw_project.002_out
   */
  output?: string;
  /**
   * @remarks
   * The output table name of the current file.
   * 
   * This parameter corresponds to the Output Table Name parameter under Output Name of Current Node in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * ods_user_info_d
   */
  refTableName?: string;
  static names(): { [key: string]: string } {
    return {
      output: 'Output',
      refTableName: 'RefTableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      output: 'string',
      refTableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration extends $tea.Model {
  /**
   * @remarks
   * The interval at which the node corresponding to the file is rerun. Unit: milliseconds.
   * 
   * @example
   * 120000
   */
  autoRerunIntervalMillis?: number;
  /**
   * @remarks
   * The number of times that the node corresponding to the file can be rerun.
   * 
   * @example
   * 3
   */
  autoRerunTimes?: number;
  /**
   * @remarks
   * The CRON expression that is used to schedule the node corresponding to the file.
   * 
   * @example
   * 00 05 00 * * ?
   */
  cronExpress?: string;
  /**
   * @remarks
   * The type of the scheduling cycle of the node that corresponds to the file. Valid values: NOT_DAY and DAY. The value NOT_DAY indicates that the node is scheduled to run by minute or hour. The value DAY indicates that the node is scheduled to run by day, week, or month.
   * 
   * This parameter corresponds to the Scheduling Cycle parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * DAY
   */
  cycleType?: string;
  /**
   * @remarks
   * The ID of the node on which the node that corresponds to the file depends when the DependentType parameter is set to USER_DEFINE. Multiple IDs are separated by commas (,).
   * 
   * The value of this parameter is equivalent to the ID of the node that you specified after you select Other Nodes for Cross-Cycle Dependency (Original Previous-Cycle Dependency) in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * 5,10,15,20
   */
  dependentNodeIdList?: string;
  /**
   * @remarks
   * The type of the cross-cycle scheduling dependency of the node. Valid values:
   * 
   * *   SELF: The instance generated for the node in the current cycle depends on the instance generated for the node in the previous cycle.
   * *   CHILD: The instance generated for the node in the current cycle depends on the instances generated for the descendant nodes at the nearest level of the node in the previous cycle.
   * *   USER_DEFINE: The instance generated for the node in the current cycle depends on the instances generated for one or more specified nodes in the previous cycle.
   * *   NONE: No cross-cycle scheduling dependency type is selected for the node.
   * 
   * @example
   * USER_DEFINE
   */
  dependentType?: string;
  /**
   * @remarks
   * The output names of the parent files on which the current file depends.
   */
  inputList?: GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList[];
  /**
   * @remarks
   * The output names of the current file.
   * 
   * This parameter corresponds to the Output Name of Current Node parameter in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   */
  outputList?: GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList[];
  /**
   * @remarks
   * The scheduling parameters of the node.
   * 
   * This parameter corresponds to the Scheduling Parameter section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console). For more information about the configurations of the scheduling parameters, see [Configure scheduling parameters](https://help.aliyun.com/document_detail/137548.html).
   * 
   * @example
   * a=x b=y
   */
  paraValue?: string;
  /**
   * @remarks
   * Indicates whether the node that corresponds to the file can be rerun. Valid values:
   * 
   * *   ALL_ALLOWED: The node can be rerun regardless of whether it is successfully run or fails to run.
   * *   FAILURE_ALLOWED: The node can be rerun only after it fails to run.
   * *   ALL_DENIED: The node cannot be rerun regardless of whether it is successfully run or fails to run.
   * 
   * This parameter corresponds to the Rerun parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * ALL_ALLOWED
   */
  rerunMode?: string;
  /**
   * @remarks
   * The ID of the resource group that is used to run the node that corresponds to the file. You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/173913.html) operation to query the available resource groups in the workspace.
   * 
   * @example
   * 375827434852437
   */
  resourceGroupId?: number;
  /**
   * @remarks
   * The scheduling type of the node. Valid values:
   * 
   * *   NORMAL: The node is an auto triggered node.
   * *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered. They correspond to the nodes in the Manually Triggered Workflows pane.
   * *   PAUSE: The node is a paused node.
   * *   SKIP: The node is a dry-run node. Dry-run nodes are started as scheduled, but the system sets the status of the nodes to successful when it starts to run them.
   * 
   * @example
   * NORMAL
   */
  schedulerType?: string;
  static names(): { [key: string]: string } {
    return {
      autoRerunIntervalMillis: 'AutoRerunIntervalMillis',
      autoRerunTimes: 'AutoRerunTimes',
      cronExpress: 'CronExpress',
      cycleType: 'CycleType',
      dependentNodeIdList: 'DependentNodeIdList',
      dependentType: 'DependentType',
      inputList: 'InputList',
      outputList: 'OutputList',
      paraValue: 'ParaValue',
      rerunMode: 'RerunMode',
      resourceGroupId: 'ResourceGroupId',
      schedulerType: 'SchedulerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoRerunIntervalMillis: 'number',
      autoRerunTimes: 'number',
      cronExpress: 'string',
      cycleType: 'string',
      dependentNodeIdList: 'string',
      dependentType: 'string',
      inputList: { 'type': 'array', 'itemType': GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList },
      outputList: { 'type': 'array', 'itemType': GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList },
      paraValue: 'string',
      rerunMode: 'string',
      resourceGroupId: 'number',
      schedulerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIDEEventDetailResponseBodyEventDetailCommittedFile extends $tea.Model {
  /**
   * @remarks
   * The type of the change to the file of the current version. Valid values: CREATE, UPDATE, and DELETE.
   * 
   * @example
   * UPDATE
   */
  changeType?: string;
  /**
   * @remarks
   * The description of the file version.
   */
  comment?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to generate the file of the current version.
   * 
   * @example
   * 7384234****
   */
  committor?: string;
  /**
   * @remarks
   * The code in the file of the current version.
   * 
   * @example
   * SHOW TABLES;
   */
  content?: string;
  /**
   * @remarks
   * The file ID.
   * 
   * @example
   * 1234123
   */
  fileId?: number;
  /**
   * @remarks
   * The name of the file.
   * 
   * @example
   * hello_dataworks.sql
   */
  fileName?: string;
  /**
   * @remarks
   * The details of the file.
   */
  filePropertyContent?: GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent;
  /**
   * @remarks
   * The type of the code for the file. Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3).
   * 
   * @example
   * 10
   */
  fileType?: number;
  /**
   * @remarks
   * The scheduling properties of the node that corresponds to the file.
   */
  nodeConfiguration?: GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration;
  /**
   * @remarks
   * The ID of the node that is scheduled.
   * 
   * @example
   * 421429
   */
  nodeId?: number;
  /**
   * @remarks
   * The module to which the file belongs. Valid values:
   * 
   * *   NORMAL: The file is used for DataStudio.
   * *   MANUAL: The file is used for a manually triggered node.
   * *   MANUAL_BIZ: The file is used for a manually triggered workflow.
   * *   SKIP: The file is used for a dry-run DataStudio node.
   * *   ADHOCQUERY: The file is used for an ad hoc query.
   * *   COMPONENT: The file is used for a snippet.
   * 
   * @example
   * NORMAL
   */
  useType?: string;
  static names(): { [key: string]: string } {
    return {
      changeType: 'ChangeType',
      comment: 'Comment',
      committor: 'Committor',
      content: 'Content',
      fileId: 'FileId',
      fileName: 'FileName',
      filePropertyContent: 'FilePropertyContent',
      fileType: 'FileType',
      nodeConfiguration: 'NodeConfiguration',
      nodeId: 'NodeId',
      useType: 'UseType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changeType: 'string',
      comment: 'string',
      committor: 'string',
      content: 'string',
      fileId: 'number',
      fileName: 'string',
      filePropertyContent: GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent,
      fileType: 'number',
      nodeConfiguration: GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration,
      nodeId: 'number',
      useType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIDEEventDetailResponseBodyEventDetailDeletedFile extends $tea.Model {
  /**
   * @remarks
   * The ID of the workflow to which the file belongs.
   * 
   * @example
   * 74328
   */
  businessId?: number;
  /**
   * @remarks
   * The code in the file of the current version.
   * 
   * @example
   * SHOW TABLES;
   */
  content?: string;
  /**
   * @remarks
   * The latest version number of the file.
   * 
   * @example
   * 1
   */
  currentVersion?: number;
  /**
   * @remarks
   * The name of the data source with which the file is associated.
   * 
   * @example
   * odps_first
   */
  dataSourceName?: string;
  /**
   * @remarks
   * The file ID.
   * 
   * @example
   * 1234123
   */
  fileId?: number;
  /**
   * @remarks
   * The name of the file.
   * 
   * @example
   * hello_dataworks.sql
   */
  fileName?: string;
  /**
   * @remarks
   * The type of the code for the file. Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3).
   * 
   * @example
   * 10
   */
  fileType?: number;
  /**
   * @remarks
   * The ID of the folder to which the file belongs. You can call the [GetFolder](https://help.aliyun.com/document_detail/173952.html) operation to query the details of the file based on the folder ID.
   * 
   * @example
   * aldurie78l2falure
   */
  folderId?: string;
  /**
   * @remarks
   * The ID of the node that is scheduled.
   * 
   * @example
   * 421429
   */
  nodeId?: number;
  /**
   * @remarks
   * The file owner.
   * 
   * @example
   * 7384234****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the do-while node or for-each node that corresponds to the file.
   * 
   * @example
   * 1234122
   */
  parentFileId?: number;
  /**
   * @remarks
   * The module to which the file belongs. Valid values:
   * 
   * *   NORMAL: The file is used for DataStudio.
   * *   MANUAL: The file is used for a manually triggered node.
   * *   MANUAL_BIZ: The file is used for a manually triggered workflow.
   * *   SKIP: The file is used for a dry-run DataStudio node.
   * *   ADHOCQUERY: The file is used for an ad hoc query.
   * *   COMPONENT: The file is used for a snippet.
   * 
   * @example
   * NORMAL
   */
  useType?: string;
  static names(): { [key: string]: string } {
    return {
      businessId: 'BusinessId',
      content: 'Content',
      currentVersion: 'CurrentVersion',
      dataSourceName: 'DataSourceName',
      fileId: 'FileId',
      fileName: 'FileName',
      fileType: 'FileType',
      folderId: 'FolderId',
      nodeId: 'NodeId',
      owner: 'Owner',
      parentFileId: 'ParentFileId',
      useType: 'UseType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessId: 'number',
      content: 'string',
      currentVersion: 'number',
      dataSourceName: 'string',
      fileId: 'number',
      fileName: 'string',
      fileType: 'number',
      folderId: 'string',
      nodeId: 'number',
      owner: 'string',
      parentFileId: 'number',
      useType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand extends $tea.Model {
  /**
   * @remarks
   * The code in the file of the current version.
   * 
   * @example
   * SHOW TABLES;
   */
  content?: string;
  /**
   * @remarks
   * The name of the data source with which the file is associated.
   * 
   * @example
   * odps_first
   */
  dataSourceName?: string;
  /**
   * @remarks
   * The file ID.
   * 
   * @example
   * 1234123
   */
  fileId?: number;
  /**
   * @remarks
   * The type of the code for the file. The code for files varies based on the file type. For more information, see [DataWorks nodes](https://help.aliyun.com/document_detail/600169.html).
   * 
   * @example
   * 10
   */
  fileType?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      dataSourceName: 'DataSourceName',
      fileId: 'FileId',
      fileType: 'FileType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      dataSourceName: 'string',
      fileId: 'number',
      fileType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIDEEventDetailResponseBodyEventDetailTableModelColumns extends $tea.Model {
  /**
   * @remarks
   * The name of the column.
   * 
   * @example
   * ID
   */
  columnName?: string;
  /**
   * @remarks
   * The data type of the column.
   * 
   * @example
   * BIGINT
   */
  columnType?: string;
  /**
   * @remarks
   * The remarks of the column.
   * 
   * @example
   * ID
   */
  comment?: string;
  /**
   * @remarks
   * Indicates whether the column is a partition key column. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  isPartitionColumn?: boolean;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      comment: 'Comment',
      isPartitionColumn: 'IsPartitionColumn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      columnType: 'string',
      comment: 'string',
      isPartitionColumn: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIDEEventDetailResponseBodyEventDetailTableModel extends $tea.Model {
  /**
   * @remarks
   * The columns in the table.
   */
  columns?: GetIDEEventDetailResponseBodyEventDetailTableModelColumns[];
  /**
   * @remarks
   * The remarks of the table.
   */
  comment?: string;
  /**
   * @remarks
   * The name of the data source to which the table belongs.
   * 
   * @example
   * odps_first
   */
  dataSourceName?: string;
  /**
   * @remarks
   * The environment in which the table is used. Valid values:
   * 
   * *   DEV
   * *   PROD
   * 
   * @example
   * DEV
   */
  env?: string;
  /**
   * @remarks
   * The lifecycle of the metatable. Unit: day.
   * 
   * @example
   * 7
   */
  lifeCycle?: number;
  /**
   * @remarks
   * The path of the table.
   * 
   * @example
   * hdfs://path/to/object
   */
  location?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * tb_hello
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      columns: 'Columns',
      comment: 'Comment',
      dataSourceName: 'DataSourceName',
      env: 'Env',
      lifeCycle: 'LifeCycle',
      location: 'Location',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columns: { 'type': 'array', 'itemType': GetIDEEventDetailResponseBodyEventDetailTableModelColumns },
      comment: 'string',
      dataSourceName: 'string',
      env: 'string',
      lifeCycle: 'number',
      location: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetIDEEventDetailResponseBodyEventDetail extends $tea.Model {
  /**
   * @remarks
   * The data snapshot when the file is committed and deployed.
   * 
   * This parameter is valid only if the message type is IDE_FILE_SUBMIT_BEFORE or IDE_FILE_DEPLOY_BEFORE.
   */
  committedFile?: GetIDEEventDetailResponseBodyEventDetailCommittedFile;
  /**
   * @remarks
   * The data snapshot when the file is deleted. This parameter is valid only if the message type is IDE_FILE_DELETE_BEFORE.
   */
  deletedFile?: GetIDEEventDetailResponseBodyEventDetailDeletedFile;
  /**
   * @remarks
   * The data snapshot when the code in the file is run. This parameter is valid only if the message type is IDE_FILE_EXECUTE_BEFORE.
   */
  fileExecutionCommand?: GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand;
  /**
   * @remarks
   * The data snapshot when the table is committed and deployed. This parameter is valid only if the message type is IDE_TABLE_SUBMIT_BEFORE or IDE_TABLE_DEPLOY_BEFORE.
   */
  tableModel?: GetIDEEventDetailResponseBodyEventDetailTableModel;
  static names(): { [key: string]: string } {
    return {
      committedFile: 'CommittedFile',
      deletedFile: 'DeletedFile',
      fileExecutionCommand: 'FileExecutionCommand',
      tableModel: 'TableModel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      committedFile: GetIDEEventDetailResponseBodyEventDetailCommittedFile,
      deletedFile: GetIDEEventDetailResponseBodyEventDetailDeletedFile,
      fileExecutionCommand: GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand,
      tableModel: GetIDEEventDetailResponseBodyEventDetailTableModel,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The baseline ID.
   * 
   * @example
   * 123123
   */
  baselineId?: number;
  /**
   * @remarks
   * The time when the instance started to run.
   * 
   * @example
   * 1590416703313
   */
  beginRunningTime?: number;
  /**
   * @remarks
   * The time when the instance started to wait for resources.
   * 
   * @example
   * 1590416703313
   */
  beginWaitResTime?: number;
  /**
   * @remarks
   * The time when the instance started to wait to be scheduled.
   * 
   * @example
   * 1590416703313
   */
  beginWaitTimeTime?: number;
  /**
   * @remarks
   * The data timestamp of the instance. In most cases, the value is one day before the time when the instance was run.
   * 
   * @example
   * 1590336000000
   */
  bizdate?: number;
  /**
   * @remarks
   * The workflow ID.
   * 
   * @example
   * 123
   */
  businessId?: number;
  /**
   * @remarks
   * The connection string.
   * 
   * @example
   * odps_first
   */
  connection?: string;
  /**
   * @remarks
   * The time when the instance was generated.
   * 
   * @example
   * 1590416703313
   */
  createTime?: number;
  /**
   * @remarks
   * The creator of the instance.
   * 
   * @example
   * 111
   */
  createUser?: string;
  /**
   * @remarks
   * The scheduling time of the instance.
   * 
   * @example
   * 1590422400000
   */
  cycTime?: number;
  /**
   * @remarks
   * The workflow ID.
   * 
   * @example
   * 338450167
   */
  dagId?: number;
  /**
   * @remarks
   * The type of the workflow. Valid values:
   * 
   * *   DAILY: The workflow is used to run auto triggered nodes.
   * *   MANUAL: The workflow is used to run manually triggered nodes.
   * *   SMOKE_TEST: The workflow is used to perform smoke testing.
   * *   SUPPLY_DATA: The workflow is used to backfill data.
   * 
   * @example
   * DAILY
   */
  dagType?: string;
  /**
   * @remarks
   * The table and partition filter expression in Data Quality that are associated with the node.
   * 
   * @example
   * [{"projectName":"ztjy_dim","tableName":"dim_user_agent_manage_area_a","partition":"ds\\u003d$[yyyy-mm-dd-1]"}]
   */
  dqcDescription?: string;
  /**
   * @remarks
   * Indicates whether the instance is associated with a monitoring rule in Data Quality. Valid values:
   * 
   * *   0: The instance is associated with a monitoring rule in Data Quality.
   * *   1: The instance is not associated with a monitoring rule in Data Quality.
   * 
   * @example
   * 1
   */
  dqcType?: number;
  /**
   * @remarks
   * The time when the running of the instance was complete.
   * 
   * @example
   * 1590416703313
   */
  finishTime?: number;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * 11713307578
   */
  instanceId?: number;
  /**
   * @remarks
   * The time when the instance was last modified.
   * 
   * @example
   * 1590416703313
   */
  modifyTime?: number;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 33115
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * kzh
   */
  nodeName?: string;
  /**
   * @remarks
   * The parameters related to the node.
   * 
   * @example
   * bizdate=$bizdate tbods=$tbods tbdw=$tbdw tbpmic=$tbpmic tbpidx=$tbpidx tbptcif=$tbptcif
   */
  paramValues?: string;
  /**
   * @remarks
   * The priority of the instance. Valid values: 1, 3, 5, 7, and 8. A greater value indicates a higher priority. Default value: 1.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The ID of the workflow to which the node belongs.
   * 
   * @example
   * 123123
   */
  relatedFlowId?: number;
  /**
   * @remarks
   * The interval at which the node is rerun after the node fails to run. Unit: milliseconds.
   * 
   * @example
   * 60000
   */
  repeatInterval?: number;
  /**
   * @remarks
   * Indicates whether the node that generates the instance can be rerun.
   * 
   * @example
   * true
   */
  repeatability?: boolean;
  /**
   * @remarks
   * The status of the node that generates the instance. Valid values:
   * 
   * *   NOT_RUN: The node is not run.
   * *   WAIT_TIME: The node is waiting for its scheduling time to arrive.
   * *   WAIT_RESOURCE: The node is waiting for resources.
   * *   RUNNING: The node is running.
   * *   CHECKING: Data quality is being checked for the node.
   * *   CHECKING_CONDITION: Branch conditions are being checked for the node.
   * *   FAILURE: The node fails to run.
   * *   SUCCESS: The node is successfully run.
   * 
   * @example
   * NOT_RUN
   */
  status?: string;
  /**
   * @remarks
   * The number of times the node can be rerun. The value of this parameter can be empty or an integer that is greater than or equal to 0.
   * 
   * *   If the value of this parameter is empty, the number of times that the node can be rerun is not specified.
   * *   If the value of this parameter is 0, the node cannot be rerun.
   * *   If the value of this parameter is a positive integer such as n, the node can still be rerun n times. For example, if the value of this parameter is 1, the node can still be rerun once. If the value of this parameter is 2, the node can still be rerun twice.
   * 
   * @example
   * 0
   */
  taskRerunTime?: number;
  /**
   * @remarks
   * The scheduling type of the node that generates the instance. Valid values:
   * 
   * *   NORMAL(0): The node is an auto triggered node. The scheduling system regularly runs the node.
   * *   MANUAL(1): The node is a manually triggered node. The scheduling system does not regularly run the node.
   * *   PAUSE(2): The node is a frozen node. The scheduling system regularly runs the node but sets the status of the node to failed when the scheduling system starts to run the node.
   * *   SKIP(3): The node is a dry-run node. The scheduling system regularly runs the node but sets the status of the node to successful when the scheduling system starts to run the node.
   * *   SKIP_UNCHOOSE(4): The node is an unselected node in a temporary workflow. This type of node exists only in temporary workflows. The scheduling system sets the status of the node to successful when the scheduling system starts to run the node.
   * *   SKIP_CYCLE(5): The node is a node that is scheduled by the week or month and is waiting for the scheduling time to arrive. The scheduling system regularly runs the node but sets the status of the node to successful when the scheduling system starts to run the node.
   * *   CONDITION_UNCHOOSE(6): The node is not selected by its ancestor branch node and is run as a dry-run node.
   * *   REALTIME_DEPRECATED(7): The node has instances that are generated in real time but deprecated. The scheduling system sets the status of the node to successful.
   * 
   * @example
   * NORMAL(0)
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      beginRunningTime: 'BeginRunningTime',
      beginWaitResTime: 'BeginWaitResTime',
      beginWaitTimeTime: 'BeginWaitTimeTime',
      bizdate: 'Bizdate',
      businessId: 'BusinessId',
      connection: 'Connection',
      createTime: 'CreateTime',
      createUser: 'CreateUser',
      cycTime: 'CycTime',
      dagId: 'DagId',
      dagType: 'DagType',
      dqcDescription: 'DqcDescription',
      dqcType: 'DqcType',
      finishTime: 'FinishTime',
      instanceId: 'InstanceId',
      modifyTime: 'ModifyTime',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      paramValues: 'ParamValues',
      priority: 'Priority',
      relatedFlowId: 'RelatedFlowId',
      repeatInterval: 'RepeatInterval',
      repeatability: 'Repeatability',
      status: 'Status',
      taskRerunTime: 'TaskRerunTime',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      beginRunningTime: 'number',
      beginWaitResTime: 'number',
      beginWaitTimeTime: 'number',
      bizdate: 'number',
      businessId: 'number',
      connection: 'string',
      createTime: 'number',
      createUser: 'string',
      cycTime: 'number',
      dagId: 'number',
      dagType: 'string',
      dqcDescription: 'string',
      dqcType: 'number',
      finishTime: 'number',
      instanceId: 'number',
      modifyTime: 'number',
      nodeId: 'number',
      nodeName: 'string',
      paramValues: 'string',
      priority: 'number',
      relatedFlowId: 'number',
      repeatInterval: 'number',
      repeatability: 'boolean',
      status: 'string',
      taskRerunTime: 'number',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank extends $tea.Model {
  /**
   * @remarks
   * The data timestamp of the instance.
   * 
   * @example
   * 1600963200000
   */
  bizdate?: number;
  /**
   * @remarks
   * The running duration of the instance. Unit: seconds.
   * 
   * @example
   * 1000
   */
  consumed?: number;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * 95279527
   */
  instanceId?: number;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 9527
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 952795279527
   */
  owner?: string;
  /**
   * @remarks
   * The type of the node.
   * 
   * @example
   * 10
   */
  prgType?: number;
  static names(): { [key: string]: string } {
    return {
      bizdate: 'Bizdate',
      consumed: 'Consumed',
      instanceId: 'InstanceId',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      owner: 'Owner',
      prgType: 'PrgType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizdate: 'number',
      consumed: 'number',
      instanceId: 'number',
      nodeId: 'number',
      nodeName: 'string',
      owner: 'string',
      prgType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank extends $tea.Model {
  /**
   * @remarks
   * The ranking data of the running durations of instances.
   */
  consumeTimeRank?: GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank[];
  /**
   * @remarks
   * The timestamp when the ranking was updated.
   * 
   * @example
   * 1600963200000
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      consumeTimeRank: 'ConsumeTimeRank',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumeTimeRank: { 'type': 'array', 'itemType': GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank },
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceCountTrendResponseBodyInstanceCounts extends $tea.Model {
  /**
   * @remarks
   * The number of instances.
   * 
   * @example
   * 9527
   */
  count?: number;
  /**
   * @remarks
   * The data timestamp.
   * 
   * @example
   * 1600963200000
   */
  date?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      date: 'Date',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      date: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank extends $tea.Model {
  /**
   * @remarks
   * The number of errors that occurred on the node.
   * 
   * @example
   * 5
   */
  count?: number;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 9527
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 952795279527
   */
  owner?: string;
  /**
   * @remarks
   * The type of the node.
   * 
   * @example
   * 10
   */
  prgType?: number;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 9527
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      owner: 'Owner',
      prgType: 'PrgType',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      nodeId: 'number',
      nodeName: 'string',
      owner: 'string',
      prgType: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceErrorRankResponseBodyInstanceErrorRank extends $tea.Model {
  /**
   * @remarks
   * The ranking data of nodes on which errors occurred within the last month.
   */
  errorRank?: GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank[];
  /**
   * @remarks
   * The timestamp at which the rankings were updated.
   * 
   * @example
   * 1600963200000
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      errorRank: 'ErrorRank',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorRank: { 'type': 'array', 'itemType': GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank },
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceStatusCountResponseBodyStatusCount extends $tea.Model {
  /**
   * @remarks
   * The number of instances that failed.
   * 
   * @example
   * 1
   */
  failureCount?: number;
  /**
   * @remarks
   * The number of instances that are not run.
   * 
   * @example
   * 1
   */
  notRunCount?: number;
  /**
   * @remarks
   * The number of instances that are running.
   * 
   * @example
   * 1
   */
  runningCount?: number;
  /**
   * @remarks
   * The number of instances that are successfully run.
   * 
   * @example
   * 1
   */
  successCount?: number;
  /**
   * @remarks
   * The total number of instances returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  /**
   * @remarks
   * The number of instances that are waiting for resources.
   * 
   * @example
   * 1
   */
  waitResCount?: number;
  /**
   * @remarks
   * The number of instances that are waiting for their scheduling time to arrive.
   * 
   * @example
   * 1
   */
  waitTimeCount?: number;
  static names(): { [key: string]: string } {
    return {
      failureCount: 'FailureCount',
      notRunCount: 'NotRunCount',
      runningCount: 'RunningCount',
      successCount: 'SuccessCount',
      totalCount: 'TotalCount',
      waitResCount: 'WaitResCount',
      waitTimeCount: 'WaitTimeCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failureCount: 'number',
      notRunCount: 'number',
      runningCount: 'number',
      successCount: 'number',
      totalCount: 'number',
      waitResCount: 'number',
      waitTimeCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInstanceStatusStatisticResponseBodyStatusCount extends $tea.Model {
  /**
   * @remarks
   * The number of instances that failed to run.
   * 
   * @example
   * 1
   */
  failureCount?: number;
  /**
   * @remarks
   * The number of instances that are not run.
   * 
   * @example
   * 1
   */
  notRunCount?: number;
  /**
   * @remarks
   * The number of instances that are running.
   * 
   * @example
   * 1
   */
  runningCount?: number;
  /**
   * @remarks
   * The number of instances that are successfully run.
   * 
   * @example
   * 1
   */
  successCount?: number;
  /**
   * @remarks
   * The total number of instances returned.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  /**
   * @remarks
   * The number of instances that are waiting for resources.
   * 
   * @example
   * 1
   */
  waitResCount?: number;
  /**
   * @remarks
   * The number of instances that are waiting to run.
   * 
   * @example
   * 1
   */
  waitTimeCount?: number;
  static names(): { [key: string]: string } {
    return {
      failureCount: 'FailureCount',
      notRunCount: 'NotRunCount',
      runningCount: 'RunningCount',
      successCount: 'SuccessCount',
      totalCount: 'TotalCount',
      waitResCount: 'WaitResCount',
      waitTimeCount: 'WaitTimeCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failureCount: 'number',
      notRunCount: 'number',
      runningCount: 'number',
      successCount: 'number',
      totalCount: 'number',
      waitResCount: 'number',
      waitTimeCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetManualDagInstancesResponseBodyInstances extends $tea.Model {
  /**
   * @remarks
   * The time when the instance started to run.
   * 
   * @example
   * 1605178414676
   */
  beginRunningTime?: number;
  /**
   * @remarks
   * The time when the instance started to wait for resources.
   * 
   * @example
   * 1605178414676
   */
  beginWaitResTime?: number;
  /**
   * @remarks
   * The time when the instance started to wait to be scheduled.
   * 
   * @example
   * 1605178414676
   */
  beginWaitTimeTime?: number;
  /**
   * @remarks
   * The data timestamp of the instance. In most cases, the value is one day before the time when the instance was run.
   * 
   * @example
   * 1605178414676
   */
  bizDate?: number;
  /**
   * @remarks
   * The time when the instance was generated.
   * 
   * @example
   * 1605178414676
   */
  createTime?: number;
  /**
   * @remarks
   * The user who performed the operation.
   * 
   * @example
   * xxx
   */
  createUser?: string;
  /**
   * @remarks
   * The time when the instance was scheduled to run.
   * 
   * @example
   * 1605178414676
   */
  cycTime?: number;
  /**
   * @remarks
   * The ID of the DAG for the manually triggered workflow.
   * 
   * @example
   * 350850491
   */
  dagId?: number;
  /**
   * @remarks
   * The type of the manually triggered workflow.
   * 
   * @example
   * 5
   */
  dagType?: string;
  /**
   * @remarks
   * The time when the instance finished running.
   * 
   * @example
   * 1605178414676
   */
  finishTime?: number;
  /**
   * @remarks
   * The ID of the instance in the manually triggered workflow.
   * 
   * @example
   * 11726873619
   */
  instanceId?: number;
  /**
   * @remarks
   * The time when the instance was last modified.
   * 
   * @example
   * 1605178414676
   */
  modifyTime?: number;
  /**
   * @remarks
   * The ID of the node in the manually triggered workflow.
   * 
   * @example
   * 37851
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * test2
   */
  nodeName?: string;
  /**
   * @remarks
   * The parameters related to the instance.
   * 
   * @example
   * xxx
   */
  paramValues?: string;
  /**
   * @remarks
   * The status of the instance. Valid values:
   * 
   * *   NOT_RUN: The instance is not run.
   * *   WAIT_TIME: The instance is waiting for its scheduling time to arrive.
   * *   WAIT_RESOURCE: The instance is waiting for resources.
   * *   RUNNING: The instance is running.
   * *   CHECKING: Data quality is being checked for the instance.
   * *   CHECKING_CONDITION: Branch conditions are being checked for the instance.
   * *   FAILURE: The instance fails to be run.
   * *   SUCCESS: The instance is successfully run.
   * 
   * @example
   * WAIT_TIME
   */
  status?: string;
  /**
   * @remarks
   * The scheduling type of the node that generates the instance. Valid values:
   * 
   * *   NORMAL(0): The node is an auto triggered node. The scheduling system regularly runs the node.
   * *   MANUAL(1): The node is a manually triggered node. The scheduling system does not regularly run the node.
   * *   PAUSE(2): The node is a paused node. The scheduling system regularly runs the node but sets the status of the node to failed when the scheduling system starts to run the node.
   * *   SKIP(3): The node is a dry-run node. The scheduling system regularly runs the node but sets the status of the node to successful when the scheduling system starts to run the node.
   * *   SKIP_UNCHOOSE(4): The node is an unselected node in a temporary workflow. This type of node exists only in temporary workflows. The scheduling system sets the status of the node to successful when the scheduling system starts to run the node.
   * *   SKIP_CYCLE(5): The node is a node that is scheduled by week or month and is waiting for the scheduling time to arrive. The scheduling system regularly runs the node but sets the status of the node to successful when the scheduling system starts to run the node.
   * *   CONDITION_UNCHOOSE(6): The node is not selected by its ancestor branch node and is run as a dry-run node.
   * *   REALTIME_DEPRECATED(7): The node has instances that are generated in real time but deprecated. The scheduling system sets the status of the node to successful.
   * 
   * @example
   * NORMAL(0)
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      beginRunningTime: 'BeginRunningTime',
      beginWaitResTime: 'BeginWaitResTime',
      beginWaitTimeTime: 'BeginWaitTimeTime',
      bizDate: 'BizDate',
      createTime: 'CreateTime',
      createUser: 'CreateUser',
      cycTime: 'CycTime',
      dagId: 'DagId',
      dagType: 'DagType',
      finishTime: 'FinishTime',
      instanceId: 'InstanceId',
      modifyTime: 'ModifyTime',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      paramValues: 'ParamValues',
      status: 'Status',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginRunningTime: 'number',
      beginWaitResTime: 'number',
      beginWaitTimeTime: 'number',
      bizDate: 'number',
      createTime: 'number',
      createUser: 'string',
      cycTime: 'number',
      dagId: 'number',
      dagType: 'string',
      finishTime: 'number',
      instanceId: 'number',
      modifyTime: 'number',
      nodeId: 'number',
      nodeName: 'string',
      paramValues: 'string',
      status: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaCategoryResponseBodyDataDataEntityList extends $tea.Model {
  /**
   * @remarks
   * The category ID.
   * 
   * @example
   * 133
   */
  categoryId?: number;
  /**
   * @remarks
   * The remarks of the category.
   * 
   * @example
   * category 1
   */
  comment?: string;
  /**
   * @remarks
   * The time when the category was created.
   * 
   * @example
   * 1541576644000
   */
  createTime?: number;
  /**
   * @remarks
   * The number of category levels.
   * 
   * @example
   * 1
   */
  depth?: number;
  /**
   * @remarks
   * The ID of the user that performed the last operation.
   * 
   * @example
   * 12345
   */
  lastOperatorId?: string;
  /**
   * @remarks
   * The time when the category was last modified.
   * 
   * @example
   * 1541576644000
   */
  modifiedTime?: number;
  /**
   * @remarks
   * The name of the category.
   * 
   * @example
   * category 1
   */
  name?: string;
  /**
   * @remarks
   * The category owner ID.
   * 
   * @example
   * 123
   */
  ownerId?: string;
  /**
   * @remarks
   * The parent category ID.
   * 
   * @example
   * 12
   */
  parentCategoryId?: number;
  static names(): { [key: string]: string } {
    return {
      categoryId: 'CategoryId',
      comment: 'Comment',
      createTime: 'CreateTime',
      depth: 'Depth',
      lastOperatorId: 'LastOperatorId',
      modifiedTime: 'ModifiedTime',
      name: 'Name',
      ownerId: 'OwnerId',
      parentCategoryId: 'ParentCategoryId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryId: 'number',
      comment: 'string',
      createTime: 'number',
      depth: 'number',
      lastOperatorId: 'string',
      modifiedTime: 'number',
      name: 'string',
      ownerId: 'string',
      parentCategoryId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaCategoryResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The information about the category tree.
   */
  dataEntityList?: GetMetaCategoryResponseBodyDataDataEntityList[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of categories returned.
   * 
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataEntityList: 'DataEntityList',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataEntityList: { 'type': 'array', 'itemType': GetMetaCategoryResponseBodyDataDataEntityList },
      pageNum: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaColumnLineageResponseBodyDataDataEntityList extends $tea.Model {
  /**
   * @remarks
   * The EMR cluster ID.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The unique identifier of the field.
   * 
   * @example
   * odps.engine_name.table_name.1
   */
  columnGuid?: string;
  /**
   * @remarks
   * The name of the field.
   * 
   * @example
   * 1
   */
  columnName?: string;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * abc
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      columnGuid: 'ColumnGuid',
      columnName: 'ColumnName',
      databaseName: 'DatabaseName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      columnGuid: 'string',
      columnName: 'string',
      databaseName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaColumnLineageResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The returned result.
   */
  dataEntityList?: GetMetaColumnLineageResponseBodyDataDataEntityList[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of fields.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataEntityList: 'DataEntityList',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataEntityList: { 'type': 'array', 'itemType': GetMetaColumnLineageResponseBodyDataDataEntityList },
      pageNum: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaDBInfoResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The compute engine instance ID. Specify the ID in the `Engine type.Engine name` format.
   * 
   * @example
   * odps.engine_name
   */
  appGuid?: string;
  /**
   * @remarks
   * The EMR cluster ID.
   * 
   * @example
   * abc
   */
  clusterBizId?: string;
  /**
   * @remarks
   * The comment.
   * 
   * @example
   * The ID of the compute engine instance. The ID is in the Engine type.Engine name format.
   */
  comment?: string;
  /**
   * @remarks
   * The time when the compute engine instance was created.
   * 
   * @example
   * 1541576644000
   */
  createTime?: number;
  /**
   * @remarks
   * The endpoint of the service.
   * 
   * @example
   * http://service.odpsstg.aliyun-inc.com/
   */
  endpoint?: string;
  /**
   * @remarks
   * The type of the environment. Valid values: 0 and 1. The value 0 indicates the development environment. The value 1 indicates the production environment.
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The storage path of the metadatabase of the EMR cluster.
   * 
   * @example
   * hdfs://
   */
  location?: string;
  /**
   * @remarks
   * The time when the compute engine instance was modified.
   * 
   * @example
   * 1541576644000
   */
  modifyTime?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * abc
   */
  name?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the workspace owner.
   * 
   * @example
   * 23
   */
  ownerId?: string;
  /**
   * @remarks
   * The name of the workspace owner.
   * 
   * @example
   * 323
   */
  ownerName?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 22
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the workspace.
   * 
   * @example
   * test
   */
  projectName?: string;
  /**
   * @remarks
   * The display name of the workspace.
   * 
   * @example
   * The storage path of the metadatabase of the EMR cluster.
   */
  projectNameCn?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 233
   */
  tenantId?: number;
  /**
   * @remarks
   * The type of the metadatabase.
   * 
   * @example
   * hive
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      appGuid: 'AppGuid',
      clusterBizId: 'ClusterBizId',
      comment: 'Comment',
      createTime: 'CreateTime',
      endpoint: 'Endpoint',
      envType: 'EnvType',
      location: 'Location',
      modifyTime: 'ModifyTime',
      name: 'Name',
      ownerId: 'OwnerId',
      ownerName: 'OwnerName',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      projectNameCn: 'ProjectNameCn',
      tenantId: 'TenantId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appGuid: 'string',
      clusterBizId: 'string',
      comment: 'string',
      createTime: 'number',
      endpoint: 'string',
      envType: 'number',
      location: 'string',
      modifyTime: 'number',
      name: 'string',
      ownerId: 'string',
      ownerName: 'string',
      projectId: 'number',
      projectName: 'string',
      projectNameCn: 'string',
      tenantId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaDBTableListResponseBodyDataTableEntityList extends $tea.Model {
  /**
   * @remarks
   * The name of the metadatabase.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * The GUID of the metatable.
   * 
   * @example
   * odps.engine_name.tname
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the metatable.
   * 
   * @example
   * tname
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      databaseName: 'DatabaseName',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseName: 'string',
      tableGuid: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaDBTableListResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The list of metatables in the compute engine instance.
   */
  tableEntityList?: GetMetaDBTableListResponseBodyDataTableEntityList[];
  /**
   * @remarks
   * The total number of compute engine instances returned.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tableEntityList: 'TableEntityList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      tableEntityList: { 'type': 'array', 'itemType': GetMetaDBTableListResponseBodyDataTableEntityList },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableBasicInfoResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The display name of the metatable.
   * 
   * @example
   * test
   */
  caption?: string;
  /**
   * @remarks
   * The ID of the EMR cluster.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The number of fields.
   * 
   * @example
   * 3
   */
  columnCount?: number;
  /**
   * @remarks
   * The comment of the metatable.
   * 
   * @example
   * test table
   */
  comment?: string;
  /**
   * @remarks
   * The time when the metatable was created.
   * 
   * @example
   * 1589870294000
   */
  createTime?: number;
  /**
   * @remarks
   * The size of storage space that is occupied by the metatable. Unit: bytes.
   * 
   * @example
   * 10
   */
  dataSize?: number;
  /**
   * @remarks
   * The name of the metadatabase.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * The type of the environment. Valid values:
   * 
   * *   0: development environment
   * *   1: production environment
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The number of times the metatable was added to a favorite list. This parameter is returned only if you set the Extension parameter to true and takes effect only if you set the DataSourceType parameter to odps.
   * 
   * @example
   * 6
   */
  favoriteCount?: number;
  /**
   * @remarks
   * Indicates whether the metatable is a partitioned table. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  isPartitionTable?: boolean;
  /**
   * @remarks
   * Indicates whether the metatable is a view. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  isView?: boolean;
  /**
   * @remarks
   * The scope in which the metatable is visible. Valid values:
   * 
   * *   0: The metatable is visible to workspace members.
   * *   1: The metatable is visible to users within the tenant.
   * *   2: The metatable is visible to all tenants.
   * *   3: The metatable is visible only to the metatable owner.
   * 
   * @example
   * 1
   */
  isVisible?: number;
  /**
   * @remarks
   * The time when the metatable was last accessed.
   * 
   * @example
   * 1589870294000
   */
  lastAccessTime?: number;
  /**
   * @remarks
   * The time when the schema of the metatable was last changed.
   * 
   * @example
   * 1589870294000
   */
  lastDdlTime?: number;
  /**
   * @remarks
   * The time when the metatable was last updated.
   * 
   * @example
   * 1589870294000
   */
  lastModifyTime?: number;
  /**
   * @remarks
   * The lifecycle of the metatable. Unit: days.
   * 
   * @example
   * 5
   */
  lifeCycle?: number;
  /**
   * @remarks
   * The storage path of the Hive metadatabase.
   * 
   * @example
   * hdfs://
   */
  location?: string;
  /**
   * @remarks
   * The ID of the metatable owner.
   * 
   * @example
   * 123
   */
  ownerId?: string;
  /**
   * @remarks
   * The partition key of the Hive metatable.
   * 
   * @example
   * ab
   */
  partitionKeys?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 232
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the workspace.
   * 
   * @example
   * test
   */
  projectName?: string;
  /**
   * @remarks
   * The number of times the metatable was read. This parameter is returned only if you set the Extension parameter to true and takes effect only if you set the DataSourceType parameter to odps.
   * 
   * @example
   * 3
   */
  readCount?: number;
  /**
   * @remarks
   * The schema information of the metatable. This parameter is returned if the three-layer model of MaxCompute is enabled.
   * 
   * @example
   * default
   */
  schema?: string;
  /**
   * @remarks
   * The GUID of the metatable.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the metatable.
   * 
   * @example
   * table_name
   */
  tableName?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 12345
   */
  tenantId?: number;
  /**
   * @remarks
   * The number of times the metatable was viewed. This parameter is returned only if you set the Extension parameter to true and takes effect only if you set the DataSourceType parameter to odps.
   * 
   * @example
   * 2
   */
  viewCount?: number;
  static names(): { [key: string]: string } {
    return {
      caption: 'Caption',
      clusterId: 'ClusterId',
      columnCount: 'ColumnCount',
      comment: 'Comment',
      createTime: 'CreateTime',
      dataSize: 'DataSize',
      databaseName: 'DatabaseName',
      envType: 'EnvType',
      favoriteCount: 'FavoriteCount',
      isPartitionTable: 'IsPartitionTable',
      isView: 'IsView',
      isVisible: 'IsVisible',
      lastAccessTime: 'LastAccessTime',
      lastDdlTime: 'LastDdlTime',
      lastModifyTime: 'LastModifyTime',
      lifeCycle: 'LifeCycle',
      location: 'Location',
      ownerId: 'OwnerId',
      partitionKeys: 'PartitionKeys',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      readCount: 'ReadCount',
      schema: 'Schema',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
      tenantId: 'TenantId',
      viewCount: 'ViewCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caption: 'string',
      clusterId: 'string',
      columnCount: 'number',
      comment: 'string',
      createTime: 'number',
      dataSize: 'number',
      databaseName: 'string',
      envType: 'number',
      favoriteCount: 'number',
      isPartitionTable: 'boolean',
      isView: 'boolean',
      isVisible: 'number',
      lastAccessTime: 'number',
      lastDdlTime: 'number',
      lastModifyTime: 'number',
      lifeCycle: 'number',
      location: 'string',
      ownerId: 'string',
      partitionKeys: 'string',
      projectId: 'number',
      projectName: 'string',
      readCount: 'number',
      schema: 'string',
      tableGuid: 'string',
      tableName: 'string',
      tenantId: 'number',
      viewCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableChangeLogResponseBodyDataDataEntityList extends $tea.Model {
  /**
   * @remarks
   * The content of the change.
   * 
   * @example
   * "[{\\"action\\":\\"ADD_COLUMN\\",\\"value\\":[{\\"originName\\":\\"\\",\\"originType\\":\\"\\",\\"originComment\\":\\"\\",\\"name\\":\\"id\\",\\"type\\":\\"struct<name:string>\\",\\"comment\\":\\"\\"}]}]",
   */
  changeContent?: string;
  /**
   * @remarks
   * The type of the change.
   * 
   * @example
   * CREATE_TABLE
   */
  changeType?: string;
  /**
   * @remarks
   * The time when the metatable was created.
   * 
   * @example
   * 1590722845000
   */
  createTime?: number;
  /**
   * @remarks
   * The time when the metatable was modified.
   * 
   * @example
   * 1590722845000
   */
  modifiedTime?: number;
  /**
   * @remarks
   * The entity on which the change was made. Valid values: TABLE and PARTITION.
   * 
   * @example
   * TABLE
   */
  objectType?: string;
  /**
   * @remarks
   * The name of the operator.
   * 
   * @example
   * abc
   */
  operator?: string;
  static names(): { [key: string]: string } {
    return {
      changeContent: 'ChangeContent',
      changeType: 'ChangeType',
      createTime: 'CreateTime',
      modifiedTime: 'ModifiedTime',
      objectType: 'ObjectType',
      operator: 'Operator',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changeContent: 'string',
      changeType: 'string',
      createTime: 'number',
      modifiedTime: 'number',
      objectType: 'string',
      operator: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableChangeLogResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of instances.
   */
  dataEntityList?: GetMetaTableChangeLogResponseBodyDataDataEntityList[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 10
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 1
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of metatables.
   * 
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataEntityList: 'DataEntityList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataEntityList: { 'type': 'array', 'itemType': GetMetaTableChangeLogResponseBodyDataDataEntityList },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableColumnResponseBodyDataColumnList extends $tea.Model {
  /**
   * @remarks
   * The description of the field.
   * 
   * @example
   * data column
   */
  caption?: string;
  /**
   * @remarks
   * The GUID of the field.
   * 
   * @example
   * odps.engine_name.table_name.name
   */
  columnGuid?: string;
  /**
   * @remarks
   * The name of the field.
   * 
   * @example
   * name
   */
  columnName?: string;
  /**
   * @remarks
   * The data type of the field.
   * 
   * @example
   * string
   */
  columnType?: string;
  /**
   * @remarks
   * The remarks of the field.
   * 
   * @example
   * comment
   */
  comment?: string;
  /**
   * @remarks
   * Indicates whether the field is a foreign key. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  isForeignKey?: boolean;
  /**
   * @remarks
   * Indicates whether the field is a partition field. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  isPartitionColumn?: boolean;
  /**
   * @remarks
   * Indicates whether the field is a primary key. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  isPrimaryKey?: boolean;
  /**
   * @remarks
   * The sequence number of the field.
   * 
   * @example
   * 1
   */
  position?: number;
  /**
   * @remarks
   * The number of times the field is read.
   * 
   * @example
   * 2
   */
  relationCount?: number;
  static names(): { [key: string]: string } {
    return {
      caption: 'Caption',
      columnGuid: 'ColumnGuid',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      comment: 'Comment',
      isForeignKey: 'IsForeignKey',
      isPartitionColumn: 'IsPartitionColumn',
      isPrimaryKey: 'IsPrimaryKey',
      position: 'Position',
      relationCount: 'RelationCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caption: 'string',
      columnGuid: 'string',
      columnName: 'string',
      columnType: 'string',
      comment: 'string',
      isForeignKey: 'boolean',
      isPartitionColumn: 'boolean',
      isPrimaryKey: 'boolean',
      position: 'number',
      relationCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableColumnResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The information about fields.
   */
  columnList?: GetMetaTableColumnResponseBodyDataColumnList[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNum?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of fields.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      columnList: 'ColumnList',
      pageNum: 'PageNum',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnList: { 'type': 'array', 'itemType': GetMetaTableColumnResponseBodyDataColumnList },
      pageNum: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableFullInfoResponseBodyDataColumnList extends $tea.Model {
  /**
   * @remarks
   * The description of the field.
   * 
   * @example
   * data comment
   */
  caption?: string;
  /**
   * @remarks
   * The GUID of the field.
   * 
   * @example
   * odps.engine_name.table_name.1
   */
  columnGuid?: string;
  /**
   * @remarks
   * The name of the field.
   * 
   * @example
   * 1
   */
  columnName?: string;
  /**
   * @remarks
   * The data type of the field.
   * 
   * @example
   * string
   */
  columnType?: string;
  /**
   * @remarks
   * The remarks of the field.
   * 
   * @example
   * comment
   */
  comment?: string;
  /**
   * @remarks
   * Indicates whether the field is a foreign key. Valid values:
   * 
   * *   true: The field is a foreign key.
   * *   false: The field is not a foreign key.
   * 
   * @example
   * true
   */
  isForeignKey?: boolean;
  /**
   * @remarks
   * Indicates whether the field is a partition field. Valid values:
   * 
   * *   true: The field is a partition field.
   * *   false: The field is not a partition field.
   * 
   * @example
   * true
   */
  isPartitionColumn?: boolean;
  /**
   * @remarks
   * Indicates whether the field is the primary key. Valid values:
   * 
   * *   true: The field is the primary key.
   * *   false: The field is not the primary key.
   * 
   * @example
   * false
   */
  isPrimaryKey?: boolean;
  /**
   * @remarks
   * The ordinal number of the field.
   * 
   * @example
   * 1
   */
  position?: number;
  static names(): { [key: string]: string } {
    return {
      caption: 'Caption',
      columnGuid: 'ColumnGuid',
      columnName: 'ColumnName',
      columnType: 'ColumnType',
      comment: 'Comment',
      isForeignKey: 'IsForeignKey',
      isPartitionColumn: 'IsPartitionColumn',
      isPrimaryKey: 'IsPrimaryKey',
      position: 'Position',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caption: 'string',
      columnGuid: 'string',
      columnName: 'string',
      columnType: 'string',
      comment: 'string',
      isForeignKey: 'boolean',
      isPartitionColumn: 'boolean',
      isPrimaryKey: 'boolean',
      position: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableFullInfoResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the EMR cluster.
   * 
   * @example
   * C-010A704DA760****
   */
  clusterId?: string;
  /**
   * @remarks
   * The fields in the metatable.
   */
  columnList?: GetMetaTableFullInfoResponseBodyDataColumnList[];
  /**
   * @remarks
   * The remarks of the metatable.
   * 
   * @example
   * comment
   */
  comment?: string;
  /**
   * @remarks
   * The time when the metatable was created. You can convert the timestamp to the related date based on the time zone that you use.
   * 
   * @example
   * 1589870293000
   */
  createTime?: number;
  /**
   * @remarks
   * The amount of storage resources that are consumed by the metatable. Unit: bytes.
   * 
   * @example
   * 10
   */
  dataSize?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * The type of the environment in which the metatable resides. Valid values:
   * 
   * *   0: indicates that the metatable resides in the development environment.
   * *   1: indicates that the metatable resides in the production environment.
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The scope in which the metatable is visible. Valid values:
   * 
   * *   0: indicates that the metatable is visible to workspace members.
   * *   1: indicates that the metatable is visible to users within a tenant.
   * *   2: indicates that the metatable is visible to all tenants.
   * *   3: indicates that the metatable is visible only to the metatable owner.
   * 
   * @example
   * 1
   */
  isVisible?: number;
  /**
   * @remarks
   * The time when the metatable was last accessed. You can convert the timestamp to the related date based on the time zone that you use.
   * 
   * @example
   * 1589870294000
   */
  lastAccessTime?: number;
  /**
   * @remarks
   * The time when the schema of the metatable was last changed. You can convert the timestamp to the related date based on the time zone that you use.
   * 
   * @example
   * 1589870294000
   */
  lastDdlTime?: number;
  /**
   * @remarks
   * The time when the metatable was last updated. You can convert the timestamp to the related date based on the time zone that you use.
   * 
   * @example
   * 1589870294000
   */
  lastModifyTime?: number;
  /**
   * @remarks
   * The lifecycle of the metatable. Unit: days.
   * 
   * @example
   * 5
   */
  lifeCycle?: number;
  /**
   * @remarks
   * The storage path of the Hive metatable.
   * 
   * @example
   * hdfs://localhost:777/user/hadoop/test.txt
   */
  location?: string;
  /**
   * @remarks
   * The ID of the metatable owner.
   * 
   * @example
   * 123
   */
  ownerId?: string;
  /**
   * @remarks
   * The partition key.
   * 
   * @example
   * abc
   */
  partitionKeys?: string;
  /**
   * @remarks
   * The ID of the workspace to which the metatable belongs.
   * 
   * @example
   * 22
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the workspace to which the metatable belongs.
   * 
   * @example
   * test
   */
  projectName?: string;
  schema?: string;
  /**
   * @remarks
   * The GUID of the metatable.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the metatable.
   * 
   * @example
   * table_name
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the tenant.
   * 
   * @example
   * 12345
   */
  tenantId?: number;
  /**
   * @remarks
   * The total number of fields.
   * 
   * @example
   * 22
   */
  totalColumnCount?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      columnList: 'ColumnList',
      comment: 'Comment',
      createTime: 'CreateTime',
      dataSize: 'DataSize',
      databaseName: 'DatabaseName',
      envType: 'EnvType',
      isVisible: 'IsVisible',
      lastAccessTime: 'LastAccessTime',
      lastDdlTime: 'LastDdlTime',
      lastModifyTime: 'LastModifyTime',
      lifeCycle: 'LifeCycle',
      location: 'Location',
      ownerId: 'OwnerId',
      partitionKeys: 'PartitionKeys',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      schema: 'Schema',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
      tenantId: 'TenantId',
      totalColumnCount: 'TotalColumnCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      columnList: { 'type': 'array', 'itemType': GetMetaTableFullInfoResponseBodyDataColumnList },
      comment: 'string',
      createTime: 'number',
      dataSize: 'number',
      databaseName: 'string',
      envType: 'number',
      isVisible: 'number',
      lastAccessTime: 'number',
      lastDdlTime: 'number',
      lastModifyTime: 'number',
      lifeCycle: 'number',
      location: 'string',
      ownerId: 'string',
      partitionKeys: 'string',
      projectId: 'number',
      projectName: 'string',
      schema: 'string',
      tableGuid: 'string',
      tableName: 'string',
      tenantId: 'number',
      totalColumnCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableIntroWikiResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The description of the metatable.
   * 
   * @example
   * \\# Business requirements\\n\\n\\&lt;a name=\\&quot;xiw5n\\&quot;
   */
  content?: string;
  /**
   * @remarks
   * The time when the metatable was created.
   * 
   * @example
   * 1584444247000
   */
  createTime?: number;
  /**
   * @remarks
   * The creator of the metatable.
   * 
   * @example
   * abc
   */
  creator?: string;
  /**
   * @remarks
   * The name of the user who creates the metatable.
   * 
   * @example
   * abc
   */
  creatorName?: string;
  /**
   * @remarks
   * The time when the metatable was last modified.
   * 
   * @example
   * 1584444247000
   */
  modifiedTime?: number;
  /**
   * @remarks
   * The version number.
   * 
   * @example
   * 1
   */
  version?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      createTime: 'CreateTime',
      creator: 'Creator',
      creatorName: 'CreatorName',
      modifiedTime: 'ModifiedTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      createTime: 'number',
      creator: 'string',
      creatorName: 'string',
      modifiedTime: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableLineageResponseBodyDataDataEntityList extends $tea.Model {
  /**
   * @remarks
   * The time when the table was created.
   * 
   * @example
   * 1638720736000
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The name of the database.
   * 
   * @example
   * db1
   */
  databaseName?: string;
  /**
   * @remarks
   * The unique identifier of the table.
   * 
   * @example
   * odps.tt.name
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * name
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      createTimestamp: 'CreateTimestamp',
      databaseName: 'DatabaseName',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTimestamp: 'number',
      databaseName: 'string',
      tableGuid: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableLineageResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The information about the table.
   */
  dataEntityList?: GetMetaTableLineageResponseBodyDataDataEntityList[];
  /**
   * @remarks
   * Indicates whether the next page exists.
   * 
   * @example
   * true
   */
  hasNext?: boolean;
  /**
   * @remarks
   * The logic of paging. If the value true is returned for the HasNext parameter and a value is returned for the NextPrimaryKey parameter in the response of the previous request, you must use the value of the NextPrimaryKey parameter for the next request.
   * 
   * @example
   * odps | retail_e_commerce_2 | retail_e_commerce_2 | dws_ec_trd__cate_commodity_gmv_kpy_fy
   */
  nextPrimaryKey?: string;
  static names(): { [key: string]: string } {
    return {
      dataEntityList: 'DataEntityList',
      hasNext: 'HasNext',
      nextPrimaryKey: 'NextPrimaryKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataEntityList: { 'type': 'array', 'itemType': GetMetaTableLineageResponseBodyDataDataEntityList },
      hasNext: 'boolean',
      nextPrimaryKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableListByCategoryResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The returned result.
   */
  tableGuidList?: string[];
  /**
   * @remarks
   * The total number of metatables.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      tableGuidList: 'TableGuidList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      tableGuidList: { 'type': 'array', 'itemType': 'string' },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableOutputResponseBodyDataDataEntityList extends $tea.Model {
  /**
   * @remarks
   * The end time.
   * 
   * @example
   * 2022-02-12 0:32:12
   */
  endTime?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 128
   */
  projectId?: number;
  /**
   * @remarks
   * The start time.
   * 
   * @example
   * 2022-02-12 0:34:13
   */
  startTime?: string;
  /**
   * @remarks
   * The GUID of the MaxCompute table.
   * 
   * @example
   * odps.sample_project.sample_table
   */
  tableGuid?: string;
  /**
   * @remarks
   * The task ID.
   * 
   * @example
   * 1048576
   */
  taskId?: string;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * 987654321
   */
  taskInstanceId?: number;
  /**
   * @remarks
   * The waiting time.
   * 
   * @example
   * 3
   */
  waitTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      projectId: 'ProjectId',
      startTime: 'StartTime',
      tableGuid: 'TableGuid',
      taskId: 'TaskId',
      taskInstanceId: 'TaskInstanceId',
      waitTime: 'WaitTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      projectId: 'number',
      startTime: 'string',
      tableGuid: 'string',
      taskId: 'string',
      taskInstanceId: 'number',
      waitTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableOutputResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of instances.
   */
  dataEntityList?: GetMetaTableOutputResponseBodyDataDataEntityList[];
  /**
   * @remarks
   * The page number. Valid values: 1 to 30. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 128
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataEntityList: 'DataEntityList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataEntityList: { 'type': 'array', 'itemType': GetMetaTableOutputResponseBodyDataDataEntityList },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTablePartitionRequestSortCriterion extends $tea.Model {
  /**
   * @remarks
   * The order in which partitions in the metatable are sorted. Valid values: asc and desc. Default value: desc.
   * 
   * @example
   * desc
   */
  order?: string;
  /**
   * @remarks
   * The field that is used to sort partitions in the metatable. Valid values: name and modify_time. By default, partitions in the metatable are sorted based on their creation time.
   * 
   * @example
   * name
   */
  sortField?: string;
  static names(): { [key: string]: string } {
    return {
      order: 'Order',
      sortField: 'SortField',
    };
  }

  static types(): { [key: string]: any } {
    return {
      order: 'string',
      sortField: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTablePartitionResponseBodyDataDataEntityList extends $tea.Model {
  /**
   * @remarks
   * The comment.
   * 
   * @example
   * test
   */
  comment?: string;
  /**
   * @remarks
   * The time when the partition was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1590032868000
   */
  createTime?: number;
  /**
   * @remarks
   * The size of the partition. Unit: bytes.
   * 
   * @example
   * 19
   */
  dataSize?: number;
  /**
   * @remarks
   * The time when the partition was modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1590032868000
   */
  modifiedTime?: number;
  /**
   * @remarks
   * The GUID of the partition.
   * 
   * @example
   * odps.engine_name.table_name.pt=20170614
   */
  partitionGuid?: string;
  /**
   * @remarks
   * The location of the Hive partition.
   * 
   * @example
   * abc
   */
  partitionLocation?: string;
  /**
   * @remarks
   * The name of the partition.
   * 
   * @example
   * pt=20170614
   */
  partitionName?: string;
  /**
   * @remarks
   * The path of the partition.
   * 
   * @example
   * abc
   */
  partitionPath?: string;
  /**
   * @remarks
   * The type of the partition.
   * 
   * @example
   * abc
   */
  partitionType?: string;
  /**
   * @remarks
   * The number of entries in the partition.
   * 
   * @example
   * 233
   */
  recordCount?: number;
  /**
   * @remarks
   * The unique identifier of the metatable.
   * 
   * @example
   * odps.engine_name.table_name
   */
  tableGuid?: string;
  static names(): { [key: string]: string } {
    return {
      comment: 'Comment',
      createTime: 'CreateTime',
      dataSize: 'DataSize',
      modifiedTime: 'ModifiedTime',
      partitionGuid: 'PartitionGuid',
      partitionLocation: 'PartitionLocation',
      partitionName: 'PartitionName',
      partitionPath: 'PartitionPath',
      partitionType: 'PartitionType',
      recordCount: 'RecordCount',
      tableGuid: 'TableGuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      comment: 'string',
      createTime: 'number',
      dataSize: 'number',
      modifiedTime: 'number',
      partitionGuid: 'string',
      partitionLocation: 'string',
      partitionName: 'string',
      partitionPath: 'string',
      partitionType: 'string',
      recordCount: 'number',
      tableGuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTablePartitionResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of partitions.
   */
  dataEntityList?: GetMetaTablePartitionResponseBodyDataDataEntityList[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of partitions.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataEntityList: 'DataEntityList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataEntityList: { 'type': 'array', 'itemType': GetMetaTablePartitionResponseBodyDataDataEntityList },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableProducingTasksResponseBodyData extends $tea.Model {
  /**
   * @example
   * 9876543210
   */
  taskId?: string;
  taskName?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
      taskName: 'TaskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
      taskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableThemeLevelResponseBodyEntityLevel extends $tea.Model {
  /**
   * @remarks
   * The description of the level.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the level.
   * 
   * @example
   * 1
   */
  levelId?: number;
  /**
   * @remarks
   * The name of the level.
   * 
   * @example
   * level1
   */
  name?: string;
  /**
   * @remarks
   * The type of the level. Valid values:
   * 
   * *   1: indicates the logical level.
   * *   2: indicates the physical level.
   * 
   * @example
   * 1
   */
  type?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      levelId: 'LevelId',
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      levelId: 'number',
      name: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableThemeLevelResponseBodyEntityTheme extends $tea.Model {
  /**
   * @remarks
   * The level of the theme. Valid values:
   * 
   * *   1
   * *   2
   * 
   * @example
   * 1
   */
  level?: number;
  /**
   * @remarks
   * The name of the theme.
   * 
   * @example
   * theme1
   */
  name?: string;
  /**
   * @remarks
   * The ID of the parent theme.
   * 
   * @example
   * 0
   */
  parentId?: number;
  /**
   * @remarks
   * The ID of the theme.
   * 
   * @example
   * 123
   */
  themeId?: number;
  static names(): { [key: string]: string } {
    return {
      level: 'Level',
      name: 'Name',
      parentId: 'ParentId',
      themeId: 'ThemeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      level: 'number',
      name: 'string',
      parentId: 'number',
      themeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMetaTableThemeLevelResponseBodyEntity extends $tea.Model {
  /**
   * @remarks
   * The information about the levels of the metatable.
   */
  level?: GetMetaTableThemeLevelResponseBodyEntityLevel[];
  /**
   * @remarks
   * The information about the themes of the metatable.
   */
  theme?: GetMetaTableThemeLevelResponseBodyEntityTheme[];
  static names(): { [key: string]: string } {
    return {
      level: 'Level',
      theme: 'Theme',
    };
  }

  static types(): { [key: string]: any } {
    return {
      level: { 'type': 'array', 'itemType': GetMetaTableThemeLevelResponseBodyEntityLevel },
      theme: { 'type': 'array', 'itemType': GetMetaTableThemeLevelResponseBodyEntityTheme },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMigrationProcessResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the step in the migration task.
   * 
   * @example
   * IMPORE_PREPARE
   */
  taskName?: string;
  /**
   * @remarks
   * The running status of the step in the migration task. Valid values:
   * 
   * *   INIT
   * *   RUNNING
   * *   FAILURE
   * *   SUCCESS
   * 
   * @example
   * SUCCESS
   */
  taskStatus?: string;
  static names(): { [key: string]: string } {
    return {
      taskName: 'TaskName',
      taskStatus: 'TaskStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskName: 'string',
      taskStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMigrationSummaryResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the user who created the task.
   * 
   * @example
   * 982293332403****
   */
  createUser?: string;
  /**
   * @remarks
   * The URL that is used to download the package of the export task. You can use the URL to download the package of the export task.
   * 
   * @example
   * https://shanghai-xxx-oss.oss-cn-shanghai.aliyuncs.com/pre/store/f10_bf47_b4fa7df0860f.zip?Expires=1639540903&OSSAccessKeyId=XXXXXXeF4Lv5j&Signature=qxxxxx
   */
  downloadUrl?: string;
  /**
   * @remarks
   * The time when the task was created.
   * 
   * @example
   * 1589904000000
   */
  gmtCreate?: number;
  /**
   * @remarks
   * The time when the task was modified.
   * 
   * @example
   * 1589904000000
   */
  gmtModified?: number;
  /**
   * @remarks
   * The task ID.
   * 
   * @example
   * 1234
   */
  migrationId?: number;
  /**
   * @remarks
   * The task name.
   * 
   * @example
   * test_export_01
   */
  name?: string;
  /**
   * @remarks
   * The ID of the user who managed the task.
   * 
   * @example
   * 982293332403****
   */
  opUser?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace to which the migration task belongs.
   * 
   * @example
   * 12345
   */
  projectId?: number;
  /**
   * @remarks
   * The status of the migration task. Valid values:
   * 
   * *   INIT
   * *   EDITING
   * *   IMPORTING
   * *   IMPORT_ERROR
   * *   IMPORT_SUCCESS
   * *   EXPORTING
   * *   EXPORT_ERROR
   * *   EXPORT_SUCCESS
   * *   REVOKED
   * *   PARTIAL_SUCCESS
   * 
   * @example
   * EXPORT_SUCCESS
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      createUser: 'CreateUser',
      downloadUrl: 'DownloadUrl',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      migrationId: 'MigrationId',
      name: 'Name',
      opUser: 'OpUser',
      projectId: 'ProjectId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createUser: 'string',
      downloadUrl: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      migrationId: 'number',
      name: 'string',
      opUser: 'string',
      projectId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The description of the node.
   * 
   * @example
   * 123456
   */
  baselineId?: number;
  /**
   * @remarks
   * The operation that you want to perform. Set the value to **GetNode**.
   * 
   * @example
   * 123
   */
  businessId?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV.
   * 
   * @example
   * odps_first_dev
   */
  connection?: string;
  createTime?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV.
   * 
   * @example
   * 00 00 00 * * ?
   */
  cronExpress?: string;
  deployDate?: number;
  /**
   * @remarks
   * The name of the resource group.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the node. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the node ID.
   * 
   * @example
   * [{"projectName":"test_0923001","tableName":"test_table_001","partition":"ds\\u003d$[yyyymmdd]"},{"projectName":"test_0923001","tableName":"test_table_002","partition":"NOTAPARTITIONTABLE"}]
   */
  dqcDescription?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * 1
   */
  dqcType?: number;
  fileId?: number;
  fileType?: number;
  fileVersion?: number;
  modifyTime?: number;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The scheduling type of the node. Valid values:
   * 
   * *   NORMAL: The node is an auto triggered node.
   * *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered.
   * *   PAUSE: The node is a paused node.
   * *   SKIP: The node is a dry-run node. Dry-run nodes are started as scheduled but the system sets the status of the nodes to successful when it starts to run them.
   * 
   * @example
   * The ID of the baseline.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the node.
   * 
   * @example
   * 17366294****
   */
  ownerId?: string;
  /**
   * @remarks
   * The CRON expression returned.
   * 
   * @example
   * a=b
   */
  paramValues?: string;
  /**
   * @remarks
   * The HTTP status code returned.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The ID of the owner of the node.
   * 
   * @example
   * ODPS_SQL
   */
  programType?: string;
  /**
   * @remarks
   * Indicates whether the node can be rerun.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * Indicates whether the node is associated with Data Quality. Valid values: 0 and 1. A value of 0 indicates that the node is associated with Data Quality. A value of 1 indicates that the node is not associated with Data Quality.
   * 
   * @example
   * 123
   */
  relatedFlowId?: number;
  /**
   * @remarks
   * The ID of the workflow to which the node belongs.
   * 
   * @example
   * 60
   */
  repeatInterval?: number;
  repeatMode?: number;
  /**
   * @remarks
   * The type of the node.
   * 
   * @example
   * true
   */
  repeatability?: string;
  resGroupIdentifier?: string;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * The table and partition filter expression in Data Quality that are associated with the node.
   */
  resGroupName?: string;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * @example
   * NORMAL
   */
  schedulerType?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      businessId: 'BusinessId',
      connection: 'Connection',
      createTime: 'CreateTime',
      cronExpress: 'CronExpress',
      deployDate: 'DeployDate',
      description: 'Description',
      dqcDescription: 'DqcDescription',
      dqcType: 'DqcType',
      fileId: 'FileId',
      fileType: 'FileType',
      fileVersion: 'FileVersion',
      modifyTime: 'ModifyTime',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      ownerId: 'OwnerId',
      paramValues: 'ParamValues',
      priority: 'Priority',
      programType: 'ProgramType',
      projectId: 'ProjectId',
      relatedFlowId: 'RelatedFlowId',
      repeatInterval: 'RepeatInterval',
      repeatMode: 'RepeatMode',
      repeatability: 'Repeatability',
      resGroupIdentifier: 'ResGroupIdentifier',
      resGroupName: 'ResGroupName',
      schedulerType: 'SchedulerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      businessId: 'number',
      connection: 'string',
      createTime: 'number',
      cronExpress: 'string',
      deployDate: 'number',
      description: 'string',
      dqcDescription: 'string',
      dqcType: 'number',
      fileId: 'number',
      fileType: 'number',
      fileVersion: 'number',
      modifyTime: 'number',
      nodeId: 'number',
      nodeName: 'string',
      ownerId: 'string',
      paramValues: 'string',
      priority: 'number',
      programType: 'string',
      projectId: 'number',
      relatedFlowId: 'number',
      repeatInterval: 'number',
      repeatMode: 'number',
      repeatability: 'string',
      resGroupIdentifier: 'string',
      resGroupName: 'string',
      schedulerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeChildrenResponseBodyDataNodes extends $tea.Model {
  /**
   * @remarks
   * The baseline ID.
   * 
   * @example
   * 12345656
   */
  baselineId?: number;
  /**
   * @remarks
   * The CRON expression. CRON expressions are used to run auto triggered nodes.
   * 
   * @example
   * 00 00 * * * *
   */
  cronExpress?: string;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 1244564565
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * test_Node
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 123124561341251321
   */
  ownerId?: string;
  /**
   * @remarks
   * The priority. Valid values: 1 to 8. A large value indicates a high priority.
   * 
   * @example
   * 3
   */
  priority?: number;
  /**
   * @remarks
   * The type of the node.
   * 
   * @example
   * ODPS_SQL
   */
  programType?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * @example
   * 12315412412
   */
  projectId?: number;
  /**
   * @remarks
   * Indicates whether the node can be rerun if the node fails to run. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  repeatability?: boolean;
  /**
   * @remarks
   * The scheduling type of the node. Valid values:
   * 
   * *   NORMAL: The node is an auto triggered node.
   * *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered.
   * *   PAUSE: The node is a paused node. Paused nodes are started as scheduled but the system sets the status of the nodes to failed when it starts to run them.
   * *   SKIP: The node is a dry-run node. Dry-run nodes are started as scheduled but the system sets the status of the nodes to successful when it starts to run them.
   * 
   * @example
   * NORMAL
   */
  schedulerType?: string;
  stepType?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      cronExpress: 'CronExpress',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      ownerId: 'OwnerId',
      priority: 'Priority',
      programType: 'ProgramType',
      projectId: 'ProjectId',
      repeatability: 'Repeatability',
      schedulerType: 'SchedulerType',
      stepType: 'StepType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      cronExpress: 'string',
      nodeId: 'number',
      nodeName: 'string',
      ownerId: 'string',
      priority: 'number',
      programType: 'string',
      projectId: 'number',
      repeatability: 'boolean',
      schedulerType: 'string',
      stepType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeChildrenResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of descendant nodes.
   */
  nodes?: GetNodeChildrenResponseBodyDataNodes[];
  static names(): { [key: string]: string } {
    return {
      nodes: 'Nodes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodes: { 'type': 'array', 'itemType': GetNodeChildrenResponseBodyDataNodes },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeOnBaselineResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 9527952****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      owner: 'Owner',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      nodeName: 'string',
      owner: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeParentsResponseBodyDataNodes extends $tea.Model {
  /**
   * @remarks
   * The baseline ID.
   * 
   * @example
   * 1244564565
   */
  baselineId?: number;
  /**
   * @remarks
   * The CRON expression. CRON expressions are used to run auto triggered nodes.
   * 
   * @example
   * 00 00 * * * *
   */
  cronExpress?: string;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 1244564565
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * test_Node
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 123124561341251321
   */
  ownerId?: string;
  /**
   * @remarks
   * The priority. Valid values: 1 to 8. A large value indicates a high priority.
   * 
   * @example
   * 3
   */
  priority?: number;
  /**
   * @remarks
   * The type of the node.
   * 
   * @example
   * ODPS_SQL
   */
  programType?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * @example
   * 12315412412
   */
  projectId?: number;
  /**
   * @remarks
   * Indicates whether the node can be rerun if the node fails to run. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  repeatability?: boolean;
  /**
   * @remarks
   * The scheduling type of the node. Valid values:
   * 
   * *   NORMAL: The node is an auto triggered node.
   * *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered.
   * *   PAUSE: The node is a paused node. Paused nodes are started as scheduled but the system sets the status of the nodes to failed when it starts to run them.
   * *   SKIP: The node is a dry-run node. Dry-run nodes are started as scheduled but the system sets the status of the nodes to successful when it starts to run them.
   * 
   * @example
   * NORMAL
   */
  schedulerType?: string;
  stepType?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      cronExpress: 'CronExpress',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      ownerId: 'OwnerId',
      priority: 'Priority',
      programType: 'ProgramType',
      projectId: 'ProjectId',
      repeatability: 'Repeatability',
      schedulerType: 'SchedulerType',
      stepType: 'StepType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      cronExpress: 'string',
      nodeId: 'number',
      nodeName: 'string',
      ownerId: 'string',
      priority: 'number',
      programType: 'string',
      projectId: 'number',
      repeatability: 'boolean',
      schedulerType: 'string',
      stepType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeParentsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ancestor nodes.
   */
  nodes?: GetNodeParentsResponseBodyDataNodes[];
  static names(): { [key: string]: string } {
    return {
      nodes: 'Nodes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodes: { 'type': 'array', 'itemType': GetNodeParentsResponseBodyDataNodes },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo extends $tea.Model {
  /**
   * @remarks
   * The type of the node, which is specified by a number.
   * 
   * @example
   * 10
   */
  nodeType?: number;
  /**
   * @remarks
   * The name of the node type.
   * 
   * @example
   * ODPS SQL
   */
  nodeTypeName?: string;
  static names(): { [key: string]: string } {
    return {
      nodeType: 'NodeType',
      nodeTypeName: 'NodeTypeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeType: 'number',
      nodeTypeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetNodeTypeListInfoResponseBodyNodeTypeInfoList extends $tea.Model {
  /**
   * @remarks
   * The information about a node type.
   */
  nodeTypeInfo?: GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 50
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 127
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      nodeTypeInfo: 'NodeTypeInfo',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeTypeInfo: { 'type': 'array', 'itemType': GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to process the permission request order.
   * 
   * @example
   * 182293110403****
   */
  baseId?: string;
  static names(): { [key: string]: string } {
    return {
      baseId: 'BaseId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baseId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList extends $tea.Model {
  /**
   * @remarks
   * The description of the column on which you request permissions.
   */
  columnComment?: string;
  /**
   * @remarks
   * The name of the column on which you request permissions.
   * 
   * @example
   * aColumnName
   */
  columnName?: string;
  /**
   * @remarks
   * The security level of the column on which you request permissions. Valid values: 0 to 9.
   * 
   * @example
   * 9
   */
  securityLevel?: string;
  static names(): { [key: string]: string } {
    return {
      columnComment: 'ColumnComment',
      columnName: 'ColumnName',
      securityLevel: 'SecurityLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnComment: 'string',
      columnName: 'string',
      securityLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList extends $tea.Model {
  /**
   * @remarks
   * The information about the column fields in the object on which you request permissions.
   */
  columnMetaList?: GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList[];
  /**
   * @remarks
   * The name of the table on which you request permissions.
   * 
   * @example
   * aTableName
   */
  objectName?: string;
  static names(): { [key: string]: string } {
    return {
      columnMetaList: 'ColumnMetaList',
      objectName: 'ObjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnMetaList: { 'type': 'array', 'itemType': GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList },
      objectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta extends $tea.Model {
  /**
   * @remarks
   * The MaxCompute project to which the object on which you request permissions belongs.
   * 
   * @example
   * aMaxComputeProject
   */
  maxComputeProjectName?: string;
  /**
   * @remarks
   * The details about the object on which you request permissions.
   */
  objectMetaList?: GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList[];
  /**
   * @remarks
   * The ID of the DataWorks workspace that is associated with the object on which you request permissions.
   * 
   * @example
   * 12345
   */
  workspaceId?: number;
  static names(): { [key: string]: string } {
    return {
      maxComputeProjectName: 'MaxComputeProjectName',
      objectMetaList: 'ObjectMetaList',
      workspaceId: 'WorkspaceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      maxComputeProjectName: 'string',
      objectMetaList: { 'type': 'array', 'itemType': GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList },
      workspaceId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent extends $tea.Model {
  /**
   * @remarks
   * The reason of the permission request. The administrator processes the request based on the reason.
   * 
   * @example
   * I need to use this table
   */
  applyReason?: string;
  /**
   * @remarks
   * The expiration time of the permissions that you request. The value is a UNIX timestamp. If LabelSecurity is disabled for the MaxCompute project in which you want to request permissions on the fields of a table, or the security level of the fields is 0 or is lower than or equal to the security level of the Alibaba Cloud account for which you want to request permissions, you can request only permanent permissions.
   * 
   * @example
   * 1617115071885
   */
  deadline?: number;
  /**
   * @remarks
   * The type of the permission request order. The parameter value is 1 and cannot be changed. This value indicates ACL-based authorization.
   * 
   * @example
   * 1
   */
  orderType?: number;
  /**
   * @remarks
   * The information about the project and workspace that are associated with the object on which you request permissions.
   */
  projectMeta?: GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta;
  static names(): { [key: string]: string } {
    return {
      applyReason: 'ApplyReason',
      deadline: 'Deadline',
      orderType: 'OrderType',
      projectMeta: 'ProjectMeta',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyReason: 'string',
      deadline: 'number',
      orderType: 'number',
      projectMeta: GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList extends $tea.Model {
  /**
   * @remarks
   * The ID of the account that is used to request permissions.
   * 
   * @example
   * 267842600408993176
   */
  granteeId?: string;
  /**
   * @remarks
   * The name of the account that is used to request permissions. The name is in the same format as that of the account used to access the MaxCompute project.
   * 
   * *   If the account is an Alibaba Cloud account, the value is in the ALIYUN$+Account name format.
   * *   If the account is a RAM user, the value is in the RAM$+Account name format.
   * 
   * @example
   * RAM$dataworks_3h1_1:StsRamUser(StsRamUser)
   */
  granteeName?: string;
  /**
   * @remarks
   * The type of the subject that requests permissions. The value is fixed as 1, which indicates users.
   * 
   * @example
   * 1
   */
  granteeType?: number;
  /**
   * @remarks
   * The subtype of the subject that requests permissions. Valid values:
   * 
   * *   101: production account
   * *   103: individual account
   * *   105: account that requests permissions for others
   * 
   * @example
   * 103
   */
  granteeTypeSub?: number;
  static names(): { [key: string]: string } {
    return {
      granteeId: 'GranteeId',
      granteeName: 'GranteeName',
      granteeType: 'GranteeType',
      granteeTypeSub: 'GranteeTypeSub',
    };
  }

  static types(): { [key: string]: any } {
    return {
      granteeId: 'string',
      granteeName: 'string',
      granteeType: 'number',
      granteeTypeSub: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that was used to submit the permission request order.
   * 
   * @example
   * 267842600408993176
   */
  applyBaseId?: string;
  /**
   * @remarks
   * The time when the permission request order was submitted. The value is a UNIX timestamp.
   * 
   * @example
   * 1615284086000
   */
  applyTimestamp?: number;
  /**
   * @remarks
   * The list of Alibaba Cloud accounts that are used to process the permission request order.
   */
  approveAccountList?: GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList[];
  /**
   * @remarks
   * The content of the permission request.
   */
  approveContent?: GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent;
  /**
   * @remarks
   * The ID of the permission request order.
   * 
   * @example
   * ad8da78d-8135-455e-9486-27cf213fc140
   */
  flowId?: string;
  /**
   * @remarks
   * The status of the permission request order. Valid values:
   * 
   * *   1: to be processed
   * *   2: approved and authorized
   * *   3: approved but authorization failed
   * *   4: rejected
   * 
   * @example
   * 2
   */
  flowStatus?: number;
  /**
   * @remarks
   * The information about the account that is used to request permissions.
   */
  granteeObjectList?: GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList[];
  static names(): { [key: string]: string } {
    return {
      applyBaseId: 'ApplyBaseId',
      applyTimestamp: 'ApplyTimestamp',
      approveAccountList: 'ApproveAccountList',
      approveContent: 'ApproveContent',
      flowId: 'FlowId',
      flowStatus: 'FlowStatus',
      granteeObjectList: 'GranteeObjectList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyBaseId: 'string',
      applyTimestamp: 'number',
      approveAccountList: { 'type': 'array', 'itemType': GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList },
      approveContent: GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent,
      flowId: 'string',
      flowStatus: 'number',
      granteeObjectList: { 'type': 'array', 'itemType': GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectResponseBodyDataTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * Env
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * Test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * 0
   */
  appkey?: string;
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * false
   */
  baseProject?: boolean;
  /**
   * @remarks
   * The ID of the resource group that was allocated by default when you purchased an exclusive resource group for MaxCompute.
   * 
   * @example
   * group_280749521****
   */
  defaultDiResourceGroupIdentifier?: string;
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * 0
   */
  destination?: number;
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * 0
   */
  devStorageQuota?: string;
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * 4
   */
  developmentType?: number;
  /**
   * @remarks
   * Indicates whether the Develop role is disabled. Valid values:
   * 
   * *   **false** (default)
   * *   **true**
   * 
   * @example
   * true
   */
  disableDevelopment?: boolean;
  /**
   * @remarks
   * The environment information of the workspace.
   */
  envTypes?: string[];
  /**
   * @remarks
   * The time when the workspace was created. Example: `Dec 3, 2019 9:12:20 PM`.
   * 
   * @example
   * Oct 10, 2019 3:42:53 PM
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the workspace was last modified. Example: `Dec 3, 2019 9:12:20 PM`.
   * 
   * @example
   * Dec 3, 2019 9:12:20 PM
   */
  gmtModified?: string;
  /**
   * @remarks
   * Indicates whether you are allowed to download the query result from DataStudio. Valid values:
   * 
   * *   **1**: You are allowed to download the query result from DataStudio.
   * *   **0**: You are not allowed to download the query result from DataStudio.
   * 
   * @example
   * 1
   */
  isAllowDownload?: number;
  /**
   * @remarks
   * Indicates whether the workspace is a default workspace. Valid values:
   * 
   * *   **1**: The workspace is a default workspace.
   * *   **0**: The workspace is not a default workspace.
   * 
   * @example
   * 1
   */
  isDefault?: number;
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * 1
   */
  maxFlowNode?: number;
  /**
   * @remarks
   * This parameter is deprecated.
   * 
   * @example
   * 1
   */
  prodStorageQuota?: string;
  /**
   * @remarks
   * The description of the workspace.
   * 
   * @example
   * abc
   */
  projectDescription?: string;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * @example
   * 27
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the workspace.
   * 
   * @example
   * abc
   */
  projectIdentifier?: string;
  /**
   * @remarks
   * The mode of the workspace. Valid values:
   * 
   * *   **2**: The workspace is in basic mode.
   * *   **3**: The workspace is in standard mode.
   * 
   * @example
   * 2
   */
  projectMode?: number;
  /**
   * @remarks
   * The display name of the workspace.
   * 
   * @example
   * abc
   */
  projectName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the workspace owner.
   * 
   * @example
   * 18229311****
   */
  projectOwnerBaseId?: string;
  /**
   * @remarks
   * Indicates whether the workspace protection feature is enabled. Valid values:
   * 
   * *   **1**: enabled
   * *   **0**: disabled
   * 
   * @example
   * 1
   */
  protectedMode?: number;
  /**
   * @remarks
   * The type of the workspace. Valid values:
   * 
   * *   **private**
   * *   **swap**
   * 
   * @example
   * private
   */
  residentArea?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmzbn7pti3zfa
   */
  resourceManagerResourceGroupId?: string;
  /**
   * @remarks
   * The default maximum number of automatic reruns that are allowed after an error occurs.
   * 
   * @example
   * 3
   */
  schedulerMaxRetryTimes?: number;
  /**
   * @remarks
   * The default interval between automatic reruns after an error occurs. Unit: milliseconds. The maximum interval is 30 minutes. You must pay attention to the conversion between units.
   * 
   * @example
   * 120000
   */
  schedulerRetryInterval?: number;
  /**
   * @remarks
   * The status of the workspace. Valid values:
   * 
   * *   **0**: AVAILABLE, which indicates that the workspace runs as expected.
   * *   **1**: DELETED, which indicates that the workspace is deleted.
   * *   **2**: INITIALIZING, which indicates that the workspace is being initialized.
   * *   **3**: INIT_FAILED, which indicates that the workspace fails to be initialized.
   * *   **4**: FORBIDDEN, which indicates that the workspace is manually disabled.
   * *   **5**: DELETING, which indicates that the workspace is being deleted.
   * *   **6**: DEL_FAILED, which indicates that the workspace fails to be deleted.
   * *   **7**: FROZEN, which indicates that the workspace is frozen due to overdue payments.
   * *   **8**: UPDATING, which indicates that the workspace is being updated. The workspace enters this state after you associate a new compute engine with the workspace and the compute engine is initialized.
   * *   **9**: UPDATE_FAILED, which indicates that the workspace fails to be updated.
   * 
   * @example
   * 0
   */
  status?: number;
  /**
   * @remarks
   * Indicates whether the MaxCompute tables in the workspace are visible to the users within a tenant. Valid values:
   * 
   * *   **0**: invisible
   * *   **1**: visible
   * 
   * @example
   * 1
   */
  tablePrivacyMode?: number;
  /**
   * @remarks
   * The tags added to the workspace.
   */
  tags?: GetProjectResponseBodyDataTags[];
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 280749521
   */
  tenantId?: number;
  /**
   * @remarks
   * Indicates whether a proxy account is used to access the MaxCompute compute engine associated with the workspace.
   * 
   * @example
   * true
   */
  useProxyOdpsAccount?: boolean;
  static names(): { [key: string]: string } {
    return {
      appkey: 'Appkey',
      baseProject: 'BaseProject',
      defaultDiResourceGroupIdentifier: 'DefaultDiResourceGroupIdentifier',
      destination: 'Destination',
      devStorageQuota: 'DevStorageQuota',
      developmentType: 'DevelopmentType',
      disableDevelopment: 'DisableDevelopment',
      envTypes: 'EnvTypes',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      isAllowDownload: 'IsAllowDownload',
      isDefault: 'IsDefault',
      maxFlowNode: 'MaxFlowNode',
      prodStorageQuota: 'ProdStorageQuota',
      projectDescription: 'ProjectDescription',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
      projectMode: 'ProjectMode',
      projectName: 'ProjectName',
      projectOwnerBaseId: 'ProjectOwnerBaseId',
      protectedMode: 'ProtectedMode',
      residentArea: 'ResidentArea',
      resourceManagerResourceGroupId: 'ResourceManagerResourceGroupId',
      schedulerMaxRetryTimes: 'SchedulerMaxRetryTimes',
      schedulerRetryInterval: 'SchedulerRetryInterval',
      status: 'Status',
      tablePrivacyMode: 'TablePrivacyMode',
      tags: 'Tags',
      tenantId: 'TenantId',
      useProxyOdpsAccount: 'UseProxyOdpsAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appkey: 'string',
      baseProject: 'boolean',
      defaultDiResourceGroupIdentifier: 'string',
      destination: 'number',
      devStorageQuota: 'string',
      developmentType: 'number',
      disableDevelopment: 'boolean',
      envTypes: { 'type': 'array', 'itemType': 'string' },
      gmtCreate: 'string',
      gmtModified: 'string',
      isAllowDownload: 'number',
      isDefault: 'number',
      maxFlowNode: 'number',
      prodStorageQuota: 'string',
      projectDescription: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
      projectMode: 'number',
      projectName: 'string',
      projectOwnerBaseId: 'string',
      protectedMode: 'number',
      residentArea: 'string',
      resourceManagerResourceGroupId: 'string',
      schedulerMaxRetryTimes: 'number',
      schedulerRetryInterval: 'number',
      status: 'number',
      tablePrivacyMode: 'number',
      tags: { 'type': 'array', 'itemType': GetProjectResponseBodyDataTags },
      tenantId: 'number',
      useProxyOdpsAccount: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectDetailResponseBodyDataTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * Env
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * Test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetProjectDetailResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The identifier of the shared resource group for Data Integration on which nodes are run.
   * 
   * @example
   * group_280749521****
   */
  defaultDiResourceGroupIdentifier?: string;
  /**
   * @remarks
   * The development type of the workspace. The value is fixed to 4.
   * 
   * @example
   * 4
   */
  developmentType?: number;
  /**
   * @remarks
   * Indicates whether the Develop role is disabled. Valid values:
   * 
   * *   **false** (default)
   * *   **true**
   * 
   * @example
   * true
   */
  disableDevelopment?: boolean;
  /**
   * @remarks
   * The environments of workspaces in different modes. Workspaces in basic mode provide only the production environment. Workspaces in standard mode provide both the development environment and the production environment.
   */
  envTypes?: string[];
  /**
   * @remarks
   * The time when the workspace was created.
   * 
   * @example
   * Oct 10, 2019 3:42:53 PM
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the workspace was last modified.
   * 
   * @example
   * Dec 3, 2019 9:12:20 PM
   */
  gmtModified?: string;
  /**
   * @remarks
   * Indicates whether the download operation is allowed.
   * 
   * @example
   * 1
   */
  isAllowDownload?: number;
  /**
   * @remarks
   * Indicates whether the workspace is a default workspace. Valid values:
   * 
   * *   1: The workspace is a default workspace.
   * *   0: The workspace is not a default workspace.
   * 
   * @example
   * 1
   */
  isDefault?: number;
  /**
   * @remarks
   * The description of the workspace.
   * 
   * @example
   * abc
   */
  projectDescription?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 27
   */
  projectId?: number;
  /**
   * @remarks
   * The unique identifier of the workspace.
   * 
   * @example
   * abc
   */
  projectIdentifier?: string;
  /**
   * @remarks
   * The mode of the workspace. The value 2 indicates that the workspace is in basic mode. The value 3 indicates that the workspace is in standard mode.
   * 
   * @example
   * 1
   */
  projectMode?: number;
  /**
   * @remarks
   * The display name of the workspace.
   * 
   * @example
   * abc
   */
  projectName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the workspace owner.
   * 
   * @example
   * 18229311****
   */
  projectOwnerBaseId?: string;
  /**
   * @remarks
   * Indicates whether the workspace protection feature is enabled.
   * 
   * @example
   * 1
   */
  protectedMode?: number;
  /**
   * @remarks
   * The type of the workspace. Valid values: private and swap.
   * 
   * @example
   * private
   */
  residentArea?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmzbn7pti3zfa
   */
  resourceManagerResourceGroupId?: string;
  /**
   * @remarks
   * The default maximum number of automatic reruns that are allowed after an error occurs.
   * 
   * @example
   * 3
   */
  schedulerMaxRetryTimes?: number;
  /**
   * @remarks
   * The interval between automatic reruns after an error occurs.
   * 
   * @example
   * 120000
   */
  schedulerRetryInterval?: number;
  /**
   * @remarks
   * The status of the workspace.
   * 
   * @example
   * 0
   */
  status?: number;
  /**
   * @remarks
   * Indicates whether the MaxCompute tables in the workspace are visible to the users within a tenant. Valid values:
   * 
   * *   0: The MaxCompute tables in the workspace are not visible to the users within a tenant.
   * *   1: The MaxCompute tables in the workspace are visible to the users within a tenant.
   * 
   * @example
   * 1
   */
  tablePrivacyMode?: number;
  /**
   * @remarks
   * The tag information.
   */
  tags?: GetProjectDetailResponseBodyDataTags[];
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 280749521950784
   */
  tenantId?: number;
  /**
   * @remarks
   * Indicates whether a proxy account is used to access the MaxCompute compute engine.
   * 
   * @example
   * true
   */
  useProxyOdpsAccount?: boolean;
  static names(): { [key: string]: string } {
    return {
      defaultDiResourceGroupIdentifier: 'DefaultDiResourceGroupIdentifier',
      developmentType: 'DevelopmentType',
      disableDevelopment: 'DisableDevelopment',
      envTypes: 'EnvTypes',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      isAllowDownload: 'IsAllowDownload',
      isDefault: 'IsDefault',
      projectDescription: 'ProjectDescription',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
      projectMode: 'ProjectMode',
      projectName: 'ProjectName',
      projectOwnerBaseId: 'ProjectOwnerBaseId',
      protectedMode: 'ProtectedMode',
      residentArea: 'ResidentArea',
      resourceManagerResourceGroupId: 'ResourceManagerResourceGroupId',
      schedulerMaxRetryTimes: 'SchedulerMaxRetryTimes',
      schedulerRetryInterval: 'SchedulerRetryInterval',
      status: 'Status',
      tablePrivacyMode: 'TablePrivacyMode',
      tags: 'Tags',
      tenantId: 'TenantId',
      useProxyOdpsAccount: 'UseProxyOdpsAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultDiResourceGroupIdentifier: 'string',
      developmentType: 'number',
      disableDevelopment: 'boolean',
      envTypes: { 'type': 'array', 'itemType': 'string' },
      gmtCreate: 'string',
      gmtModified: 'string',
      isAllowDownload: 'number',
      isDefault: 'number',
      projectDescription: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
      projectMode: 'number',
      projectName: 'string',
      projectOwnerBaseId: 'string',
      protectedMode: 'number',
      residentArea: 'string',
      resourceManagerResourceGroupId: 'string',
      schedulerMaxRetryTimes: 'number',
      schedulerRetryInterval: 'number',
      status: 'number',
      tablePrivacyMode: 'number',
      tags: { 'type': 'array', 'itemType': GetProjectDetailResponseBodyDataTags },
      tenantId: 'number',
      useProxyOdpsAccount: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQualityEntityResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The time when the partition filter expression was created.
   * 
   * @example
   * 1593964800000
   */
  createTime?: number;
  /**
   * @remarks
   * The level of the partition filter expression. Valid values:
   * 
   * *   0: The partition filter expression is at the SQL level. This indicates that the system checks data quality after each SQL statement is executed.
   * *   1: The partition filter expression is at the node level. This indicates that the system checks data quality after all the SQL statements for a node are executed.
   * 
   * @example
   * 0
   */
  entityLevel?: number;
  /**
   * @remarks
   * The type of the compute engine instance or data source.
   * 
   * @example
   * odps
   */
  envType?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to receive alert notifications.
   * 
   * @example
   * 1822931****
   */
  followers?: string;
  /**
   * @remarks
   * Indicates whether the partition filter expression is associated with a node. Valid values:
   * 
   * *   true: The partition filter expression is associated with a node.
   * *   false: The partition filter expression is not associated with a node.
   * 
   * @example
   * true
   */
  hasRelativeNode?: boolean;
  /**
   * @remarks
   * The ID of the partition filter expression.
   * 
   * @example
   * 4003918
   */
  id?: number;
  /**
   * @remarks
   * The partition filter expression.
   * 
   * @example
   * dt=$[yyyymmdd-1]
   */
  matchExpression?: string;
  /**
   * @remarks
   * The time when the partition filter expression was modified.
   * 
   * @example
   * 1593964800000
   */
  modifyTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to modify the partition filter expression.
   * 
   * @example
   * 1822931****
   */
  modifyUser?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to configure the partition filter expression.
   * 
   * @example
   * 1822931****
   */
  onDuty?: string;
  /**
   * @remarks
   * The name of the Alibaba Cloud account that is used to configure the partition filter expression.
   * 
   * @example
   * test
   */
  onDutyAccountName?: string;
  /**
   * @remarks
   * The name of the compute engine instance or data source.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The information about the node with which the partition filter expression is associated. The information includes the following items:
   * 
   * *   ProjectName: the name of the workspace to which the node belongs.
   * *   NodeID: the ID of the node.
   * 
   * @example
   * [{"projectName":"xc_DP****","nodeId":7000026****}]
   */
  relativeNode?: string;
  /**
   * @remarks
   * Indicates that the partition filter expression is at the SQL level.
   * 
   * @example
   * 0
   */
  sql?: number;
  /**
   * @remarks
   * The name of the partitioned table.
   * 
   * @example
   * test_dqc_de****
   */
  tableName?: string;
  /**
   * @remarks
   * The node.
   * 
   * @example
   * 0
   */
  task?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      entityLevel: 'EntityLevel',
      envType: 'EnvType',
      followers: 'Followers',
      hasRelativeNode: 'HasRelativeNode',
      id: 'Id',
      matchExpression: 'MatchExpression',
      modifyTime: 'ModifyTime',
      modifyUser: 'ModifyUser',
      onDuty: 'OnDuty',
      onDutyAccountName: 'OnDutyAccountName',
      projectName: 'ProjectName',
      relativeNode: 'RelativeNode',
      sql: 'Sql',
      tableName: 'TableName',
      task: 'Task',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      entityLevel: 'number',
      envType: 'string',
      followers: 'string',
      hasRelativeNode: 'boolean',
      id: 'number',
      matchExpression: 'string',
      modifyTime: 'number',
      modifyUser: 'string',
      onDuty: 'string',
      onDutyAccountName: 'string',
      projectName: 'string',
      relativeNode: 'string',
      sql: 'number',
      tableName: 'string',
      task: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQualityFollowerResponseBodyData extends $tea.Model {
  /**
   * @example
   * 1
   */
  alarmMode?: number;
  createTime?: number;
  /**
   * @example
   * 1234
   */
  entityId?: string;
  /**
   * @example
   * 1234
   */
  follower?: string;
  /**
   * @example
   * test
   */
  followerAccountName?: string;
  /**
   * @example
   * 123
   */
  id?: number;
  modifyTime?: number;
  /**
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @example
   * dual
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      alarmMode: 'AlarmMode',
      createTime: 'CreateTime',
      entityId: 'EntityId',
      follower: 'Follower',
      followerAccountName: 'FollowerAccountName',
      id: 'Id',
      modifyTime: 'ModifyTime',
      projectName: 'ProjectName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmMode: 'number',
      createTime: 'number',
      entityId: 'string',
      follower: 'string',
      followerAccountName: 'string',
      id: 'number',
      modifyTime: 'number',
      projectName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetQualityRuleResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The strength of the monitoring rule. The strength of a monitoring rule indicates the importance of the rule. Valid values:
   * 
   * *   1: the monitoring rule is a strong rule.
   * *   0: the monitoring rule is a weak rule. You can specify whether a monitoring rule is a strong rule based on your business requirements. If a monitoring rule is a strong rule and the critical threshold is exceeded, a critical alert is reported and tasks that are associated with the rule are blocked from running.
   * 
   * @example
   * 1
   */
  blockType?: number;
  /**
   * @remarks
   * The checker ID. The value of this parameter corresponds to the ID at the frontend and is converted from the ID of the primary key.
   * 
   * @example
   * 9
   */
  checker?: number;
  /**
   * @remarks
   * The name of the checker.
   * 
   * @example
   * compared with a fixed value
   */
  checkerName?: string;
  /**
   * @remarks
   * The description of the monitoring rule.
   */
  comment?: string;
  /**
   * @remarks
   * The threshold for a critical alert. The threshold indicates the deviation of the check result from the expected value. You can specify a value for the threshold based on your business requirements. If a monitoring rule is a strong rule and the critical threshold is exceeded, a critical alert is reported and tasks that are associated with the rule are blocked from running.
   * 
   * @example
   * 20
   */
  criticalThreshold?: string;
  /**
   * @remarks
   * The ID of the partition filter expression.
   * 
   * @example
   * 165523
   */
  entityId?: number;
  /**
   * @remarks
   * The expected value.
   * 
   * @example
   * 30
   */
  expectValue?: string;
  /**
   * @remarks
   * Indicates whether the monitoring is performed based on a fixed value.
   * 
   * @example
   * true
   */
  fixCheck?: boolean;
  /**
   * @remarks
   * The monitoring rule ID.
   * 
   * @example
   * 123232
   */
  id?: number;
  /**
   * @remarks
   * The ID of the task that is associated with the partition filter expression.
   * 
   * @example
   * 8
   */
  methodId?: number;
  /**
   * @remarks
   * The method that is used to collect sample data, such as avg, count, sum, min, max, count_distinct, user_defined, table_count, table_size, table_dt_load_count, table_dt_refuseload_count, null_value, null_value/table_count, (table_count-count_distinct)/table_count, or table_count-count_distinct.
   * 
   * @example
   * table_count
   */
  methodName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to configure the monitoring rule.
   * 
   * @example
   * 1822931****
   */
  onDuty?: string;
  /**
   * @remarks
   * The name of the Alibaba Cloud account that is used to configure the monitoring rule.
   * 
   * @example
   * test
   */
  onDutyAccountName?: string;
  /**
   * @remarks
   * Indicates whether the monitoring rule is enabled.
   * 
   * @example
   * true
   */
  openSwitch?: boolean;
  /**
   * @remarks
   * The comparison operator of the monitoring rule.
   * 
   * @example
   * >=
   */
  operator?: string;
  /**
   * @remarks
   * Indicates whether the threshold is a dynamic threshold. Valid values:
   * 
   * *   0: The threshold is not a dynamic threshold.
   * *   1: The threshold is a dynamic threshold.
   * 
   * @example
   * 0
   */
  predictType?: number;
  /**
   * @remarks
   * The field whose data quality is checked based on the monitoring rule. This field is a column in the data source table that is monitored.
   * 
   * @example
   * id
   */
  property?: string;
  /**
   * @remarks
   * The name of the monitoring rule.
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the monitoring rule.
   * 
   * @example
   * 0
   */
  ruleType?: number;
  taskSetting?: string;
  /**
   * @remarks
   * The ID of the monitoring template.
   * 
   * @example
   * 7
   */
  templateId?: number;
  /**
   * @remarks
   * The name of the monitoring template.
   * 
   * @example
   * SQL task table rows, 1,7, 30 days fluctuation test
   */
  templateName?: string;
  /**
   * @remarks
   * The trend of the check result.
   * 
   * @example
   * abs
   */
  trend?: string;
  /**
   * @remarks
   * The threshold for a warning alert. The threshold indicates the deviation of the check result from the expected value. You can customize this threshold based on your business requirements.
   * 
   * @example
   * 10
   */
  warningThreshold?: string;
  /**
   * @remarks
   * The filter condition or custom SQL statement that is used for monitoring.
   * 
   * @example
   * id>10
   */
  whereCondition?: string;
  static names(): { [key: string]: string } {
    return {
      blockType: 'BlockType',
      checker: 'Checker',
      checkerName: 'CheckerName',
      comment: 'Comment',
      criticalThreshold: 'CriticalThreshold',
      entityId: 'EntityId',
      expectValue: 'ExpectValue',
      fixCheck: 'FixCheck',
      id: 'Id',
      methodId: 'MethodId',
      methodName: 'MethodName',
      onDuty: 'OnDuty',
      onDutyAccountName: 'OnDutyAccountName',
      openSwitch: 'OpenSwitch',
      operator: 'Operator',
      predictType: 'PredictType',
      property: 'Property',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      taskSetting: 'TaskSetting',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
      trend: 'Trend',
      warningThreshold: 'WarningThreshold',
      whereCondition: 'WhereCondition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockType: 'number',
      checker: 'number',
      checkerName: 'string',
      comment: 'string',
      criticalThreshold: 'string',
      entityId: 'number',
      expectValue: 'string',
      fixCheck: 'boolean',
      id: 'number',
      methodId: 'number',
      methodName: 'string',
      onDuty: 'string',
      onDutyAccountName: 'string',
      openSwitch: 'boolean',
      operator: 'string',
      predictType: 'number',
      property: 'string',
      ruleName: 'string',
      ruleType: 'number',
      taskSetting: 'string',
      templateId: 'number',
      templateName: 'string',
      trend: 'string',
      warningThreshold: 'string',
      whereCondition: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRemindResponseBodyDataBaselines extends $tea.Model {
  /**
   * @remarks
   * The baseline ID.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  /**
   * @remarks
   * The name of the baseline.
   */
  baselineName?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      baselineName: 'BaselineName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      baselineName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRemindResponseBodyDataBizProcesses extends $tea.Model {
  /**
   * @remarks
   * The workflow ID.
   * 
   * @example
   * 9527
   */
  bizId?: number;
  /**
   * @remarks
   * The name of the workflow.
   */
  bizProcessName?: string;
  static names(): { [key: string]: string } {
    return {
      bizId: 'BizId',
      bizProcessName: 'BizProcessName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizId: 'number',
      bizProcessName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRemindResponseBodyDataNodes extends $tea.Model {
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 9527951795****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      owner: 'Owner',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      nodeName: 'string',
      owner: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRemindResponseBodyDataProjects extends $tea.Model {
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRemindResponseBodyDataReceivers extends $tea.Model {
  alertTargets?: string[];
  alertUnit?: string;
  static names(): { [key: string]: string } {
    return {
      alertTargets: 'AlertTargets',
      alertUnit: 'AlertUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertTargets: { 'type': 'array', 'itemType': 'string' },
      alertUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRemindResponseBodyDataRobots extends $tea.Model {
  /**
   * @remarks
   * Indicates whether all group members are notified when the alert notification is sent to a DingTalk group. Valid values: true and false.
   * 
   * @example
   * true
   */
  atAll?: boolean;
  /**
   * @remarks
   * The webhook URL of the DingTalk chatbot.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=******************************
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      atAll: 'AtAll',
      webUrl: 'WebUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      atAll: 'boolean',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRemindResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The minimum interval at which alerts are reported. Unit: seconds.
   * 
   * @example
   * 1800
   */
  alertInterval?: number;
  alertMethods?: string[];
  alertTargets?: string[];
  /**
   * @remarks
   * The recipient of the alert. Valid values: OWNER and OTHER. The value OWNER indicates the node owner. The value OTHER indicates a specified user.
   * 
   * @example
   * OWNER
   */
  alertUnit?: string;
  allowNodes?: number[];
  /**
   * @remarks
   * The baselines to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is BASELINE.
   */
  baselines?: GetRemindResponseBodyDataBaselines[];
  /**
   * @remarks
   * The workflows to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is BIZPROCESS.
   */
  bizProcesses?: GetRemindResponseBodyDataBizProcesses[];
  /**
   * @remarks
   * *   If the value of the RemindType parameter is FINISHED, this parameter is left empty.
   * *   If the value of the RemindType parameter is UNFINISHED, the trigger conditions are returned as key-value pairs. Example: {"hour":23,"minu":59}. Valid values of hour: [0,47]. Valid values of minu: [0,59].
   * *   If the value of the RemindType parameter is ERROR, this parameter is left empty.
   * *   If the value of the RemindType parameter is CYCLE_UNFINISHED, the trigger conditions are returned as key-value pairs. Example: {"1":"05:50","2":"06:50","3":"07:50","4":"08:50","5":"09:50","6":"10:50","7":"11:50","8":"12:50","9":"13:50","10":"14:50","11":"15:50","12":"16:50","13":"17:50","14":"18:50","15":"19:50","16":"20:50","17":"21:50","18":"22:50","19":"23:50","20":"24:50","21":"25:50"}. The key indicates the ID of the cycle. Valid values: [1,288]. The value indicates the timeout period of the node that is running in the cycle. Specify the value in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
   * *   If the value of the RemindType parameter is TIMEOUT, the timeout period is returned. Unit: seconds. Example: 1800. This value indicates that an alert is reported if the node has run for more than 30 minutes.
   * 
   * @example
   * {"hour":23,"minu":59}
   */
  detail?: string;
  /**
   * @remarks
   * The end time of the quiet hours. The value is in the hh:mm format. Valid values of hh: [0,23]. Valid values of mm: [0,59].
   * 
   * @example
   * 08:00
   */
  dndEnd?: string;
  /**
   * @remarks
   * The start time of the quiet hours. The value is in the hh:mm format. Valid values of hh: [0,23]. Valid values of mm: [0,59].
   * 
   * @example
   * 00:00
   */
  dndStart?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the creator of the custom alert rule.
   * 
   * @example
   * 9527951795****
   */
  founder?: string;
  /**
   * @remarks
   * The maximum number of alerts.
   * 
   * @example
   * 3
   */
  maxAlertTimes?: number;
  /**
   * @remarks
   * The nodes to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is NODE.
   */
  nodes?: GetRemindResponseBodyDataNodes[];
  /**
   * @remarks
   * The workspaces to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is PROJECT.
   */
  projects?: GetRemindResponseBodyDataProjects[];
  receivers?: GetRemindResponseBodyDataReceivers[];
  /**
   * @remarks
   * The custom alert rule ID.
   * 
   * @example
   * 1234
   */
  remindId?: number;
  /**
   * @remarks
   * The name of the rule.
   */
  remindName?: string;
  /**
   * @remarks
   * The conditions that trigger an alert. Valid values: FINISHED, UNFINISHED, ERROR, CYCLE_UNFINISHED, and TIMEOUT.
   * 
   * @example
   * FINISHED
   */
  remindType?: string;
  /**
   * @remarks
   * The type of the object to which the custom alert rule is applied. Valid values: NODE, BASELINE, PROJECT, and BIZPROCESS. The value NODE indicates a node. The value BASELINE indicates a baseline. The value PROJECT indicates a workspace. The value BIZPROCESS indicates a workflow.
   * 
   * @example
   * NODE
   */
  remindUnit?: string;
  /**
   * @remarks
   * The webhook URLs of the DingTalk chatbots.
   */
  robots?: GetRemindResponseBodyDataRobots[];
  /**
   * @remarks
   * Indicates whether the custom alert rule is enabled. Valid values: true and false.
   * 
   * @example
   * true
   */
  useflag?: boolean;
  webhooks?: string[];
  static names(): { [key: string]: string } {
    return {
      alertInterval: 'AlertInterval',
      alertMethods: 'AlertMethods',
      alertTargets: 'AlertTargets',
      alertUnit: 'AlertUnit',
      allowNodes: 'AllowNodes',
      baselines: 'Baselines',
      bizProcesses: 'BizProcesses',
      detail: 'Detail',
      dndEnd: 'DndEnd',
      dndStart: 'DndStart',
      founder: 'Founder',
      maxAlertTimes: 'MaxAlertTimes',
      nodes: 'Nodes',
      projects: 'Projects',
      receivers: 'Receivers',
      remindId: 'RemindId',
      remindName: 'RemindName',
      remindType: 'RemindType',
      remindUnit: 'RemindUnit',
      robots: 'Robots',
      useflag: 'Useflag',
      webhooks: 'Webhooks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertInterval: 'number',
      alertMethods: { 'type': 'array', 'itemType': 'string' },
      alertTargets: { 'type': 'array', 'itemType': 'string' },
      alertUnit: 'string',
      allowNodes: { 'type': 'array', 'itemType': 'number' },
      baselines: { 'type': 'array', 'itemType': GetRemindResponseBodyDataBaselines },
      bizProcesses: { 'type': 'array', 'itemType': GetRemindResponseBodyDataBizProcesses },
      detail: 'string',
      dndEnd: 'string',
      dndStart: 'string',
      founder: 'string',
      maxAlertTimes: 'number',
      nodes: { 'type': 'array', 'itemType': GetRemindResponseBodyDataNodes },
      projects: { 'type': 'array', 'itemType': GetRemindResponseBodyDataProjects },
      receivers: { 'type': 'array', 'itemType': GetRemindResponseBodyDataReceivers },
      remindId: 'number',
      remindName: 'string',
      remindType: 'string',
      remindUnit: 'string',
      robots: { 'type': 'array', 'itemType': GetRemindResponseBodyDataRobots },
      useflag: 'boolean',
      webhooks: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend extends $tea.Model {
  /**
   * @remarks
   * The number of instances.
   * 
   * @example
   * 10
   */
  count?: number;
  /**
   * @remarks
   * The point in time. Valid values: 00:00 to 23:00.
   * 
   * @example
   * 01:00
   */
  timePoint?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      timePoint: 'TimePoint',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      timePoint: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend extends $tea.Model {
  /**
   * @remarks
   * The number of instances.
   * 
   * @example
   * 10
   */
  count?: number;
  /**
   * @remarks
   * The point in time. Valid values: 00:00 to 23:00.
   * 
   * @example
   * 01:00
   */
  timePoint?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      timePoint: 'TimePoint',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      timePoint: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend extends $tea.Model {
  /**
   * @remarks
   * The number of instances.
   * 
   * @example
   * 10
   */
  count?: number;
  /**
   * @remarks
   * The point in time. Valid values: 00:00 to 23:00.
   * 
   * @example
   * 01:00
   */
  timePoint?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      timePoint: 'TimePoint',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      timePoint: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSuccessInstanceTrendResponseBodyInstanceStatusTrend extends $tea.Model {
  /**
   * @remarks
   * The average trend.
   */
  avgTrend?: GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend[];
  /**
   * @remarks
   * The trend on the current day.
   */
  todayTrend?: GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend[];
  /**
   * @remarks
   * The trend on the previous day.
   */
  yesterdayTrend?: GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend[];
  static names(): { [key: string]: string } {
    return {
      avgTrend: 'AvgTrend',
      todayTrend: 'TodayTrend',
      yesterdayTrend: 'YesterdayTrend',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgTrend: { 'type': 'array', 'itemType': GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend },
      todayTrend: { 'type': 'array', 'itemType': GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend },
      yesterdayTrend: { 'type': 'array', 'itemType': GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTopicResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The timestamp when the event was found.
   * 
   * @example
   * 1553524393000
   */
  addTime?: number;
  /**
   * @remarks
   * The timestamp when the first alert was reported.
   * 
   * @example
   * 1553524393000
   */
  alertTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the alert recipient.
   * 
   * @example
   * 952795****
   */
  assigner?: string;
  /**
   * @remarks
   * The margin of the worst baseline instance. Unit: seconds.
   * 
   * @example
   * 3600
   */
  baselineBuffer?: number;
  /**
   * @remarks
   * The ID of the baseline to which the worst baseline instance belongs.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  /**
   * @remarks
   * The ID of the cycle of the worst baseline instance.
   * 
   * @example
   * 1
   */
  baselineInGroupId?: number;
  /**
   * @remarks
   * The name of the baseline to which the worst baseline instance belongs.
   */
  baselineName?: string;
  /**
   * @remarks
   * The status of the baseline. Valid values: ERROR, SAFE, DANGROUS, and OVER. The value ERROR indicates that no nodes are associated with the baseline, or all nodes associated with the baseline are suspended. The value SAFE indicates that nodes are run before the alert duration begins. The value DANGROUS indicates that nodes are still running after the alert duration ends but the committed completion time does not arrive. The value OVER indicates that nodes are still running after the committed completion time.
   * 
   * @example
   * SAFE
   */
  baselineStatus?: string;
  /**
   * @remarks
   * The margin of the event. Unit: seconds.
   * 
   * @example
   * 1200
   */
  buffer?: number;
  /**
   * @remarks
   * The timestamp when the event was last processed.
   * 
   * @example
   * 1553524393000
   */
  dealTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the user who last processed the event.
   * 
   * @example
   * 952795****
   */
  dealUser?: string;
  /**
   * @remarks
   * The timestamp when the event was processed.
   * 
   * @example
   * 1553524393000
   */
  fixTime?: number;
  /**
   * @remarks
   * The timestamp when the event occurred. A time difference may exist between the time when the event occurred and the time when the event was found.
   * 
   * @example
   * 1553524393000
   */
  happenTime?: number;
  /**
   * @remarks
   * The ID of the instance that triggered the event.
   * 
   * @example
   * 12345
   */
  instanceId?: number;
  /**
   * @remarks
   * The timestamp when the system reports the next alert.
   * 
   * @example
   * 1553524393000
   */
  nextAlertTime?: number;
  /**
   * @remarks
   * The ID of the node that triggered the event.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node that triggered the event.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the event owner.
   * 
   * @example
   * 952795****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node that triggered the event belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The event ID.
   * 
   * @example
   * 1234
   */
  topicId?: number;
  /**
   * @remarks
   * The name of the event.
   */
  topicName?: string;
  /**
   * @remarks
   * The status of the event. Valid values: IGNORE, NEW, FIXING, and RECOVER.
   * 
   * @example
   * FIXING
   */
  topicStatus?: string;
  /**
   * @remarks
   * The type of the event. Valid values: SLOW and ERROR. The value SLOW indicates that the duration of the task is significantly longer than the average duration of the task in previous cycles. The value ERROR indicates that the task fails to run.
   * 
   * @example
   * ERROR
   */
  topicType?: string;
  static names(): { [key: string]: string } {
    return {
      addTime: 'AddTime',
      alertTime: 'AlertTime',
      assigner: 'Assigner',
      baselineBuffer: 'BaselineBuffer',
      baselineId: 'BaselineId',
      baselineInGroupId: 'BaselineInGroupId',
      baselineName: 'BaselineName',
      baselineStatus: 'BaselineStatus',
      buffer: 'Buffer',
      dealTime: 'DealTime',
      dealUser: 'DealUser',
      fixTime: 'FixTime',
      happenTime: 'HappenTime',
      instanceId: 'InstanceId',
      nextAlertTime: 'NextAlertTime',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      owner: 'Owner',
      projectId: 'ProjectId',
      topicId: 'TopicId',
      topicName: 'TopicName',
      topicStatus: 'TopicStatus',
      topicType: 'TopicType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addTime: 'number',
      alertTime: 'number',
      assigner: 'string',
      baselineBuffer: 'number',
      baselineId: 'number',
      baselineInGroupId: 'number',
      baselineName: 'string',
      baselineStatus: 'string',
      buffer: 'number',
      dealTime: 'number',
      dealUser: 'string',
      fixTime: 'number',
      happenTime: 'number',
      instanceId: 'number',
      nextAlertTime: 'number',
      nodeId: 'number',
      nodeName: 'string',
      owner: 'string',
      projectId: 'number',
      topicId: 'number',
      topicName: 'string',
      topicStatus: 'string',
      topicType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTopicInfluenceResponseBodyDataInfluences extends $tea.Model {
  /**
   * @example
   * 1234
   */
  baselineId?: number;
  baselineName?: string;
  /**
   * @example
   * 1553356800000
   */
  bizdate?: number;
  /**
   * @example
   * 360
   */
  buffer?: number;
  /**
   * @example
   * 1
   */
  inGroupId?: number;
  /**
   * @example
   * 952795****
   */
  owner?: string;
  /**
   * @example
   * 1
   */
  priority?: number;
  /**
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @example
   * SAFE
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      baselineName: 'BaselineName',
      bizdate: 'Bizdate',
      buffer: 'Buffer',
      inGroupId: 'InGroupId',
      owner: 'Owner',
      priority: 'Priority',
      projectId: 'ProjectId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      baselineName: 'string',
      bizdate: 'number',
      buffer: 'number',
      inGroupId: 'number',
      owner: 'string',
      priority: 'number',
      projectId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTopicInfluenceResponseBodyData extends $tea.Model {
  influences?: GetTopicInfluenceResponseBodyDataInfluences[];
  /**
   * @example
   * 1234
   */
  topicId?: number;
  static names(): { [key: string]: string } {
    return {
      influences: 'Influences',
      topicId: 'TopicId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      influences: { 'type': 'array', 'itemType': GetTopicInfluenceResponseBodyDataInfluences },
      topicId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ImportDataSourcesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The reason why the data sources failed to be imported. If the data sources were imported, this parameter is left empty.
   * 
   * @example
   * Data source DEV XXX already exists
   */
  message?: string;
  /**
   * @remarks
   * Indicates whether the data sources were imported. Valid values:
   * 
   * *   true: All data sources were imported.
   * *   false: Specific data sources failed to be imported. You can troubleshoot issues based on the Message parameter.
   * 
   * @example
   * true
   */
  status?: boolean;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      status: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertMessagesResponseBodyDataAlertMessagesInstances extends $tea.Model {
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * 12345
   */
  instanceId?: number;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The status of the instance. Valid values: NOT_RUN, WAIT_TIME, WAIT_RESOURCE, RUNNING, CHECKING, CHECKING_CONDITION, FAILURE, and SUCCESS. The value NOT_RUN indicates that the instance is not run. The value WAIT_TIME indicates that the instance is waiting to be run. The value WAIT_RESOURCE indicates that the instance is waiting for resources. The value RUNNING indicates that the instance is running. The value CHECKING indicates that data quality is being checked for the node for which the instance is generated. The value CHECKING_CONDITION indicates that branch conditions are being checked for the node for which the instance is generated. The value FAILURE indicates that the instance fails to run. The value SUCCESS indicates that the instance is successfully run.
   * 
   * @example
   * NOT_RUN
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      projectId: 'ProjectId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      nodeId: 'number',
      nodeName: 'string',
      projectId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertMessagesResponseBodyDataAlertMessagesNodes extends $tea.Model {
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 95279527952****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      owner: 'Owner',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      nodeName: 'string',
      owner: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert extends $tea.Model {
  /**
   * @remarks
   * The baseline ID.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  /**
   * @remarks
   * The name of the baseline.
   */
  baselineName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the baseline owner. Multiple IDs are separated by commas (,).
   * 
   * @example
   * 952795279****
   */
  baselineOwner?: string;
  /**
   * @remarks
   * The data timestamp of the baseline instance.
   * 
   * @example
   * 1553443200000
   */
  bizdate?: number;
  /**
   * @remarks
   * The ID of the cycle of the baseline instance. Valid values of the ID of an hour-level cycle: [1,24]. The ID of a day-level cycle is 1.
   * 
   * @example
   * 1
   */
  inGroupId?: number;
  /**
   * @remarks
   * The ID of the workspace to which the baseline belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The status of the baseline. Valid values: ERROR, SAFE, DANGEROUS, and OVER. The value ERROR indicates that no nodes are associated with the baseline, or all nodes associated with the baseline are suspended. The value SAFE indicates that nodes are run before the alert duration begins. The value DANGEROUS indicates that nodes are still running after the alert duration ends but the committed completion time does not arrive. The value OVER indicates that nodes are still running after the committed completion time.
   * 
   * @example
   * SAFE
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      baselineName: 'BaselineName',
      baselineOwner: 'BaselineOwner',
      bizdate: 'Bizdate',
      inGroupId: 'InGroupId',
      projectId: 'ProjectId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      baselineName: 'string',
      baselineOwner: 'string',
      bizdate: 'number',
      inGroupId: 'number',
      projectId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertMessagesResponseBodyDataAlertMessagesTopics extends $tea.Model {
  /**
   * @remarks
   * The ID of the instance that triggered the event.
   * 
   * @example
   * 12345
   */
  instanceId?: number;
  /**
   * @remarks
   * The ID of the node that triggered the event.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The event ID.
   * 
   * @example
   * 1234
   */
  topicId?: number;
  /**
   * @remarks
   * The name of the event.
   */
  topicName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the event owner.
   * 
   * @example
   * 9527952795****
   */
  topicOwner?: string;
  /**
   * @remarks
   * The status of the event. Valid values: IGNORE, NEW, FIXING, and RECOVER. The value IGNORE indicates that the event is ignored. The value NEW indicates that the event is a new event. The value FIXING indicates that the event is being handled. The value RECOVER indicates that the event is handled.
   * 
   * @example
   * FIXING
   */
  topicStatus?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      nodeId: 'NodeId',
      topicId: 'TopicId',
      topicName: 'TopicName',
      topicOwner: 'TopicOwner',
      topicStatus: 'TopicStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'number',
      nodeId: 'number',
      topicId: 'number',
      topicName: 'string',
      topicOwner: 'string',
      topicStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertMessagesResponseBodyDataAlertMessages extends $tea.Model {
  /**
   * @remarks
   * The alert ID.
   * 
   * @example
   * 1234
   */
  alertId?: number;
  /**
   * @remarks
   * The sending status of the notification. Valid values: READY_TO_SEND, SEND_FAIL, SEND_SUCCESS, and SEND_OVERLIMIT. The value READY_TO_SEND indicates that the notification is waiting to be sent. The value SEND_FAIL indicates that the notification fails to be sent. The value SEND_SUCCESS indicates that the notification is sent. The value SEND_OVERLIMIT indicates that the number of notifications that are sent exceeds the upper limit.
   * 
   * @example
   * READY_TO_SEND
   */
  alertMessageStatus?: string;
  /**
   * @remarks
   * The notification method. Valid values: MAIL, SMS, and PHONE. Only DataWorks Professional Edition and more advanced editions support the PHONE notification method.
   * 
   * @example
   * SMS
   */
  alertMethod?: string;
  /**
   * @remarks
   * The timestamp when the alert was reported.
   * 
   * @example
   * 1553531401000
   */
  alertTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud used by the alert recipient.
   * 
   * @example
   * 9527952795****
   */
  alertUser?: string;
  /**
   * @remarks
   * The content of the alert.
   */
  content?: string;
  /**
   * @remarks
   * The instances that triggered the custom alert rule. This parameter is returned if the value of the Source parameter is REMIND_ALERT. This parameter is left empty if the value of the Source parameter is not REMIND_ALERT.
   */
  instances?: ListAlertMessagesResponseBodyDataAlertMessagesInstances[];
  /**
   * @remarks
   * The nodes returned for different alert sources.
   * 
   * *   The nodes that form a loop are returned if the value of the Source parameter is NODE_CYCLE_ALERT.
   * *   The nodes that are isolated are returned if the value of the Source parameter is NODE_LONELY_ALERT.
   */
  nodes?: ListAlertMessagesResponseBodyDataAlertMessagesNodes[];
  /**
   * @remarks
   * The ID of the custom alert rule that was triggered. This parameter is returned if the value of the Source parameter is REMIND_ALERT.
   * 
   * @example
   * 1234
   */
  remindId?: number;
  /**
   * @remarks
   * The name of the custom alert rule that was triggered. This parameter is returned if the value of the Source parameter is REMIND_ALERT.
   */
  remindName?: string;
  /**
   * @remarks
   * The basic information about the baseline instance that triggered an alert. This parameter is returned if the value of the Source parameter is SLA_ALERT. This parameter is left empty if the value of the Source parameter is not SLA_ALERT.
   */
  slaAlert?: ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert;
  /**
   * @remarks
   * The type of the alert. Valid values: REMIND_ALERT, TOPIC_ALERT, SLA_ALERT, NODE_CYCLE_ALERT, and NODE_LONELY_ALERT. The value REMIND_ALERT indicates that the alert is a custom alert. The value TOPIC_ALERT indicates that the alert is an event alert. The value SLA_ALERT indicates that the alert is a baseline alert. The value NODE_CYCLE_ALERT indicates that the alert is reported for a node dependency loop. The value NODE_LONELY_ALERT indicates that the alert is reported for isolated nodes.
   * 
   * @example
   * REMIND_ALERT
   */
  source?: string;
  /**
   * @remarks
   * The events that triggered alerts. This parameter is returned if the value of the Source parameter is TOPIC_ALERT. This parameter is left empty if the value of the Source parameter is not TOPIC_ALERT.
   */
  topics?: ListAlertMessagesResponseBodyDataAlertMessagesTopics[];
  static names(): { [key: string]: string } {
    return {
      alertId: 'AlertId',
      alertMessageStatus: 'AlertMessageStatus',
      alertMethod: 'AlertMethod',
      alertTime: 'AlertTime',
      alertUser: 'AlertUser',
      content: 'Content',
      instances: 'Instances',
      nodes: 'Nodes',
      remindId: 'RemindId',
      remindName: 'RemindName',
      slaAlert: 'SlaAlert',
      source: 'Source',
      topics: 'Topics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertId: 'number',
      alertMessageStatus: 'string',
      alertMethod: 'string',
      alertTime: 'number',
      alertUser: 'string',
      content: 'string',
      instances: { 'type': 'array', 'itemType': ListAlertMessagesResponseBodyDataAlertMessagesInstances },
      nodes: { 'type': 'array', 'itemType': ListAlertMessagesResponseBodyDataAlertMessagesNodes },
      remindId: 'number',
      remindName: 'string',
      slaAlert: ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert,
      source: 'string',
      topics: { 'type': 'array', 'itemType': ListAlertMessagesResponseBodyDataAlertMessagesTopics },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAlertMessagesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The alerts.
   */
  alertMessages?: ListAlertMessagesResponseBodyDataAlertMessages[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  /**
   * @remarks
   * The total number of alerts returned.
   * 
   * @example
   * 100
   */
  totalCount?: string;
  static names(): { [key: string]: string } {
    return {
      alertMessages: 'AlertMessages',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertMessages: { 'type': 'array', 'itemType': ListAlertMessagesResponseBodyDataAlertMessages },
      pageNumber: 'string',
      pageSize: 'string',
      totalCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselineConfigsResponseBodyDataBaselines extends $tea.Model {
  /**
   * @remarks
   * The baseline ID.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  /**
   * @remarks
   * The name of the baseline.
   */
  baselineName?: string;
  /**
   * @remarks
   * The type of the baseline. Valid values: DAILY and HOURLY.
   * 
   * @example
   * DAILY
   */
  baselineType?: string;
  /**
   * @remarks
   * The hour in the alerting time of the day-level baseline. Valid values: [0, 47].
   * 
   * @example
   * 7
   */
  expHour?: number;
  /**
   * @remarks
   * The minute in the alerting time of the day-level baseline. Valid values: [0, 59].
   * 
   * @example
   * 30
   */
  expMinu?: number;
  /**
   * @remarks
   * The alerting time of the hour-level baseline. This parameter is presented as key-value pairs in the JSON format. The key indicates the ID of the cycle, and the value is presented in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
   * 
   * @example
   * {"1":"03:28","2":"04:28","3":"05:28","4":"06:28","5":"07:28","6":"08:28","7":"09:28","8":"10:28","9":"11:28","10":"12:28","11":"13:28","12":"14:28","13":"15:28","14":"16:28","15":"17:28","16":"18:28","17":"19:28","18":"20:28","19":"21:28","20":"22:28","21":"23:28","22":"24:28","23":"25:28","24":"26:28"}
   */
  hourExpDetail?: string;
  /**
   * @remarks
   * The committed completion time of the hour-level baseline. This parameter is presented as key-value pairs in the JSON format. The key indicates the ID of the cycle, and the value is presented in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
   * 
   * @example
   * {"1":"03:58","2":"04:58","3":"05:58","4":"06:58","5":"07:58","6":"08:58","7":"09:58","8":"10:58","9":"11:58","10":"12:58","11":"13:58","12":"14:58","13":"15:58","14":"16:58","15":"17:58","16":"18:58","17":"19:58","18":"20:58","19":"21:58","20":"22:58","21":"23:58","22":"24:58","23":"25:58","24":"26:58"}
   */
  hourSlaDetail?: string;
  /**
   * @remarks
   * Indicates whether the baseline is a default baseline of the workspace. Valid values: true and false.
   * 
   * @example
   * true
   */
  isDefault?: boolean;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the baseline owner. Multiple IDs can be specified. The IDs are separated by commas (,).
   * 
   * @example
   * 952795****
   */
  owner?: string;
  /**
   * @remarks
   * The priority of the baseline. Valid values: {1,3,5,7,8}.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The ID of the workspace to which the baseline belongs.
   * 
   * @example
   * 9527
   */
  projectId?: number;
  /**
   * @remarks
   * The hour in the committed completion time of the day-level baseline. Valid values: [0, 47].
   * 
   * @example
   * 9
   */
  slaHour?: number;
  /**
   * @remarks
   * The minute in the alerting time of the day-level baseline. Valid values: [0, 59].
   * 
   * @example
   * 30
   */
  slaMinu?: number;
  /**
   * @remarks
   * Indicates whether the baseline is enabled. Valid values: true and false.
   * 
   * @example
   * true
   */
  useFlag?: boolean;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      baselineName: 'BaselineName',
      baselineType: 'BaselineType',
      expHour: 'ExpHour',
      expMinu: 'ExpMinu',
      hourExpDetail: 'HourExpDetail',
      hourSlaDetail: 'HourSlaDetail',
      isDefault: 'IsDefault',
      owner: 'Owner',
      priority: 'Priority',
      projectId: 'ProjectId',
      slaHour: 'SlaHour',
      slaMinu: 'SlaMinu',
      useFlag: 'UseFlag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      baselineName: 'string',
      baselineType: 'string',
      expHour: 'number',
      expMinu: 'number',
      hourExpDetail: 'string',
      hourSlaDetail: 'string',
      isDefault: 'boolean',
      owner: 'string',
      priority: 'number',
      projectId: 'number',
      slaHour: 'number',
      slaMinu: 'number',
      useFlag: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselineConfigsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of baselines.
   */
  baselines?: ListBaselineConfigsResponseBodyDataBaselines[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of baselines returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      baselines: 'Baselines',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselines: { 'type': 'array', 'itemType': ListBaselineConfigsResponseBodyDataBaselines },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselineStatusesResponseBodyDataBaselineStatuses extends $tea.Model {
  /**
   * @remarks
   * The baseline ID.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  /**
   * @remarks
   * The name of the baseline.
   * 
   * @example
   * Baseline name
   */
  baselineName?: string;
  /**
   * @remarks
   * The data timestamp.
   * 
   * @example
   * 1553443200000
   */
  bizdate?: number;
  /**
   * @remarks
   * The margin of the baseline instance. Unit: seconds.
   * 
   * @example
   * 1800
   */
  buffer?: number;
  /**
   * @remarks
   * The timestamp of the predicted time when the baseline instance finished running.
   * 
   * @example
   * 1553531400000
   */
  endCast?: number;
  /**
   * @remarks
   * The timestamp of the alerting time of the baseline instance.
   * 
   * @example
   * 1553531400000
   */
  expTime?: number;
  /**
   * @remarks
   * The status of the baseline instance. Valid values: UNFINISH and FINISH.
   * 
   * @example
   * UNFINISH
   */
  finishStatus?: string;
  /**
   * @remarks
   * The timestamp of the actual time when the baseline instance finished running. This parameter is returned if the value of the FinishStatus parameter is FINISH.
   * 
   * @example
   * 1553531400000
   */
  finishTime?: number;
  /**
   * @remarks
   * The ID of the cycle of the baseline instance. Valid values of the ID of an hour-level cycle: [1,24]. The ID of a day-level cycle is 1.
   * 
   * @example
   * 1
   */
  inGroupId?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the baseline owner. Multiple IDs are separated by commas (,).
   * 
   * @example
   * 9527952795****
   */
  owner?: string;
  /**
   * @remarks
   * The priority of the baseline. Valid values: {1,3,5,7,8}.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The ID of the workspace to which the baseline belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The timestamp of the actual time when the baseline instance finished running.
   * 
   * @example
   * 1553531400000
   */
  slaTime?: number;
  /**
   * @remarks
   * The status of the baseline. Valid values: ERROR, SAFE, DANGEROUS, and OVER. The value ERROR indicates that no nodes are associated with the baseline, or all nodes associated with the baseline are suspended. The value SAFE indicates that nodes are run before the alert duration begins. The value DANGEROUS indicates that nodes are still running after the alert duration ends but the committed completion time does not arrive. The value OVER indicates that nodes are still running after the committed completion time.
   * 
   * @example
   * SAFE
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      baselineName: 'BaselineName',
      bizdate: 'Bizdate',
      buffer: 'Buffer',
      endCast: 'EndCast',
      expTime: 'ExpTime',
      finishStatus: 'FinishStatus',
      finishTime: 'FinishTime',
      inGroupId: 'InGroupId',
      owner: 'Owner',
      priority: 'Priority',
      projectId: 'ProjectId',
      slaTime: 'SlaTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      baselineName: 'string',
      bizdate: 'number',
      buffer: 'number',
      endCast: 'number',
      expTime: 'number',
      finishStatus: 'string',
      finishTime: 'number',
      inGroupId: 'number',
      owner: 'string',
      priority: 'number',
      projectId: 'number',
      slaTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselineStatusesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of baseline instances.
   */
  baselineStatuses?: ListBaselineStatusesResponseBodyDataBaselineStatuses[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of baseline instances.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      baselineStatuses: 'BaselineStatuses',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineStatuses: { 'type': 'array', 'itemType': ListBaselineStatusesResponseBodyDataBaselineStatuses },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselinesResponseBodyDataBaselinesOverTimeSettings extends $tea.Model {
  /**
   * @remarks
   * The cycle that corresponds to the committed completion time. For a day-level baseline, the value of this parameter is 1. For an hour-level baseline, the value of this parameter cannot exceed 24.
   * 
   * @example
   * 1
   */
  cycle?: number;
  /**
   * @remarks
   * The committed completion time in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
   * 
   * @example
   * 00:00
   */
  time?: string;
  static names(): { [key: string]: string } {
    return {
      cycle: 'Cycle',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycle: 'number',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselinesResponseBodyDataBaselines extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the alerting feature is enabled. Valid values: true and false.
   * 
   * @example
   * true
   */
  alertEnabled?: boolean;
  /**
   * @remarks
   * The alert margin threshold for the baseline instance. Unit: minutes.
   * 
   * @example
   * 30
   */
  alertMarginThreshold?: number;
  /**
   * @remarks
   * The baseline ID.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  /**
   * @remarks
   * The name of the baseline.
   * 
   * @example
   * BaselineName
   */
  baselineName?: string;
  /**
   * @remarks
   * The type of the baseline. Valid values: DAILY and HOURLY.
   * 
   * @example
   * DAILY
   */
  baselineType?: string;
  /**
   * @remarks
   * Indicates whether the baseline is enabled. Valid values: true and false.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * The settings of the committed completion time of the baseline.
   */
  overTimeSettings?: ListBaselinesResponseBodyDataBaselinesOverTimeSettings[];
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the baseline owner. Multiple IDs can be specified. The IDs are separated by commas (,).
   * 
   * @example
   * 952795****
   */
  owner?: string;
  /**
   * @remarks
   * The priority of the baseline. Valid values: {1,2,5,7,8}.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The ID of the workspace to which the baseline belongs.
   * 
   * @example
   * 9527
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      alertEnabled: 'AlertEnabled',
      alertMarginThreshold: 'AlertMarginThreshold',
      baselineId: 'BaselineId',
      baselineName: 'BaselineName',
      baselineType: 'BaselineType',
      enabled: 'Enabled',
      overTimeSettings: 'OverTimeSettings',
      owner: 'Owner',
      priority: 'Priority',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertEnabled: 'boolean',
      alertMarginThreshold: 'number',
      baselineId: 'number',
      baselineName: 'string',
      baselineType: 'string',
      enabled: 'boolean',
      overTimeSettings: { 'type': 'array', 'itemType': ListBaselinesResponseBodyDataBaselinesOverTimeSettings },
      owner: 'string',
      priority: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBaselinesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The baselines.
   */
  baselines?: ListBaselinesResponseBodyDataBaselines[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: string;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: string;
  /**
   * @remarks
   * The total number of baselines returned.
   * 
   * @example
   * 100
   */
  totalCount?: string;
  static names(): { [key: string]: string } {
    return {
      baselines: 'Baselines',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselines: { 'type': 'array', 'itemType': ListBaselinesResponseBodyDataBaselines },
      pageNumber: 'string',
      pageSize: 'string',
      totalCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBusinessResponseBodyDataBusiness extends $tea.Model {
  /**
   * @remarks
   * The ID of the workflow.
   * 
   * @example
   * 3000001
   */
  businessId?: number;
  /**
   * @remarks
   * The name of the workflow.
   * 
   * @example
   * My first workflow
   */
  businessName?: string;
  /**
   * @remarks
   * The description of the workflow.
   * 
   * @example
   * My first workflow
   */
  description?: string;
  /**
   * @remarks
   * The owner of the workflow.
   * 
   * @example
   * 34824327****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the workspace to which the workflow belongs.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The module to which the workflow belongs. Valid values: NORMAL and MANUAL_BIZ. The value NORMAL indicates that the workflow belongs to auto triggered workflows. The value MANUAL_BIZ indicates that the workflow belongs to manually triggered workflows.
   * 
   * @example
   * NORMAL
   */
  useType?: string;
  static names(): { [key: string]: string } {
    return {
      businessId: 'BusinessId',
      businessName: 'BusinessName',
      description: 'Description',
      owner: 'Owner',
      projectId: 'ProjectId',
      useType: 'UseType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessId: 'number',
      businessName: 'string',
      description: 'string',
      owner: 'string',
      projectId: 'number',
      useType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListBusinessResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The details of the workflow.
   */
  business?: ListBusinessResponseBodyDataBusiness[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 13
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      business: 'Business',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      business: { 'type': 'array', 'itemType': ListBusinessResponseBodyDataBusiness },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalcEnginesResponseBodyDataCalcEngines extends $tea.Model {
  /**
   * @remarks
   * The ID of the workspace with which the compute engine is associated.
   * 
   * @example
   * 27
   */
  bindingProjectId?: number;
  /**
   * @remarks
   * The name of the workspace with which the compute engine is associated.
   * 
   * @example
   * abc
   */
  bindingProjectName?: string;
  /**
   * @remarks
   * The type of the compute engine.
   * 
   * @example
   * ODPS
   */
  calcEngineType?: string;
  /**
   * @remarks
   * The region where the DataWorks workspace with which the compute engine is associated resides.
   * 
   * @example
   * cn-zhangjiakou
   */
  dwRegion?: string;
  /**
   * @remarks
   * The compute engine ID.
   * 
   * @example
   * 35
   */
  engineId?: number;
  /**
   * @remarks
   * The details of the compute engine.
   * 
   * *   ODPS
   * 
   *         {
   *           "pubEndpoint": "service.cn.maxcompute.aliyun.com/api",
   *           "endpoint": "service.cn.maxcompute.aliyun-inc.com/api",
   *           "initProperties": " 
   *           {\\"odpsTypeMode\\":\\"STANDARD\\",\\"openPai\\":false,\\"openPaiGpu\\":false}",
   *           "resourceGroupType": "ODPS",
   *           "resourceGroupId": "361826516****",
   *           "vpcEndpoint": "service.cn.maxcompute.aliyun-inc.com/api",
   *           "projectName": "onefall_test_zjk",
   *           "taskSameAsOwner": "true"
   *         }
   * 
   * *   EMR
   * 
   *         {
   *           "emrClusterId": "C-xxx",
   *           "specs": "{\\"emrClusterId\\":\\"C-xxx\\",\\"emrAccessMode\\":\\"simple\\",\\"emrResourceQueueName\\":\\"default\\",\\"emrProjectId\\":\\"FP-xxx\\"}",
   *           "endpoint": "emr.aliyuncs.com",
   *           "emrResourceQueueName": "default",
   *           "emrAccessMode": "simple",
   *           "resourceGroupType": "DW",
   *           "projectName": "xx-xxxx",
   *           "emrProjectId": "FP-xxxx",
   *           "taskSameAsOwner": "false"
   *         }   
   * 
   * *   BLINK
   * 
   *         {
   *           "bayesProjectId": "xxxx",
   *           "bayesProjectName": "xc_blxxixxxnk_1",
   *           "cluster": "xxxssxsx",
   *           "endpoint": "https://stream.console.aliyun.com",
   *           "engineType": "BLINK",
   *           "name": "xsxsxxxxx",
   *           "projectName": "xc_blxxxsxink_1",
   *           "queue": "root.xc_blxsxxxxxxink_1",
   *           "resourceGroupType": "DW",
   *           "specs": "{\\"cluster\\":\\"xxxxxx\\",\\"bayesProjectName\\":\\"xc_blxxixxxnk_1\\",\\"bayesProjectId\\":\\"ssxxxsa\\",\\"name\\":\\"sxsxsxxx\\",\\"queue\\":\\"root.sxxsxxsx\\"}",
   *           "taskSameAsOwner": false
   *         }
   * 
   * *   HOLO
   * 
   *         {
   *           "endpoint": "hgprecn-cn-xsxssxsx-cn-shanghai-internal.hologres.aliyuncs.com:80",
   *           "engineType": "ODPS",
   *           "odpsEndpoint": "hgprecn-cn-xsxssxxs-cn-shanghai-internal.hologres.aliyuncs.com:80",
   *           "odpsProjectName": "xsxssxsxsx",
   *           "projectName": "xsxssxsxsx",
   *           "resourceGroupType": "DW",
   *           "specs": "{\\"pubEndpoint\\":\\"hgprecn-cn-xsxssxsxs-cn-shanghai.hologres.aliyuncs.com:80\\",\\"commonBuyInstanceId\\":\\"hgprecn-cn-xsxsxsxs\\",\\"project\\":\\"holo_upxsxgrade1\\",\\"common_buy_instance_id\\":\\"hgprecn-cn-xsxsxs\\",\\"endpoint\\":\\"hgprecn-cn-xsxxsxs-cn-shanghai-internal.hologres.aliyuncs.com:80\\",\\"port\\":\\"80\\",\\"host\\":\\"hgprecn-cn-xsxsxsxs-cn-shanghai-internal.hologres.aliyuncs.com\\",\\"vpcEndpoint\\":\\"hgprecn-cn-xsxsxsxs-cn-shanghai-vpc.hologres.aliyuncs.com:80\\",\\"authType\\":2,\\"region\\":\\"cn-shanghai\\"}",
   *           "taskSameAsOwner": false
   *         }
   * 
   * *   MaxGraph
   * 
   *         {
   *           "endpoint": "http://pre-graphcompute.aliyuncs.com",
   *           "engineType": "ODPS",
   *           "odpsEndpoint": "http://pre-graphcompute.aliyuncs.com",
   *           "odpsProjectName": "xsxsxsxs",
   *           "projectName": "xsxsxsxs",
   *           "resourceGroupType": "DW",
   *           "taskSameAsOwner": false
   *         }
   * 
   * *   HYBRIDDB_FOR_POSTGRESQL
   * 
   *         {
   *           "endpoint": "hybriddb_for_postgresql_mo12121ck_endpoint",
   *           "engineType": "ODPS",
   *           "odpsEndpoint": "hybriddb_for_postgresql_m121212ock_endpoint",
   *           "odpsProjectName": "sxasaxsaxaxas",
   *           "projectName": "sxasaxsaxaxas",
   *           "resourceGroupType": "DW",
   *           "specs": "{\\"connectionString\\":\\"gp-xsxsxsxxs.gpdb.rds.aliyuncs.com\\",\\"database\\":\\"xsxsxxsxs\\",\\"password\\":\\"xxxxxxx\\",\\"instanceId\\":\\"gp-cdcdacdacda\\",\\"port\\":\\"3432\\",\\"ownerId\\":\\"12121212\\",\\"username\\":\\"sdasaddsa\\"}",
   *           "taskSameAsOwner": false
   *         }
   * 
   * *   ADB_MYSQL
   * 
   *         {
   *           "endpoint": "adb_mysql_mock_endpoint",
   *           "engineType": "ODPS",
   *           "odpsEndpoint": "adb_mysql_mock_endpoint",
   *           "odpsProjectName": "am-xsaxaxa",
   *           "projectName": "am-xsxsaxa",
   *           "resourceGroupType": "DW",
   *           "specs": "{\\"connectionString\\":\\"am-xsaxsa.ads.aliyuncs.com:3306\\",\\"database\\":\\"xsaxsaxa\\",\\"password\\":\\"xsaxsaxassxsa\\",\\"instanceId\\":\\"am-xsaxsasx\\",\\"username\\":\\"xsaxsadsd\\"}",
   *           "taskSameAsOwner": false
   *         }
   * 
   * *   HADOOP_CDH
   * 
   *         {
   *           "bindingBaseId": "xsaxsaxs",
   *           "endpoint": "xsaaaaa",
   *           "engineType": "ODPS",
   *           "odpsEndpoint": "axsxaxssxs",
   *           "odpsProjectName": "ssxxax",
   *           "projectName": "xsaxsaxsa",
   *           "resourceGroupId": 45208xxxxxx,
   *           "resourceGroupType": "GATEWAY",
   *           "specs": "{\\"cluster\\":{\\"hive\\":{\\"hiveServer2Url\\":\\"jdbc:hive2://xxxxxxer-1-cn-shanghai-pre-kerberos-1:10000\\",\\"hiveMetastore\\":\\"thrift://xxxxxxxr-1-cn-shanghai-pre-kerberos-1:9083\\",\\"version\\":\\"2.1.1\\"},\\"configFiles\\":{\\"coreSite\\":\\"4534574xxxxxx\\",\\"hdfsSite\\":\\"453457919xxxxxxx\\",\\"mapredSite\\":\\"45345750xxxxxx\\",\\"yarnSite\\":\\"4534575xxxxx\\",\\"krb5Conf\\":\\"4534576xxxxx1\\",\\"hiveSite\\":\\"453457xxxxx20\\"},\\"spark\\":{\\"version\\":\\"2.4.0\\"},\\"cdh\\":{\\"version\\":\\"6.3.2\\"},\\"hdfs\\":{\\"version\\":\\"3.0.0\\"},\\"impala\\":{\\"impalaUrl\\":\\"jdbc:impala://cdh-xsxssxxsx-1-cn-shanghai-pre-kerberos-1:21050\\",\\"version\\":\\"3.2.0\\"},\\"yarn\\":{\\"YarnUrl\\":\\"http://cdh-xsxsxsxsxs-1-cn-shanghai-pre-kerberos-1:8032\\",\\"webUrl\\":\\"http://cdh-xsxsxssxxssx-1-cn-shanghai-pre-kerberos-1:8088\\",\\"version\\":\\"3.0.0\\"},\\"presto\\":{\\"prestoUrl\\":\\"jdbc:presto://cdh-xssxsxxsxsxs-1-cn-shanghai-pre-kerberos-1:8080/hive/default\\",\\"version\\":\\"0.244.1\\"}},\\"instanceId\\":161sdads733,\\"authDetail\\":{\\"principal\\":\\"hive@HADOOP.COM\\",\\"keytabFileId\\":\\"45345815xsxsxs3\\",\\"type\\":\\"kerberos\\",\\"username\\":\\"xsxsxsxsa@HADOOP.COM\\"},\\"resGroupStatus\\":\\"\\",\\"hadoopAuthType\\":\\"kerberos\\",\\"clusterIdentifier\\":\\"xssxsxsxsx\\",\\"clusterId\\":xsxsx,\\"resGroupId\\":4520870619xsxssxxs,\\"accessMode\\":\\"security\\",\\"authType\\":2}",
   *           "taskSameAsOwner": false
   *         }
   * 
   * @example
   * {"pubEndpoint":"http://service.cn.maxcompute.aliyun.com/api","endpoint":"http://service.cn.maxcompute.aliyun-inc.com/api","resourceGroupType":"ODPS","resourceGroupId":"361826516****","vpcEndpoint":"http://service.cn.maxcompute.aliyun-inc.com/api","projectName":"onefall_test_zjk","taskSameAsOwner":"true"}
   */
  engineInfo?: { [key: string]: any };
  /**
   * @remarks
   * The environment in which the compute engine is used. Valid values:
   * 
   * *   **DEV**
   * *   **PRD**
   * 
   * @example
   * PRD
   */
  envType?: string;
  /**
   * @remarks
   * The time when the compute engine was created.
   * 
   * @example
   * Oct 10, 2019 3:42:44 PM
   */
  gmtCreate?: string;
  /**
   * @remarks
   * Indicates whether the compute engine is the default engine of the current type.
   * 
   * @example
   * true
   */
  isDefault?: boolean;
  /**
   * @remarks
   * The display name of the compute engine.
   * 
   * @example
   * abc
   */
  name?: string;
  /**
   * @remarks
   * The region where the compute engine resides.
   * 
   * @example
   * cn-zhangjiakou
   */
  region?: string;
  /**
   * @remarks
   * The identity that is used to access the compute engine. Valid values:
   * 
   * *   **USER**: the current user
   * *   **PROJECT**: the workspace executor
   * *   **SUBACCOUNT**: a RAM user
   * *   **STS_ROLE**: the Security Token Service (STS) role
   * 
   * @example
   * PROJECT
   */
  taskAuthType?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 1234567
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      bindingProjectId: 'BindingProjectId',
      bindingProjectName: 'BindingProjectName',
      calcEngineType: 'CalcEngineType',
      dwRegion: 'DwRegion',
      engineId: 'EngineId',
      engineInfo: 'EngineInfo',
      envType: 'EnvType',
      gmtCreate: 'GmtCreate',
      isDefault: 'IsDefault',
      name: 'Name',
      region: 'Region',
      taskAuthType: 'TaskAuthType',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindingProjectId: 'number',
      bindingProjectName: 'string',
      calcEngineType: 'string',
      dwRegion: 'string',
      engineId: 'number',
      engineInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      envType: 'string',
      gmtCreate: 'string',
      isDefault: 'boolean',
      name: 'string',
      region: 'string',
      taskAuthType: 'string',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCalcEnginesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The compute engines.
   */
  calcEngines?: ListCalcEnginesResponseBodyDataCalcEngines[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of compute engine instances.
   * 
   * @example
   * 1
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      calcEngines: 'CalcEngines',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      calcEngines: { 'type': 'array', 'itemType': ListCalcEnginesResponseBodyDataCalcEngines },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClustersResponseBodyData extends $tea.Model {
  clusters?: Cluster[];
  /**
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      clusters: 'Clusters',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusters: { 'type': 'array', 'itemType': Cluster },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListConnectionsResponseBodyDataConnections extends $tea.Model {
  /**
   * @remarks
   * The ID of the compute engine with which the data source is associated.
   * 
   * @example
   * 123
   */
  bindingCalcEngineId?: number;
  /**
   * @remarks
   * The status of the data source. Valid values:
   * 
   * *   1: The data source is normal.
   * *   2: The data source is disabled.
   * 
   * @example
   * 1
   */
  connectStatus?: number;
  /**
   * @remarks
   * The type of the data source. Valid values:
   * 
   * *   odps
   * *   mysql
   * *   rds
   * *   oss
   * *   sqlserver
   * *   polardb
   * *   oracle
   * *   mongodb
   * *   emr
   * *   postgresql
   * *   analyticdb_for_mysql
   * *   hybriddb_for_postgresql
   * *   holo
   * 
   * @example
   * mysql
   */
  connectionType?: string;
  /**
   * @remarks
   * The details of the data source. Examples of details of some common data sources:
   * 
   * *   odps
   * 
   * <!---->
   * 
   *     {
   *       "accessId": "xssssss",
   *       "accessKey": "xsaxsaxsa",
   *       "authType": 2,
   *       "endpoint": "http://service.odps.aliyun.com/api",
   *       "project": "xsaxsax",
   *       "tag": "public"
   *     }
   * 
   * *   mysql
   * 
   * <!---->
   * 
   *     {
   *       "database": "xsaxsa",
   *       "instanceName": "rm-xsaxsa",
   *       "password": "xsaxsa",
   *       "rdsOwnerId": "xasxsa",
   *       "regionId": "cn-shanghai",
   *       "tag": "rds",
   *       "username": "xsaxsa"
   *     }
   * 
   * *   rds
   * 
   * <!---->
   * 
   *     {
   *       "configType": 1,
   *       "tag": "rds",
   *       "database": "xsaxsa",
   *       "username": "xsaxsa",
   *       "password": "xssaxsa$32050",
   *       "instanceName": "rm-xsaxs",
   *       "rdsOwnerId": "11111111"
   *     }
   * 
   * *   oss
   * 
   * <!---->
   * 
   *     {
   *       "accessId": "sssssxx",
   *       "accessKey": "xsaxaxsaxs",
   *       "bucket": "xsa-xs-xs",
   *       "endpoint": "http://oss-cn-shanghai.aliyuncs.com",
   *       "tag": "public"
   *     }
   * 
   * *   sqlserver
   * 
   * <!---->
   * 
   *     {
   *       "jdbcUrl": "jdbc:sqlserver://xsaxsa-xsaxsa.database.xxx.cn:123;DatabaseName=xsxs-xsxs",
   *       "password": "sdasda$fs",
   *       "tag": "public",
   *       "username": "sxaxacdacdd"
   *     }
   * 
   * *   polardb
   * 
   * <!---->
   * 
   *     {
   *       "clusterId": "pc-sdadsadsa",
   *       "database": "dsadsadsa",
   *       "ownerId": "121212122",
   *       "password": "sdasdafssa",
   *       "region": "cn-shanghai",
   *       "tag": "polardb",
   *       "username": "asdadsads"
   *     }
   * 
   * *   oracle
   * 
   * <!---->
   * 
   *     {
   *       "jdbcUrl": "jdbc:oracle:saaa:@xxxxx:1521:PROD",
   *       "password": "sxasaxsa",
   *       "tag": "public",
   *       "username": "sasfadfa"
   *     }
   * 
   * *   mongodb
   * 
   * <!---->
   * 
   *     {
   *       "address": "[\\"xsaxxsa.mongodb.rds.aliyuncs.com:3717\\"]",
   *       "database": "admin",
   *       "password": "sadsda@",
   *       "tag": "public",
   *       "username": "dsadsadas"
   *     }
   * 
   * *   emr
   * 
   * <!---->
   * 
   *     {
   *       "accessId": "xsaxsa",
   *       "emrClusterId": "C-dsads",
   *       "emrResourceQueueName": "default",
   *       "emrEndpoint": "emr.aliyuncs.com",
   *       "accessKey": "dsadsad",
   *       "emrUserId": "224833315798889783",
   *       "name": "sasdsadsa",
   *       "emrAccessMode": "simple",
   *       "region": "cn-shanghai",
   *       "authType": "2",
   *       "emrProjectId": "FP-sdadsad"
   *     }
   * 
   * *   postgresql
   * 
   * <!---->
   * 
   *     {
   *       "jdbcUrl": "jdbc:postgresql://xxxx:1921/ssss",
   *       "password": "sdadsads",
   *       "tag": "public",
   *       "username": "sdsasda"
   *     }
   * 
   * *   analyticdb_for_mysql
   * 
   * <!---->
   * 
   *     {
   *       "instanceId": "am-sadsada",
   *       "database": "xsxsx",
   *       "username": "xsxsa",
   *       "password": "asdadsa",
   *       "connectionString": "am-xssxsxs.ads.aliyuncs.com:3306"
   *     }
   * 
   * *   hybriddb_for_postgresql
   * 
   * <!---->
   * 
   *     {
   *       "connectionString": "gp-xsaxsaxa-master.gpdbmaster.rds.aliyuncs.com",
   *       "database": "xsaxsaxas",
   *       "password": "xsaxsaxsa@11",
   *       "instanceId": "gp-xsaxsaxsa",
   *       "port": "541132",
   *       "ownerId": "xsaxsaxsas",
   *       "username": "sadsad"
   *     }
   * 
   * *   holo
   * 
   * <!---->
   * 
   *     {
   *       "accessId": "xsaxsaxs",
   *       "accessKey": "xsaxsaxsa",
   *       "database": "xsaxsaxsa",
   *       "instanceId": "xsaxa",
   *       "tag": "aliyun"
   *     }
   * 
   * *   kafka
   * 
   * <!---->
   * 
   *     {
   *       "instanceId": "xsax-cn-xsaxsa",
   *       "regionId": "cn-shanghai",
   *       "tag": "aliyun",
   *       "ownerId": "1212121212112"
   *     }
   * 
   * @example
   * {\\"database\\":\\"xxx\\",\\"instanceName\\":\\"xxx\\",\\"password\\":\\"xxx\\",\\"rdsOwnerId\\":\\"xxx\\",\\"tag\\":\\"rds\\",\\"username\\":\\"xxx\\"}
   */
  content?: string;
  /**
   * @remarks
   * Indicates whether the compute engine that is associated with the data source is the default compute engine used by data sources of the same type.
   * 
   * @example
   * false
   */
  defaultEngine?: boolean;
  /**
   * @remarks
   * The description of the data source.
   * 
   * @example
   * a connection
   */
  description?: string;
  /**
   * @remarks
   * The environment in which the data source is used. Valid values:
   * 
   * *   0: development environment
   * *   1: production environment
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The time when the data source was created. Example: Mar 17, 2021 4:09:32 PM.
   * 
   * @example
   * Mar 17, 2021 4:09:32 PM
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the data source was last modified. Example: Mar 17, 2021 4:09:32 PM.
   * 
   * @example
   * Mar 17, 2021 4:09:32 PM
   */
  gmtModified?: string;
  /**
   * @remarks
   * The data source ID.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The name of the data source.
   * 
   * @example
   * abc
   */
  name?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to last modify the data source.
   * 
   * @example
   * 193543050****
   */
  operator?: string;
  /**
   * @remarks
   * The ID of the workspace with which the data source is associated.
   * 
   * @example
   * 123
   */
  projectId?: number;
  /**
   * @remarks
   * The field that is used to sort data sources. Data sources are sorted in descending order based on the value of this parameter.
   * 
   * @example
   * 300
   */
  sequence?: number;
  /**
   * @remarks
   * Indicates whether the data source is a shared data source.
   * 
   * @example
   * false
   */
  shared?: boolean;
  /**
   * @remarks
   * The status of the data source. Valid values:
   * 
   * *   1: The data source is normal.
   * *   2: The data source is disabled.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The subtype of the data source. This parameter is used in scenarios where a type includes subtypes. The following type and subtypes are supported:
   * 
   * *   Type: `rds`
   * *   Subtypes: `mysql`, `sqlserver`, and `postgresql`.
   * 
   * @example
   * mysql
   */
  subType?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 1234567
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      bindingCalcEngineId: 'BindingCalcEngineId',
      connectStatus: 'ConnectStatus',
      connectionType: 'ConnectionType',
      content: 'Content',
      defaultEngine: 'DefaultEngine',
      description: 'Description',
      envType: 'EnvType',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      operator: 'Operator',
      projectId: 'ProjectId',
      sequence: 'Sequence',
      shared: 'Shared',
      status: 'Status',
      subType: 'SubType',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindingCalcEngineId: 'number',
      connectStatus: 'number',
      connectionType: 'string',
      content: 'string',
      defaultEngine: 'boolean',
      description: 'string',
      envType: 'number',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      name: 'string',
      operator: 'string',
      projectId: 'number',
      sequence: 'number',
      shared: 'boolean',
      status: 'number',
      subType: 'string',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListConnectionsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The data sources.
   */
  connections?: ListConnectionsResponseBodyDataConnections[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of data sources returned.
   * 
   * @example
   * 3
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      connections: 'Connections',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connections: { 'type': 'array', 'itemType': ListConnectionsResponseBodyDataConnections },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationChannels extends $tea.Model {
  /**
   * @remarks
   * The alert notification methods.
   */
  channels?: string[];
  /**
   * @remarks
   * The severity level. Valid values:
   * 
   * *   Warning
   * *   Critical
   * 
   * @example
   * Warning
   */
  severity?: string;
  static names(): { [key: string]: string } {
    return {
      channels: 'Channels',
      severity: 'Severity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channels: { 'type': 'array', 'itemType': 'string' },
      severity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationReceivers extends $tea.Model {
  /**
   * @remarks
   * The recipient type.
   * 
   * *   If the alert notification method is Mail, Phone, or Sms, the recipient type is Alibaba Cloud account ID.
   * *   If the alert notification method is Ding, the recipient type is DingTalk chatbot token.
   * 
   * @example
   * DingToken
   */
  receiverType?: string;
  /**
   * @remarks
   * The recipients.
   */
  receiverValues?: string[];
  static names(): { [key: string]: string } {
    return {
      receiverType: 'ReceiverType',
      receiverValues: 'ReceiverValues',
    };
  }

  static types(): { [key: string]: any } {
    return {
      receiverType: 'string',
      receiverValues: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings extends $tea.Model {
  /**
   * @remarks
   * The duration of the alert suppression interval. Unit: minutes.
   * 
   * @example
   * 5
   */
  inhibitionInterval?: number;
  /**
   * @remarks
   * The alert notification methods.
   */
  notificationChannels?: ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationChannels[];
  /**
   * @remarks
   * The alert notification recipients.
   */
  notificationReceivers?: ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationReceivers[];
  static names(): { [key: string]: string } {
    return {
      inhibitionInterval: 'InhibitionInterval',
      notificationChannels: 'NotificationChannels',
      notificationReceivers: 'NotificationReceivers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inhibitionInterval: 'number',
      notificationChannels: { 'type': 'array', 'itemType': ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationChannels },
      notificationReceivers: { 'type': 'array', 'itemType': ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationReceivers },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions extends $tea.Model {
  /**
   * @remarks
   * The time interval for alert calculation. Unit: minutes.
   * 
   * @example
   * 15
   */
  duration?: number;
  /**
   * @remarks
   * The severity level. Valid values:
   * 
   * *   Warning
   * *   Critical
   * 
   * @example
   * Warning
   */
  severity?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * *   If the alert rule is for task status, no threshold is used.
   * *   If the alert rule is for failovers, the threshold is the number of failovers.
   * *   If the alert rule is for latency, the threshold is the latency duration, in seconds.
   * 
   * @example
   * 5
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      severity: 'Severity',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      severity: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules extends $tea.Model {
  /**
   * @remarks
   * The alert rule ID.
   * 
   * @example
   * 41998
   */
  DIAlarmRuleId?: number;
  /**
   * @remarks
   * The ID of the task with which the alert rule is associated.
   * 
   * @example
   * 11260
   */
  DIJobId?: number;
  /**
   * @remarks
   * The description of the alert rule.
   */
  description?: string;
  /**
   * @remarks
   * Indicates whether the alert rule is enabled.
   * 
   * @example
   * true
   */
  enabled?: boolean;
  /**
   * @remarks
   * The metric type in the alert rule. Valid values:
   * 
   * *   Heartbeat
   * *   FailoverCount
   * *   Delay
   * 
   * @example
   * Heartbeat
   */
  metricType?: string;
  /**
   * @remarks
   * The alert notification settings.
   */
  notificationSettings?: ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings;
  /**
   * @remarks
   * The conditions that can trigger the alert rule.
   */
  triggerConditions?: ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions[];
  static names(): { [key: string]: string } {
    return {
      DIAlarmRuleId: 'DIAlarmRuleId',
      DIJobId: 'DIJobId',
      description: 'Description',
      enabled: 'Enabled',
      metricType: 'MetricType',
      notificationSettings: 'NotificationSettings',
      triggerConditions: 'TriggerConditions',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIAlarmRuleId: 'number',
      DIJobId: 'number',
      description: 'string',
      enabled: 'boolean',
      metricType: 'string',
      notificationSettings: ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings,
      triggerConditions: { 'type': 'array', 'itemType': ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIAlarmRulesResponseBodyDIAlarmRulePaging extends $tea.Model {
  /**
   * @remarks
   * The list of alert rules.
   */
  DIJobAlarmRules?: ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 2
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      DIJobAlarmRules: 'DIJobAlarmRules',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobAlarmRules: { 'type': 'array', 'itemType': ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIJobsResponseBodyDIJobPagingDIJobs extends $tea.Model {
  /**
   * @remarks
   * The task ID.
   * 
   * @example
   * 16626
   */
  DIJobId?: number;
  /**
   * @remarks
   * The type of the destination. The value Hologres is returned.
   * 
   * @example
   * Hologres
   */
  destinationDataSourceType?: string;
  /**
   * @remarks
   * The task name.
   * 
   * @example
   * mysql_to_holo_sync_8772
   */
  jobName?: string;
  /**
   * @remarks
   * The task status. Valid values:
   * 
   * *   Finished
   * *   Initialized
   * *   Stopped
   * *   Failed
   * *   Running
   * *   Stopping
   * 
   * @example
   * Finished
   */
  jobStatus?: string;
  /**
   * @remarks
   * The synchronization type. Valid values:
   * 
   * *   FullAndRealtimeIncremental: one-time full synchronization and real-time incremental synchronization
   * *   RealtimeIncremental: real-time incremental synchronization
   * *   Full: one-time full synchronization
   * 
   * @example
   * Full
   */
  migrationType?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 1967
   */
  projectId?: number;
  /**
   * @remarks
   * The type of the source. The value MySQL is returned.
   * 
   * @example
   * MySQL
   */
  sourceDataSourceType?: string;
  static names(): { [key: string]: string } {
    return {
      DIJobId: 'DIJobId',
      destinationDataSourceType: 'DestinationDataSourceType',
      jobName: 'JobName',
      jobStatus: 'JobStatus',
      migrationType: 'MigrationType',
      projectId: 'ProjectId',
      sourceDataSourceType: 'SourceDataSourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobId: 'number',
      destinationDataSourceType: 'string',
      jobName: 'string',
      jobStatus: 'string',
      migrationType: 'string',
      projectId: 'number',
      sourceDataSourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIJobsResponseBodyDIJobPaging extends $tea.Model {
  /**
   * @remarks
   * The list of tasks.
   */
  DIJobs?: ListDIJobsResponseBodyDIJobPagingDIJobs[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 6
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      DIJobs: 'DIJobs',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DIJobs: { 'type': 'array', 'itemType': ListDIJobsResponseBodyDIJobPagingDIJobs },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDIProjectConfigResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The default global configuration of synchronization solutions. The value indicates the processing rules of different types of DDL messages. Example: {"RENAMECOLUMN":"WARNING","DROPTABLE":"WARNING","CREATETABLE":"WARNING","MODIFYCOLUMN":"WARNING","TRUNCATETABLE":"WARNING","DROPCOLUMN":"WARNING","ADDCOLUMN":"WARNING","RENAMETABLE":"WARNING"}
   * 
   * Field description:
   * 
   * *   RENAMECOLUMN: renames a column.
   * *   DROPTABLE: deletes a table.
   * *   CREATETABLE: creates a table.
   * *   MODIFYCOLUMN: changes the data type of a column.
   * *   TRUNCATETABLE: clears a table.
   * *   DROPCOLUMN: deletes a column.
   * *   ADDCOLUMN: creates a column.
   * *   RENAMETABLE: renames a table.
   * 
   * DataWorks processes a DDL message of a specific type based on the following rules:
   * 
   * *   WARNING: ignores the message and records an alert in real-time synchronization logs. The alert contains information about the situation that the message is ignored because of an execution error.
   * *   IGNORE: discards the message and does not send it to the destination.
   * *   CRITICAL: terminates the real-time synchronization node and sets the node status to Failed.
   * *   NORMAL: sends the message to the destination to process the message. Each destination processes DDL messages based on its own business logic. If DataWorks adopts the NORMAL policy, DataWorks only forwards DDL messages.
   * 
   * @example
   * {"RENAMECOLUMN":"WARNING","DROPTABLE":"WARNING","CREATETABLE":"WARNING","MODIFYCOLUMN":"WARNING","TRUNCATETABLE":"WARNING","DROPCOLUMN":"WARNING","ADDCOLUMN":"WARNING","RENAMETABLE":"WARNING"}
   */
  config?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDagsResponseBodyDataDags extends $tea.Model {
  /**
   * @remarks
   * The data timestamp.
   * 
   * @example
   * 1605052800000
   */
  bizdate?: number;
  /**
   * @remarks
   * The creation time.
   * 
   * @example
   * 1605052800000
   */
  createTime?: number;
  /**
   * @remarks
   * The creator.
   * 
   * @example
   * 1736629400048545
   */
  createUser?: string;
  /**
   * @remarks
   * The DAG ID.
   * 
   * @example
   * 351249682
   */
  dagId?: number;
  /**
   * @remarks
   * The end time.
   * 
   * @example
   * 1605052800000
   */
  finishTime?: number;
  /**
   * @remarks
   * The actual running time.
   * 
   * @example
   * 1605052800000
   */
  gmtdate?: number;
  /**
   * @remarks
   * The modification time.
   * 
   * @example
   * 1605052800000
   */
  modifyTime?: number;
  /**
   * @remarks
   * The name of the DAG.
   * 
   * @example
   * test_dag
   */
  name?: string;
  /**
   * @remarks
   * The sequence number of the operation.
   * 
   * @example
   * 123
   */
  opSeq?: number;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 112345
   */
  projectId?: number;
  /**
   * @remarks
   * The start time.
   * 
   * @example
   * 1605052800000
   */
  startTime?: number;
  /**
   * @remarks
   * The status of the DAG. Valid values:
   * 
   * *   CREATED
   * *   RUNNING
   * *   FAILURE
   * *   SUCCESS
   * 
   * @example
   * FAILURE
   */
  status?: string;
  /**
   * @remarks
   * The type of the DAG. Valid values:
   * 
   * *   MANUAL: DAG for a manually triggered workflow
   * *   SMOKE_TEST: DAG for a smoke testing workflow
   * *   SUPPLY_DATA: DAG for a data backfill instance
   * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
   * 
   * @example
   * MANUAL_FLOW
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      bizdate: 'Bizdate',
      createTime: 'CreateTime',
      createUser: 'CreateUser',
      dagId: 'DagId',
      finishTime: 'FinishTime',
      gmtdate: 'Gmtdate',
      modifyTime: 'ModifyTime',
      name: 'Name',
      opSeq: 'OpSeq',
      projectId: 'ProjectId',
      startTime: 'StartTime',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizdate: 'number',
      createTime: 'number',
      createUser: 'string',
      dagId: 'number',
      finishTime: 'number',
      gmtdate: 'number',
      modifyTime: 'number',
      name: 'string',
      opSeq: 'number',
      projectId: 'number',
      startTime: 'number',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDagsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The entities returned.
   */
  dags?: ListDagsResponseBodyDataDags[];
  static names(): { [key: string]: string } {
    return {
      dags: 'Dags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dags: { 'type': 'array', 'itemType': ListDagsResponseBodyDataDags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords extends $tea.Model {
  /**
   * @remarks
   * The time when the access permissions on the API were granted to other users.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  createdTime?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the API owner.
   * 
   * @example
   * 12345
   */
  creatorId?: string;
  /**
   * @remarks
   * The end time of the validity period of the authorization.
   * 
   * @example
   * 2020-06-24T00:21:01+0800
   */
  endTime?: string;
  /**
   * @remarks
   * The ID of the workspace to which the access permissions on the API are granted.
   * 
   * @example
   * 10004
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      creatorId: 'CreatorId',
      endTime: 'EndTime',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      creatorId: 'string',
      endTime: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * 10002
   */
  apiId?: number;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * My API name
   */
  apiName?: string;
  /**
   * @remarks
   * The path of the API.
   * 
   * @example
   * /test/1
   */
  apiPath?: string;
  /**
   * @remarks
   * The status of the API. Valid values: 0 and 1. The value 0 indicates that the API is not published. The value 1 indicates that the API is published.
   * 
   * @example
   * 0
   */
  apiStatus?: number;
  /**
   * @remarks
   * The authorization records.
   */
  authorizationRecords?: ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords[];
  /**
   * @remarks
   * The time when the API was created.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  createdTime?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the API owner.
   * 
   * @example
   * 12345
   */
  creatorId?: string;
  /**
   * @remarks
   * The group ID.
   * 
   * @example
   * ab123
   */
  groupId?: string;
  /**
   * @remarks
   * The time when the API was last modified.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 10001
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      apiPath: 'ApiPath',
      apiStatus: 'ApiStatus',
      authorizationRecords: 'AuthorizationRecords',
      createdTime: 'CreatedTime',
      creatorId: 'CreatorId',
      groupId: 'GroupId',
      modifiedTime: 'ModifiedTime',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      apiName: 'string',
      apiPath: 'string',
      apiStatus: 'number',
      authorizationRecords: { 'type': 'array', 'itemType': ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords },
      createdTime: 'string',
      creatorId: 'string',
      groupId: 'string',
      modifiedTime: 'string',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApiAuthoritiesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The APIs on which other users are granted the access permissions.
   */
  apiAuthorizationList?: ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList[];
  /**
   * @remarks
   * The page number. The value of this parameter is the same as that of the PageNumber parameter in the request.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiAuthorizationList: 'ApiAuthorizationList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiAuthorizationList: { 'type': 'array', 'itemType': ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApiTestResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the DataService Studio API on which the test is performed.
   * 
   * @example
   * 2343
   */
  apiId?: number;
  /**
   * @remarks
   * The time that is consumed to complete the test.
   * 
   * @example
   * 10
   */
  costTime?: number;
  /**
   * @remarks
   * The time when the test was initiated.
   * 
   * @example
   * 1651824913000
   */
  createTime?: number;
  /**
   * @remarks
   * The request parameters configured for the test.
   * 
   * @example
   * {"name":"test"}
   */
  paramMap?: string;
  /**
   * @remarks
   * The status code returned for the test. If the test is not complete, this parameter is not returned.
   * 
   * @example
   * 0
   */
  retCode?: number;
  /**
   * @remarks
   * The result returned for the test.
   * 
   * @example
   * {"id":2}
   */
  retResult?: string;
  /**
   * @remarks
   * The status of the test. Valid values: RUNNING and FINISHED.
   * 
   * @example
   * FINISHED
   */
  status?: string;
  /**
   * @remarks
   * The ID of the test.
   * 
   * @example
   * 123
   */
  testId?: number;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      costTime: 'CostTime',
      createTime: 'CreateTime',
      paramMap: 'ParamMap',
      retCode: 'RetCode',
      retResult: 'RetResult',
      status: 'Status',
      testId: 'TestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      costTime: 'number',
      createTime: 'number',
      paramMap: 'string',
      retCode: 'number',
      retResult: 'string',
      status: 'string',
      testId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1001
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * fail to call
   */
  errorMessage?: string;
  /**
   * @remarks
   * The solution used to fix the error.
   * 
   * @example
   * retry
   */
  errorSolution?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      errorSolution: 'ErrorSolution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      errorSolution: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
   * 
   * @example
   * column1
   */
  columnName?: string;
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * default1
   */
  defaultValue?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example1
   */
  exampleValue?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required.
   * 
   * @example
   * true
   */
  isRequiredParameter?: boolean;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description1
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * name1
   */
  parameterName?: string;
  /**
   * @remarks
   * The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates the Equal operator. The value 1 indicates the Like operator. The value 2 indicates the Const operator. The value 3 indicates the In operator. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
   * 
   * @example
   * 0
   */
  parameterOperator?: number;
  /**
   * @remarks
   * The position of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the parameter is in the URL path of the request. The value 1 indicates that the parameter is in the Query parameter of the request URL. The value 2 indicates that the parameter is in the request header. The value 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
   * 
   * @example
   * 0
   */
  parameterPosition?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      defaultValue: 'DefaultValue',
      exampleValue: 'ExampleValue',
      isRequiredParameter: 'IsRequiredParameter',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
      parameterOperator: 'ParameterOperator',
      parameterPosition: 'ParameterPosition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      defaultValue: 'string',
      exampleValue: 'string',
      isRequiredParameter: 'boolean',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
      parameterOperator: 'number',
      parameterPosition: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBodyDataApisRegistrationDetails extends $tea.Model {
  /**
   * @remarks
   * The sample error response of the API.
   * 
   * @example
   * {"success": false}
   */
  failedResultSample?: string;
  /**
   * @remarks
   * The error codes returned for the API generated by registration.
   */
  registrationErrorCodes?: ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes[];
  /**
   * @remarks
   * The request parameters of the API generated by registration.
   */
  registrationRequestParameters?: ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters[];
  /**
   * @remarks
   * The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
   * 
   * @example
   * 0
   */
  serviceContentType?: number;
  /**
   * @remarks
   * The URL of the backend service.
   * 
   * @example
   * http://example.aliyundoc.com
   */
  serviceHost?: string;
  /**
   * @remarks
   * The path of the backend service.
   * 
   * @example
   * /index
   */
  servicePath?: string;
  /**
   * @remarks
   * The description of the request body initiated to call the backend service.
   * 
   * @example
   * {"abc":1}
   */
  serviceRequestBodyDescription?: string;
  /**
   * @remarks
   * The sample success response of the API.
   * 
   * @example
   * {"success": true}
   */
  successfulResultSample?: string;
  static names(): { [key: string]: string } {
    return {
      failedResultSample: 'FailedResultSample',
      registrationErrorCodes: 'RegistrationErrorCodes',
      registrationRequestParameters: 'RegistrationRequestParameters',
      serviceContentType: 'ServiceContentType',
      serviceHost: 'ServiceHost',
      servicePath: 'ServicePath',
      serviceRequestBodyDescription: 'ServiceRequestBodyDescription',
      successfulResultSample: 'SuccessfulResultSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedResultSample: 'string',
      registrationErrorCodes: { 'type': 'array', 'itemType': ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes },
      registrationRequestParameters: { 'type': 'array', 'itemType': ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters },
      serviceContentType: 'number',
      serviceHost: 'string',
      servicePath: 'string',
      serviceRequestBodyDescription: 'string',
      successfulResultSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection extends $tea.Model {
  /**
   * @remarks
   * The data source ID.
   * 
   * @example
   * 123
   */
  connectionId?: number;
  /**
   * @remarks
   * The name of the table in the data source.
   * 
   * @example
   * t
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      connectionId: 'ConnectionId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionId: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
   * 
   * @example
   * column1
   */
  columnName?: string;
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * default1
   */
  defaultValue?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example1
   */
  exampleValue?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required.
   * 
   * @example
   * true
   */
  isRequiredParameter?: boolean;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description1
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param1
   */
  parameterName?: string;
  /**
   * @remarks
   * The operator used for the value of the parameter. Valid values:
   * 
   * *   0: Equal
   * *   1: Like
   * *   2: Const
   * *   3: In
   * 
   * APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
   * 
   * @example
   * 0
   */
  parameterOperator?: number;
  /**
   * @remarks
   * The position of the parameter. Valid values:
   * 
   * *   0: indicates that the parameter is in the URL path of the request.
   * *   1: indicates that the parameter is in the Query parameter of the request URL.
   * *   2: indicates that the parameter is in the request header.
   * *   3: indicates that the parameter is in the request body.
   * 
   * APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
   * 
   * @example
   * 0
   */
  parameterPosition?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      defaultValue: 'DefaultValue',
      exampleValue: 'ExampleValue',
      isRequiredParameter: 'IsRequiredParameter',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
      parameterOperator: 'ParameterOperator',
      parameterPosition: 'ParameterPosition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      defaultValue: 'string',
      exampleValue: 'string',
      isRequiredParameter: 'boolean',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
      parameterOperator: 'number',
      parameterPosition: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
   * 
   * @example
   * column2
   */
  columnName?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example2
   */
  exampleValue?: string;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description2
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param2
   */
  parameterName?: string;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      exampleValue: 'ExampleValue',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      exampleValue: 'string',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBodyDataApisScriptDetails extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the entries are returned by page.
   * 
   * @example
   * true
   */
  isPagedResponse?: boolean;
  /**
   * @remarks
   * The SQL script.
   * 
   * @example
   * select a from t
   */
  script?: string;
  /**
   * @remarks
   * The data source information about the API generated in script mode.
   */
  scriptConnection?: ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection;
  /**
   * @remarks
   * The request parameters of the API generated in script mode.
   */
  scriptRequestParameters?: ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters[];
  /**
   * @remarks
   * The response parameters of the API generated in script mode.
   */
  scriptResponseParameters?: ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters[];
  static names(): { [key: string]: string } {
    return {
      isPagedResponse: 'IsPagedResponse',
      script: 'Script',
      scriptConnection: 'ScriptConnection',
      scriptRequestParameters: 'ScriptRequestParameters',
      scriptResponseParameters: 'ScriptResponseParameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isPagedResponse: 'boolean',
      script: 'string',
      scriptConnection: ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection,
      scriptRequestParameters: { 'type': 'array', 'itemType': ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters },
      scriptResponseParameters: { 'type': 'array', 'itemType': ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection extends $tea.Model {
  /**
   * @remarks
   * The data source ID.
   * 
   * @example
   * 123
   */
  connectionId?: number;
  /**
   * @remarks
   * The name of the table in the data source.
   * 
   * @example
   * t
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      connectionId: 'ConnectionId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionId: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
   * 
   * @example
   * column1
   */
  columnName?: string;
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * default1
   */
  defaultValue?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example1
   */
  exampleValue?: string;
  /**
   * @remarks
   * Indicates whether the parameter is required.
   * 
   * @example
   * true
   */
  isRequiredParameter?: boolean;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description1
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param1
   */
  parameterName?: string;
  /**
   * @remarks
   * The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates the Equal operator. The value 1 indicates the Like operator. The value 2 indicates the Const operator. The value 3 indicates the In operator. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
   * 
   * @example
   * 0
   */
  parameterOperator?: number;
  /**
   * @remarks
   * The position of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the parameter is in the URL path of the request. The value 1 indicates that the parameter is in the Query parameter of the request URL. The value 2 indicates that the parameter is in the request header. The value 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
   * 
   * @example
   * 0
   */
  parameterPosition?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      defaultValue: 'DefaultValue',
      exampleValue: 'ExampleValue',
      isRequiredParameter: 'IsRequiredParameter',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
      parameterOperator: 'ParameterOperator',
      parameterPosition: 'ParameterPosition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      defaultValue: 'string',
      exampleValue: 'string',
      isRequiredParameter: 'boolean',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
      parameterOperator: 'number',
      parameterPosition: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters extends $tea.Model {
  /**
   * @remarks
   * The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
   * 
   * @example
   * column2
   */
  columnName?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example2
   */
  exampleValue?: string;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description2
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param2
   */
  parameterName?: string;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      exampleValue: 'ExampleValue',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      exampleValue: 'string',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBodyDataApisWizardDetails extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the entries are returned by page.
   * 
   * @example
   * true
   */
  isPagedResponse?: boolean;
  /**
   * @remarks
   * The data source information about the API generated in wizard mode.
   */
  wizardConnection?: ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection;
  /**
   * @remarks
   * The request parameters of the API generated in wizard mode.
   */
  wizardRequestParameters?: ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters[];
  /**
   * @remarks
   * The response parameters of the API generated in wizard mode.
   */
  wizardResponseParameters?: ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters[];
  static names(): { [key: string]: string } {
    return {
      isPagedResponse: 'IsPagedResponse',
      wizardConnection: 'WizardConnection',
      wizardRequestParameters: 'WizardRequestParameters',
      wizardResponseParameters: 'WizardResponseParameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      isPagedResponse: 'boolean',
      wizardConnection: ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection,
      wizardRequestParameters: { 'type': 'array', 'itemType': ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters },
      wizardResponseParameters: { 'type': 'array', 'itemType': ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBodyDataApis extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * 10002
   */
  apiId?: number;
  /**
   * @remarks
   * The type of the API. Valid values: 0, 1, and 2. The value 0 indicates that the API is generated in wizard mode. The value 1 indicates that the API is generated in script mode. The value 2 indicates that the API is generated by registration.
   * 
   * @example
   * 0
   */
  apiMode?: number;
  /**
   * @remarks
   * The name of the API.
   */
  apiName?: string;
  /**
   * @remarks
   * The path of the API.
   * 
   * @example
   * /test/1
   */
  apiPath?: string;
  /**
   * @remarks
   * The time when the API was created.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  createdTime?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the creator of the API.
   * 
   * @example
   * 1234567
   */
  creatorId?: string;
  /**
   * @remarks
   * The description of the API.
   */
  description?: string;
  /**
   * @remarks
   * The folder ID.
   * 
   * @example
   * 0
   */
  folderId?: number;
  /**
   * @remarks
   * The group ID.
   * 
   * @example
   * abcde123456789
   */
  groupId?: string;
  /**
   * @remarks
   * The time when the API was last modified.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the user who last modified the API.
   * 
   * @example
   * 2345678
   */
  operatorId?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The list of fields.
   */
  protocols?: number[];
  /**
   * @remarks
   * The details of the API generated by registration. This parameter is returned only if the API is generated by registration.
   */
  registrationDetails?: ListDataServiceApisResponseBodyDataApisRegistrationDetails;
  /**
   * @remarks
   * The request method of the API. Valid values: 0, 1, 2, and 3. The value 0 indicates the GET method. The value 1 indicates the POST method. The value 2 indicates the PUT method. The value 3 indicates the DELETE method. APIs generated in wizard or script mode support the GET and POST methods. APIs generated by registration support the GET, POST, PUT, and DELETE methods.
   * 
   * @example
   * 0
   */
  requestMethod?: number;
  /**
   * @remarks
   * The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
   * 
   * @example
   * 0
   */
  responseContentType?: number;
  /**
   * @remarks
   * The details of the API generated in script mode. This parameter is returned only if the API is generated in script mode.
   */
  scriptDetails?: ListDataServiceApisResponseBodyDataApisScriptDetails;
  /**
   * @remarks
   * The status of the API. Valid values: 0 and 1. The value 0 indicates that the API is not published. The value 1 indicates that the API is published.
   * 
   * @example
   * 0
   */
  status?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 10000
   */
  tenantId?: number;
  /**
   * @remarks
   * The timeout period of the API request. Unit: milliseconds.
   * 
   * @example
   * 10000
   */
  timeout?: number;
  /**
   * @remarks
   * The scope in which the API is visible. Valid values: 0 and 1. The value 0 indicates that the API is visible within the workspace. The value 1 indicates that the API is visible only to its owner.
   * 
   * @example
   * 0
   */
  visibleRange?: number;
  /**
   * @remarks
   * The details of the API generated in wizard mode. This parameter is returned only if the API is generated in wizard mode.
   */
  wizardDetails?: ListDataServiceApisResponseBodyDataApisWizardDetails;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiMode: 'ApiMode',
      apiName: 'ApiName',
      apiPath: 'ApiPath',
      createdTime: 'CreatedTime',
      creatorId: 'CreatorId',
      description: 'Description',
      folderId: 'FolderId',
      groupId: 'GroupId',
      modifiedTime: 'ModifiedTime',
      operatorId: 'OperatorId',
      projectId: 'ProjectId',
      protocols: 'Protocols',
      registrationDetails: 'RegistrationDetails',
      requestMethod: 'RequestMethod',
      responseContentType: 'ResponseContentType',
      scriptDetails: 'ScriptDetails',
      status: 'Status',
      tenantId: 'TenantId',
      timeout: 'Timeout',
      visibleRange: 'VisibleRange',
      wizardDetails: 'WizardDetails',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      apiMode: 'number',
      apiName: 'string',
      apiPath: 'string',
      createdTime: 'string',
      creatorId: 'string',
      description: 'string',
      folderId: 'number',
      groupId: 'string',
      modifiedTime: 'string',
      operatorId: 'string',
      projectId: 'number',
      protocols: { 'type': 'array', 'itemType': 'number' },
      registrationDetails: ListDataServiceApisResponseBodyDataApisRegistrationDetails,
      requestMethod: 'number',
      responseContentType: 'number',
      scriptDetails: ListDataServiceApisResponseBodyDataApisScriptDetails,
      status: 'number',
      tenantId: 'number',
      timeout: 'number',
      visibleRange: 'number',
      wizardDetails: ListDataServiceApisResponseBodyDataApisWizardDetails,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApisResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of APIs in the development state.
   */
  apis?: ListDataServiceApisResponseBodyDataApis[];
  /**
   * @remarks
   * The page number. The value of this parameter is the same as that of the PageNumber parameter in the request.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 50. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apis: 'Apis',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apis: { 'type': 'array', 'itemType': ListDataServiceApisResponseBodyDataApis },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApplicationsResponseBodyDataApplications extends $tea.Model {
  /**
   * @remarks
   * The application ID.
   * 
   * @example
   * 20000
   */
  applicationId?: number;
  /**
   * @remarks
   * The name of the application.
   * 
   * @example
   * My application
   */
  applicationName?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      applicationName: 'ApplicationName',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'number',
      applicationName: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceApplicationsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The basic information of the applications.
   */
  applications?: ListDataServiceApplicationsResponseBodyDataApplications[];
  /**
   * @remarks
   * The page number. The value of this parameter is the same as that of the PageNumber parameter in the request.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      applications: 'Applications',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applications: { 'type': 'array', 'itemType': ListDataServiceApplicationsResponseBodyDataApplications },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * 10002
   */
  apiId?: number;
  /**
   * @remarks
   * The name of the API.
   * 
   * @example
   * My API Name
   */
  apiName?: string;
  /**
   * @remarks
   * The path of the API.
   * 
   * @example
   * /test/1
   */
  apiPath?: string;
  /**
   * @remarks
   * The status of the API. Valid values: 0 and 1. The value 0 indicates that the API is not published. The value 1 indicates that the API is published.
   * 
   * @example
   * 0
   */
  apiStatus?: number;
  /**
   * @remarks
   * The time when the API was created.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  createdTime?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the API owner.
   * 
   * @example
   * 12345
   */
  creatorId?: string;
  /**
   * @remarks
   * The time when the access permissions on the API were granted.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  grantCreatedTime?: string;
  /**
   * @remarks
   * The expiration time of the access permissions granted on the API.
   * 
   * @example
   * 2020-06-24T00:21:01+0800
   */
  grantEndTime?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the user who granted the access permissions on the API.
   * 
   * @example
   * 23456
   */
  grantOperatorId?: string;
  /**
   * @remarks
   * The group ID.
   * 
   * @example
   * abcde123456789
   */
  groupId?: string;
  /**
   * @remarks
   * The time when the API was last updated.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 10001
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiName: 'ApiName',
      apiPath: 'ApiPath',
      apiStatus: 'ApiStatus',
      createdTime: 'CreatedTime',
      creatorId: 'CreatorId',
      grantCreatedTime: 'GrantCreatedTime',
      grantEndTime: 'GrantEndTime',
      grantOperatorId: 'GrantOperatorId',
      groupId: 'GroupId',
      modifiedTime: 'ModifiedTime',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      apiName: 'string',
      apiPath: 'string',
      apiStatus: 'number',
      createdTime: 'string',
      creatorId: 'string',
      grantCreatedTime: 'string',
      grantEndTime: 'string',
      grantOperatorId: 'string',
      groupId: 'string',
      modifiedTime: 'string',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceAuthorizedApisResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The APIs that you are authorized to access.
   */
  apiAuthorizedList?: ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList[];
  /**
   * @remarks
   * The page number. The value of this parameter is the same as that of the PageNumber parameter in the request.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apiAuthorizedList: 'ApiAuthorizedList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiAuthorizedList: { 'type': 'array', 'itemType': ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceFoldersResponseBodyFolderPagingResultFolders extends $tea.Model {
  /**
   * @remarks
   * The time when the folder was created.
   * 
   * @example
   * 2020-09-24T18:37:51+0800
   */
  createdTime?: string;
  /**
   * @remarks
   * The folder ID.
   * 
   * @example
   * 11
   */
  folderId?: number;
  /**
   * @remarks
   * The name of the folder.
   * 
   * @example
   * test1
   */
  folderName?: string;
  /**
   * @remarks
   * The ID of the business process to which the folder belongs.
   * 
   * @example
   * ds_1234
   */
  groupId?: string;
  /**
   * @remarks
   * The time when the folder was last modified.
   * 
   * @example
   * 2020-09-24T18:37:51+0800
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The ID of the parent folder. The ID of the root folder in a business process is 0, and the ID of a folder created by a user in a business process is greater than 0.
   * 
   * @example
   * 0
   */
  parentId?: number;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 10001
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 10002
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      folderId: 'FolderId',
      folderName: 'FolderName',
      groupId: 'GroupId',
      modifiedTime: 'ModifiedTime',
      parentId: 'ParentId',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'string',
      folderId: 'number',
      folderName: 'string',
      groupId: 'string',
      modifiedTime: 'string',
      parentId: 'number',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceFoldersResponseBodyFolderPagingResult extends $tea.Model {
  /**
   * @remarks
   * The folders.
   */
  folders?: ListDataServiceFoldersResponseBodyFolderPagingResultFolders[];
  /**
   * @remarks
   * The page number. The value of this parameter is the same as that of the PageNumber parameter in the request.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      folders: 'Folders',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folders: { 'type': 'array', 'itemType': ListDataServiceFoldersResponseBodyFolderPagingResultFolders },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceGroupsResponseBodyGroupPagingResultGroups extends $tea.Model {
  /**
   * @remarks
   * The ID of the API Gateway group to which the workflow is bound.
   * 
   * @example
   * 100abc
   */
  apiGatewayGroupId?: string;
  /**
   * @remarks
   * The time when the business process was created.
   * 
   * @example
   * 2020-09-24T18:37:51+0800
   */
  createdTime?: string;
  /**
   * @remarks
   * The user identifier (UID) of the creator of the business process. The value of this parameter may be empty for creators of some existing business processes.
   * 
   * @example
   * 10001
   */
  creatorId?: string;
  /**
   * @remarks
   * The description of the business process.
   * 
   * @example
   * Test
   */
  description?: string;
  /**
   * @remarks
   * The business process ID.
   * 
   * @example
   * ds_123abc
   */
  groupId?: string;
  /**
   * @remarks
   * The name of the business process.
   * 
   * @example
   * Test
   */
  groupName?: string;
  /**
   * @remarks
   * The time when the business process was modified.
   * 
   * @example
   * 2020-09-24T18:37:51+0800
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 10002
   */
  projectId?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 10003
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      apiGatewayGroupId: 'ApiGatewayGroupId',
      createdTime: 'CreatedTime',
      creatorId: 'CreatorId',
      description: 'Description',
      groupId: 'GroupId',
      groupName: 'GroupName',
      modifiedTime: 'ModifiedTime',
      projectId: 'ProjectId',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiGatewayGroupId: 'string',
      createdTime: 'string',
      creatorId: 'string',
      description: 'string',
      groupId: 'string',
      groupName: 'string',
      modifiedTime: 'string',
      projectId: 'number',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServiceGroupsResponseBodyGroupPagingResult extends $tea.Model {
  /**
   * @remarks
   * The business processes.
   */
  groups?: ListDataServiceGroupsResponseBodyGroupPagingResultGroups[];
  /**
   * @remarks
   * The page number. The value of this parameter is the same as that of the PageNumber parameter in the request.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      groups: 'Groups',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groups: { 'type': 'array', 'itemType': ListDataServiceGroupsResponseBodyGroupPagingResultGroups },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1001
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * fail to call
   */
  errorMessage?: string;
  /**
   * @remarks
   * The solution used to fix the error.
   * 
   * @example
   * retry
   */
  errorSolution?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      errorSolution: 'ErrorSolution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      errorSolution: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters extends $tea.Model {
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * default1
   */
  defaultValue?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example1
   */
  exampleValue?: string;
  /**
   * @remarks
   * Indicates whether the request parameter is required.
   * 
   * @example
   * true
   */
  isRequiredParameter?: boolean;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description1
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * name1
   */
  parameterName?: string;
  /**
   * @remarks
   * The operator used for the value of the parameter. Valid values:
   * 
   * *   0: Equal
   * *   1: Like
   * *   2: Const
   * *   3: In
   * 
   * APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
   * 
   * @example
   * 0
   */
  parameterOperator?: number;
  /**
   * @remarks
   * The position of the parameter. Valid values:
   * 
   * *   0: indicates that the parameter is in the URL path of the request.
   * *   1: indicates that the parameter is in the Query parameter of the request URL.
   * *   2: indicates that the parameter is in the request header.
   * *   3: indicates that the parameter is in the request body.
   * 
   * APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
   * 
   * @example
   * 0
   */
  parameterPosition?: number;
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      exampleValue: 'ExampleValue',
      isRequiredParameter: 'IsRequiredParameter',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
      parameterOperator: 'ParameterOperator',
      parameterPosition: 'ParameterPosition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'string',
      exampleValue: 'string',
      isRequiredParameter: 'boolean',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
      parameterOperator: 'number',
      parameterPosition: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails extends $tea.Model {
  /**
   * @remarks
   * The sample error response of the API.
   * 
   * @example
   * {"success": false}
   */
  failedResultSample?: string;
  /**
   * @remarks
   * The error codes returned for the API generated by registration.
   */
  registrationErrorCodes?: ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes[];
  /**
   * @remarks
   * The request parameters of the API generated by registration.
   */
  registrationRequestParameters?: ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters[];
  /**
   * @remarks
   * The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
   * 
   * @example
   * 0
   */
  serviceContentType?: number;
  /**
   * @remarks
   * The URL of the backend service.
   * 
   * @example
   * http://example.aliyundoc.com
   */
  serviceHost?: string;
  /**
   * @remarks
   * The path of the backend service.
   * 
   * @example
   * /index
   */
  servicePath?: string;
  /**
   * @remarks
   * The description of the request body initiated to call the backend service.
   * 
   * @example
   * {"abc":1}
   */
  serviceRequestBodyDescription?: string;
  /**
   * @remarks
   * The sample success response of the API.
   * 
   * @example
   * {"success": true}
   */
  successfulResultSample?: string;
  static names(): { [key: string]: string } {
    return {
      failedResultSample: 'FailedResultSample',
      registrationErrorCodes: 'RegistrationErrorCodes',
      registrationRequestParameters: 'RegistrationRequestParameters',
      serviceContentType: 'ServiceContentType',
      serviceHost: 'ServiceHost',
      servicePath: 'ServicePath',
      serviceRequestBodyDescription: 'ServiceRequestBodyDescription',
      successfulResultSample: 'SuccessfulResultSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedResultSample: 'string',
      registrationErrorCodes: { 'type': 'array', 'itemType': ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes },
      registrationRequestParameters: { 'type': 'array', 'itemType': ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters },
      serviceContentType: 'number',
      serviceHost: 'string',
      servicePath: 'string',
      serviceRequestBodyDescription: 'string',
      successfulResultSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection extends $tea.Model {
  /**
   * @remarks
   * The data source ID.
   * 
   * @example
   * 123
   */
  connectionId?: number;
  /**
   * @remarks
   * The name of the table in the data source.
   * 
   * @example
   * t
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      connectionId: 'ConnectionId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionId: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1001
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * fail to call
   */
  errorMessage?: string;
  /**
   * @remarks
   * The solution used to fix the error.
   * 
   * @example
   * retry
   */
  errorSolution?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      errorSolution: 'ErrorSolution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      errorSolution: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters extends $tea.Model {
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * default1
   */
  defaultValue?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example1
   */
  exampleValue?: string;
  /**
   * @remarks
   * Indicates whether the request parameter is required.
   * 
   * @example
   * true
   */
  isRequiredParameter?: boolean;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * 
   * Advanced scripts also support the following data types:
   * 
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description1
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param1
   */
  parameterName?: string;
  /**
   * @remarks
   * The operator used for the value of the parameter. Valid values:
   * 
   * *   0: Equal
   * *   1: Like
   * *   2: Const
   * *   3: In
   * 
   * APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
   * 
   * @example
   * 0
   */
  parameterOperator?: number;
  /**
   * @remarks
   * The position of the parameter. Valid values:
   * 
   * *   0: indicates that the parameter is in the URL path of the request.
   * *   1: indicates that the parameter is in the Query parameter of the request URL.
   * *   2: indicates that the parameter is in the request header.
   * *   3: indicates that the parameter is in the request body.
   * 
   * APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
   * 
   * @example
   * 0
   */
  parameterPosition?: number;
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      exampleValue: 'ExampleValue',
      isRequiredParameter: 'IsRequiredParameter',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
      parameterOperator: 'ParameterOperator',
      parameterPosition: 'ParameterPosition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'string',
      exampleValue: 'string',
      isRequiredParameter: 'boolean',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
      parameterOperator: 'number',
      parameterPosition: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters extends $tea.Model {
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example2
   */
  exampleValue?: string;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description2
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param2
   */
  parameterName?: string;
  static names(): { [key: string]: string } {
    return {
      exampleValue: 'ExampleValue',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exampleValue: 'string',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApisScriptDetails extends $tea.Model {
  /**
   * @remarks
   * The sample error response of the API.
   * 
   * @example
   * {"success": false}
   */
  failedResultSample?: string;
  /**
   * @remarks
   * Indicates whether the entries are returned by page.
   * 
   * @example
   * true
   */
  isPagedResponse?: boolean;
  /**
   * @remarks
   * The SQL script.
   * 
   * @example
   * select a from t
   */
  script?: string;
  /**
   * @remarks
   * The data source information about the API generated in script mode.
   */
  scriptConnection?: ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection;
  /**
   * @remarks
   * The error codes returned for the API generated in script mode.
   */
  scriptErrorCodes?: ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes[];
  /**
   * @remarks
   * The request parameters of the API generated in script mode.
   */
  scriptRequestParameters?: ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters[];
  /**
   * @remarks
   * The response parameters of the API generated in script mode.
   */
  scriptResponseParameters?: ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters[];
  /**
   * @remarks
   * The sample success response of the API.
   * 
   * @example
   * {"success": true}
   */
  successfulResultSample?: string;
  static names(): { [key: string]: string } {
    return {
      failedResultSample: 'FailedResultSample',
      isPagedResponse: 'IsPagedResponse',
      script: 'Script',
      scriptConnection: 'ScriptConnection',
      scriptErrorCodes: 'ScriptErrorCodes',
      scriptRequestParameters: 'ScriptRequestParameters',
      scriptResponseParameters: 'ScriptResponseParameters',
      successfulResultSample: 'SuccessfulResultSample',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedResultSample: 'string',
      isPagedResponse: 'boolean',
      script: 'string',
      scriptConnection: ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection,
      scriptErrorCodes: { 'type': 'array', 'itemType': ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes },
      scriptRequestParameters: { 'type': 'array', 'itemType': ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters },
      scriptResponseParameters: { 'type': 'array', 'itemType': ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters },
      successfulResultSample: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection extends $tea.Model {
  /**
   * @remarks
   * The data source ID.
   * 
   * @example
   * 123
   */
  connectionId?: number;
  /**
   * @remarks
   * The name of the table in the data source.
   * 
   * @example
   * t
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      connectionId: 'ConnectionId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectionId: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes extends $tea.Model {
  /**
   * @remarks
   * The error code.
   * 
   * @example
   * 1001
   */
  errorCode?: string;
  /**
   * @remarks
   * The error message.
   * 
   * @example
   * fail to call
   */
  errorMessage?: string;
  /**
   * @remarks
   * The solution used to fix the error.
   * 
   * @example
   * retry
   */
  errorSolution?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      errorSolution: 'ErrorSolution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorMessage: 'string',
      errorSolution: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters extends $tea.Model {
  /**
   * @remarks
   * The default value.
   * 
   * @example
   * default1
   */
  defaultValue?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example1
   */
  exampleValue?: string;
  /**
   * @remarks
   * Indicates whether the request parameter is required.
   * 
   * @example
   * true
   */
  isRequiredParameter?: boolean;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description1
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param1
   */
  parameterName?: string;
  /**
   * @remarks
   * The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates the Equal operator. The value 1 indicates the Like operator. The value 2 indicates the Const operator. The value 3 indicates the In operator. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
   * 
   * @example
   * 0
   */
  parameterOperator?: number;
  /**
   * @remarks
   * The position of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the parameter is in the URL path of the request. The value 1 indicates that the parameter is in the Query parameter of the request URL. The value 2 indicates that the parameter is in the request header. The value 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
   * 
   * @example
   * 0
   */
  parameterPosition?: number;
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      exampleValue: 'ExampleValue',
      isRequiredParameter: 'IsRequiredParameter',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
      parameterOperator: 'ParameterOperator',
      parameterPosition: 'ParameterPosition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'string',
      exampleValue: 'string',
      isRequiredParameter: 'boolean',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
      parameterOperator: 'number',
      parameterPosition: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters extends $tea.Model {
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * example2
   */
  exampleValue?: string;
  /**
   * @remarks
   * The data type of the parameter. Valid values:
   * 
   * *   0: String
   * *   1: Int
   * *   2: Long
   * *   3: Float
   * *   4: Double
   * *   5: Boolean
   * *   6: StringList
   * *   7: IntList
   * *   8: LongList
   * *   9: FloatList
   * *   10: DoubleList
   * *   11: BooleanList
   * 
   * @example
   * 0
   */
  parameterDataType?: number;
  /**
   * @remarks
   * The description.
   * 
   * @example
   * description2
   */
  parameterDescription?: string;
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * param2
   */
  parameterName?: string;
  static names(): { [key: string]: string } {
    return {
      exampleValue: 'ExampleValue',
      parameterDataType: 'ParameterDataType',
      parameterDescription: 'ParameterDescription',
      parameterName: 'ParameterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exampleValue: 'string',
      parameterDataType: 'number',
      parameterDescription: 'string',
      parameterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApisWizardDetails extends $tea.Model {
  /**
   * @remarks
   * The sample error response of the API.
   * 
   * @example
   * {"success": false}
   */
  failedResultSample?: string;
  /**
   * @remarks
   * Indicates whether the entries are returned by page.
   * 
   * @example
   * true
   */
  isPagedResponse?: boolean;
  /**
   * @remarks
   * The sample success response of the API.
   * 
   * @example
   * {"success": true}
   */
  successfulResultSample?: string;
  /**
   * @remarks
   * The data source information about the API generated in wizard mode.
   */
  wizardConnection?: ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection;
  /**
   * @remarks
   * The error codes returned for the API generated in wizard mode.
   */
  wizardErrorCodes?: ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes[];
  /**
   * @remarks
   * The request parameters of the API generated in wizard mode.
   */
  wizardRequestParameters?: ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters[];
  /**
   * @remarks
   * The response parameters of the API generated in wizard mode.
   */
  wizardResponseParameters?: ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters[];
  static names(): { [key: string]: string } {
    return {
      failedResultSample: 'FailedResultSample',
      isPagedResponse: 'IsPagedResponse',
      successfulResultSample: 'SuccessfulResultSample',
      wizardConnection: 'WizardConnection',
      wizardErrorCodes: 'WizardErrorCodes',
      wizardRequestParameters: 'WizardRequestParameters',
      wizardResponseParameters: 'WizardResponseParameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failedResultSample: 'string',
      isPagedResponse: 'boolean',
      successfulResultSample: 'string',
      wizardConnection: ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection,
      wizardErrorCodes: { 'type': 'array', 'itemType': ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes },
      wizardRequestParameters: { 'type': 'array', 'itemType': ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters },
      wizardResponseParameters: { 'type': 'array', 'itemType': ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyDataApis extends $tea.Model {
  /**
   * @remarks
   * The API ID.
   * 
   * @example
   * 10002
   */
  apiId?: number;
  /**
   * @remarks
   * The type of the API. Valid values: 0, 1, and 2. The value 0 indicates that the API is generated in wizard mode. The value 1 indicates that the API is generated in script mode. The value 2 indicates that the API is generated by registration.
   * 
   * @example
   * 0
   */
  apiMode?: number;
  /**
   * @remarks
   * The name of the API.
   */
  apiName?: string;
  /**
   * @remarks
   * The path of the API.
   * 
   * @example
   * /test/1
   */
  apiPath?: string;
  /**
   * @remarks
   * The time when the API was created.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  createdTime?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the creator of the API.
   * 
   * @example
   * 1234567
   */
  creatorId?: string;
  /**
   * @remarks
   * The description.
   */
  description?: string;
  /**
   * @remarks
   * The group ID.
   * 
   * @example
   * ab123
   */
  groupId?: string;
  /**
   * @remarks
   * The time when the API was last modified.
   * 
   * @example
   * 2020-06-23T00:21:01+0800
   */
  modifiedTime?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the user who last modified the API.
   * 
   * @example
   * 2345678
   */
  operatorId?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 10000
   */
  projectId?: number;
  /**
   * @remarks
   * The protocol used by the API. Valid values: 0 and 1. The value 0 indicates HTTP. The value 1 indicates HTTPS.
   */
  protocols?: number[];
  /**
   * @remarks
   * The details of the API generated by registration. This parameter is returned only if the API is generated by registration.
   */
  registrationDetails?: ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails;
  /**
   * @remarks
   * The request method of the API. Valid values: 0, 1, 2, and 3. The value 0 indicates the GET method. The value 1 indicates the POST method. The value 2 indicates the PUT method. The value 3 indicates the DELETE method. APIs generated in wizard or script mode support the GET and POST methods. APIs generated by registration support the GET, POST, PUT, and DELETE methods.
   * 
   * @example
   * 0
   */
  requestMethod?: number;
  /**
   * @remarks
   * The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
   * 
   * @example
   * 0
   */
  responseContentType?: number;
  /**
   * @remarks
   * The details of the API generated in script mode. This parameter is returned only if the API is generated in script mode.
   */
  scriptDetails?: ListDataServicePublishedApisResponseBodyDataApisScriptDetails;
  /**
   * @remarks
   * The status of the API. Valid values: 0 and 1. The value 0 indicates that the API is not published. The value 1 indicates that the API is published.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 10001
   */
  tenantId?: number;
  /**
   * @remarks
   * The timeout period of the API request. Unit: milliseconds.
   * 
   * @example
   * 10000
   */
  timeout?: number;
  /**
   * @remarks
   * The scope in which the API is visible. Valid values: 0 and 1. The value 0 indicates that the API is visible within the workspace. The value 1 indicates that the API is visible only to its owner.
   * 
   * @example
   * 0
   */
  visibleRange?: number;
  /**
   * @remarks
   * The details of the API generated in wizard mode. This parameter is returned only if the API is generated in wizard mode.
   */
  wizardDetails?: ListDataServicePublishedApisResponseBodyDataApisWizardDetails;
  static names(): { [key: string]: string } {
    return {
      apiId: 'ApiId',
      apiMode: 'ApiMode',
      apiName: 'ApiName',
      apiPath: 'ApiPath',
      createdTime: 'CreatedTime',
      creatorId: 'CreatorId',
      description: 'Description',
      groupId: 'GroupId',
      modifiedTime: 'ModifiedTime',
      operatorId: 'OperatorId',
      projectId: 'ProjectId',
      protocols: 'Protocols',
      registrationDetails: 'RegistrationDetails',
      requestMethod: 'RequestMethod',
      responseContentType: 'ResponseContentType',
      scriptDetails: 'ScriptDetails',
      status: 'Status',
      tenantId: 'TenantId',
      timeout: 'Timeout',
      visibleRange: 'VisibleRange',
      wizardDetails: 'WizardDetails',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiId: 'number',
      apiMode: 'number',
      apiName: 'string',
      apiPath: 'string',
      createdTime: 'string',
      creatorId: 'string',
      description: 'string',
      groupId: 'string',
      modifiedTime: 'string',
      operatorId: 'string',
      projectId: 'number',
      protocols: { 'type': 'array', 'itemType': 'number' },
      registrationDetails: ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails,
      requestMethod: 'number',
      responseContentType: 'number',
      scriptDetails: ListDataServicePublishedApisResponseBodyDataApisScriptDetails,
      status: 'number',
      tenantId: 'number',
      timeout: 'number',
      visibleRange: 'number',
      wizardDetails: ListDataServicePublishedApisResponseBodyDataApisWizardDetails,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataServicePublishedApisResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The information about the APIs in the published state.
   */
  apis?: ListDataServicePublishedApisResponseBodyDataApis[];
  /**
   * @remarks
   * The page number. The value of this parameter is the same as that of the PageNumber parameter in the request.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Valid values: 1 to 100. Default value: 10.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      apis: 'Apis',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apis: { 'type': 'array', 'itemType': ListDataServicePublishedApisResponseBodyDataApis },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourcesResponseBodyDataDataSources extends $tea.Model {
  /**
   * @remarks
   * The ID of the compute engine with which the data source is associated.
   * 
   * @example
   * 123
   */
  bindingCalcEngineId?: number;
  /**
   * @remarks
   * The status of the data source. Valid values:
   * 
   * *   1: The data source is accessible.
   * *   2: The data source is inaccessible.
   * 
   * @example
   * 1
   */
  connectStatus?: number;
  /**
   * @remarks
   * The data connection string. The value of this parameter is in the JSON format. Examples of connection strings of common data sources:
   * 
   * *   MaxCompute
   * 
   *         {
   *           "pubEndpoint": "http://service.cn.maxcompute.aliyun.com/api",
   *           "accessId": "xxxxxxx",
   *           "securityToken": null,
   *           "endpoint": "http://service.cn.maxcompute.aliyun-inc.com/api",
   *           "accessKey": "***",
   *           "name": "PRE_PROJECT_A_engine",
   *           "project": "PRE_PROJECT_A",
   *           "vpcEndpoint": "http://service.cn.maxcompute.aliyun-inc.com/api",
   *           "region": "cn-shanghai",
   *           "authType": "2"
   *         }
   * 
   * *   MySQL
   * 
   *         {
   *           "configType": "1",
   *           "database": "mysql_d111b",
   *           "instanceName": "rm-xxxxxx",
   *           "password": "***",
   *           "rdsOwnerId": "12133xxxxxx",
   *           "tag": "rds",
   *           "username": "mysql_db111"
   *         }
   * 
   * *   ApsaraDB RDS for SQL Server
   * 
   *         {
   *           "configType": "1",
   *           "jdbcUrl": "jdbc:sqlserver://rm-xxxxx.sqlserver.rds.aliyuncs.com:1433;DatabaseName=sqlserver_db1",
   *           "password": "***",
   *           "tag": "public",
   *           "username": "sqlserver_db111"
   *         }
   * 
   * *   Object Storage Service (OSS)
   * 
   *         {
   *           "accessId": "LTAINbR9Uxxxx",
   *           "accessKey": "***",
   *           "bucket": "bigxxx1223",
   *           "configType": "1",
   *           "endpoint": "http://oss-cn-hangzhou.aliyuncs.com",
   *           "tag": "public"
   *         }
   * 
   * *   ApsaraDB RDS for PostgreSQL
   * 
   *         {
   *           "configType": "1",
   *           "database": "cdp_xxx",
   *           "instanceName": "rm-xxxx",
   *           "password": "***",
   *           "rdsOwnerId": "121xxxxx",
   *           "tag": "rds",
   *           "username": "cdp_xxx"
   *         }
   * 
   * *   AnalyticDB for MySQL
   * 
   *         {
   *           "configType": "1",
   *           "password": "***",
   *           "schema": "ads_demo",
   *           "tag": "public",
   *           "url": "ads-xxx-xxxx.cn-hangzhou-1.ads.aliyuncs.com:3029",
   *           "username": "lslslsls"
   *         }
   * 
   * @example
   * {"pubEndpoint":"http://service.cn.maxcompute.aliyun.com/api","accessId":"TMP.3KecGjvzy3i8MYfn2BGHgF7EHGyBFZcHm7GgngrABVRyvvKQrfF5kskR36xP361C3dqwbGo7SGYptAeGyiTwHXqLaBUvYC","securityToken":null,"endpoint":"http://service.cn.maxcompute.aliyun-inc.com/api","accessKey":"***","name":"PRE_PROJECT_A_engine","project":"PRE_PROJECT_A","vpcEndpoint":"http://service.cn.maxcompute.aliyun-inc.com/api","region":"cn-shanghai","authType":"2"}
   */
  content?: string;
  /**
   * @remarks
   * The type of the data source. Valid values:
   * 
   * *   odps
   * *   mysql
   * *   rds
   * *   oss
   * *   sqlserver
   * *   polardb
   * *   oracle
   * *   mongodb
   * *   emr
   * *   postgresql
   * *   analyticdb_for_mysql
   * *   hybriddb_for_postgresql
   * *   holo
   * 
   * @example
   * rds
   */
  dataSourceType?: string;
  /**
   * @remarks
   * Indicates whether the compute engine that is associated with the data source is the default compute engine used by data sources of the same type.
   * 
   * @example
   * false
   */
  defaultEngine?: boolean;
  /**
   * @remarks
   * The description of the data source.
   * 
   * @example
   * a connection
   */
  description?: string;
  /**
   * @remarks
   * The environment in which the data source is used. Valid values:
   * 
   * *   0: development environment
   * *   1: production environment
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The time when the data source was created. Example: Mar 17, 2021 4:09:32 PM.
   * 
   * @example
   * Mar 17, 2021 4:09:32 PM
   */
  gmtCreate?: string;
  /**
   * @remarks
   * The time when the data source was last modified. Example: Mar 17, 2021 4:09:32 PM.
   * 
   * @example
   * Mar 17, 2021 4:09:32 PM
   */
  gmtModified?: string;
  /**
   * @remarks
   * The data source ID.
   * 
   * @example
   * 1
   */
  id?: number;
  /**
   * @remarks
   * The name of the data source.
   * 
   * @example
   * abc
   */
  name?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to last modify the data source.
   * 
   * @example
   * 193543050****
   */
  operator?: string;
  /**
   * @remarks
   * The ID of the workspace to which the data source belongs.
   * 
   * @example
   * 123
   */
  projectId?: number;
  /**
   * @remarks
   * The sequence number of the data source. Data sources are sorted in descending order based on the value of this parameter.
   * 
   * @example
   * 300
   */
  sequence?: number;
  /**
   * @remarks
   * Indicates whether the data source is a shared data source.
   * 
   * @example
   * false
   */
  shared?: boolean;
  /**
   * @remarks
   * The status of the data source. Valid values:
   * 
   * *   1: The data source is accessible.
   * *   2: The data source is inaccessible.
   * 
   * @example
   * 1
   */
  status?: number;
  /**
   * @remarks
   * The subtype of the data source. This parameter takes effect only when the DataSourceType parameter is set to rds.
   * 
   * @example
   * mysql
   */
  subType?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 1234567
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      bindingCalcEngineId: 'BindingCalcEngineId',
      connectStatus: 'ConnectStatus',
      content: 'Content',
      dataSourceType: 'DataSourceType',
      defaultEngine: 'DefaultEngine',
      description: 'Description',
      envType: 'EnvType',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      operator: 'Operator',
      projectId: 'ProjectId',
      sequence: 'Sequence',
      shared: 'Shared',
      status: 'Status',
      subType: 'SubType',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindingCalcEngineId: 'number',
      connectStatus: 'number',
      content: 'string',
      dataSourceType: 'string',
      defaultEngine: 'boolean',
      description: 'string',
      envType: 'number',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      name: 'string',
      operator: 'string',
      projectId: 'number',
      sequence: 'number',
      shared: 'boolean',
      status: 'number',
      subType: 'string',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDataSourcesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The data sources.
   */
  dataSources?: ListDataSourcesResponseBodyDataDataSources[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of data sources.
   * 
   * @example
   * 233
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataSources: 'DataSources',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSources: { 'type': 'array', 'itemType': ListDataSourcesResponseBodyDataDataSources },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeploymentsResponseBodyDataDeployments extends $tea.Model {
  /**
   * @remarks
   * The time when the deployment package was created.
   * 
   * @example
   * 1593877765000
   */
  createTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the user who created the deployment package.
   * 
   * @example
   * 2003****
   */
  creator?: string;
  /**
   * @remarks
   * The error message returned when the deployment package failed.
   * 
   * @example
   * OK
   */
  errorMessage?: string;
  /**
   * @remarks
   * The time when the deployment package was run. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1593877765000
   */
  executeTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the user who ran the deployment package.
   * 
   * @example
   * 2003****
   */
  executor?: string;
  /**
   * @remarks
   * The deployment package ID. You can call the [GetDeployment](https://help.aliyun.com/document_detail/173950.html) operation to obtain the ID.
   * 
   * @example
   * 11111
   */
  id?: number;
  /**
   * @remarks
   * The name of the deployment package.
   * 
   * @example
   * auto_created
   */
  name?: string;
  /**
   * @remarks
   * The status of the deployment package. Valid values:
   * 
   * *   0: The deployment package is ready.
   * *   1: The deployment package is deployed.
   * *   2: The deployment package fails to be deployed.
   * *   6: The deployment package is rejected.
   * 
   * @example
   * 1
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      creator: 'Creator',
      errorMessage: 'ErrorMessage',
      executeTime: 'ExecuteTime',
      executor: 'Executor',
      id: 'Id',
      name: 'Name',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creator: 'string',
      errorMessage: 'string',
      executeTime: 'number',
      executor: 'string',
      id: 'number',
      name: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListDeploymentsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The deployment packages.
   */
  deployments?: ListDeploymentsResponseBodyDataDeployments[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 13
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      deployments: 'Deployments',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deployments: { 'type': 'array', 'itemType': ListDeploymentsResponseBodyDataDeployments },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEnabledExtensionsForProjectResponseBodyExtensions extends $tea.Model {
  /**
   * @remarks
   * The creator of the extension.
   * 
   * @example
   * 3444434343555
   */
  createUser?: string;
  /**
   * @remarks
   * The unique code of the extension.
   * 
   * @example
   * a94a8e23bc0b4dfab9a5e4d2f374d645
   */
  extensionCode?: string;
  /**
   * @remarks
   * The description of the extension.
   */
  extensionDesc?: string;
  /**
   * @remarks
   * The name of the extension.
   */
  extensionName?: string;
  /**
   * @remarks
   * The modifier of the extension.
   * 
   * @example
   * 34452335611988
   */
  modifyUser?: string;
  /**
   * @remarks
   * The owner ID.
   * 
   * @example
   * 21323672*******55500
   */
  owner?: string;
  /**
   * @remarks
   * The parameter settings of the extension. For more information, see [Configure extension parameters](https://help.aliyun.com/document_detail/405354.html).
   * 
   * @example
   * extension.fileType.23.deploy-file.enabled=true
   */
  parameterSetting?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 529889518659842
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      createUser: 'CreateUser',
      extensionCode: 'ExtensionCode',
      extensionDesc: 'ExtensionDesc',
      extensionName: 'ExtensionName',
      modifyUser: 'ModifyUser',
      owner: 'Owner',
      parameterSetting: 'ParameterSetting',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createUser: 'string',
      extensionCode: 'string',
      extensionDesc: 'string',
      extensionName: 'string',
      modifyUser: 'string',
      owner: 'string',
      parameterSetting: 'string',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListEntitiesByTagsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The entities.
   */
  entityList?: Entity[];
  /**
   * @remarks
   * A pagination token. It can be used in the next request to retrieve a new page of results.
   * 
   * @example
   * 12345
   */
  nextToken?: string;
  static names(): { [key: string]: string } {
    return {
      entityList: 'EntityList',
      nextToken: 'NextToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityList: { 'type': 'array', 'itemType': Entity },
      nextToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExtensionsResponseBodyPagingInfoExtensionsBindEventList extends $tea.Model {
  /**
   * @remarks
   * The code of the event.
   * 
   * @example
   * commit-file
   */
  eventCode?: string;
  /**
   * @remarks
   * The name of the event.
   */
  eventName?: string;
  static names(): { [key: string]: string } {
    return {
      eventCode: 'EventCode',
      eventName: 'EventName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventCode: 'string',
      eventName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExtensionsResponseBodyPagingInfoExtensions extends $tea.Model {
  /**
   * @remarks
   * The list of extension point events.
   */
  bindEventList?: ListExtensionsResponseBodyPagingInfoExtensionsBindEventList[];
  /**
   * @remarks
   * The unique code of the extension.
   */
  extensionCode?: string;
  /**
   * @remarks
   * The description of the extension.
   */
  extensionDesc?: string;
  /**
   * @remarks
   * The name of the extension.
   */
  extensionName?: string;
  /**
   * @remarks
   * The ID of the RAM user.
   * 
   * @example
   * 2003****
   */
  owner?: string;
  /**
   * @remarks
   * The state of the extension. Valid values: 0: Testing 1: Publishing 3: Disabled 4: Processing 5: Approved 6: Approve Failed
   * 
   * @example
   * 0
   */
  status?: number;
  static names(): { [key: string]: string } {
    return {
      bindEventList: 'BindEventList',
      extensionCode: 'ExtensionCode',
      extensionDesc: 'ExtensionDesc',
      extensionName: 'ExtensionName',
      owner: 'Owner',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindEventList: { 'type': 'array', 'itemType': ListExtensionsResponseBodyPagingInfoExtensionsBindEventList },
      extensionCode: 'string',
      extensionDesc: 'string',
      extensionName: 'string',
      owner: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListExtensionsResponseBodyPagingInfo extends $tea.Model {
  /**
   * @remarks
   * The list of extensions.
   */
  extensions?: ListExtensionsResponseBodyPagingInfoExtensions[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 12
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      extensions: 'Extensions',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extensions: { 'type': 'array', 'itemType': ListExtensionsResponseBodyPagingInfoExtensions },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo extends $tea.Model {
  /**
   * @remarks
   * The code of the node type. The codes and names of node types have the following mappings: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3)
   * 
   * @example
   * 10
   */
  nodeType?: number;
  /**
   * @remarks
   * The name of the node type. The codes and names of node types have the following mappings: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3)
   * 
   * @example
   * ODPS SQL
   */
  nodeTypeName?: string;
  static names(): { [key: string]: string } {
    return {
      nodeType: 'NodeType',
      nodeTypeName: 'NodeTypeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeType: 'number',
      nodeTypeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileTypeResponseBodyNodeTypeInfoList extends $tea.Model {
  /**
   * @remarks
   * The information about the node type.
   */
  nodeTypeInfo?: ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 50
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 127
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      nodeTypeInfo: 'NodeTypeInfo',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeTypeInfo: { 'type': 'array', 'itemType': ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileVersionsResponseBodyDataFileVersions extends $tea.Model {
  /**
   * @remarks
   * The type of the change to the file of the current version. Valid values: CREATE, UPDATE, and DELETE.
   * 
   * @example
   * UPDATE
   */
  changeType?: string;
  /**
   * @remarks
   * The description of the file version.
   */
  comment?: string;
  /**
   * @remarks
   * The time when the file version was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1593881265000
   */
  commitTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used to create the file of the current version.
   * 
   * @example
   * 73842342****
   */
  commitUser?: string;
  /**
   * @remarks
   * The code in the file of the current version.
   * 
   * @example
   * SHOW TABLES;
   */
  fileContent?: string;
  /**
   * @remarks
   * The name of the file of the current version.
   * 
   * @example
   * ods_user_info_d
   */
  fileName?: string;
  /**
   * @remarks
   * The basic information about the file of the current version.
   * 
   * @example
   * {"fileName":"ods_user_info_d","fileType":10}
   */
  filePropertyContent?: string;
  /**
   * @remarks
   * The version of the file.
   * 
   * @example
   * 2
   */
  fileVersion?: number;
  /**
   * @remarks
   * Indicates whether the file version is the same as the latest file version in the production environment.
   * 
   * @example
   * false
   */
  isCurrentProd?: boolean;
  /**
   * @remarks
   * The scheduling configurations for the node that corresponds to the file of the current version.
   * 
   * @example
   * {"cycleType":0,"cronExpress":"00 05 00 * * ?"}
   */
  nodeContent?: string;
  /**
   * @remarks
   * The ID of the auto triggered node that corresponds to the file of the current version.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The status of the file of the current version. Valid values: COMMITTING, COMMITTED, CHECK_OK, PACKAGED, DEPLOYING, DEPLOYED, and CANCELLED.
   * 
   * @example
   * COMMITTED
   */
  status?: string;
  /**
   * @remarks
   * The functional module to which the file belongs. Valid values: NORMAL, MANUAL, MANUAL_BIZ, SKIP, ADHOCQUERY, and COMPONENT. The value SKIP indicates that the node corresponding to the file is run in dry-run mode.
   * 
   * @example
   * NORMAL
   */
  useType?: string;
  static names(): { [key: string]: string } {
    return {
      changeType: 'ChangeType',
      comment: 'Comment',
      commitTime: 'CommitTime',
      commitUser: 'CommitUser',
      fileContent: 'FileContent',
      fileName: 'FileName',
      filePropertyContent: 'FilePropertyContent',
      fileVersion: 'FileVersion',
      isCurrentProd: 'IsCurrentProd',
      nodeContent: 'NodeContent',
      nodeId: 'NodeId',
      status: 'Status',
      useType: 'UseType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      changeType: 'string',
      comment: 'string',
      commitTime: 'number',
      commitUser: 'string',
      fileContent: 'string',
      fileName: 'string',
      filePropertyContent: 'string',
      fileVersion: 'number',
      isCurrentProd: 'boolean',
      nodeContent: 'string',
      nodeId: 'number',
      status: 'string',
      useType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileVersionsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The details of the file version.
   */
  fileVersions?: ListFileVersionsResponseBodyDataFileVersions[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 13
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      fileVersions: 'FileVersions',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileVersions: { 'type': 'array', 'itemType': ListFileVersionsResponseBodyDataFileVersions },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFilesResponseBodyDataFiles extends $tea.Model {
  absoluteFolderPath?: string;
  /**
   * @remarks
   * Specifies whether the automatic parsing feature is enabled for the file. Valid values:
   * 
   * *   true: The automatic parsing feature is enabled for the file.
   * *   false: The automatic parsing feature is not enabled for the file.
   * 
   * This parameter is equivalent to the Analyze Code parameter in the Dependencies section of the Properties panel in the [DataWorks console](https://workbench.data.aliyun.com/console).
   * 
   * @example
   * true
   */
  autoParsing?: boolean;
  /**
   * @remarks
   * The ID of the workflow to which the file belongs. This parameter is deprecated and replaced by the BusinessId parameter.
   * 
   * @example
   * 300000
   */
  bizId?: number;
  /**
   * @remarks
   * The ID of the workflow to which the file belongs.
   * 
   * @example
   * 300000
   */
  businessId?: number;
  /**
   * @remarks
   * Indicates whether the latest code in the file is committed. Valid values: 0 and 1. The value 0 indicates that the latest code in the file is not committed. The value 1 indicates that the latest code in the file is committed.
   * 
   * @example
   * 1
   */
  commitStatus?: number;
  /**
   * @remarks
   * The ID of the compute engine instance that is used to run the node that corresponds to the file.
   * 
   * @example
   * odps_first
   */
  connectionName?: string;
  /**
   * @remarks
   * This parameter is deprecated. You can call the [GetFile](~~173954#doc-api-dataworks-public-GetFile~~) operation to query the details of the file.
   * 
   * @example
   * SHOW TABLES;
   */
  content?: string;
  /**
   * @remarks
   * The time when the file was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1593950832000
   */
  createTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to create the file.
   * 
   * @example
   * 382762****
   */
  createUser?: string;
  /**
   * @remarks
   * The latest version number of the file.
   * 
   * @example
   * 2
   */
  currentVersion?: number;
  /**
   * @remarks
   * The description of the file.
   * 
   * @example
   * my test datastudio file
   */
  fileDescription?: string;
  /**
   * @remarks
   * The ID of the folder to which the file belongs.
   * 
   * @example
   * 2735c2****
   */
  fileFolderId?: string;
  /**
   * @remarks
   * The ID of the file.
   * 
   * @example
   * 10000001
   */
  fileId?: number;
  /**
   * @remarks
   * The name of the file.
   * 
   * @example
   * ods_user_info_d
   */
  fileName?: string;
  /**
   * @remarks
   * The type of the code in the file. Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3).
   * 
   * @example
   * 10
   */
  fileType?: number;
  /**
   * @remarks
   * Indicates whether the file needs to be uploaded to MaxCompute if the file is a MaxCompute resource file.
   * 
   * This parameter is returned only if the file is a MaxCompute resource file.
   * 
   * @example
   * false
   */
  isMaxCompute?: boolean;
  /**
   * @remarks
   * The time when the file was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1593950832000
   */
  lastEditTime?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used to last modify the file.
   * 
   * @example
   * 38748246285727
   */
  lastEditUser?: string;
  /**
   * @remarks
   * The ID of the auto triggered node that is generated in the scheduling system after the file is committed.
   * 
   * @example
   * 300001
   */
  nodeId?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the file owner.
   * 
   * @example
   * 3872572****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the node group file to which the current file belongs. This parameter is returned only if the current file is an inner file of the node group file.
   * 
   * @example
   * -1
   */
  parentId?: number;
  /**
   * @remarks
   * The module to which the file belongs. Valid values:
   * 
   * *   NORMAL: The file is used for DataStudio.
   * *   MANUAL: The file is used for a manually triggered node.
   * *   MANUAL_BIZ: The file is used for a manually triggered workflow.
   * *   SKIP: The files is used for a dry-run node in DataStudio.
   * *   ADHOCQUERY: The file is used for an ad hoc query.
   * *   COMPONENT: The file is used for a snippet.
   * 
   * @example
   * NORMAL
   */
  useType?: string;
  static names(): { [key: string]: string } {
    return {
      absoluteFolderPath: 'AbsoluteFolderPath',
      autoParsing: 'AutoParsing',
      bizId: 'BizId',
      businessId: 'BusinessId',
      commitStatus: 'CommitStatus',
      connectionName: 'ConnectionName',
      content: 'Content',
      createTime: 'CreateTime',
      createUser: 'CreateUser',
      currentVersion: 'CurrentVersion',
      fileDescription: 'FileDescription',
      fileFolderId: 'FileFolderId',
      fileId: 'FileId',
      fileName: 'FileName',
      fileType: 'FileType',
      isMaxCompute: 'IsMaxCompute',
      lastEditTime: 'LastEditTime',
      lastEditUser: 'LastEditUser',
      nodeId: 'NodeId',
      owner: 'Owner',
      parentId: 'ParentId',
      useType: 'UseType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      absoluteFolderPath: 'string',
      autoParsing: 'boolean',
      bizId: 'number',
      businessId: 'number',
      commitStatus: 'number',
      connectionName: 'string',
      content: 'string',
      createTime: 'number',
      createUser: 'string',
      currentVersion: 'number',
      fileDescription: 'string',
      fileFolderId: 'string',
      fileId: 'number',
      fileName: 'string',
      fileType: 'number',
      isMaxCompute: 'boolean',
      lastEditTime: 'number',
      lastEditUser: 'string',
      nodeId: 'number',
      owner: 'string',
      parentId: 'number',
      useType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFilesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The details of the files.
   */
  files?: ListFilesResponseBodyDataFiles[];
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 13
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      files: 'Files',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      files: { 'type': 'array', 'itemType': ListFilesResponseBodyDataFiles },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFoldersResponseBodyDataFolders extends $tea.Model {
  /**
   * @remarks
   * The folder ID.
   * 
   * @example
   * 2735c2****
   */
  folderId?: string;
  /**
   * @remarks
   * The path of the folder.
   */
  folderPath?: string;
  static names(): { [key: string]: string } {
    return {
      folderId: 'FolderId',
      folderPath: 'FolderPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folderId: 'string',
      folderPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFoldersResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of folders.
   */
  folders?: ListFoldersResponseBodyDataFolders[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 13
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      folders: 'Folders',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      folders: { 'type': 'array', 'itemType': ListFoldersResponseBodyDataFolders },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInnerNodesResponseBodyPagingNodes extends $tea.Model {
  /**
   * @remarks
   * The baseline ID.
   * 
   * @example
   * 1234
   */
  baselineId?: number;
  /**
   * @remarks
   * The workflow ID.
   * 
   * @example
   * 123
   */
  businessId?: number;
  /**
   * @remarks
   * The connection string.
   * 
   * @example
   * odps_first
   */
  connection?: string;
  /**
   * @remarks
   * The CRON expression.
   * 
   * @example
   * 00 00 00 * * ?
   */
  cronExpress?: string;
  /**
   * @remarks
   * The description of the inner node.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The table and partition filter expression in Data Quality that are associated with the inner node.
   * 
   * @example
   * [{"projectName":"ztjy_dim","tableName":"dim_user_agent_manage_area_a","partition":"ds\\u003d$[yyyy-mm-dd-1]"}]
   */
  dqcDescription?: string;
  /**
   * @remarks
   * Indicates whether the inner node is associated with a monitoring rule in Data Quality. Valid values: 0 and 1. The value 0 indicates that the inner node is associated with a monitoring rule in Data Quality. The value 1 indicates that the inner node is not associated with a monitoring rule in Data Quality.
   * 
   * @example
   * 1
   */
  dqcType?: string;
  /**
   * @remarks
   * The inner node ID.
   * 
   * @example
   * 12
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the inner node.
   * 
   * @example
   * liux_test_n****
   */
  nodeName?: string;
  /**
   * @remarks
   * The owner ID.
   * 
   * @example
   * 1933****36551
   */
  ownerId?: string;
  /**
   * @remarks
   * The additional parameters.
   * 
   * @example
   * a=b
   */
  paramValues?: string;
  /**
   * @remarks
   * The priority of the inner node. Valid values: 1, 3, 5, 7, and 8.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The type of the inner node.
   * 
   * @example
   * ODPS_SQL
   */
  programType?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 123
   */
  projectId?: number;
  /**
   * @remarks
   * The interval at which the inner node is rerun after the inner node fails to run.
   * 
   * @example
   * 60
   */
  repeatInterval?: number;
  /**
   * @remarks
   * Indicates whether the inner node can be rerun.
   * 
   * @example
   * true
   */
  repeatability?: boolean;
  /**
   * @remarks
   * The name of the resource group.
   */
  resGroupName?: string;
  /**
   * @remarks
   * The scheduling type of the inner node. Valid values:
   * 
   * *   NORMAL: The inner node is an auto triggered node.
   * *   MANUAL: The inner node is a manually triggered node. The scheduling system does not run the node on a regular basis.
   * *   PAUSE: The inner node is a paused node.
   * *   SKIP: The inner node is a dry-run node. Dry-run nodes are started as scheduled, but the scheduling system sets the status of the nodes to successful when it starts to run them.
   * 
   * @example
   * NORMAL
   */
  schedulerType?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      businessId: 'BusinessId',
      connection: 'Connection',
      cronExpress: 'CronExpress',
      description: 'Description',
      dqcDescription: 'DqcDescription',
      dqcType: 'DqcType',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      ownerId: 'OwnerId',
      paramValues: 'ParamValues',
      priority: 'Priority',
      programType: 'ProgramType',
      projectId: 'ProjectId',
      repeatInterval: 'RepeatInterval',
      repeatability: 'Repeatability',
      resGroupName: 'ResGroupName',
      schedulerType: 'SchedulerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      businessId: 'number',
      connection: 'string',
      cronExpress: 'string',
      description: 'string',
      dqcDescription: 'string',
      dqcType: 'string',
      nodeId: 'number',
      nodeName: 'string',
      ownerId: 'string',
      paramValues: 'string',
      priority: 'number',
      programType: 'string',
      projectId: 'number',
      repeatInterval: 'number',
      repeatability: 'boolean',
      resGroupName: 'string',
      schedulerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInnerNodesResponseBodyPaging extends $tea.Model {
  /**
   * @remarks
   * The list of inner nodes.
   */
  nodes?: ListInnerNodesResponseBodyPagingNodes[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of inner nodes returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      nodes: 'Nodes',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodes: { 'type': 'array', 'itemType': ListInnerNodesResponseBodyPagingNodes },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceAmountResponseBodyInstanceCounts extends $tea.Model {
  /**
   * @remarks
   * The number of auto triggered node instances.
   * 
   * @example
   * 9527
   */
  count?: number;
  /**
   * @remarks
   * The data timestamp at which the number of auto triggered node instances was obtained. This value is a UNIX timestamp.
   * 
   * @example
   * 1623772800000
   */
  date?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      date: 'Date',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      date: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceHistoryResponseBodyInstances extends $tea.Model {
  /**
   * @remarks
   * The time when the instance started to be run. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1590416703313
   */
  beginRunningTime?: number;
  /**
   * @remarks
   * The time when the instance started to wait for resources.
   * 
   * @example
   * 1590416703313
   */
  beginWaitResTime?: number;
  /**
   * @remarks
   * The time when the instance started to wait to be scheduled.
   * 
   * @example
   * 1590416703313
   */
  beginWaitTimeTime?: number;
  /**
   * @remarks
   * The data timestamp of the instance. In most cases, the value is one day before the time when the instance was run.
   * 
   * @example
   * 1590336000000
   */
  bizdate?: number;
  /**
   * @remarks
   * The time when the instance was generated.
   * 
   * @example
   * 1590416703313
   */
  createTime?: number;
  /**
   * @remarks
   * The time when the node started to be run. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1590422400000
   */
  cycTime?: number;
  /**
   * @remarks
   * The workflow ID.
   * 
   * @example
   * 33845
   */
  dagId?: number;
  /**
   * @remarks
   * Indicates whether the instance is associated with a monitoring rule in Data Quality. Valid values:
   * 
   * *   0: The instance is associated with a monitoring rule in Data Quality.
   * *   1: The instance is not associated with a monitoring rule in Data Quality.
   * 
   * @example
   * 1
   */
  dagType?: string;
  /**
   * @remarks
   * The error message. This parameter is deprecated. You can call the GetInstanceLog operation to query the error information related to the node.
   * 
   * @example
   * error message
   */
  errorMessage?: string;
  /**
   * @remarks
   * The time when the running of the node was complete. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
   * 
   * @example
   * 1590416703313
   */
  finishTime?: number;
  /**
   * @remarks
   * The historical record number of the instance.
   * 
   * @example
   * 1
   */
  instanceHistoryId?: number;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * 1234
   */
  instanceId?: number;
  /**
   * @remarks
   * The time when the node was last modified.
   * 
   * @example
   * 1590416703313
   */
  modifyTime?: number;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 33115
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * kzh
   */
  nodeName?: string;
  /**
   * @remarks
   * The status of the node that generates the instance. Valid values:
   * 
   * *   NOT_RUN: The node is not run.
   * *   WAIT_TIME: The node is waiting for the scheduling time to arrive.
   * *   WAIT_RESOURCE: The node is waiting for resources.
   * *   RUNNING: The node is running.
   * *   CHECKING: Data quality is being checked for the node.
   * *   CHECKING_CONDITION: Branch conditions are being checked for the node.
   * *   FAILURE: The node fails to be run.
   * *   SUCCESS: The node is successfully run.
   * 
   * @example
   * NOT_RUN
   */
  status?: string;
  /**
   * @remarks
   * The scheduling type of the node. Valid values:
   * 
   * *   NORMAL(0): The node is an auto triggered node. The scheduling system regularly runs the node.
   * *   MANUAL(1): The node is a manually triggered node. The scheduling system does not regularly run the node.
   * *   PAUSE(2): The node is a frozen node. The scheduling system regularly runs the node but sets the status of the node to failed when the scheduling system starts to run the node.
   * *   SKIP(3): The node is a dry-run node. The scheduling system regularly runs the node but sets the status of the node to successful when the scheduling system starts to run the node.
   * *   SKIP_UNCHOOSE(4): The node is an unselected node in a temporary workflow. This type of node exists only in temporary workflows. The scheduling system sets the status of the node to successful when the scheduling system starts to run the node.
   * *   SKIP_CYCLE(5): The node is a node that is scheduled by the week or month and is waiting for the scheduling time to arrive. The scheduling system regularly runs the node but sets the status of the node to successful when the scheduling system starts to run the node.
   * *   CONDITION_UNCHOOSE(6): The node is not selected by its ancestor branch node and is run as a dry-run node.
   * *   REALTIME_DEPRECATED(7): The node has instances that are generated in real time but deprecated. The scheduling system sets the status of the node to successful.
   * 
   * @example
   * NORMAL(0)
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      beginRunningTime: 'BeginRunningTime',
      beginWaitResTime: 'BeginWaitResTime',
      beginWaitTimeTime: 'BeginWaitTimeTime',
      bizdate: 'Bizdate',
      createTime: 'CreateTime',
      cycTime: 'CycTime',
      dagId: 'DagId',
      dagType: 'DagType',
      errorMessage: 'ErrorMessage',
      finishTime: 'FinishTime',
      instanceHistoryId: 'InstanceHistoryId',
      instanceId: 'InstanceId',
      modifyTime: 'ModifyTime',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      status: 'Status',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginRunningTime: 'number',
      beginWaitResTime: 'number',
      beginWaitTimeTime: 'number',
      bizdate: 'number',
      createTime: 'number',
      cycTime: 'number',
      dagId: 'number',
      dagType: 'string',
      errorMessage: 'string',
      finishTime: 'number',
      instanceHistoryId: 'number',
      instanceId: 'number',
      modifyTime: 'number',
      nodeId: 'number',
      nodeName: 'string',
      status: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBodyDataInstances extends $tea.Model {
  /**
   * @remarks
   * The type of the workflow. Valid values:
   * 
   * *   DAILY: The workflow is used to run auto triggered nodes.
   * *   MANUAL: The workflow is used to run manually triggered nodes.
   * *   SMOKE_TEST: The workflow is used to perform smoke testing.
   * *   SUPPLY_DATA: The workflow is used to backfill data.
   * 
   * @example
   * 123123
   */
  baselineId?: number;
  /**
   * @remarks
   * The time when the instance started to run.
   * 
   * @example
   * 1590416703313
   */
  beginRunningTime?: number;
  /**
   * @remarks
   * The time when the node stopped running.
   * 
   * @example
   * 1590416703313
   */
  beginWaitResTime?: number;
  /**
   * @remarks
   * The ID of the request. You can use the ID to locate logs and troubleshoot issues.
   * 
   * @example
   * 1590416703313
   */
  beginWaitTimeTime?: number;
  /**
   * @remarks
   * The number of entries to return on each page. Default value: 10. Maximum value: 100.
   * 
   * You cannot specify the sorting method for the instances to be returned by this operation. By default, the instances are sorted in descending order of the time when the instances were created.
   * 
   * @example
   * 1590336000000
   */
  bizdate?: number;
  /**
   * @remarks
   * The ID of the workflow to which the node belongs.
   * 
   * @example
   * 123
   */
  businessId?: number;
  /**
   * @remarks
   * The number of times the node can be rerun. The value of this parameter can be empty or an integer that is greater than or equal to 0.
   * 
   * *   If the value of this parameter is empty, the number of times that the node can be rerun is not specified.
   * *   If the value of this parameter is 0, the node cannot be rerun.
   * *   If the value of this parameter is a positive integer such as n, the node can be rerun n times. For example, if the value of this parameter is 1, the node can be rerun once. If the value of this parameter is 2, the node can be rerun twice.
   * 
   * @example
   * odps_first
   */
  connection?: string;
  /**
   * @remarks
   * The interval at which the node is rerun after the node fails to run. Unit: milliseconds.
   * 
   * @example
   * 1590416703313
   */
  createTime?: number;
  /**
   * @remarks
   * The ID of the node. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the ID of the node.
   * 
   * @example
   * Test
   */
  createUser?: string;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * 1590422400000
   */
  cycTime?: number;
  /**
   * @remarks
   * The time when the instance started to wait for resources.
   * 
   * @example
   * 33845
   */
  dagId?: number;
  /**
   * @remarks
   * The data timestamp of the instance. In most cases, the value is one day before the time when the instance was run.
   * 
   * @example
   * DAILY
   */
  dagType?: string;
  /**
   * @remarks
   * The operation that you want to perform.
   * 
   * @example
   * [{"projectName":"ztjy_dim","tableName":"dim_user_agent_manage_area_a","partition":"ds\\u003d$[yyyy-mm-dd-1]"}]
   */
  dqcDescription?: string;
  /**
   * @remarks
   * The status of the node. Valid values:
   * 
   * *   NOT_RUN: The node is not run.
   * *   WAIT_TIME: The node is waiting for the scheduling time to arrive.
   * *   WAIT_RESOURCE: The node is waiting for resources.
   * *   RUNNING: The node is running.
   * *   CHECKING: Data quality is being checked for the node.
   * *   CHECKING_CONDITION: Branch conditions are being checked for the node.
   * *   FAILURE: The node fails to run.
   * *   SUCCESS: The node is successfully run.
   * 
   * @example
   * 1
   */
  dqcType?: number;
  /**
   * @remarks
   * The name of the account that is used to run the instance. For example, if an account named Test was used to run the instance to backfill data, the value of this parameter is Test.
   * 
   * @example
   * error message
   */
  errorMessage?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the workspace administrator. You can log on to the Alibaba Cloud Management Console and view the ID on the Security Settings page of the Account Center console.
   * 
   * @example
   * 1590416703313
   */
  finishTime?: number;
  /**
   * @remarks
   * The number of the page to return. Minimum value:1. Maximum value: 100.
   * 
   * @example
   * 1234
   */
  instanceId?: number;
  /**
   * @remarks
   * The name of the workflow. You can call the [ListBusiness](https://help.aliyun.com/document_detail/173945.html) operation to query the name of the workflow.
   * 
   * @example
   * 1590416703313
   */
  modifyTime?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment. The value DEV indicates the development environment.
   * 
   * @example
   * 33115
   */
  nodeId?: number;
  /**
   * @remarks
   * The ID of the workflow.
   * 
   * @example
   * kzh
   */
  nodeName?: string;
  /**
   * @remarks
   * The table and partition filter expression in Data Quality that are associated with the node.
   * 
   * @example
   * bizdate=$bizdate tbods=$tbods
   */
  paramValues?: string;
  /**
   * @remarks
   * The total number of instances.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The type of the node. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the type of the node.
   * 
   * @example
   * 123456
   */
  relatedFlowId?: number;
  /**
   * @remarks
   * The scheduling type of the node. Valid values:
   * 
   * *   NORMAL(0): The node is an auto triggered node. The scheduling system regularly runs the node.
   * 
   * *   MANUAL(1): The node is a manually triggered node. The scheduling system does not regularly run the node.
   * 
   * *   PAUSE(2): The node is a frozen node. The scheduling system regularly runs the node but sets the status of the node to failed when the scheduling system starts to run the node.
   * 
   * *   SKIP(3): The node is a dry-run node. The scheduling system regularly runs the node but sets the status of the node to succeeded when the scheduling system starts to run the node.
   * 
   * *   SKIP_UNCHOOSE(4): The node is an unselected node in a temporary workflow. This type of node exists only in temporary workflows. The scheduling system sets the status of the node to succeeded when the scheduling system starts to run the node.
   * 
   * *   SKIP_CYCLE(5): The node is a node that is scheduled by week or month and is waiting for the scheduling time to arrive. The scheduling system regularly runs the node but sets the status of the node to succeeded when the scheduling system starts to run the node.
   * 
   * *   CONDITION_UNCHOOSE(6): The node is not selected by its ancestor branch node and is run as a dry-run node.
   * 
   *     REALTIME_DEPRECATED(7): The node has instances that are generated in real time but deprecated. The scheduling system sets the status of the node to succeeded.
   * 
   * @example
   * 60000
   */
  repeatInterval?: number;
  /**
   * @remarks
   * The status of the node. Valid values:
   * 
   * *   NOT_RUN: The node is not run.
   * *   WAIT_TIME: The node is waiting for the scheduling time to arrive.
   * *   WAIT_RESOURCE: The node is waiting for resources.
   * *   RUNNING: The node is running.
   * *   CHECKING: Data quality is being checked for the node.
   * *   CHECKING_CONDITION: Branch conditions are being checked for the node.
   * *   FAILURE: The node fails to run.
   * *   SUCCESS: The node is successfully run.
   * 
   * @example
   * true
   */
  repeatability?: boolean;
  /**
   * @remarks
   * The data timestamp of the instances that you want to query. Specify the timestamp in the yyyy-MM-dd HH:mm:ss format.
   * 
   * @example
   * NOT_RUN
   */
  status?: string;
  /**
   * @remarks
   * The ID of the workspace. You can call the [ListProjects](https://help.aliyun.com/document_detail/178393.html) operation to query the ID of the workspace.
   * 
   * @example
   * 0
   */
  taskRerunTime?: number;
  /**
   * @remarks
   * The information about the instances.
   * 
   * @example
   * NORMAL(0)
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      beginRunningTime: 'BeginRunningTime',
      beginWaitResTime: 'BeginWaitResTime',
      beginWaitTimeTime: 'BeginWaitTimeTime',
      bizdate: 'Bizdate',
      businessId: 'BusinessId',
      connection: 'Connection',
      createTime: 'CreateTime',
      createUser: 'CreateUser',
      cycTime: 'CycTime',
      dagId: 'DagId',
      dagType: 'DagType',
      dqcDescription: 'DqcDescription',
      dqcType: 'DqcType',
      errorMessage: 'ErrorMessage',
      finishTime: 'FinishTime',
      instanceId: 'InstanceId',
      modifyTime: 'ModifyTime',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      paramValues: 'ParamValues',
      priority: 'Priority',
      relatedFlowId: 'RelatedFlowId',
      repeatInterval: 'RepeatInterval',
      repeatability: 'Repeatability',
      status: 'Status',
      taskRerunTime: 'TaskRerunTime',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      beginRunningTime: 'number',
      beginWaitResTime: 'number',
      beginWaitTimeTime: 'number',
      bizdate: 'number',
      businessId: 'number',
      connection: 'string',
      createTime: 'number',
      createUser: 'string',
      cycTime: 'number',
      dagId: 'number',
      dagType: 'string',
      dqcDescription: 'string',
      dqcType: 'number',
      errorMessage: 'string',
      finishTime: 'number',
      instanceId: 'number',
      modifyTime: 'number',
      nodeId: 'number',
      nodeName: 'string',
      paramValues: 'string',
      priority: 'number',
      relatedFlowId: 'number',
      repeatInterval: 'number',
      repeatability: 'boolean',
      status: 'string',
      taskRerunTime: 'number',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstancesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the node. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the name of the node.
   */
  instances?: ListInstancesResponseBodyDataInstances[];
  /**
   * @remarks
   * The time when the node was scheduled to run.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The end of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The priority of the instance. Valid values: 1, 3, 5, 7, and 8.
   * 
   * A greater value indicates a higher priority. Default value: 1.
   * 
   * @example
   * 66
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: { 'type': 'array', 'itemType': ListInstancesResponseBodyDataInstances },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLineageResponseBodyDataDataEntityListRelationList extends $tea.Model {
  /**
   * @remarks
   * The data channel. Valid values:
   * 
   *     FIRST_PARTY: DataWorks platformTHIRD_PARTY: user registration
   * 
   * @example
   * THIRD_PARTY
   */
  channel?: string;
  /**
   * @remarks
   * The name of the data source.
   * 
   * @example
   * mysql
   */
  datasource?: string;
  /**
   * @remarks
   * The unique relationship ID.
   * 
   * @example
   * aaabbccddguid
   */
  guid?: string;
  /**
   * @remarks
   * The task type, which is used to describe the relationship between entities, such as SQL-based calculation, mapping based on report fields, or API operation definition.
   * 
   * @example
   * sql
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      channel: 'Channel',
      datasource: 'Datasource',
      guid: 'Guid',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channel: 'string',
      datasource: 'string',
      guid: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLineageResponseBodyDataDataEntityList extends $tea.Model {
  /**
   * @remarks
   * The time when the lineage was generated.
   * 
   * @example
   * 1686215809269
   */
  createTimestamp?: number;
  /**
   * @remarks
   * The information about the entity.
   */
  entity?: Entity;
  /**
   * @remarks
   * The array of the relationship structure.
   */
  relationList?: ListLineageResponseBodyDataDataEntityListRelationList[];
  static names(): { [key: string]: string } {
    return {
      createTimestamp: 'CreateTimestamp',
      entity: 'Entity',
      relationList: 'RelationList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTimestamp: 'number',
      entity: Entity,
      relationList: { 'type': 'array', 'itemType': ListLineageResponseBodyDataDataEntityListRelationList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListLineageResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The array of the entity structure.
   */
  dataEntityList?: ListLineageResponseBodyDataDataEntityList[];
  /**
   * @remarks
   * A pagination token. It can be used in the next request to retrieve a new page of results.
   * 
   * @example
   * nextTokenFromRequest-xxxsd-ff
   */
  nextToken?: string;
  static names(): { [key: string]: string } {
    return {
      dataEntityList: 'DataEntityList',
      nextToken: 'NextToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataEntityList: { 'type': 'array', 'itemType': ListLineageResponseBodyDataDataEntityList },
      nextToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListManualDagInstancesResponseBodyInstances extends $tea.Model {
  /**
   * @remarks
   * The time when the instance started to run.
   * 
   * @example
   * 1605178414676
   */
  beginRunningTime?: number;
  /**
   * @remarks
   * The time when the instance started to wait for resources.
   * 
   * @example
   * 1605178414676
   */
  beginWaitResTime?: number;
  /**
   * @remarks
   * The time when the instance started to wait to be scheduled.
   * 
   * @example
   * 1605178414676
   */
  beginWaitTimeTime?: number;
  /**
   * @remarks
   * The data timestamp of the instance. In most cases, the value is one day before the time when the instance was run.
   * 
   * @example
   * 1605178414676
   */
  bizDate?: number;
  /**
   * @remarks
   * The time when the instance was generated.
   * 
   * @example
   * 1605178414676
   */
  createTime?: number;
  /**
   * @remarks
   * The name of the account that is used to run the instance. For example, if you use an account named Test to run the instance, the value of this parameter is Test.
   * 
   * @example
   * Test
   */
  createUser?: string;
  /**
   * @remarks
   * The time when the instance was scheduled to run.
   * 
   * @example
   * 1605178414676
   */
  cycTime?: number;
  /**
   * @remarks
   * The ID of the DAG for the instance in the manually triggered workflow.
   * 
   * @example
   * 350850491
   */
  dagId?: number;
  /**
   * @remarks
   * The type of the manually triggered workflow.
   * 
   * @example
   * 5
   */
  dagType?: string;
  /**
   * @remarks
   * The time when the instance finished running.
   * 
   * @example
   * 1605178414676
   */
  finishTime?: number;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * 11726873619
   */
  instanceId?: number;
  /**
   * @remarks
   * The time when the instance was last modified.
   * 
   * @example
   * 1605178414676
   */
  modifyTime?: number;
  /**
   * @remarks
   * The ID of the node in the manually triggered workflow.
   * 
   * @example
   * 37851
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * test2
   */
  nodeName?: string;
  /**
   * @remarks
   * The parameters related to the instance.
   * 
   * @example
   * xxx=yyy
   */
  paramValues?: string;
  /**
   * @remarks
   * The status of the instance. Valid values:
   * 
   * *   NOT_RUN: The instance is not run.
   * *   WAIT_TIME: The instance is waiting for its scheduling time to arrive.
   * *   WAIT_RESOURCE: The instance is waiting for resources.
   * *   RUNNING: The instance is running.
   * *   CHECKING: Data quality is being checked for the instance.
   * *   CHECKING_CONDITION: Branch conditions are being checked for the instance.
   * *   FAILURE: The instance fails to be run.
   * *   SUCCESS: The instance is successfully run.
   * 
   * @example
   * SUCCESS
   */
  status?: string;
  /**
   * @remarks
   * The scheduling type of the node. Valid values:
   * 
   * *   NORMAL(0): The node is an auto triggered node. The scheduling system regularly runs the node.
   * *   MANUAL(1): The node is a manually triggered node. The scheduling system does not regularly run the node.
   * *   PAUSE(2): The node is a frozen node. The scheduling system regularly runs the node but sets the status of the node to failed when the scheduling system starts to run the node.
   * *   SKIP(3): The node is a dry-run node. The scheduling system regularly runs the node but sets the status of the node to successful when the scheduling system starts to run the node.
   * *   SKIP_UNCHOOSE(4): The node is an unselected node in a temporary workflow. This type of node exists only in temporary workflows. The scheduling system sets the status of the node to successful when the scheduling system starts to run the node.
   * *   SKIP_CYCLE(5): The node is a node that is scheduled by week or month and is waiting for the scheduling time to arrive. The scheduling system regularly runs the node but sets the status of the node to successful when the scheduling system starts to run the node.
   * *   CONDITION_UNCHOOSE(6): The node is not selected by its ancestor branch node and is run as a dry-run node.
   * *   REALTIME_DEPRECATED(7): The node has instances that are generated in real time but deprecated. The scheduling system sets the status of the node to successful.
   * 
   * @example
   * MANUAL
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      beginRunningTime: 'BeginRunningTime',
      beginWaitResTime: 'BeginWaitResTime',
      beginWaitTimeTime: 'BeginWaitTimeTime',
      bizDate: 'BizDate',
      createTime: 'CreateTime',
      createUser: 'CreateUser',
      cycTime: 'CycTime',
      dagId: 'DagId',
      dagType: 'DagType',
      finishTime: 'FinishTime',
      instanceId: 'InstanceId',
      modifyTime: 'ModifyTime',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      paramValues: 'ParamValues',
      status: 'Status',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginRunningTime: 'number',
      beginWaitResTime: 'number',
      beginWaitTimeTime: 'number',
      bizDate: 'number',
      createTime: 'number',
      createUser: 'string',
      cycTime: 'number',
      dagId: 'number',
      dagType: 'string',
      finishTime: 'number',
      instanceId: 'number',
      modifyTime: 'number',
      nodeId: 'number',
      nodeName: 'string',
      paramValues: 'string',
      status: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMeasureDataResponseBodyMeasureDatas extends $tea.Model {
  /**
   * @remarks
   * The measurement component.
   * 
   * @example
   * Count
   */
  componentCode?: string;
  /**
   * @remarks
   * The item that is measured.
   * 
   * @example
   * DideAlarmPhone
   */
  domainCode?: string;
  /**
   * @remarks
   * The end timestamp of the measurement period, in milliseconds.
   * 
   * @example
   * 1717430400000
   */
  endTime?: number;
  /**
   * @remarks
   * The start timestamp of the measurement period, in milliseconds.
   * 
   * @example
   * 1717344000000
   */
  startTime?: number;
  /**
   * @remarks
   * The total quantity used within the measurement period.
   * 
   * @example
   * 10
   */
  usage?: number;
  static names(): { [key: string]: string } {
    return {
      componentCode: 'ComponentCode',
      domainCode: 'DomainCode',
      endTime: 'EndTime',
      startTime: 'StartTime',
      usage: 'Usage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      componentCode: 'string',
      domainCode: 'string',
      endTime: 'number',
      startTime: 'number',
      usage: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMetaCollectionEntitiesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The entities.
   */
  entityList?: Entity[];
  /**
   * @remarks
   * A pagination token. It can be used in the next request to retrieve a new page of results.
   * 
   * @example
   * 123344
   */
  nextToken?: string;
  static names(): { [key: string]: string } {
    return {
      entityList: 'EntityList',
      nextToken: 'NextToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityList: { 'type': 'array', 'itemType': Entity },
      nextToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMetaCollectionsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The collections.
   */
  collectionList?: Collection[];
  /**
   * @remarks
   * A pagination token. It can be used in the next request to retrieve a new page of results.
   * 
   * @example
   * 37ae2053d87d380f28ce0dc0853ca51e
   */
  nextToken?: string;
  static names(): { [key: string]: string } {
    return {
      collectionList: 'CollectionList',
      nextToken: 'NextToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      collectionList: { 'type': 'array', 'itemType': Collection },
      nextToken: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMetaDBResponseBodyDatabaseInfoDbList extends $tea.Model {
  /**
   * @remarks
   * The timestamp at which the metadatabase was created. You can convert the timestamp to the date based on the time zone that you use.
   * 
   * @example
   * 1388776825
   */
  createTimeStamp?: number;
  /**
   * @remarks
   * The URL of the metadatabase.
   * 
   * @example
   * hdfs://localhost:777/user/hadoop/test.txt
   */
  location?: string;
  /**
   * @remarks
   * The timestamp at which the metadatabase was updated.
   * 
   * @example
   * 1388776837
   */
  modifiedTimeStamp?: number;
  /**
   * @remarks
   * The name of the metadatabase.
   * 
   * @example
   * name
   */
  name?: string;
  /**
   * @remarks
   * The owner ID.
   * 
   * @example
   * 1232
   */
  ownerId?: string;
  /**
   * @remarks
   * The type of the metadatabase.
   * 
   * @example
   * HIVE
   */
  type?: string;
  /**
   * @remarks
   * The UUID of the metadatabase.
   * 
   * @example
   * 32342
   */
  UUID?: string;
  static names(): { [key: string]: string } {
    return {
      createTimeStamp: 'CreateTimeStamp',
      location: 'Location',
      modifiedTimeStamp: 'ModifiedTimeStamp',
      name: 'Name',
      ownerId: 'OwnerId',
      type: 'Type',
      UUID: 'UUID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTimeStamp: 'number',
      location: 'string',
      modifiedTimeStamp: 'number',
      name: 'string',
      ownerId: 'string',
      type: 'string',
      UUID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMetaDBResponseBodyDatabaseInfo extends $tea.Model {
  /**
   * @remarks
   * The metadatabases.
   */
  dbList?: ListMetaDBResponseBodyDatabaseInfoDbList[];
  /**
   * @remarks
   * The total number of the metadatabases returned.
   * 
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dbList: 'DbList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbList: { 'type': 'array', 'itemType': ListMetaDBResponseBodyDatabaseInfoDbList },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMigrationsResponseBodyDataMigrations extends $tea.Model {
  /**
   * @remarks
   * The time when the migration task was created.
   * 
   * @example
   * 123124123123123
   */
  createTime?: number;
  /**
   * @remarks
   * The ID of the user who created the migration task.
   * 
   * @example
   * 123123****
   */
  createUser?: string;
  /**
   * @remarks
   * The name of the user who created the migration task.
   * 
   * @example
   * 3h1_test
   */
  createUserName?: string;
  /**
   * @remarks
   * The description of the export task.
   */
  description?: string;
  /**
   * @remarks
   * The URL that is used to download the package of the export task. You can use the URL to download the package of the export task.
   * 
   * @example
   * http://geoip-sdk-user.oss-cn-zhangjiakou.aliyuncs.com/product/v1/ipv4/trace/v1.20220424123842.dex?Expires=1650780849&OSSAccessKeyId=XXXXXXeF4Lv5j&Signature=qxxxxx
   */
  downloadUrl?: string;
  /**
   * @remarks
   * The primary key ID.
   * 
   * @example
   * 436064
   */
  id?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * An internal system error occurred. datasource kafka region is not cn-chengdu, can\\"t open network for it
   */
  message?: string;
  /**
   * @remarks
   * The type of the migration task.
   * 
   * *   IMPORT
   * *   EXPORT
   * 
   * @example
   * EXPORT
   */
  migrationType?: string;
  /**
   * @remarks
   * The name of the migration task.
   * 
   * @example
   * test_task_1638498642279
   */
  name?: string;
  /**
   * @remarks
   * The type of the import or export package. Valid values:
   * 
   * *   DWMA (standard format)
   * *   DATAWORKS_MODEL (standard format)
   * *   DATAWORKS_V2 (Apsara Stack DataWorks V3.6.1 to V3.11)
   * *   DATAWORKS_V3 (Apsara Stack DataWorks V3.12 and later)
   * 
   * The DWMA and DATAWORKS_MODEL types are interchangeable.
   * 
   * @example
   * DATAWORKS_MODEL
   */
  packageType?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace to which the task belongs.
   * 
   * @example
   * 72132
   */
  projectId?: number;
  /**
   * @remarks
   * The status of the migration task. Valid values:
   * 
   * *   INIT: The migration task is in the initial state.
   * *   EDITING: The migration task is being edited.
   * *   RUNNING: The migration task is running.
   * *   FAILURE: The migration task fails to run.
   * *   SUCCESS: The migration task is successfully run.
   * 
   * @example
   * SUCCESS
   */
  status?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 16307
   */
  tenantId?: number;
  /**
   * @remarks
   * The time when the migration task was last updated.
   * 
   * @example
   * 123123123123123
   */
  updateTime?: number;
  /**
   * @remarks
   * The ID of the user who last updated the migration task.
   * 
   * @example
   * 1231****
   */
  updateUser?: string;
  /**
   * @remarks
   * The name of the user who last updated the migration task.
   * 
   * @example
   * 3h1_test
   */
  updateUserName?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      createUser: 'CreateUser',
      createUserName: 'CreateUserName',
      description: 'Description',
      downloadUrl: 'DownloadUrl',
      id: 'Id',
      message: 'Message',
      migrationType: 'MigrationType',
      name: 'Name',
      packageType: 'PackageType',
      projectId: 'ProjectId',
      status: 'Status',
      tenantId: 'TenantId',
      updateTime: 'UpdateTime',
      updateUser: 'UpdateUser',
      updateUserName: 'UpdateUserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      createUser: 'string',
      createUserName: 'string',
      description: 'string',
      downloadUrl: 'string',
      id: 'number',
      message: 'string',
      migrationType: 'string',
      name: 'string',
      packageType: 'string',
      projectId: 'number',
      status: 'string',
      tenantId: 'number',
      updateTime: 'number',
      updateUser: 'string',
      updateUserName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListMigrationsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of migration tasks.
   */
  migrations?: ListMigrationsResponseBodyDataMigrations[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 50.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries.
   * 
   * @example
   * 20
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      migrations: 'Migrations',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      migrations: { 'type': 'array', 'itemType': ListMigrationsResponseBodyDataMigrations },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodeIOResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the ancestor or descendant node.
   * 
   * @example
   * dataworks_a.1234_out
   */
  data?: string;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 123123
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the input or output table.
   * 
   * @example
   * dataworks_a.datastudio_tenant_waitres_alarm
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      nodeId: 'NodeId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      nodeId: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodeInputOrOutputResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The name of the ancestor or descendant node.
   * 
   * @example
   * xxxx.123141254_out
   */
  data?: string;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 1234667
   */
  nodeId?: number;
  /**
   * @remarks
   * This parameter does not take effect. You cannot obtain the parameter settings.
   * 
   * @example
   * dwd_xxx_table
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      nodeId: 'NodeId',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      nodeId: 'number',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesResponseBodyDataNodes extends $tea.Model {
  /**
   * @remarks
   * The number of the page to return. Minimum value: 1. Maximum value: 100.
   * 
   * @example
   * 123456
   */
  baselineId?: number;
  /**
   * @remarks
   * The operation that you want to perform. Set the value to **ListNodes**.
   * 
   * @example
   * 123
   */
  businessId?: number;
  /**
   * @remarks
   * The name of the resource group.
   * 
   * @example
   * odps_first
   */
  connection?: string;
  createTime?: number;
  /**
   * @remarks
   * The name of the workflow.
   * 
   * @example
   * 00 00 00 * * ?
   */
  cronExpress?: string;
  deployDate?: number;
  /**
   * @remarks
   * The priority for running the node. Valid values: 1, 3, 5, 7, and 8.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The ID of the owner.
   * 
   * @example
   * [{"projectName":"ztjy_dim","tableName":"dim_user_agent_manage_area_a","partition":"ds\\u003d$[yyyy-mm-dd-1]"}]
   */
  dqcDescription?: string;
  /**
   * @remarks
   * The connection string.
   * 
   * @example
   * 1
   */
  dqcType?: number;
  fileId?: number;
  fileType?: number;
  fileVersion?: number;
  modifyTime?: number;
  /**
   * @remarks
   * The types of the nodes. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the type of the node.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The total number of nodes returned.
   * 
   * @example
   * liux_test_n****
   */
  nodeName?: string;
  /**
   * @remarks
   * The additional parameters.
   * 
   * @example
   * 19337906836551
   */
  ownerId?: string;
  /**
   * @remarks
   * The type of the node.
   * 
   * @example
   * a=b
   */
  paramValues?: string;
  /**
   * @remarks
   * The ID of the owner.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The error message returned.
   * 
   * @example
   * ODPS_SQL
   */
  programType?: string;
  /**
   * @remarks
   * The information about the nodes.
   * 
   * @example
   * 33671
   */
  projectId?: number;
  /**
   * @remarks
   * The table and partition filter expression in Data Quality that are associated with the node.
   * 
   * @example
   * 1231123
   */
  relatedFlowId?: number;
  /**
   * @remarks
   * The environment of the workspace. Valid values: PROD and DEV.
   * 
   * @example
   * 60
   */
  repeatInterval?: number;
  repeatMode?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * true
   */
  repeatability?: boolean;
  resGroupIdentifier?: string;
  /**
   * @remarks
   * The ID of the workflow.
   * 
   * @example
   * The ID of the request. You can use the ID to query logs and troubleshoot issues.
   */
  resGroupName?: string;
  /**
   * @remarks
   * The types of the nodes. You can call the [ListNodes](https://help.aliyun.com/document_detail/173979.html) operation to query the type of the node.
   * 
   * @example
   * NORMAL
   */
  schedulerType?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      businessId: 'BusinessId',
      connection: 'Connection',
      createTime: 'CreateTime',
      cronExpress: 'CronExpress',
      deployDate: 'DeployDate',
      description: 'Description',
      dqcDescription: 'DqcDescription',
      dqcType: 'DqcType',
      fileId: 'FileId',
      fileType: 'FileType',
      fileVersion: 'FileVersion',
      modifyTime: 'ModifyTime',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      ownerId: 'OwnerId',
      paramValues: 'ParamValues',
      priority: 'Priority',
      programType: 'ProgramType',
      projectId: 'ProjectId',
      relatedFlowId: 'RelatedFlowId',
      repeatInterval: 'RepeatInterval',
      repeatMode: 'RepeatMode',
      repeatability: 'Repeatability',
      resGroupIdentifier: 'ResGroupIdentifier',
      resGroupName: 'ResGroupName',
      schedulerType: 'SchedulerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      businessId: 'number',
      connection: 'string',
      createTime: 'number',
      cronExpress: 'string',
      deployDate: 'number',
      description: 'string',
      dqcDescription: 'string',
      dqcType: 'number',
      fileId: 'number',
      fileType: 'number',
      fileVersion: 'number',
      modifyTime: 'number',
      nodeId: 'number',
      nodeName: 'string',
      ownerId: 'string',
      paramValues: 'string',
      priority: 'number',
      programType: 'string',
      projectId: 'number',
      relatedFlowId: 'number',
      repeatInterval: 'number',
      repeatMode: 'number',
      repeatability: 'boolean',
      resGroupIdentifier: 'string',
      resGroupName: 'string',
      schedulerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The scheduling type of the node. Valid values:
   * 
   * *   NORMAL: indicates that the node is a normal auto triggered node.
   * *   MANUAL: indicates that the node is a manually triggered node.
   * *   PAUSE: indicates that the node is a paused node.
   * *   SKIP: indicates that the node is a dry-run node. Dry-run nodes are started as scheduled but the system sets the status of the nodes to successful when it starts to run them.
   */
  nodes?: ListNodesResponseBodyDataNodes[];
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The cron expression returned.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The name of the workflow.
   * 
   * @example
   * 66
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      nodes: 'Nodes',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodes: { 'type': 'array', 'itemType': ListNodesResponseBodyDataNodes },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesByBaselineResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 9527952****
   */
  owner?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      owner: 'Owner',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'number',
      nodeName: 'string',
      owner: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesByOutputResponseBodyDataNodeList extends $tea.Model {
  /**
   * @remarks
   * The baseline ID.
   * 
   * @example
   * 1235667
   */
  baselineId?: number;
  /**
   * @remarks
   * The name of the data source.
   * 
   * @example
   * odps_first
   */
  connection?: string;
  /**
   * @remarks
   * The CRON expression.
   * 
   * @example
   * 00 00 00 * * ?
   */
  cronExpress?: string;
  /**
   * @remarks
   * The description of the node.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The table and partition filter expression in Data Quality that are associated with the node.
   * 
   * @example
   * [{"projectName":"ztjy_dim","tableName":"dim_user_agent_manage_area_a","partition":"ds\\u003d$[yyyy-mm-dd-1]"}]
   */
  dqcDescription?: string;
  /**
   * @remarks
   * Indicates whether the node is associated with a monitoring rule in Data Quality. Valid values: 0 and 1. The value 0 indicates that the node is associated with a monitoring rule in Data Quality. The value 1 indicates that the node is not associated with a monitoring rule in Data Quality.
   * 
   * @example
   * 1
   */
  dqcType?: number;
  /**
   * @remarks
   * The node type. Valid values:
   * 
   * 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3)
   * 
   * @example
   * ODPS_SQL
   */
  fileType?: string;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 125677
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * liux_test_n****
   */
  nodeName?: string;
  /**
   * @remarks
   * The owner ID.
   * 
   * @example
   * 19337906836551
   */
  ownerId?: string;
  /**
   * @remarks
   * The scheduling parameters of the node.
   * 
   * @example
   * a=b
   */
  paramValues?: string;
  /**
   * @remarks
   * The priority of the node. Valid values: 1, 3, 5, 7, and 8. A greater value indicates a higher priority. Default value: 1.
   * 
   * @example
   * 1
   */
  priority?: number;
  /**
   * @remarks
   * The node type. This parameter is deprecated. For more information about node types, see valid values of the FileType parameter.
   * 
   * @example
   * ODPS_SQL
   */
  programType?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 33671
   */
  projectId?: number;
  /**
   * @remarks
   * The ID of the workflow to which the node belongs.
   * 
   * @example
   * 1235655464
   */
  relatedFlowId?: number;
  /**
   * @remarks
   * The interval at which the node is rerun after the node fails to run.
   * 
   * @example
   * 60
   */
  repeatInterval?: number;
  /**
   * @remarks
   * Indicates whether the node can be rerun.
   * 
   * @example
   * true
   */
  repeatability?: boolean;
  /**
   * @remarks
   * The name of the resource group.
   */
  resGroupName?: string;
  /**
   * @remarks
   * The scheduling type of the node. Valid values:
   * 
   * *   NORMAL: The node is an auto triggered node. The scheduling system regularly runs the node.
   * *   MANUAL: The node is a manually triggered node. The scheduling system does not regularly run the node.
   * *   PAUSE: The node is a frozen node. The scheduling system regularly runs the node but sets the status of the node to failed when the scheduling system starts to run the node.
   * *   SKIP: The node is a dry-run node. The scheduling system regularly runs the node but sets the status of the node to successful when the scheduling system starts to run the node.
   * 
   * @example
   * NORMAL
   */
  schedulerType?: string;
  static names(): { [key: string]: string } {
    return {
      baselineId: 'BaselineId',
      connection: 'Connection',
      cronExpress: 'CronExpress',
      description: 'Description',
      dqcDescription: 'DqcDescription',
      dqcType: 'DqcType',
      fileType: 'FileType',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      ownerId: 'OwnerId',
      paramValues: 'ParamValues',
      priority: 'Priority',
      programType: 'ProgramType',
      projectId: 'ProjectId',
      relatedFlowId: 'RelatedFlowId',
      repeatInterval: 'RepeatInterval',
      repeatability: 'Repeatability',
      resGroupName: 'ResGroupName',
      schedulerType: 'SchedulerType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineId: 'number',
      connection: 'string',
      cronExpress: 'string',
      description: 'string',
      dqcDescription: 'string',
      dqcType: 'number',
      fileType: 'string',
      nodeId: 'number',
      nodeName: 'string',
      ownerId: 'string',
      paramValues: 'string',
      priority: 'number',
      programType: 'string',
      projectId: 'number',
      relatedFlowId: 'number',
      repeatInterval: 'number',
      repeatability: 'boolean',
      resGroupName: 'string',
      schedulerType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListNodesByOutputResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The information about the nodes returned.
   */
  nodeList?: ListNodesByOutputResponseBodyDataNodeList[];
  /**
   * @remarks
   * The output name of the current node.
   * 
   * @example
   * test_0709_1.630003556_out
   */
  output?: string;
  static names(): { [key: string]: string } {
    return {
      nodeList: 'NodeList',
      output: 'Output',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeList: { 'type': 'array', 'itemType': ListNodesByOutputResponseBodyDataNodeList },
      output: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList extends $tea.Model {
  actions?: string[];
  /**
   * @remarks
   * The name of the table on which you requested permissions.
   * 
   * @example
   * aTableName
   */
  objectName?: string;
  static names(): { [key: string]: string } {
    return {
      actions: 'Actions',
      objectName: 'ObjectName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actions: { 'type': 'array', 'itemType': 'string' },
      objectName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta extends $tea.Model {
  /**
   * @remarks
   * The information about the object on which you requested permissions.
   */
  objectMetaList?: ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList[];
  /**
   * @remarks
   * The name of the DataWorks workspace that is associated with the MaxCompute project in which you requested permissions on a table.
   * 
   * @example
   * aWorkspaceName
   */
  workspaceName?: string;
  static names(): { [key: string]: string } {
    return {
      objectMetaList: 'ObjectMetaList',
      workspaceName: 'WorkspaceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      objectMetaList: { 'type': 'array', 'itemType': ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList },
      workspaceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent extends $tea.Model {
  /**
   * @remarks
   * The reason for your request. The administrator determines whether to approve the request based on the reason.
   * 
   * @example
   * I need to use this table
   */
  applyReason?: string;
  /**
   * @remarks
   * The type of the permission request order. The parameter value is 1 and cannot be changed. This value indicates ACL-based authorization.
   * 
   * @example
   * 1
   */
  orderType?: number;
  /**
   * @remarks
   * The content of the object on which you requested permissions.
   */
  projectMeta?: ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta;
  static names(): { [key: string]: string } {
    return {
      applyReason: 'ApplyReason',
      orderType: 'OrderType',
      projectMeta: 'ProjectMeta',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyReason: 'string',
      orderType: 'number',
      projectMeta: ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder extends $tea.Model {
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that was used to submit the permission request order.
   * 
   * @example
   * 267842600408993176
   */
  applyBaseId?: string;
  /**
   * @remarks
   * The time when the permission request order was submitted. The parameter value is a UNIX timestamp.
   * 
   * @example
   * 1615284086000
   */
  applyTimestamp?: number;
  /**
   * @remarks
   * The content of the permission request order.
   */
  approveContent?: ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent;
  /**
   * @remarks
   * The ID of the permission request order.
   * 
   * @example
   * ad8da78d-8135-455e-9486-27cf213fc140
   */
  flowId?: string;
  /**
   * @remarks
   * The status of the permission request order. Valid values:
   * 
   * *   1: to be processed
   * *   2: approved and authorized
   * *   3: approved but authorization failed
   * *   4: rejected
   * 
   * @example
   * 2
   */
  flowStatus?: number;
  static names(): { [key: string]: string } {
    return {
      applyBaseId: 'ApplyBaseId',
      applyTimestamp: 'ApplyTimestamp',
      approveContent: 'ApproveContent',
      flowId: 'FlowId',
      flowStatus: 'FlowStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyBaseId: 'string',
      applyTimestamp: 'number',
      approveContent: ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent,
      flowId: 'string',
      flowStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPermissionApplyOrdersResponseBodyApplyOrders extends $tea.Model {
  /**
   * @remarks
   * The list of the permission request orders.
   */
  applyOrder?: ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 150
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      applyOrder: 'ApplyOrder',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyOrder: { 'type': 'array', 'itemType': ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProgramTypeCountResponseBodyProgramTypeAndCounts extends $tea.Model {
  /**
   * @remarks
   * The number of nodes.
   * 
   * @example
   * 3
   */
  count?: number;
  /**
   * @remarks
   * The node type.
   * 
   * @example
   * ODPS_SQL
   */
  programType?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      programType: 'ProgramType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      programType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList extends $tea.Model {
  /**
   * @remarks
   * The code of the role. DataWorks provides built-in roles and allows you to create custom roles based on your business requirements. For more information about roles, see [Overview of users, roles, and permissions](https://help.aliyun.com/document_detail/295463.html).
   * 
   * @example
   * role_project_guest
   */
  projectRoleCode?: string;
  /**
   * @remarks
   * The role ID.
   * 
   * @example
   * 1
   */
  projectRoleId?: number;
  /**
   * @remarks
   * The name of the role. DataWorks provides built-in roles and allows you to create custom roles based on your business requirements. For more information about roles, see [Overview of users, roles, and permissions](https://help.aliyun.com/document_detail/295463.html).
   * 
   * @example
   * test
   */
  projectRoleName?: string;
  /**
   * @remarks
   * The type of the role. Valid values:
   * 
   * *   0: SYSTEM, which indicates that the role is a built-in role.
   * *   2: USER_CUSTOM, which indicates that the role is a custom role.
   * 
   * @example
   * 0
   */
  projectRoleType?: string;
  static names(): { [key: string]: string } {
    return {
      projectRoleCode: 'ProjectRoleCode',
      projectRoleId: 'ProjectRoleId',
      projectRoleName: 'ProjectRoleName',
      projectRoleType: 'ProjectRoleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectRoleCode: 'string',
      projectRoleId: 'number',
      projectRoleName: 'string',
      projectRoleType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponseBodyDataProjectMemberList extends $tea.Model {
  /**
   * @remarks
   * The nickname of the member.
   * 
   * @example
   * zhangsan
   */
  nick?: string;
  /**
   * @remarks
   * The member ID.
   * 
   * @example
   * 121
   */
  projectMemberId?: string;
  /**
   * @remarks
   * The name of the member.
   * 
   * @example
   * zhangsan
   */
  projectMemberName?: string;
  /**
   * @remarks
   * The type of the member. Valid values:
   * 
   * *   1: USER_ALIYUN, which indicates that the member is an Alibaba Cloud account.
   * *   5: USER_UBACCOUNT, which indicates that the member is a RAM user.
   * *   6: USER_STS_ROLE, which indicates that the member is a RAM role.
   * 
   * @example
   * 1
   */
  projectMemberType?: string;
  /**
   * @remarks
   * The roles that are assigned to the member.
   */
  projectRoleList?: ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList[];
  /**
   * @remarks
   * The status of the member. Valid values:
   * 
   * *   0: NORMAL, which indicates that the member is in a normal state.
   * *   1: FORBIDDEN, which indicates that the member is disabled.
   * *   2: DELETED, which indicates that the member is deleted.
   * 
   * @example
   * 0
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      nick: 'Nick',
      projectMemberId: 'ProjectMemberId',
      projectMemberName: 'ProjectMemberName',
      projectMemberType: 'ProjectMemberType',
      projectRoleList: 'ProjectRoleList',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nick: 'string',
      projectMemberId: 'string',
      projectMemberName: 'string',
      projectMemberType: 'string',
      projectRoleList: { 'type': 'array', 'itemType': ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectMembersResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The information about members in the DataWorks workspace.
   */
  projectMemberList?: ListProjectMembersResponseBodyDataProjectMemberList[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 3
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectMemberList: 'ProjectMemberList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      projectMemberList: { 'type': 'array', 'itemType': ListProjectMembersResponseBodyDataProjectMemberList },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectRolesResponseBodyProjectRoleList extends $tea.Model {
  /**
   * @remarks
   * The code of the role in the DataWorks workspace.
   * 
   * @example
   * role_project_guest
   */
  projectRoleCode?: string;
  /**
   * @remarks
   * The ID of the role in the DataWorks workspace.
   * 
   * @example
   * 1
   */
  projectRoleId?: number;
  /**
   * @remarks
   * The name of the role in the DataWorks workspace.
   * 
   * @example
   * visitor
   */
  projectRoleName?: string;
  /**
   * @remarks
   * The type of the role in the DataWorks workspace.
   * 
   * @example
   * 0
   */
  projectRoleType?: string;
  static names(): { [key: string]: string } {
    return {
      projectRoleCode: 'ProjectRoleCode',
      projectRoleId: 'ProjectRoleId',
      projectRoleName: 'ProjectRoleName',
      projectRoleType: 'ProjectRoleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectRoleCode: 'string',
      projectRoleId: 'number',
      projectRoleName: 'string',
      projectRoleType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsRequestTags extends $tea.Model {
  /**
   * @remarks
   * The key of tag N to add to the workspace.
   * 
   * @example
   * Env
   */
  key?: string;
  /**
   * @remarks
   * The value of tag N to add to the workspace.
   * 
   * @example
   * Test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyPageResultProjectListTags extends $tea.Model {
  /**
   * @remarks
   * The key of tag N added to the workspace.
   * 
   * @example
   * Env
   */
  key?: string;
  /**
   * @remarks
   * The value of tag N added to the workspace.
   * 
   * @example
   * Test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyPageResultProjectList extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the Development role is disabled. Valid values:
   * 
   * *   **false**: enabled
   * *   **true**: disabled
   * 
   * @example
   * true
   */
  disableDevelopment?: boolean;
  /**
   * @remarks
   * Indicates whether the workspace is a default workspace. Valid values:
   * 
   * *   **1**: The workspace is a default workspace.
   * *   **0**: The workspace is not a default workspace.
   * 
   * @example
   * 1
   */
  isDefault?: number;
  /**
   * @remarks
   * The description of the workspace.
   * 
   * @example
   * test_describe
   */
  projectDescription?: string;
  /**
   * @remarks
   * The workspace ID.
   * 
   * @example
   * 1212
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the workspace.
   * 
   * @example
   * test
   */
  projectIdentifier?: string;
  /**
   * @remarks
   * The display name of the workspace.
   * 
   * @example
   * test_project
   */
  projectName?: string;
  /**
   * @remarks
   * The ID of the user used by the workspace owner.
   * 
   * @example
   * 122222
   */
  projectOwnerBaseId?: string;
  /**
   * @remarks
   * The status of the workspace. Valid values:
   * 
   * *   0: AVAILABLE, which indicates that the workspace is running as expected.
   * *   1: DELETED, which indicates that the workspace is deleted.
   * *   2: INITIALIZING, which indicates that the workspace is being initialized.
   * *   3: INIT_FAILED, which indicates that the workspace fails to be initialized.
   * *   4: FORBIDDEN, which indicates that the workspace is manually disabled.
   * *   5: DELETING, which indicates that the workspace is being deleted.
   * *   6: DEL_FAILED, which indicates that the workspace fails to be deleted.
   * *   7: FROZEN, which indicates that the workspace is frozen due to overdue payments.
   * *   8: UPDATING, which indicates that the workspace is being updated. After you associate a compute engine with the workspace, the system initializes the compute engine and updates the workspace.
   * *   9: UPDATE_FAILED, which indicates that the workspace fails to be updated.
   * 
   * @example
   * 0
   */
  projectStatus?: number;
  /**
   * @remarks
   * The status code of the workspace. Valid values:
   * 
   * *   AVAILABLE: 0, which indicates that the workspace is running as expected.
   * *   DELETED: 1, which indicates that the workspace is deleted.
   * *   INITIALIZING: 2, which indicates that the workspace is being initialized.
   * *   INIT_FAILED: 3, which indicates that the workspace fails to be initialized.
   * *   FORBIDDEN: 4, which indicates that the workspace is manually disabled.
   * *   DELETING: 5, which indicates that the workspace is being deleted.
   * *   DEL_FAILED: 6, which indicates that the workspace fails to be deleted.
   * *   FROZEN: 7, which indicates that the workspace is frozen due to overdue payments.
   * *   UPDATING: 8, which indicates that the workspace is being updated. After you associate a compute engine with the workspace, the system initializes the compute engine and updates the workspace.
   * *   UPDATE_FAILED: 9, which indicates that the workspace fails to be updated.
   * 
   * @example
   * AVAILABLE
   */
  projectStatusCode?: string;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * rg-acfmzbn7pti3zfa
   */
  resourceManagerResourceGroupId?: string;
  /**
   * @remarks
   * Indicates whether the MaxCompute tables in the workspace are visible to the users within a tenant. Valid values:
   * 
   * *   **0**: invisible
   * *   **1**: visible
   * 
   * @example
   * 1
   */
  tablePrivacyMode?: number;
  /**
   * @remarks
   * The tags added to the workspace.
   */
  tags?: ListProjectsResponseBodyPageResultProjectListTags[];
  /**
   * @remarks
   * Indicates whether a proxy account is used to access the MaxCompute compute engine associated with the workspace. Valid values:
   * 
   * *   **false**
   * *   **true**
   * 
   * @example
   * true
   */
  useProxyOdpsAccount?: boolean;
  static names(): { [key: string]: string } {
    return {
      disableDevelopment: 'DisableDevelopment',
      isDefault: 'IsDefault',
      projectDescription: 'ProjectDescription',
      projectId: 'ProjectId',
      projectIdentifier: 'ProjectIdentifier',
      projectName: 'ProjectName',
      projectOwnerBaseId: 'ProjectOwnerBaseId',
      projectStatus: 'ProjectStatus',
      projectStatusCode: 'ProjectStatusCode',
      resourceManagerResourceGroupId: 'ResourceManagerResourceGroupId',
      tablePrivacyMode: 'TablePrivacyMode',
      tags: 'Tags',
      useProxyOdpsAccount: 'UseProxyOdpsAccount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      disableDevelopment: 'boolean',
      isDefault: 'number',
      projectDescription: 'string',
      projectId: 'number',
      projectIdentifier: 'string',
      projectName: 'string',
      projectOwnerBaseId: 'string',
      projectStatus: 'number',
      projectStatusCode: 'string',
      resourceManagerResourceGroupId: 'string',
      tablePrivacyMode: 'number',
      tags: { 'type': 'array', 'itemType': ListProjectsResponseBodyPageResultProjectListTags },
      useProxyOdpsAccount: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListProjectsResponseBodyPageResult extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The DataWorks workspaces.
   */
  projectList?: ListProjectsResponseBodyPageResultProjectList[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 123
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      projectList: 'ProjectList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      projectList: { 'type': 'array', 'itemType': ListProjectsResponseBodyPageResultProjectList },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue extends $tea.Model {
  /**
   * @remarks
   * The data timestamp. In most cases, if the monitored business entity is offline data, the value is one day before the monitoring is performed.
   * 
   * @example
   * 2020-12-03
   */
  bizDate?: string;
  /**
   * @remarks
   * The values of the sample field that are grouped by using the GROUP BY clause. For example, the values of the Gender field are grouped by using the GROUP BY clause. In this case, the values of the DiscreteProperty parameter are Male, Female, and null.
   * 
   * @example
   * 0
   */
  discreteProperty?: string;
  /**
   * @remarks
   * The check result.
   * 
   * @example
   * 0
   */
  singleCheckResult?: number;
  /**
   * @remarks
   * The threshold.
   * 
   * @example
   * 0.5
   */
  threshold?: number;
  /**
   * @remarks
   * The check value.
   * 
   * @example
   * 19
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      bizDate: 'BizDate',
      discreteProperty: 'DiscreteProperty',
      singleCheckResult: 'SingleCheckResult',
      threshold: 'Threshold',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizDate: 'string',
      discreteProperty: 'string',
      singleCheckResult: 'number',
      threshold: 'number',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue extends $tea.Model {
  /**
   * @remarks
   * The data timestamp. In most cases, if the monitored business entity is offline data, the value is one day before the monitoring is performed.
   * 
   * @example
   * 2020-12-03
   */
  bizDate?: string;
  /**
   * @remarks
   * The values of the sample field that are grouped by using the GROUP BY clause. For example, the values of the Gender field are grouped by using the GROUP BY clause. In this case, the values of the DiscreteProperty parameter are Male, Female, and null.
   * 
   * @example
   * 0
   */
  discreteProperty?: string;
  /**
   * @remarks
   * The current sample value.
   * 
   * @example
   * 19
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      bizDate: 'BizDate',
      discreteProperty: 'DiscreteProperty',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizDate: 'string',
      discreteProperty: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByEntityResponseBodyDataRuleChecks extends $tea.Model {
  /**
   * @remarks
   * The monitored partition in the data source table.
   * 
   * @example
   * ds=20200912
   */
  actualExpression?: string;
  /**
   * @remarks
   * The time when the monitoring started.
   * 
   * @example
   * 1600704000000
   */
  beginTime?: number;
  /**
   * @remarks
   * The data timestamp. In most cases, if the monitored business entity is offline data, the value is one day before the monitoring is performed.
   * 
   * @example
   * 1600704000000
   */
  bizDate?: number;
  /**
   * @remarks
   * The strength of the monitoring rule. The strength of a monitoring rule indicates the importance of the rule. Valid values:
   * 
   * *   1: the monitoring rule is a strong rule.
   * *   0: the monitoring rule is a weak rule. You can specify whether a monitoring rule is a strong rule based on your business requirements. If a monitoring rule is a strong rule and the critical threshold is exceeded, a critical alert is reported and tasks that are associated with the rule are blocked from running.
   * 
   * @example
   * 0
   */
  blockType?: number;
  /**
   * @remarks
   * The check result. The value of this parameter is the same as the value of the CheckResultStatus parameter. Valid values:
   * 
   * *   0: indicates that the data source table is normal.
   * *   1: indicates that a warning alert is reported.
   * *   2: indicates that a critical alert is reported.
   * 
   * @example
   * 0
   */
  checkResult?: number;
  /**
   * @remarks
   * The check result of the monitoring rule. Valid values:
   * 
   * *   0: indicates that the data source table is normal.
   * *   1: indicates that a warning alert is reported.
   * *   2: indicates that a critical alert is reported.
   * 
   * @example
   * 0
   */
  checkResultStatus?: number;
  /**
   * @remarks
   * The checker ID.
   * 
   * @example
   * 7
   */
  checkerId?: number;
  /**
   * @remarks
   * The name of the checker.
   * 
   * @example
   * fulx
   */
  checkerName?: string;
  /**
   * @remarks
   * The check type. Valid values:
   * 
   * *   0: indicates that the monitoring is performed based on a fixed value.
   * *   1: indicates that the monitoring is performed based on a non-fixed value.
   * *   2: indicates that the monitoring is performed based on a dynamic threshold.
   * 
   * @example
   * 1
   */
  checkerType?: number;
  /**
   * @remarks
   * The description of the monitoring rule.
   */
  comment?: string;
  /**
   * @remarks
   * The threshold for a critical alert. The threshold indicates the deviation of the check result from the expected value. You can specify a value for the threshold based on your business requirements. If a monitoring rule is a strong rule and the critical threshold is exceeded, a critical alert is reported and tasks that are associated with the rule are blocked from running.
   * 
   * @example
   * 0.5
   */
  criticalThreshold?: number;
  /**
   * @remarks
   * The scheduling frequency. In most cases, the value of this parameter is YMD. This value indicates year, month, and day.
   * 
   * @example
   * YMD
   */
  dateType?: string;
  /**
   * @remarks
   * Indicates whether the monitoring is discrete monitoring. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  discreteCheck?: boolean;
  /**
   * @remarks
   * The deadline for querying the check result.
   * 
   * @example
   * 1600704000000
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the partition filter expression.
   * 
   * @example
   * 15432322
   */
  entityId?: number;
  /**
   * @remarks
   * The expected value.
   * 
   * @example
   * 200
   */
  expectValue?: number;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 1112323123
   */
  externalId?: string;
  /**
   * @remarks
   * The type of the scheduling system. Only CWF scheduling systems are supported.
   * 
   * @example
   * CWF2
   */
  externalType?: string;
  /**
   * @remarks
   * Indicates whether the monitoring is performed based on a fixed value. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  fixedCheck?: boolean;
  /**
   * @remarks
   * The primary key ID.
   * 
   * @example
   * 121212121
   */
  id?: number;
  /**
   * @remarks
   * Indicates whether the check result is the same as the predicted result. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  isPrediction?: boolean;
  /**
   * @remarks
   * The lower limit of the predicted result. The value of this parameter is automatically generated based on the threshold that you specify.
   * 
   * @example
   * 2344
   */
  lowerValue?: number;
  /**
   * @remarks
   * The partition filter expression.
   * 
   * @example
   * ds=$[yyyymmdd]
   */
  matchExpression?: string;
  /**
   * @remarks
   * The method used to collect sample data, such as such as avg, count, sum, min, max, count_distinct, user_defined, table_count, table_size, table_dt_load_count, table_dt_refuseload_count, null_value, null_value/table_count, (table_count-count_distinct)/table_count, or table_count-count_distinct.
   * 
   * @example
   * count_distinct
   */
  methodName?: string;
  /**
   * @remarks
   * The comparison operator.
   * 
   * @example
   * >
   */
  op?: string;
  /**
   * @remarks
   * The name of the compute engine or data source for which data quality is monitored.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The field whose data quality is checked based on the monitoring rule. This field is a column in the data source table that is monitored.
   * 
   * @example
   * type
   */
  property?: string;
  /**
   * @remarks
   * The historical sample values.
   */
  referenceValue?: ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue[];
  /**
   * @remarks
   * The string of the check result.
   * 
   * @example
   * test
   */
  resultString?: string;
  /**
   * @remarks
   * The ID of the monitoring rule.
   * 
   * @example
   * 123123232
   */
  ruleId?: number;
  /**
   * @remarks
   * The name of the monitoring rule.
   */
  ruleName?: string;
  /**
   * @remarks
   * The current sample value.
   */
  sampleValue?: ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue[];
  /**
   * @remarks
   * The name of the table that is monitored.
   * 
   * @example
   * dual
   */
  tableName?: string;
  /**
   * @remarks
   * The monitoring task ID.
   * 
   * @example
   * 16008552981681a0d6****
   */
  taskId?: string;
  /**
   * @remarks
   * The ID of the monitoring template.
   * 
   * @example
   * 5
   */
  templateId?: number;
  /**
   * @remarks
   * The name of the monitoring template.
   */
  templateName?: string;
  /**
   * @remarks
   * The time that was taken to run the monitoring task. Unit: seconds.
   * 
   * @example
   * 202
   */
  timeCost?: string;
  /**
   * @remarks
   * The trend of the check result.
   * 
   * @example
   * abs
   */
  trend?: string;
  /**
   * @remarks
   * The upper limit of the predicted result. The value of this parameter is automatically generated based on the threshold that you specify.
   * 
   * @example
   * 25555
   */
  upperValue?: number;
  /**
   * @remarks
   * The threshold for a warning alert. The threshold indicates the deviation of the check result from the expected value. You can customize this threshold based on your business requirements.
   * 
   * @example
   * 0.1
   */
  warningThreshold?: number;
  /**
   * @remarks
   * The filter condition of the monitoring rule.
   * 
   * @example
   * id>0
   */
  whereCondition?: string;
  static names(): { [key: string]: string } {
    return {
      actualExpression: 'ActualExpression',
      beginTime: 'BeginTime',
      bizDate: 'BizDate',
      blockType: 'BlockType',
      checkResult: 'CheckResult',
      checkResultStatus: 'CheckResultStatus',
      checkerId: 'CheckerId',
      checkerName: 'CheckerName',
      checkerType: 'CheckerType',
      comment: 'Comment',
      criticalThreshold: 'CriticalThreshold',
      dateType: 'DateType',
      discreteCheck: 'DiscreteCheck',
      endTime: 'EndTime',
      entityId: 'EntityId',
      expectValue: 'ExpectValue',
      externalId: 'ExternalId',
      externalType: 'ExternalType',
      fixedCheck: 'FixedCheck',
      id: 'Id',
      isPrediction: 'IsPrediction',
      lowerValue: 'LowerValue',
      matchExpression: 'MatchExpression',
      methodName: 'MethodName',
      op: 'Op',
      projectName: 'ProjectName',
      property: 'Property',
      referenceValue: 'ReferenceValue',
      resultString: 'ResultString',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      sampleValue: 'SampleValue',
      tableName: 'TableName',
      taskId: 'TaskId',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
      timeCost: 'TimeCost',
      trend: 'Trend',
      upperValue: 'UpperValue',
      warningThreshold: 'WarningThreshold',
      whereCondition: 'WhereCondition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualExpression: 'string',
      beginTime: 'number',
      bizDate: 'number',
      blockType: 'number',
      checkResult: 'number',
      checkResultStatus: 'number',
      checkerId: 'number',
      checkerName: 'string',
      checkerType: 'number',
      comment: 'string',
      criticalThreshold: 'number',
      dateType: 'string',
      discreteCheck: 'boolean',
      endTime: 'number',
      entityId: 'number',
      expectValue: 'number',
      externalId: 'string',
      externalType: 'string',
      fixedCheck: 'boolean',
      id: 'number',
      isPrediction: 'boolean',
      lowerValue: 'number',
      matchExpression: 'string',
      methodName: 'string',
      op: 'string',
      projectName: 'string',
      property: 'string',
      referenceValue: { 'type': 'array', 'itemType': ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue },
      resultString: 'string',
      ruleId: 'number',
      ruleName: 'string',
      sampleValue: { 'type': 'array', 'itemType': ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue },
      tableName: 'string',
      taskId: 'string',
      templateId: 'number',
      templateName: 'string',
      timeCost: 'string',
      trend: 'string',
      upperValue: 'number',
      warningThreshold: 'number',
      whereCondition: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByEntityResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The returned check results.
   */
  ruleChecks?: ListQualityResultsByEntityResponseBodyDataRuleChecks[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 50
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleChecks: 'RuleChecks',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      ruleChecks: { 'type': 'array', 'itemType': ListQualityResultsByEntityResponseBodyDataRuleChecks },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue extends $tea.Model {
  /**
   * @remarks
   * The data timestamp. If the monitored business entity is offline data, the value is usually one day before the monitoring is performed.
   * 
   * @example
   * 1600704000000
   */
  bizDate?: string;
  /**
   * @remarks
   * The values of the sample field that are grouped by using the GROUP BY clause. For example, the values of the Gender field are grouped by using the GROUP BY clause. In this case, the values of DiscreteProperty are Male, Female, and null.
   * 
   * @example
   * type1
   */
  discreteProperty?: string;
  /**
   * @remarks
   * The string of the monitoring result.
   * 
   * @example
   * 2
   */
  singleCheckResult?: number;
  /**
   * @remarks
   * The threshold.
   * 
   * @example
   * 0.2
   */
  threshold?: number;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * 20
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      bizDate: 'BizDate',
      discreteProperty: 'DiscreteProperty',
      singleCheckResult: 'SingleCheckResult',
      threshold: 'Threshold',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizDate: 'string',
      discreteProperty: 'string',
      singleCheckResult: 'number',
      threshold: 'number',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue extends $tea.Model {
  /**
   * @remarks
   * The data timestamp. If the monitored business entity is offline data, the value is usually one day before the monitoring is performed.
   * 
   * @example
   * 1600704000000
   */
  bizDate?: string;
  /**
   * @remarks
   * The values of the sample field that are grouped by using the GROUP BY clause. For example, the values of the Gender field are grouped by using the GROUP BY clause. In this case, the values of DiscreteProperty are Male, Female, and null.
   * 
   * @example
   * type2
   */
  discreteProperty?: string;
  /**
   * @remarks
   * The sample value.
   * 
   * @example
   * 23
   */
  value?: number;
  static names(): { [key: string]: string } {
    return {
      bizDate: 'BizDate',
      discreteProperty: 'DiscreteProperty',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizDate: 'string',
      discreteProperty: 'string',
      value: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByRuleResponseBodyDataRuleChecks extends $tea.Model {
  /**
   * @remarks
   * The partition in the monitored data source table.
   * 
   * @example
   * ds=20200925
   */
  actualExpression?: string;
  /**
   * @remarks
   * The time when the monitoring started.
   * 
   * @example
   * 1600704000000
   */
  beginTime?: number;
  /**
   * @remarks
   * The data timestamp. If the monitored business entity is offline data, the value is usually one day before the monitoring is performed.
   * 
   * @example
   * 1600704000000
   */
  bizDate?: number;
  /**
   * @remarks
   * The strength of the monitoring rule. The strength of a monitoring rule indicates the importance of the rule. Valid values:
   * 
   * *   1: indicates that the monitoring rule is a strong rule.
   * *   0: indicates that the monitoring rule is a weak rule. You can specify the strength of a monitoring rule based on your business requirements. If a monitoring rule is a strong rule and the critical threshold is exceeded, a critical alert is reported and tasks that are associated with the rule are blocked from running.
   * 
   * @example
   * 1
   */
  blockType?: number;
  /**
   * @remarks
   * The monitoring result.
   * 
   * @example
   * 2
   */
  checkResult?: number;
  /**
   * @remarks
   * The status of the monitoring result.
   * 
   * @example
   * 2
   */
  checkResultStatus?: number;
  /**
   * @remarks
   * The checker ID.
   * 
   * @example
   * 7
   */
  checkerId?: number;
  /**
   * @remarks
   * The name of the checker.
   * 
   * @example
   * fulx
   */
  checkerName?: string;
  /**
   * @remarks
   * The type of the checker.
   * 
   * @example
   * 0
   */
  checkerType?: number;
  /**
   * @remarks
   * The description of the monitoring rule.
   */
  comment?: string;
  /**
   * @remarks
   * The threshold for a critical alert. The threshold indicates the deviation of the monitoring result from the expected value. You can specify a custom value for the threshold based on your business requirements. If a monitoring rule is a strong rule and the critical threshold is exceeded, a critical alert is reported and tasks that are associated with the rule are blocked from running.
   * 
   * @example
   * 0.6
   */
  criticalThreshold?: number;
  /**
   * @remarks
   * The scheduling frequency. In most cases, the value of this parameter is YMD. This value indicates year, month, and day.
   * 
   * @example
   * YMD
   */
  dateType?: string;
  /**
   * @remarks
   * Indicates whether the monitoring is discrete monitoring. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * true
   */
  discreteCheck?: boolean;
  /**
   * @remarks
   * The time when the monitoring ended.
   * 
   * @example
   * 1600704000000
   */
  endTime?: number;
  /**
   * @remarks
   * The ID of the partition filter expression.
   * 
   * @example
   * 14534343
   */
  entityId?: number;
  /**
   * @remarks
   * The expected value.
   * 
   * @example
   * 90
   */
  expectValue?: number;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 123112232
   */
  externalId?: string;
  /**
   * @remarks
   * The type of the scheduling system. Only CWF scheduling systems are supported.
   * 
   * @example
   * CWF2
   */
  externalType?: string;
  /**
   * @remarks
   * Indicates whether the monitoring is performed based on a fixed value. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  fixedCheck?: boolean;
  /**
   * @remarks
   * The primary key ID.
   * 
   * @example
   * 2231123
   */
  id?: number;
  /**
   * @remarks
   * Indicates whether the monitoring result is the same as the predicted result. Valid values:
   * 
   * *   true
   * *   false
   * 
   * @example
   * false
   */
  isPrediction?: boolean;
  /**
   * @remarks
   * The lower limit of the predicted result. The value of this parameter is automatically generated based on the threshold that you specify.
   * 
   * @example
   * 2344
   */
  lowerValue?: number;
  /**
   * @remarks
   * The partition filter expression.
   * 
   * @example
   * ds=$[yyyymmdd]
   */
  matchExpression?: string;
  /**
   * @remarks
   * The method used to collect sample data, such as such as avg, count, sum, min, max, count_distinct, user_defined, table_count, table_size, table_dt_load_count, table_dt_refuseload_count, null_value, null_value/table_count, (table_count-count_distinct)/table_count, or table_count-count_distinct.
   * 
   * @example
   * max
   */
  methodName?: string;
  /**
   * @remarks
   * The comparison operator.
   * 
   * @example
   * >
   */
  op?: string;
  /**
   * @remarks
   * Indicates whether the monitoring rule is enabled.
   * 
   * @example
   * true
   */
  open?: boolean;
  /**
   * @remarks
   * The name of the compute engine or data source for which data quality is monitored.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The field whose data quality is checked based on the monitoring rule. This field is a column in the data source table that is monitored.
   * 
   * @example
   * type
   */
  property?: string;
  /**
   * @remarks
   * The historical sample values.
   */
  referenceValue?: ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue[];
  /**
   * @remarks
   * The string of the monitoring result.
   * 
   * @example
   * ResultString
   */
  resultString?: string;
  /**
   * @remarks
   * The ID of the monitoring rule.
   * 
   * @example
   * 123421
   */
  ruleId?: number;
  /**
   * @remarks
   * The name of the monitoring rule.
   */
  ruleName?: string;
  /**
   * @remarks
   * The current sample values.
   */
  sampleValue?: ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue[];
  /**
   * @remarks
   * The name of the table that is monitored.
   * 
   * @example
   * dual
   */
  tableName?: string;
  /**
   * @remarks
   * The monitoring task ID.
   * 
   * @example
   * 16008552981681a0d6****
   */
  taskId?: string;
  /**
   * @remarks
   * The ID of the monitoring template.
   * 
   * @example
   * 5
   */
  templateId?: number;
  /**
   * @remarks
   * The name of the monitoring template.
   */
  templateName?: string;
  /**
   * @remarks
   * The time that was taken to run the monitoring task.
   * 
   * @example
   * 10
   */
  timeCost?: string;
  /**
   * @remarks
   * The trend of the monitoring result.
   * 
   * @example
   * up
   */
  trend?: string;
  /**
   * @remarks
   * The upper limit of the predicted result. The value of this parameter is automatically generated based on the threshold that you specify.
   * 
   * @example
   * 22200
   */
  upperValue?: number;
  /**
   * @remarks
   * The threshold for a warning alert. The threshold specifies the deviation of the monitoring result from the expected value. You can specify a custom value for the threshold based on your business requirements.
   * 
   * @example
   * 0.1
   */
  warningThreshold?: number;
  /**
   * @remarks
   * The filter condition of the monitoring task.
   * 
   * @example
   * type!=\\"type2\\"
   */
  whereCondition?: string;
  static names(): { [key: string]: string } {
    return {
      actualExpression: 'ActualExpression',
      beginTime: 'BeginTime',
      bizDate: 'BizDate',
      blockType: 'BlockType',
      checkResult: 'CheckResult',
      checkResultStatus: 'CheckResultStatus',
      checkerId: 'CheckerId',
      checkerName: 'CheckerName',
      checkerType: 'CheckerType',
      comment: 'Comment',
      criticalThreshold: 'CriticalThreshold',
      dateType: 'DateType',
      discreteCheck: 'DiscreteCheck',
      endTime: 'EndTime',
      entityId: 'EntityId',
      expectValue: 'ExpectValue',
      externalId: 'ExternalId',
      externalType: 'ExternalType',
      fixedCheck: 'FixedCheck',
      id: 'Id',
      isPrediction: 'IsPrediction',
      lowerValue: 'LowerValue',
      matchExpression: 'MatchExpression',
      methodName: 'MethodName',
      op: 'Op',
      open: 'Open',
      projectName: 'ProjectName',
      property: 'Property',
      referenceValue: 'ReferenceValue',
      resultString: 'ResultString',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      sampleValue: 'SampleValue',
      tableName: 'TableName',
      taskId: 'TaskId',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
      timeCost: 'TimeCost',
      trend: 'Trend',
      upperValue: 'UpperValue',
      warningThreshold: 'WarningThreshold',
      whereCondition: 'WhereCondition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualExpression: 'string',
      beginTime: 'number',
      bizDate: 'number',
      blockType: 'number',
      checkResult: 'number',
      checkResultStatus: 'number',
      checkerId: 'number',
      checkerName: 'string',
      checkerType: 'number',
      comment: 'string',
      criticalThreshold: 'number',
      dateType: 'string',
      discreteCheck: 'boolean',
      endTime: 'number',
      entityId: 'number',
      expectValue: 'number',
      externalId: 'string',
      externalType: 'string',
      fixedCheck: 'boolean',
      id: 'number',
      isPrediction: 'boolean',
      lowerValue: 'number',
      matchExpression: 'string',
      methodName: 'string',
      op: 'string',
      open: 'boolean',
      projectName: 'string',
      property: 'string',
      referenceValue: { 'type': 'array', 'itemType': ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue },
      resultString: 'string',
      ruleId: 'number',
      ruleName: 'string',
      sampleValue: { 'type': 'array', 'itemType': ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue },
      tableName: 'string',
      taskId: 'string',
      templateId: 'number',
      templateName: 'string',
      timeCost: 'string',
      trend: 'string',
      upperValue: 'number',
      warningThreshold: 'number',
      whereCondition: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityResultsByRuleResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The returned monitoring results.
   */
  ruleChecks?: ListQualityResultsByRuleResponseBodyDataRuleChecks[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 200
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      ruleChecks: 'RuleChecks',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      ruleChecks: { 'type': 'array', 'itemType': ListQualityResultsByRuleResponseBodyDataRuleChecks },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityRulesResponseBodyDataRules extends $tea.Model {
  /**
   * @remarks
   * The strength of the monitoring rule. The strength of a monitoring rule indicates the importance of the rule. Valid values:
   * 
   * *   1: The monitoring rule is a strong rule.
   * *   0: The monitoring rule is a weak rule. You can specify the strength of a monitoring rule based on your business requirements. If a monitoring rule is a strong rule and the critical threshold is exceeded, a critical alert is reported and tasks that are associated with the rule are blocked from running.
   * 
   * @example
   * 0
   */
  blockType?: number;
  /**
   * @remarks
   * The checker ID.
   * 
   * @example
   * 7
   */
  checkerId?: number;
  /**
   * @remarks
   * The description of the system defense rule.
   */
  comment?: string;
  /**
   * @remarks
   * The threshold for a critical alert. The threshold indicates the deviation of the monitoring result from the expected value. You can specify a custom value for the threshold based on your business requirements. If a monitoring rule is a strong rule and the critical threshold is exceeded, a critical alert is reported and tasks that are associated with the rule are blocked from running.
   * 
   * @example
   * 40
   */
  criticalThreshold?: string;
  /**
   * @remarks
   * The ID of the partition filter expression.
   * 
   * @example
   * 1234
   */
  entityId?: number;
  /**
   * @remarks
   * The expected value.
   * 
   * @example
   * 1000
   */
  expectValue?: string;
  /**
   * @remarks
   * Indicates whether the monitoring is performed based on a fixed value.
   * 
   * @example
   * true
   */
  fixCheck?: boolean;
  /**
   * @remarks
   * The historical threshold for a critical alert.
   * 
   * @example
   * history max:80%,history min:50%
   */
  historyCriticalThreshold?: string;
  /**
   * @remarks
   * The historical threshold for a warning alert.
   * 
   * @example
   * history max:40%,history min:10%
   */
  historyWarningThreshold?: string;
  /**
   * @remarks
   * The monitoring rule ID.
   * 
   * @example
   * 1234
   */
  id?: number;
  /**
   * @remarks
   * The partition filter expression.
   * 
   * @example
   * dt=$[yyyymmdd]
   */
  matchExpression?: string;
  /**
   * @remarks
   * The ID of the task that is associated with the partition filter expression.
   * 
   * @example
   * 21
   */
  methodId?: number;
  /**
   * @remarks
   * The method that is used to collect sample data, such as avg, count, sum, min, max, count_distinct, user_defined, table_count, table_size, table_dt_load_count, table_dt_refuseload_count, null_value, null_value/table_count, (table_count-count_distinct)/table_count, or table_count-count_distinct.
   * 
   * @example
   * count/table_count
   */
  methodName?: string;
  /**
   * @remarks
   * The name of the Alibaba Cloud account that is used to configure the monitoring rule.
   * 
   * @example
   * 1912****
   */
  onDuty?: string;
  /**
   * @remarks
   * The name of the Alibaba Cloud account that is used to configure the monitoring rule.
   * 
   * @example
   * test
   */
  onDutyAccountName?: string;
  /**
   * @remarks
   * The name of the compute engine or data source.
   * 
   * @example
   * autotest
   */
  projectName?: string;
  /**
   * @remarks
   * The name of the field.
   * 
   * @example
   * id
   */
  property?: string;
  /**
   * @remarks
   * The field that is used to associate with monitoring rules at the frontend. This parameter can be ignored.
   * 
   * @example
   * table_count
   */
  propertyKey?: string;
  /**
   * @remarks
   * The ID of the task that is associated with the partition filter expression.
   * 
   * @example
   * 132323
   */
  ruleCheckerRelationId?: number;
  /**
   * @remarks
   * The name of the monitoring rule.
   * 
   * @example
   * test
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the monitoring rule. Valid values:
   * 
   * *   0: The monitoring rule is created by the system.
   * *   1: The monitoring rule is created by a user.
   * *   2: The monitoring rule is a workspace-level rule.
   * 
   * @example
   * 0
   */
  ruleType?: number;
  /**
   * @remarks
   * The name of the table.
   * 
   * @example
   * dual
   */
  tableName?: string;
  /**
   * @remarks
   * The ID of the monitoring template.
   * 
   * @example
   * 7
   */
  templateId?: number;
  /**
   * @remarks
   * The name of the monitoring template.
   */
  templateName?: string;
  /**
   * @remarks
   * The trend of the monitoring result.
   * 
   * @example
   * abs
   */
  trend?: string;
  /**
   * @remarks
   * The threshold for a warning alert. The threshold specifies the deviation of the monitoring result from the expected value. You can specify a custom value for the threshold based on your business requirements.
   * 
   * @example
   * 10
   */
  warningThreshold?: string;
  static names(): { [key: string]: string } {
    return {
      blockType: 'BlockType',
      checkerId: 'CheckerId',
      comment: 'Comment',
      criticalThreshold: 'CriticalThreshold',
      entityId: 'EntityId',
      expectValue: 'ExpectValue',
      fixCheck: 'FixCheck',
      historyCriticalThreshold: 'HistoryCriticalThreshold',
      historyWarningThreshold: 'HistoryWarningThreshold',
      id: 'Id',
      matchExpression: 'MatchExpression',
      methodId: 'MethodId',
      methodName: 'MethodName',
      onDuty: 'OnDuty',
      onDutyAccountName: 'OnDutyAccountName',
      projectName: 'ProjectName',
      property: 'Property',
      propertyKey: 'PropertyKey',
      ruleCheckerRelationId: 'RuleCheckerRelationId',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      tableName: 'TableName',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
      trend: 'Trend',
      warningThreshold: 'WarningThreshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockType: 'number',
      checkerId: 'number',
      comment: 'string',
      criticalThreshold: 'string',
      entityId: 'number',
      expectValue: 'string',
      fixCheck: 'boolean',
      historyCriticalThreshold: 'string',
      historyWarningThreshold: 'string',
      id: 'number',
      matchExpression: 'string',
      methodId: 'number',
      methodName: 'string',
      onDuty: 'string',
      onDutyAccountName: 'string',
      projectName: 'string',
      property: 'string',
      propertyKey: 'string',
      ruleCheckerRelationId: 'number',
      ruleName: 'string',
      ruleType: 'number',
      tableName: 'string',
      templateId: 'number',
      templateName: 'string',
      trend: 'string',
      warningThreshold: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQualityRulesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 20
   */
  pageSize?: number;
  /**
   * @remarks
   * The details of the monitoring rule.
   */
  rules?: ListQualityRulesResponseBodyDataRules[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 400
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      rules: 'Rules',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      rules: { 'type': 'array', 'itemType': ListQualityRulesResponseBodyDataRules },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRefDISyncTasksResponseBodyDataDISyncTasks extends $tea.Model {
  /**
   * @remarks
   * The destination of the synchronization task. If the synchronization task has multiple destinations, the return value is a JSON array, such as \\\\"odps_writer\\\\", \\\\"mysql\\\\". If the RefType parameter is set to to, the synchronization tasks that use the specified data source as the destination are returned. In this case, the value of this parameter indicates the specified data source.
   * 
   * @example
   * [\\"qcc_polardb2\\"]
   */
  diDestinationDatasource?: string;
  /**
   * @remarks
   * The source of the synchronization task. If the synchronization task has multiple sources, the return value is a JSON array, such as \\\\"odps_writer\\\\", \\\\"mysql\\\\". If the RefType parameter is set to from, the synchronization tasks that use the specified data source as the source are returned. In this case, the value of this parameter indicates the specified data source.
   * 
   * @example
   * [\\"odps_writer\\"]
   */
  diSourceDatasource?: string;
  /**
   * @remarks
   * The ID of the synchronization task.
   * 
   * @example
   * 100000
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the synchronization task.
   * 
   * @example
   * abcd1234
   */
  nodeName?: string;
  /**
   * @remarks
   * The type of the synchronization task. Valid values:
   * 
   * *   DI_OFFLINE: batch synchronization task
   * *   DI_REALTIME: real-time synchronization task
   * 
   * @example
   * DI_OFFLINE
   */
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      diDestinationDatasource: 'DiDestinationDatasource',
      diSourceDatasource: 'DiSourceDatasource',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diDestinationDatasource: 'string',
      diSourceDatasource: 'string',
      nodeId: 'number',
      nodeName: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRefDISyncTasksResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The details of the synchronization tasks. In most cases, a data source is used by multiple synchronization tasks. Therefore, the value of this parameter is an array. The following parameters are the elements in the array. The sample values of these parameters show the details of a synchronization task.
   */
  DISyncTasks?: ListRefDISyncTasksResponseBodyDataDISyncTasks[];
  static names(): { [key: string]: string } {
    return {
      DISyncTasks: 'DISyncTasks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      DISyncTasks: { 'type': 'array', 'itemType': ListRefDISyncTasksResponseBodyDataDISyncTasks },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRemindsResponseBodyDataReminds extends $tea.Model {
  /**
   * @remarks
   * The notification method. Valid values: MAIL, SMS, and PHONE. The value MAIL indicates that the notification is sent by email. Only DataWorks Professional Edition and more advanced editions support the PHONE notification method.
   */
  alertMethods?: string[];
  /**
   * @remarks
   * The IDs of the Alibaba Cloud accounts used by alert recipients.
   */
  alertTargets?: string[];
  /**
   * @remarks
   * The alert recipient. Valid values: OWNER and OTHER. The value OWNER indicates the node owner. The value OTHER indicates a specified user.
   * 
   * @example
   * OWNER
   */
  alertUnit?: string;
  /**
   * @remarks
   * The IDs of the baselines to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is BASELINE.
   */
  baselineIds?: number[];
  /**
   * @remarks
   * The IDs of the workflows to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is BIZPROCESS.
   */
  bizProcessIds?: number[];
  /**
   * @remarks
   * The end time of the quiet hours. The time is in the hh:mm format. Valid values of hh: [0,23]. Valid values of mm: [0,59].
   * 
   * @example
   * 08:00
   */
  dndEnd?: string;
  /**
   * @remarks
   * The start time of the quiet hours. The time is in the hh:mm format. Valid values of hh: [0,23]. Valid values of mm: [0,59].
   * 
   * @example
   * 00:00
   */
  dndStart?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the rule creator.
   * 
   * @example
   * 952795****
   */
  founder?: string;
  /**
   * @remarks
   * The IDs of the nodes to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is NODE.
   */
  nodeIds?: number[];
  /**
   * @remarks
   * The IDs of the workspaces to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is PROJECT.
   */
  projectIds?: number[];
  /**
   * @remarks
   * The custom alert rule ID.
   * 
   * @example
   * 1234
   */
  remindId?: number;
  /**
   * @remarks
   * The name of the custom alert rule.
   * 
   * @example
   * Alert Rule
   */
  remindName?: string;
  /**
   * @remarks
   * The condition that triggers an alert. Valid values: FINISHED, UNFINISHED, ERROR, CYCLE_UNFINISHED, and TIMEOUT.
   * 
   * @example
   * FINISHED
   */
  remindType?: string;
  /**
   * @remarks
   * The type of the object to which the custom alert rule is applied. Valid values: NODE, BASELINE, PROJECT, and BIZPROCESS. The value NODE indicates a node. The value BASELINE indicates a baseline. The value PROJECT indicates a workspace. The value BIZPROCESS indicates a workflow.
   * 
   * @example
   * NODE
   */
  remindUnit?: string;
  /**
   * @remarks
   * Indicates whether the custom alert rule is enabled. Valid values: true and false.
   * 
   * @example
   * true
   */
  useflag?: boolean;
  static names(): { [key: string]: string } {
    return {
      alertMethods: 'AlertMethods',
      alertTargets: 'AlertTargets',
      alertUnit: 'AlertUnit',
      baselineIds: 'BaselineIds',
      bizProcessIds: 'BizProcessIds',
      dndEnd: 'DndEnd',
      dndStart: 'DndStart',
      founder: 'Founder',
      nodeIds: 'NodeIds',
      projectIds: 'ProjectIds',
      remindId: 'RemindId',
      remindName: 'RemindName',
      remindType: 'RemindType',
      remindUnit: 'RemindUnit',
      useflag: 'Useflag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertMethods: { 'type': 'array', 'itemType': 'string' },
      alertTargets: { 'type': 'array', 'itemType': 'string' },
      alertUnit: 'string',
      baselineIds: { 'type': 'array', 'itemType': 'number' },
      bizProcessIds: { 'type': 'array', 'itemType': 'number' },
      dndEnd: 'string',
      dndStart: 'string',
      founder: 'string',
      nodeIds: { 'type': 'array', 'itemType': 'number' },
      projectIds: { 'type': 'array', 'itemType': 'number' },
      remindId: 'number',
      remindName: 'string',
      remindType: 'string',
      remindUnit: 'string',
      useflag: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRemindsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The list of custom alert rules.
   */
  reminds?: ListRemindsResponseBodyDataReminds[];
  /**
   * @remarks
   * The total number of custom alert rules returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      reminds: 'Reminds',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      reminds: { 'type': 'array', 'itemType': ListRemindsResponseBodyDataReminds },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourceGroupsRequestTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * Env
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * Test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourceGroupsResponseBodyDataTags extends $tea.Model {
  /**
   * @remarks
   * The tag key.
   * 
   * @example
   * Env
   */
  key?: string;
  /**
   * @remarks
   * The tag value.
   * 
   * @example
   * Test
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListResourceGroupsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The category of the resource group. Valid values:
   * 
   * *   default: shared resource group
   * *   single: exclusive resource group
   * 
   * @example
   * default
   */
  bizExtKey?: string;
  /**
   * @remarks
   * The name of the cluster. This parameter is returned only if the type of the resource group is MaxCompute or PAI.
   * 
   * @example
   * AY18G
   */
  cluster?: string;
  /**
   * @remarks
   * The time when the cluster was created. Example: Jul 9, 2018 2:43:37 PM.
   * 
   * @example
   * Jul 9, 2018 2:43:37 PM
   */
  createTime?: string;
  /**
   * @remarks
   * Indicates whether the UID of an Alibaba Cloud account is used for access. Valid values:
   * 
   * *   true: The MaxCompute compute engine uses the UID of the Alibaba Cloud account as the display name of the account for access.
   * *   false: The MaxCompute compute engine uses the name of the Alibaba Cloud account as the display name of the account for access. The remaining values are useless. This parameter is returned only if the type of the resource group is MaxCompute.
   * 
   * @example
   * false
   */
  enableKp?: boolean;
  /**
   * @remarks
   * The resource group ID.
   * 
   * @example
   * 1234567
   */
  id?: number;
  /**
   * @remarks
   * The identifier of the resource group.
   * 
   * @example
   * e1815577-2f4e-4c5e-b29****
   */
  identifier?: string;
  /**
   * @remarks
   * Indicates whether the resource group is the default resource group. Valid values:
   * 
   * *   true: The resource group is the default resource group.
   * *   false: The resource group is not the default resource group.
   * 
   * @example
   * true
   */
  isDefault?: boolean;
  /**
   * @remarks
   * The mode of the resource group. Valid values:
   * 
   * *   ISOLATE: exclusive resource group that adopts the subscription billing method
   * *   SHARE: shared resource group that adopts the pay-as-you-go billing method
   * *   DEVELOP: resource group for developers
   * 
   * @example
   * SHARE
   */
  mode?: string;
  /**
   * @remarks
   * The name of the resource group.
   * 
   * @example
   * abc
   */
  name?: string;
  /**
   * @remarks
   * The type of the resource group. Valid values:
   * 
   * *   0: DataWorks
   * *   2: MaxCompute
   * *   3: PAI
   * *   4: Data Integration
   * *   7: scheduling
   * *   9: DataService Studio
   * 
   * @example
   * 3
   */
  resourceGroupType?: string;
  /**
   * @remarks
   * The ID of your Alibaba Cloud resource group.
   * 
   * @example
   * rg-acfmzbn7pti3zfa
   */
  resourceManagerResourceGroupId?: string;
  /**
   * @remarks
   * The sequence number of the resource group. Created resource groups are sorted in ascending order by sequence number.
   * 
   * @example
   * 300
   */
  sequence?: number;
  /**
   * @remarks
   * The details of the resource group. The content enclosed in braces {} is the details of the resource group.
   * 
   * @example
   * {}
   */
  specs?: { [key: string]: any };
  /**
   * @remarks
   * The status of the resource group. Valid values:
   * 
   * *   0: NORMAL, which indicates that the resource group is running or in service.
   * *   1: STOP, which indicates that the resource group has expired and is frozen.
   * *   2: DELETED, which indicates that the resource group is released or destroyed.
   * *   3: CREATING, which indicates that the resource group is being created or started.
   * *   4: CREATE_FAILED, which indicates that the resource group fails to be created or started.
   * *   5: UPDATING, which indicates that the resource group is being scaled out or upgraded.
   * *   6: UPDATE_FAILED, which indicates that the resource group fails to be scaled out or upgraded.
   * *   7: DELETING, which indicates that the resource group is being released or destroyed.
   * *   8: DELETE_FAILED, which indicates that the resource group fails to be released or destroyed.
   * *   9: TIMEOUT, which indicates that the operation performed on the resource group times out. All operations may time out. This value is temporarily available only for DataService Studio.
   * 
   * @example
   * 0
   */
  status?: number;
  /**
   * @remarks
   * The tags.
   */
  tags?: ListResourceGroupsResponseBodyDataTags[];
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 1234567
   */
  tenantId?: number;
  /**
   * @remarks
   * The time when the resource group was last updated.
   * 
   * @example
   * Jul 9, 2018 2:43:37 PM
   */
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      bizExtKey: 'BizExtKey',
      cluster: 'Cluster',
      createTime: 'CreateTime',
      enableKp: 'EnableKp',
      id: 'Id',
      identifier: 'Identifier',
      isDefault: 'IsDefault',
      mode: 'Mode',
      name: 'Name',
      resourceGroupType: 'ResourceGroupType',
      resourceManagerResourceGroupId: 'ResourceManagerResourceGroupId',
      sequence: 'Sequence',
      specs: 'Specs',
      status: 'Status',
      tags: 'Tags',
      tenantId: 'TenantId',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizExtKey: 'string',
      cluster: 'string',
      createTime: 'string',
      enableKp: 'boolean',
      id: 'number',
      identifier: 'string',
      isDefault: 'boolean',
      mode: 'string',
      name: 'string',
      resourceGroupType: 'string',
      resourceManagerResourceGroupId: 'string',
      sequence: 'number',
      specs: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      status: 'number',
      tags: { 'type': 'array', 'itemType': ListResourceGroupsResponseBodyDataTags },
      tenantId: 'number',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListShiftPersonnelsResponseBodyPagingShiftPersons extends $tea.Model {
  /**
   * @remarks
   * The time when the on-duty engineer starts the shift.
   * 
   * @example
   * 1593950832000
   */
  beginTime?: number;
  /**
   * @remarks
   * The time when the on-duty engineer ends the shift.
   * 
   * @example
   * 1593950832000
   */
  endTime?: number;
  /**
   * @remarks
   * The name of the on-duty engineer.
   */
  shiftPersonName?: string;
  /**
   * @remarks
   * The UID of the on-duty engineer.
   * 
   * @example
   * 3726346****
   */
  shiftPersonUID?: string;
  static names(): { [key: string]: string } {
    return {
      beginTime: 'BeginTime',
      endTime: 'EndTime',
      shiftPersonName: 'ShiftPersonName',
      shiftPersonUID: 'ShiftPersonUID',
    };
  }

  static types(): { [key: string]: any } {
    return {
      beginTime: 'number',
      endTime: 'number',
      shiftPersonName: 'string',
      shiftPersonUID: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListShiftPersonnelsResponseBodyPaging extends $tea.Model {
  /**
   * @remarks
   * The page number. Valid values: 1 to 100. Default value: 1.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page. Default value: 10. Maximum value: 100.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * A list of on-duty engineers in a shift schedule.
   */
  shiftPersons?: ListShiftPersonnelsResponseBodyPagingShiftPersons[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      shiftPersons: 'ShiftPersons',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      shiftPersons: { 'type': 'array', 'itemType': ListShiftPersonnelsResponseBodyPagingShiftPersons },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListShiftSchedulesResponseBodyPagingShiftSchedules extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the shift schedule. You can use the identifier to query the on-duty engineers in the shift schedule.
   * 
   * @example
   * 2ab6456ada634b2f938ee******9b45b
   */
  shiftScheduleIdentifier?: string;
  /**
   * @remarks
   * The name of the shift schedule.
   */
  shiftScheduleName?: string;
  static names(): { [key: string]: string } {
    return {
      shiftScheduleIdentifier: 'ShiftScheduleIdentifier',
      shiftScheduleName: 'ShiftScheduleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      shiftScheduleIdentifier: 'string',
      shiftScheduleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListShiftSchedulesResponseBodyPaging extends $tea.Model {
  /**
   * @remarks
   * The page number. Minimum value: 1. Maximum value: 100.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The shift schedules.
   */
  shiftSchedules?: ListShiftSchedulesResponseBodyPagingShiftSchedules[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      shiftSchedules: 'ShiftSchedules',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      shiftSchedules: { 'type': 'array', 'itemType': ListShiftSchedulesResponseBodyPagingShiftSchedules },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend extends $tea.Model {
  /**
   * @remarks
   * The number of instances that are successfully run.
   * 
   * @example
   * 10
   */
  count?: number;
  /**
   * @remarks
   * The point in time. The value is an exact hour that ranges from 00:00 to 23:00, such as 00:00, 01:00, or 02:00.
   * 
   * @example
   * 01:00
   */
  timePoint?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      timePoint: 'TimePoint',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      timePoint: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend extends $tea.Model {
  /**
   * @remarks
   * The number of instances that are successfully run.
   * 
   * @example
   * 10
   */
  count?: number;
  /**
   * @remarks
   * The point in time. The value is an exact hour that ranges from 00:00 to 23:00, such as 00:00, 01:00, or 02:00.
   * 
   * @example
   * 01:00
   */
  timePoint?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      timePoint: 'TimePoint',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      timePoint: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend extends $tea.Model {
  /**
   * @remarks
   * The number of instances that are successfully run.
   * 
   * @example
   * 10
   */
  count?: number;
  /**
   * @remarks
   * The point in time. The value is an exact hour that ranges from 00:00 to 23:00, such as 00:00, 01:00, or 02:00.
   * 
   * @example
   * 01:00
   */
  timePoint?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      timePoint: 'TimePoint',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      timePoint: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSuccessInstanceAmountResponseBodyInstanceStatusTrend extends $tea.Model {
  /**
   * @remarks
   * The average trend.
   */
  avgTrend?: ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend[];
  /**
   * @remarks
   * The trend of the number of auto triggered node instances that are successfully run on the current day.
   */
  todayTrend?: ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend[];
  /**
   * @remarks
   * The trend of the number of auto triggered node instances that are successfully run one day earlier than the current day.
   */
  yesterdayTrend?: ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend[];
  static names(): { [key: string]: string } {
    return {
      avgTrend: 'AvgTrend',
      todayTrend: 'TodayTrend',
      yesterdayTrend: 'YesterdayTrend',
    };
  }

  static types(): { [key: string]: any } {
    return {
      avgTrend: { 'type': 'array', 'itemType': ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend },
      todayTrend: { 'type': 'array', 'itemType': ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend },
      yesterdayTrend: { 'type': 'array', 'itemType': ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableLevelResponseBodyTableLevelInfoLevelList extends $tea.Model {
  /**
   * @remarks
   * The description of the table level.
   * 
   * @example
   * test
   */
  description?: string;
  /**
   * @remarks
   * The table level ID.
   * 
   * @example
   * 123
   */
  levelId?: number;
  /**
   * @remarks
   * The table level type. Valid values: 1 and 2. The value 1 indicates the logical level. The value 2 indicates the physical level.
   * 
   * @example
   * 1
   */
  levelType?: number;
  /**
   * @remarks
   * The name of the table level.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The ID of the DataWorks workspace.
   * 
   * @example
   * 123
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      levelId: 'LevelId',
      levelType: 'LevelType',
      name: 'Name',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      levelId: 'number',
      levelType: 'number',
      name: 'string',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableLevelResponseBodyTableLevelInfo extends $tea.Model {
  /**
   * @remarks
   * The list of table levels.
   */
  levelList?: ListTableLevelResponseBodyTableLevelInfoLevelList[];
  /**
   * @remarks
   * The total number of table levels returned.
   * 
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      levelList: 'LevelList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      levelList: { 'type': 'array', 'itemType': ListTableLevelResponseBodyTableLevelInfoLevelList },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableThemeResponseBodyDataThemeList extends $tea.Model {
  /**
   * @remarks
   * The time when the table level was created.
   * 
   * @example
   * 123432343243
   */
  createTimeStamp?: number;
  /**
   * @remarks
   * The creator of the table level.
   * 
   * @example
   * 123455
   */
  creator?: string;
  /**
   * @remarks
   * The level of the table folder. Valid values: 1 and 2. The value 1 indicates the first level. The value 2 indicates the second level.
   * 
   * @example
   * 1
   */
  level?: number;
  /**
   * @remarks
   * The name of the table level.
   * 
   * @example
   * test
   */
  name?: string;
  /**
   * @remarks
   * The ancestor node ID.
   * 
   * @example
   * 122
   */
  parentId?: number;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 123
   */
  projectId?: number;
  /**
   * @remarks
   * The table theme ID.
   * 
   * @example
   * 123
   */
  themeId?: number;
  static names(): { [key: string]: string } {
    return {
      createTimeStamp: 'CreateTimeStamp',
      creator: 'Creator',
      level: 'Level',
      name: 'Name',
      parentId: 'ParentId',
      projectId: 'ProjectId',
      themeId: 'ThemeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTimeStamp: 'number',
      creator: 'string',
      level: 'number',
      name: 'string',
      parentId: 'number',
      projectId: 'number',
      themeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTableThemeResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of table levels.
   */
  themeList?: ListTableThemeResponseBodyDataThemeList[];
  /**
   * @remarks
   * The total number of entries returned.
   * 
   * @example
   * 10
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      themeList: 'ThemeList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      themeList: { 'type': 'array', 'itemType': ListTableThemeResponseBodyDataThemeList },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBodyDataTableEntityListEntityContent extends $tea.Model {
  /**
   * @example
   * accountId:cn-shanghai:odps:project
   */
  dataSourceQualifiedName?: string;
  /**
   * @example
   * e70f92239d491057f6a2563b545bdaf8cc6b537d9dc55ec84c55f7cfefg
   */
  dataSourceUniqueId?: string;
  /**
   * @example
   * database
   */
  databaseName?: string;
  /**
   * @example
   * rm-uf6rn0123
   */
  instanceId?: string;
  /**
   * @example
   * project
   */
  projectName?: string;
  /**
   * @example
   * table
   */
  tableName?: string;
  static names(): { [key: string]: string } {
    return {
      dataSourceQualifiedName: 'DataSourceQualifiedName',
      dataSourceUniqueId: 'DataSourceUniqueId',
      databaseName: 'DatabaseName',
      instanceId: 'InstanceId',
      projectName: 'ProjectName',
      tableName: 'TableName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataSourceQualifiedName: 'string',
      dataSourceUniqueId: 'string',
      databaseName: 'string',
      instanceId: 'string',
      projectName: 'string',
      tableName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBodyDataTableEntityList extends $tea.Model {
  entityContent?: ListTablesResponseBodyDataTableEntityListEntityContent;
  /**
   * @example
   * maxcompute-table.project.table
   */
  entityQualifiedName?: string;
  static names(): { [key: string]: string } {
    return {
      entityContent: 'EntityContent',
      entityQualifiedName: 'EntityQualifiedName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityContent: ListTablesResponseBodyDataTableEntityListEntityContent,
      entityQualifiedName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTablesResponseBodyData extends $tea.Model {
  /**
   * @example
   * AAAAAVY3rYiv9VoUJQSiCitgjgSwg+byk0FIjirFkm4zfM4G0xYwM/FQvOhgrTHsCPIZ5yqXYu2NG6qRCRC52HvwbOA=
   */
  nextToken?: string;
  tableEntityList?: ListTablesResponseBodyDataTableEntityList[];
  /**
   * @example
   * 100
   */
  total?: number;
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      tableEntityList: 'TableEntityList',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      tableEntityList: { 'type': 'array', 'itemType': ListTablesResponseBodyDataTableEntityList },
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTopicsResponseBodyDataTopics extends $tea.Model {
  /**
   * @remarks
   * The timestamp when the event was found.
   * 
   * @example
   * 1553524393000
   */
  addTime?: number;
  /**
   * @remarks
   * The timestamp when the event was processed.
   * 
   * @example
   * 1553508465000
   */
  fixTime?: number;
  /**
   * @remarks
   * The timestamp when the event occurred. A time difference may exist between the time when the event occurred and the time when the event was found.
   * 
   * @example
   * 1553508465000
   */
  happenTime?: number;
  /**
   * @remarks
   * The ID of the node instance that triggers the event.
   * 
   * @example
   * 12345
   */
  instanceId?: number;
  /**
   * @remarks
   * The ID of the node that triggers the event.
   * 
   * @example
   * 1234
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   * 
   * @example
   * Node Name
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account that is used by the node owner.
   * 
   * @example
   * 952795****
   */
  nodeOwner?: string;
  /**
   * @remarks
   * The ID of the workspace to which the node belongs.
   * 
   * @example
   * 1234
   */
  projectId?: number;
  /**
   * @remarks
   * The ID of the event.
   * 
   * @example
   * 1234
   */
  topicId?: number;
  /**
   * @remarks
   * The name of the event.
   * 
   * @example
   * 1234 Error
   */
  topicName?: string;
  /**
   * @remarks
   * The status of the event. Valid values: IGNORE, NEW, FIXING, and RECOVER. The value IGNORE indicates that the event is ignored. The value NEW indicates that the event is a new event. The value FIXING indicates that the event is being processed. The value RECOVER indicates that the event is processed.
   * 
   * @example
   * NEW
   */
  topicStatus?: string;
  /**
   * @remarks
   * The type of the event. Valid values: SLOW and ERROR. The value SLOW indicates that the running duration of the node in the current scheduling cycle is significantly longer than the average running duration of the node in previous scheduling cycles. The value ERROR indicates that the node fails to run.
   * 
   * @example
   * ERROR
   */
  topicType?: string;
  static names(): { [key: string]: string } {
    return {
      addTime: 'AddTime',
      fixTime: 'FixTime',
      happenTime: 'HappenTime',
      instanceId: 'InstanceId',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      nodeOwner: 'NodeOwner',
      projectId: 'ProjectId',
      topicId: 'TopicId',
      topicName: 'TopicName',
      topicStatus: 'TopicStatus',
      topicType: 'TopicType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addTime: 'number',
      fixTime: 'number',
      happenTime: 'number',
      instanceId: 'number',
      nodeId: 'number',
      nodeName: 'string',
      nodeOwner: 'string',
      projectId: 'number',
      topicId: 'number',
      topicName: 'string',
      topicStatus: 'string',
      topicType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTopicsResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The page number of the returned page.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries returned per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The events returned.
   */
  topics?: ListTopicsResponseBodyDataTopics[];
  /**
   * @remarks
   * The total number of the events returned.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      topics: 'Topics',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      topics: { 'type': 'array', 'itemType': ListTopicsResponseBodyDataTopics },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDISyncTaskConfigProcessResultResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The reason why the parameters fail to be obtained. If the parameters are obtained, the value null is returned.
   * 
   * @example
   * fileId:[100] is invalid.
   */
  message?: string;
  /**
   * @remarks
   * Indicates whether the parameters are obtained. Valid values:
   * 
   * *   success: The parameters are obtained.
   * *   fail: The parameters fail to be obtained. You can view the reason for the failure and troubleshoot the issue based on the reason.
   * 
   * @example
   * success
   */
  status?: string;
  /**
   * @remarks
   * The parameters that are obtained. The parameters are used as the request parameters of the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) or [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to create or update a real-time synchronization task in Data Integration.
   * 
   * @example
   * {"extend":{"mode":"migration_holo","resourceGroup":"280749","name":"h"},"type":"job","steps":[{"stepType":"mysql","parameter":{"connection":[{"datasourceType":"mysql","datasource":"mm","selectedTables":[{"schema":[{"tableInfos":[{"enable":true,"table":"m_v1","tableName":"m_v1"}]}],"dbName":"m"}]}]},"name":"reader","category":"reader"},{"stepType":"holo","parameter":{"datasource":"h","tableMappingRule":{"datasource":[{"tableRule":[{"srcTable":"m_v1","mergeIntoCycleType":"DEFAULT","hourDeltaEnable":false,"dstTable":"m.m_v1","dayDeltaEnable":false,"primaryKeyInfo":{"column":["id"],"type":"pk"},"dstCreateTableInfo":{"indexType":"m_v1","dataColumn":[{"columnSize":0,"name":"id","index":0,"comment":"","newDigit":0,"type":"int8","digit":0,"primaryKey":true}],"schemaName":"m","tableName":"m_v1"},"srcDbName":"m"],"srcDatasourceName":"mm"}],"totalTableMapping":1},"writeMode":"replay"},"name":"writer","category":"writer"}],"version":"2.0","order":{"hops":[{"from":"reader","to":"writer"}]}}
   */
  taskContent?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      status: 'Status',
      taskContent: 'TaskContent',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      status: 'string',
      taskContent: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RegisterLineageRelationResponseBodyLineageRelation extends $tea.Model {
  /**
   * @remarks
   * The unique identifier of the destination entity.
   * 
   * @example
   * custom-report.month_stat_user
   */
  destEntityQualifiedName?: string;
  /**
   * @remarks
   * The ID of the lineage between entities.
   * 
   * @example
   * dfsldfdlsfdsaaaabbbb
   */
  relationshipGuid?: string;
  /**
   * @remarks
   * The unique identifier of the source entity.
   * 
   * @example
   * maxcompute-table.project.table
   */
  srcEntityQualifiedName?: string;
  static names(): { [key: string]: string } {
    return {
      destEntityQualifiedName: 'DestEntityQualifiedName',
      relationshipGuid: 'RelationshipGuid',
      srcEntityQualifiedName: 'SrcEntityQualifiedName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destEntityQualifiedName: 'string',
      relationshipGuid: 'string',
      srcEntityQualifiedName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMetaTablesResponseBodyDataDataEntityList extends $tea.Model {
  /**
   * @remarks
   * The ID of the EMR cluster.
   * 
   * @example
   * abc
   */
  clusterId?: string;
  /**
   * @remarks
   * The name of the metadatabase.
   * 
   * @example
   * abc
   */
  databaseName?: string;
  /**
   * @remarks
   * The type of the metatable. Valid values:
   * 
   * *   0: table
   * *   1: view
   * 
   * @example
   * 0
   */
  entityType?: number;
  /**
   * @remarks
   * The type of the environment. Valid values:
   * 
   * *   1: production environment
   * *   0: development environment
   * 
   * @example
   * 1
   */
  envType?: number;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the workspace owner.
   * 
   * @example
   * 123
   */
  ownerId?: string;
  /**
   * @remarks
   * The ID of the workspace.
   * 
   * @example
   * 323
   */
  projectId?: number;
  /**
   * @remarks
   * The name of the workspace.
   * 
   * @example
   * test
   */
  projectName?: string;
  /**
   * @remarks
   * The schema information of the table. You must configure this parameter if you enable the three-layer model of MaxCompute.
   * 
   * @example
   * default
   */
  schema?: string;
  /**
   * @remarks
   * The GUID of the metatable.
   * 
   * @example
   * odps.engine_name.test_name
   */
  tableGuid?: string;
  /**
   * @remarks
   * The name of the metatable.
   * 
   * @example
   * test_name
   */
  tableName?: string;
  /**
   * @remarks
   * The tenant ID.
   * 
   * @example
   * 12345
   */
  tenantId?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      databaseName: 'DatabaseName',
      entityType: 'EntityType',
      envType: 'EnvType',
      ownerId: 'OwnerId',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      schema: 'Schema',
      tableGuid: 'TableGuid',
      tableName: 'TableName',
      tenantId: 'TenantId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      databaseName: 'string',
      entityType: 'number',
      envType: 'number',
      ownerId: 'string',
      projectId: 'number',
      projectName: 'string',
      schema: 'string',
      tableGuid: 'string',
      tableName: 'string',
      tenantId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SearchMetaTablesResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The list of metatables.
   */
  dataEntityList?: SearchMetaTablesResponseBodyDataDataEntityList[];
  /**
   * @remarks
   * The page number.
   * 
   * @example
   * 1
   */
  pageNumber?: number;
  /**
   * @remarks
   * The number of entries per page.
   * 
   * @example
   * 10
   */
  pageSize?: number;
  /**
   * @remarks
   * The total number of metatables.
   * 
   * @example
   * 100
   */
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      dataEntityList: 'DataEntityList',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dataEntityList: { 'type': 'array', 'itemType': SearchMetaTablesResponseBodyDataDataEntityList },
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetDataSourceShareResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The reason why the data source failed to be shared. If the data source is successfully shared, the value of this parameter is an empty string.
   * 
   * @example
   * datasource is wrong
   */
  message?: string;
  /**
   * @remarks
   * Indicates whether the data source was shared. Valid values:
   * 
   * *   success.
   * *   fail. You can view the value of the Message parameter to identify the cause of the failure.
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDIJobRequestRealtimeStartSettingsFailoverSettings extends $tea.Model {
  /**
   * @remarks
   * The failover interval. Unit: minutes.
   * 
   * @example
   * 10
   */
  interval?: number;
  /**
   * @remarks
   * The maximum number of failovers.
   * 
   * @example
   * 30
   */
  upperLimit?: number;
  static names(): { [key: string]: string } {
    return {
      interval: 'Interval',
      upperLimit: 'UpperLimit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interval: 'number',
      upperLimit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDIJobRequestRealtimeStartSettings extends $tea.Model {
  /**
   * @remarks
   * The failover settings.
   */
  failoverSettings?: StartDIJobRequestRealtimeStartSettingsFailoverSettings;
  /**
   * @remarks
   * The timestamp of the start offset. Unit: seconds. If you do not configure this parameter, the offset is not reset by default.
   * 
   * @example
   * 1671516776
   */
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      failoverSettings: 'FailoverSettings',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failoverSettings: StartDIJobRequestRealtimeStartSettingsFailoverSettings,
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDISyncInstanceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The reason why the real-time synchronization task or the data synchronization solution fails to be started.
   * 
   * If the real-time synchronization task or the data synchronization solution is started, the value null is returned.
   * 
   * @example
   * fileId:[100] is invalid.
   */
  message?: string;
  /**
   * @remarks
   * Indicates whether the real-time synchronization task or the data synchronization solution is started. Valid values:
   * 
   * *   success: The real-time synchronization task or the data synchronization solution is started.
   * *   fail: The real-time synchronization task or the data synchronization solution fails to be started. You can troubleshoot the issue based on the provided cause.
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopDISyncInstanceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The reason why the synchronization task fails to be stopped.
   * 
   * If the synchronization task is stopped, the value null is returned.
   * 
   * @example
   * fileId:[100] is invalid.
   */
  message?: string;
  /**
   * @remarks
   * Indicates whether the synchronization task is stopped. Valid values:
   * 
   * *   success
   * *   fail
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TerminateDISyncInstanceResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The reason why the real-time synchronization task fails to be terminated. If the real-time synchronization task is undeployed, the value of this parameter is null.
   * 
   * @example
   * fileId:[100] is invalid.
   */
  message?: string;
  /**
   * @remarks
   * Indicates whether the real-time synchronization task is undeployed. Valid values:
   * 
   * *   success
   * *   fail
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestDataServiceApiRequestBodyParams extends $tea.Model {
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * name
   */
  paramKey?: string;
  /**
   * @remarks
   * The value of the parameter.
   * 
   * @example
   * test
   */
  paramValue?: string;
  static names(): { [key: string]: string } {
    return {
      paramKey: 'ParamKey',
      paramValue: 'ParamValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paramKey: 'string',
      paramValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestDataServiceApiRequestHeadParams extends $tea.Model {
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * requestId
   */
  paramKey?: string;
  /**
   * @remarks
   * The value of the parameter.
   * 
   * @example
   * abcd
   */
  paramValue?: string;
  static names(): { [key: string]: string } {
    return {
      paramKey: 'ParamKey',
      paramValue: 'ParamValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paramKey: 'string',
      paramValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestDataServiceApiRequestPathParams extends $tea.Model {
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * path1
   */
  paramKey?: string;
  /**
   * @remarks
   * The value of the parameter.
   * 
   * @example
   * api
   */
  paramValue?: string;
  static names(): { [key: string]: string } {
    return {
      paramKey: 'ParamKey',
      paramValue: 'ParamValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paramKey: 'string',
      paramValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestDataServiceApiRequestQueryParam extends $tea.Model {
  /**
   * @remarks
   * The name of the parameter.
   * 
   * @example
   * name
   */
  paramKey?: string;
  /**
   * @remarks
   * The value of the parameter.
   * 
   * @example
   * test
   */
  paramValue?: string;
  static names(): { [key: string]: string } {
    return {
      paramKey: 'ParamKey',
      paramValue: 'ParamValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      paramKey: 'string',
      paramValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestDataServiceApiResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The ID of the test.
   * 
   * @example
   * 232432
   */
  testId?: string;
  static names(): { [key: string]: string } {
    return {
      testId: 'TestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      testId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TestNetworkConnectionResponseBodyTaskList extends $tea.Model {
  /**
   * @remarks
   * The reason why the data source and resource group failed the connectivity test. If data source and the resource group passed the connectivity test, this parameter is left empty.
   */
  connectMessage?: string;
  /**
   * @remarks
   * The result of the connectivity test. Valid values:
   * 
   * *   true: The data source and the resource group passed the connectivity test.
   * *   false: The data source and the resource group failed the connectivity test. You can troubleshoot issues based on the ConnectMessage parameter.
   * 
   * @example
   * true
   */
  connectStatus?: boolean;
  static names(): { [key: string]: string } {
    return {
      connectMessage: 'ConnectMessage',
      connectStatus: 'ConnectStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connectMessage: 'string',
      connectStatus: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank extends $tea.Model {
  /**
   * @remarks
   * The data timestamp of the instance.
   * 
   * @example
   * 1600963200000
   */
  businessDate?: number;
  /**
   * @remarks
   * The run time length of the instance. Unit: seconds.
   * 
   * @example
   * 1000
   */
  consumed?: number;
  /**
   * @remarks
   * The instance ID.
   * 
   * @example
   * 95279527
   */
  instanceId?: number;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 9527
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 952795279527
   */
  owner?: string;
  /**
   * @remarks
   * The type of the node. Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3)
   * 
   * @example
   * 10
   */
  programType?: number;
  static names(): { [key: string]: string } {
    return {
      businessDate: 'BusinessDate',
      consumed: 'Consumed',
      instanceId: 'InstanceId',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      owner: 'Owner',
      programType: 'ProgramType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessDate: 'number',
      consumed: 'number',
      instanceId: 'number',
      nodeId: 'number',
      nodeName: 'string',
      owner: 'string',
      programType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank extends $tea.Model {
  /**
   * @remarks
   * The ranking data of the running durations of the instances.
   */
  consumeTimeRank?: TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank[];
  /**
   * @remarks
   * The timestamp at which the ranking of the running durations of the instances was updated.
   * 
   * @example
   * 1600963200000
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      consumeTimeRank: 'ConsumeTimeRank',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumeTimeRank: { 'type': 'array', 'itemType': TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank },
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank extends $tea.Model {
  /**
   * @remarks
   * The number of errors that occurred on the node.
   * 
   * @example
   * 5
   */
  count?: number;
  /**
   * @remarks
   * The node ID.
   * 
   * @example
   * 9527
   */
  nodeId?: number;
  /**
   * @remarks
   * The name of the node.
   */
  nodeName?: string;
  /**
   * @remarks
   * The ID of the Alibaba Cloud account used by the node owner.
   * 
   * @example
   * 952795279527
   */
  owner?: string;
  /**
   * @remarks
   * The type of the node. Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3)
   * 
   * @example
   * 10
   */
  programType?: number;
  /**
   * @remarks
   * The DataWorks workspace ID.
   * 
   * @example
   * 9527
   */
  projectId?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      owner: 'Owner',
      programType: 'ProgramType',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      nodeId: 'number',
      nodeName: 'string',
      owner: 'string',
      programType: 'number',
      projectId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TopTenErrorTimesInstanceResponseBodyInstanceErrorRank extends $tea.Model {
  /**
   * @remarks
   * The ranking data of nodes on which errors occurred within the last month.
   */
  errorRank?: TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank[];
  /**
   * @remarks
   * The timestamp at which the rankings were updated.
   * 
   * @example
   * 1600963200000
   */
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      errorRank: 'ErrorRank',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorRank: { 'type': 'array', 'itemType': TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank },
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBaselineRequestAlertSettingsDingRobots extends $tea.Model {
  /**
   * @remarks
   * Specifies whether to remind all members by using the at sign (@). Valid values: true and false.
   * 
   * @example
   * false
   */
  atAll?: boolean;
  /**
   * @remarks
   * The webhook URL of the DingTalk chatbot.
   * 
   * @example
   * https://oapi.dingtalk.com/robot/send?access_token=xxx
   */
  webUrl?: string;
  static names(): { [key: string]: string } {
    return {
      atAll: 'AtAll',
      webUrl: 'WebUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      atAll: 'boolean',
      webUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBaselineRequestAlertSettings extends $tea.Model {
  /**
   * @remarks
   * The interval at which an event alert notification is sent. Unit: seconds. Minimum value: 900.
   * 
   * @example
   * 1800
   */
  alertInterval?: number;
  /**
   * @remarks
   * The maximum number of times an event alert notification is sent. Maximum value: 24.
   * 
   * @example
   * 1
   */
  alertMaximum?: number;
  /**
   * @remarks
   * The alert notification methods. Valid values: MAIL, SMS, PHONE, DINGROBOTS, and Webhooks. The value MAIL indicates that alert notifications are sent by email. The value SMS indicates that alert notifications are sent by text message. The value PHONE indicates that alert notifications are sent by phone call. You can use this notification method only in DataWorks Professional Edition or a more advanced edition. The value DINGROBOTS indicates that alert notifications are sent by using a DingTalk chatbot. You can use this notification method only if the RobotUrls parameter is configured. The value Webhooks indicates that alert notifications are sent by WeCom or Lark. You can use this notification method only if the Webhooks parameter is configured.
   */
  alertMethods?: string[];
  /**
   * @remarks
   * The details of the alert recipient. If you set AlertRecipientType to OWNER, leave this parameter empty. If you set AlertRecipientType to SHIFT_SCHEDULE, set this parameter to the name of the shift schedule. If you set AlertRecipientType to OTHER, set this parameter to the employee IDs of specified personnel.
   * 
   * @example
   * 123123
   */
  alertRecipient?: string;
  /**
   * @remarks
   * The type of the alert recipient. Valid values: OWNER, OTHER, and SHIFT_SCHEDULE. The value OWNER indicates the node owner. The value OTHER indicates specified personnel. The value SHIFT_SCHEDULE indicates personnel in a shift schedule.
   * 
   * @example
   * OWNER
   */
  alertRecipientType?: string;
  /**
   * @remarks
   * The type of the alert. Valid values: BASELINE and TOPIC. The value BASELINE indicates a baseline alert. The value TOPIC indicates an event alert.
   * 
   * @example
   * BASELINE
   */
  alertType?: string;
  /**
   * @remarks
   * Specifies whether to enable the baseline alerting feature. This feature is specific to baselines. Valid values: true and false.
   * 
   * @example
   * true
   */
  baselineAlertEnabled?: boolean;
  /**
   * @remarks
   * The DingTalk chatbots.
   */
  dingRobots?: UpdateBaselineRequestAlertSettingsDingRobots[];
  /**
   * @remarks
   * The end time of silence.
   * 
   * @example
   * 00:00:00
   */
  silenceEndTime?: string;
  /**
   * @remarks
   * The start time of silence.
   * 
   * @example
   * 00:00:00
   */
  silenceStartTime?: string;
  /**
   * @remarks
   * The types of event alerts, which are event-specific configurations.
   */
  topicTypes?: string[];
  /**
   * @remarks
   * The webhook URLs.
   */
  webhooks?: string[];
  static names(): { [key: string]: string } {
    return {
      alertInterval: 'AlertInterval',
      alertMaximum: 'AlertMaximum',
      alertMethods: 'AlertMethods',
      alertRecipient: 'AlertRecipient',
      alertRecipientType: 'AlertRecipientType',
      alertType: 'AlertType',
      baselineAlertEnabled: 'BaselineAlertEnabled',
      dingRobots: 'DingRobots',
      silenceEndTime: 'SilenceEndTime',
      silenceStartTime: 'SilenceStartTime',
      topicTypes: 'TopicTypes',
      webhooks: 'Webhooks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertInterval: 'number',
      alertMaximum: 'number',
      alertMethods: { 'type': 'array', 'itemType': 'string' },
      alertRecipient: 'string',
      alertRecipientType: 'string',
      alertType: 'string',
      baselineAlertEnabled: 'boolean',
      dingRobots: { 'type': 'array', 'itemType': UpdateBaselineRequestAlertSettingsDingRobots },
      silenceEndTime: 'string',
      silenceStartTime: 'string',
      topicTypes: { 'type': 'array', 'itemType': 'string' },
      webhooks: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBaselineRequestOvertimeSettings extends $tea.Model {
  /**
   * @remarks
   * The cycle that corresponds to the committed completion time. For a day-level baseline, set this parameter to 1. For an hour-level baseline, set this parameter to a value that does not exceed 24.
   * 
   * @example
   * 1
   */
  cycle?: number;
  /**
   * @remarks
   * The committed completion time in the hh:mm format. Valid values of hh: [0,47]. Valid values of mm: [0,59].
   * 
   * @example
   * 00:00
   */
  time?: string;
  static names(): { [key: string]: string } {
    return {
      cycle: 'Cycle',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycle: 'number',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels extends $tea.Model {
  /**
   * @remarks
   * The alert notification methods.
   */
  channels?: string[];
  /**
   * @remarks
   * The severity level. Valid values:
   * 
   * *   Warning
   * *   Critical
   * 
   * @example
   * Warning
   */
  severity?: string;
  static names(): { [key: string]: string } {
    return {
      channels: 'Channels',
      severity: 'Severity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channels: { 'type': 'array', 'itemType': 'string' },
      severity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers extends $tea.Model {
  /**
   * @remarks
   * The recipient type.
   * 
   * *   If the alert notification method is Mail, Phone, or Sms, the recipient type is Alibaba Cloud account ID.
   * *   If the alert notification method is Ding, the recipient type is DingTalk chatbot token.
   * 
   * @example
   * DingToken
   */
  receiverType?: string;
  /**
   * @remarks
   * The recipients.
   */
  receiverValues?: string[];
  static names(): { [key: string]: string } {
    return {
      receiverType: 'ReceiverType',
      receiverValues: 'ReceiverValues',
    };
  }

  static types(): { [key: string]: any } {
    return {
      receiverType: 'string',
      receiverValues: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIAlarmRuleRequestNotificationSettings extends $tea.Model {
  /**
   * @remarks
   * The duration of the alert suppression interval. Default value: 5. Unit: minutes.
   * 
   * @example
   * 5
   */
  inhibitionInterval?: number;
  /**
   * @remarks
   * The alert notification methods.
   * 
   * This parameter is required.
   */
  notificationChannels?: UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels[];
  /**
   * @remarks
   * The alert notification recipients.
   * 
   * This parameter is required.
   */
  notificationReceivers?: UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers[];
  static names(): { [key: string]: string } {
    return {
      inhibitionInterval: 'InhibitionInterval',
      notificationChannels: 'NotificationChannels',
      notificationReceivers: 'NotificationReceivers',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inhibitionInterval: 'number',
      notificationChannels: { 'type': 'array', 'itemType': UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels },
      notificationReceivers: { 'type': 'array', 'itemType': UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIAlarmRuleRequestTriggerConditions extends $tea.Model {
  /**
   * @remarks
   * The time interval for alert calculation. Unit: minutes.
   * 
   * @example
   * 15
   */
  duration?: number;
  /**
   * @remarks
   * The severity level. Valid values:
   * 
   * *   Warning
   * *   Critical
   * 
   * @example
   * Warning
   */
  severity?: string;
  /**
   * @remarks
   * The alert threshold.
   * 
   * *   If the alert rule is for task status, you do not need to specify a threshold.
   * *   If the alert rule is for failovers, specify the number of failovers.
   * *   If the alert rule is for latency, specify the latency duration, in seconds.
   * 
   * @example
   * 5
   */
  threshold?: number;
  static names(): { [key: string]: string } {
    return {
      duration: 'Duration',
      severity: 'Severity',
      threshold: 'Threshold',
    };
  }

  static types(): { [key: string]: any } {
    return {
      duration: 'number',
      severity: 'string',
      threshold: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobRequestJobSettingsColumnDataTypeSettings extends $tea.Model {
  /**
   * @remarks
   * The data type of a destination field.
   * 
   * @example
   * text
   */
  destinationDataType?: string;
  /**
   * @remarks
   * The data type of a source field.
   * 
   * @example
   * bigint
   */
  sourceDataType?: string;
  static names(): { [key: string]: string } {
    return {
      destinationDataType: 'DestinationDataType',
      sourceDataType: 'SourceDataType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      destinationDataType: 'string',
      sourceDataType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobRequestJobSettingsCycleScheduleSettings extends $tea.Model {
  scheduleParameters?: string;
  static names(): { [key: string]: string } {
    return {
      scheduleParameters: 'ScheduleParameters',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scheduleParameters: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobRequestJobSettingsDdlHandlingSettings extends $tea.Model {
  /**
   * @remarks
   * The processing policy for DDL messages. Valid values:
   * 
   * *   Ignore: ignores a DDL message.
   * *   Critical: reports an error for a DDL message.
   * *   Normal: normally processes a DDL message.
   * 
   * @example
   * Critical
   */
  action?: string;
  /**
   * @remarks
   * The type of the DDL operation. Valid values:
   * 
   * *   RenameColumn
   * *   ModifyColumn
   * *   CreateTable
   * *   TruncateTable
   * *   DropTable
   * *   DropColumn
   * *   AddColumn
   * 
   * @example
   * AddColumn
   */
  type?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobRequestJobSettingsRuntimeSettings extends $tea.Model {
  /**
   * @remarks
   * The name of the configuration item. Valid values:
   * 
   * *   runtime.offline.speed.limit.mb: indicates the maximum transmission rate that is allowed for a batch synchronization task. This configuration item takes effect only when runtime.offline.speed.limit.enable is set to true.
   * *   runtime.offline.speed.limit.enable: indicates whether throttling is enabled for a batch synchronization task.
   * *   dst.offline.connection.max: indicates the maximum number of connections that are allowed for writing data to the destination of a batch synchronization task.
   * *   runtime.offline.concurrent: indicates the maximum number of parallel threads that are allowed for a batch synchronization task.
   * *   dst.realtime.connection.max: indicates the maximum number of connections that are allowed for writing data to the destination of a real-time synchronization task.
   * *   runtime.enable.auto.create.schema: indicates whether schemas are automatically created in the destination of a synchronization task.
   * *   src.offline.datasource.max.connection: indicates the maximum number of connections that are allowed for reading data from the source of a batch synchronization task.
   * *   runtime.realtime.concurrent: indicates the maximum number of parallel threads that are allowed for a real-time synchronization task.
   * 
   * @example
   * runtime.offline.concurrent
   */
  name?: string;
  /**
   * @remarks
   * The value of the configuration item.
   * 
   * @example
   * 1
   */
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobRequestJobSettings extends $tea.Model {
  channelSettings?: string;
  /**
   * @remarks
   * The settings for data type mappings between source fields and destination fields. The value of this parameter must be an array.
   */
  columnDataTypeSettings?: UpdateDIJobRequestJobSettingsColumnDataTypeSettings[];
  cycleScheduleSettings?: UpdateDIJobRequestJobSettingsCycleScheduleSettings;
  /**
   * @remarks
   * The settings for processing DDL messages. The value of this parameter must be an array.
   */
  ddlHandlingSettings?: UpdateDIJobRequestJobSettingsDdlHandlingSettings[];
  /**
   * @remarks
   * The runtime settings. The value of this parameter must be an array.
   */
  runtimeSettings?: UpdateDIJobRequestJobSettingsRuntimeSettings[];
  static names(): { [key: string]: string } {
    return {
      channelSettings: 'ChannelSettings',
      columnDataTypeSettings: 'ColumnDataTypeSettings',
      cycleScheduleSettings: 'CycleScheduleSettings',
      ddlHandlingSettings: 'DdlHandlingSettings',
      runtimeSettings: 'RuntimeSettings',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelSettings: 'string',
      columnDataTypeSettings: { 'type': 'array', 'itemType': UpdateDIJobRequestJobSettingsColumnDataTypeSettings },
      cycleScheduleSettings: UpdateDIJobRequestJobSettingsCycleScheduleSettings,
      ddlHandlingSettings: { 'type': 'array', 'itemType': UpdateDIJobRequestJobSettingsDdlHandlingSettings },
      runtimeSettings: { 'type': 'array', 'itemType': UpdateDIJobRequestJobSettingsRuntimeSettings },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobRequestResourceSettingsOfflineResourceSettings extends $tea.Model {
  /**
   * @remarks
   * The identifier of the resource group for Data Integration used for batch synchronization.
   * 
   * @example
   * S_res_group_111_222
   */
  resourceGroupIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupIdentifier: 'ResourceGroupIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobRequestResourceSettingsRealtimeResourceSettings extends $tea.Model {
  /**
   * @remarks
   * The identifier of the resource group for Data Integration used for real-time synchronization.
   * 
   * @example
   * S_res_group_111_222
   */
  resourceGroupIdentifier?: string;
  static names(): { [key: string]: string } {
    return {
      resourceGroupIdentifier: 'ResourceGroupIdentifier',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceGroupIdentifier: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobRequestResourceSettings extends $tea.Model {
  /**
   * @remarks
   * The resource used for batch synchronization.
   */
  offlineResourceSettings?: UpdateDIJobRequestResourceSettingsOfflineResourceSettings;
  /**
   * @remarks
   * The resource used for real-time synchronization.
   */
  realtimeResourceSettings?: UpdateDIJobRequestResourceSettingsRealtimeResourceSettings;
  requestedCu?: number;
  static names(): { [key: string]: string } {
    return {
      offlineResourceSettings: 'OfflineResourceSettings',
      realtimeResourceSettings: 'RealtimeResourceSettings',
      requestedCu: 'RequestedCu',
    };
  }

  static types(): { [key: string]: any } {
    return {
      offlineResourceSettings: UpdateDIJobRequestResourceSettingsOfflineResourceSettings,
      realtimeResourceSettings: UpdateDIJobRequestResourceSettingsRealtimeResourceSettings,
      requestedCu: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobRequestTableMappingsSourceObjectSelectionRules extends $tea.Model {
  /**
   * @remarks
   * The expression.
   * 
   * @example
   * mysql_table_1
   */
  expression?: string;
  /**
   * @remarks
   * The type of the object. Valid values:
   * 
   * *   Table
   * *   Database
   * 
   * @example
   * Table
   */
  objectType?: string;
  static names(): { [key: string]: string } {
    return {
      expression: 'Expression',
      objectType: 'ObjectType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expression: 'string',
      objectType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobRequestTableMappingsTransformationRules extends $tea.Model {
  /**
   * @remarks
   * The type of the action. Valid values:
   * 
   * *   DefinePrimaryKey
   * *   Rename
   * *   AddColumn
   * *   HandleDml
   * 
   * @example
   * Rename
   */
  ruleActionType?: string;
  /**
   * @remarks
   * The name of the rule. If the values of the RuleActionType parameter and the RuleTargetType parameter are the same for multiple transformation rules, you must make sure that the transformation rule names are unique.
   * 
   * @example
   * rename_rule_1
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the object on which you want to perform the action. Valid values:
   * 
   * *   Table
   * *   Schema
   * 
   * @example
   * Table
   */
  ruleTargetType?: string;
  static names(): { [key: string]: string } {
    return {
      ruleActionType: 'RuleActionType',
      ruleName: 'RuleName',
      ruleTargetType: 'RuleTargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleActionType: 'string',
      ruleName: 'string',
      ruleTargetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobRequestTableMappings extends $tea.Model {
  /**
   * @remarks
   * The rule used to select synchronization objects in the source. You can configure multiple rules.
   */
  sourceObjectSelectionRules?: UpdateDIJobRequestTableMappingsSourceObjectSelectionRules[];
  /**
   * @remarks
   * The transformation rules that are applied to the selected synchronization objects.
   */
  transformationRules?: UpdateDIJobRequestTableMappingsTransformationRules[];
  static names(): { [key: string]: string } {
    return {
      sourceObjectSelectionRules: 'SourceObjectSelectionRules',
      transformationRules: 'TransformationRules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceObjectSelectionRules: { 'type': 'array', 'itemType': UpdateDIJobRequestTableMappingsSourceObjectSelectionRules },
      transformationRules: { 'type': 'array', 'itemType': UpdateDIJobRequestTableMappingsTransformationRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIJobRequestTransformationRules extends $tea.Model {
  /**
   * @remarks
   * The type of the action. Valid values:
   * 
   * *   DefinePrimaryKey
   * *   Rename
   * *   AddColumn
   * *   HandleDml
   * 
   * @example
   * Rename
   */
  ruleActionType?: string;
  /**
   * @remarks
   * The expression of the rule. The expression is a JSON string.
   * 
   * Example of a renaming rule: {"expression":"${srcDatasourceName}_${srcDatabaseName}_0922","variables":[{"variableName":"srcDatabaseName","variableRules":[{"from":"fromdb","to":"todb"}]}]}.
   * 
   * expression: the expression of the renaming rule. The expression may contain the following variables: ${srcDatasourceName}, ${srcDatabaseName}, and ${srcTableName}. ${srcDatasourceName} indicates the name of the source. ${srcDatabaseName} indicates the name of a source database. ${srcTableName} indicates the name of a source table. variables: the generation rule for a variable used in the expression of the renaming rule. The default value of the specified variable is the original value of the object indicated by the variable. You can define a group of string replacement rules to change the original values based on your business requirements. variableName: the name of the variable. The variable name is not enclosed in ${}. variableRules: the string replacement rules for variables. The system runs the string replacement rules in sequence for string replacement. from indicates the original string. to indicates the new string. Example of a rule used to add a specific field to the destination and assign a value to the field: {"columns":[{"columnName":"my_add_column","columnValueType":"Constant","columnValue":"123"}]}.
   * 
   * If no rule of this type is configured, no fields are added to the destination and no values are assigned by default. columnName: the name of the field that is added. columnValueType: the value type of the field. Valid values: Constant and Variable. columnValue: the value of the field that is added. If the valueType parameter is set to Constant, the value of the columnValue parameter must be a constant of the STRING type. If the valueType parameter is set to Variable, the value of the columnValue parameter must be a built-in variable. The following built-in variables are supported: EXECUTE_TIME (LONG data type), DB_NAME_SRC (STRING data type), DATASOURCE_NAME_SRC (STRING data type), TABLE_NAME_SRC (STRING data type), DB_NAME_DEST (STRING data type), DATASOURCE_NAME_DEST (STRING data type), TABLE_NAME_DEST (STRING data type), and DB_NAME_SRC_TRANSED (STRING data type). EXECUTE_TIME indicates the execution time. DB_NAME_SRC indicates the name of a source database. DATASOURCE_NAME_SRC indicates the name of the source. TABLE_NAME_SRC indicates the name of a source table. DB_NAME_DEST indicates the name of a destination database. DATASOURCE_NAME_DEST indicates the name of the destination. TABLE_NAME_DEST indicates the name of a destination table. DB_NAME_SRC_TRANSED indicates the database name obtained after a transformation. Example of a rule used to specify primary key fields for a destination table: {"columns":["ukcolumn1","ukcolumn2"]}.
   * 
   * If no rule of this type is configured, the primary key fields in the mapped source table are used for the destination table by default. If the destination table is an existing table, Data Integration does not modify the schema of the destination table. If the specified primary key fields do not exist in the destination table, an error is reported when the synchronization task starts to run. If the destination table is automatically created by the system, Data Integration automatically creates the schema of the destination table. The schema contains the primary key fields that you specify. If the specified primary key fields do not exist in the destination table, an error is reported when the synchronization task starts to run. Example of a rule used to process DML messages: {"dmlPolicies":[{"dmlType":"Delete","dmlAction":"Filter","filterCondition":"id > 1"}]}.
   * 
   * If no rule of this type is configured, the default processing policy for messages generated for insert, update, and delete operations is Normal. dmlType: the DML operation. Valid values: Insert, Update, and Delete. dmlAction: the processing policy for DML messages. Valid values: Normal, Ignore, Filter, and LogicalDelete. Filter indicates conditional processing. You can set the dmlAction parameter to Filter only when the dmlType parameter is set to Update or Delete. filterCondition: the condition used to filter DML messages. This parameter is required only when the dmlAction parameter is set to Filter.
   * 
   * @example
   * {"expression":"${srcDatasoureName}_${srcDatabaseName}"}
   */
  ruleExpression?: string;
  /**
   * @remarks
   * The name of the rule. If the values of the RuleActionType parameter and the RuleTargetType parameter are the same for multiple transformation rules, you must make sure that the transformation rule names are unique.
   * 
   * @example
   * rename_rule_1
   */
  ruleName?: string;
  /**
   * @remarks
   * The type of the object on which you want to perform the action. Valid values:
   * 
   * *   Table
   * *   Schema
   * 
   * @example
   * Table
   */
  ruleTargetType?: string;
  static names(): { [key: string]: string } {
    return {
      ruleActionType: 'RuleActionType',
      ruleExpression: 'RuleExpression',
      ruleName: 'RuleName',
      ruleTargetType: 'RuleTargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleActionType: 'string',
      ruleExpression: 'string',
      ruleName: 'string',
      ruleTargetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDIProjectConfigResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * Indicates whether the default global configuration of synchronization solutions is modified. Valid values:
   * 
   * *   success
   * *   fail
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateDISyncTaskResponseBodyData extends $tea.Model {
  /**
   * @remarks
   * The error message returned if the data synchronization task fails to be updated. If the data synchronization task is successfully updated, the value null is returned for this parameter.
   * 
   * @example
   * ResourceGroup:[S_res_group_XXX] is invalid.
   */
  message?: string;
  /**
   * @remarks
   * The update status of the data synchronization task. Valid values:
   * 
   * *   success
   * *   fail
   * 
   * @example
   * success
   */
  status?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableRequestColumns extends $tea.Model {
  /**
   * @remarks
   * The name of the field.
   * 
   * This parameter is required.
   * 
   * @example
   * abc
   */
  columnName?: string;
  /**
   * @remarks
   * The display name of the field.
   */
  columnNameCn?: string;
  /**
   * @remarks
   * The type of the field. For more information, see MaxCompute field types.
   * 
   * This parameter is required.
   * 
   * @example
   * string
   */
  columnType?: string;
  /**
   * @remarks
   * The comment of the field.
   */
  comment?: string;
  /**
   * @remarks
   * Specifies whether the field is a partition field. Valid values: 0 and 1. The value 0 indicates that the field is not a partition field. The value 1 indicates that the field is a partition field.
   * 
   * @example
   * 0
   */
  isPartitionCol?: boolean;
  /**
   * @remarks
   * The length of the field.
   * 
   * @example
   * 10
   */
  length?: number;
  /**
   * @remarks
   * The sequence number of the field. If the field is a partition field, this parameter is not supported.
   * 
   * @example
   * 1
   */
  seqNumber?: number;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      columnNameCn: 'ColumnNameCn',
      columnType: 'ColumnType',
      comment: 'Comment',
      isPartitionCol: 'IsPartitionCol',
      length: 'Length',
      seqNumber: 'SeqNumber',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      columnNameCn: 'string',
      columnType: 'string',
      comment: 'string',
      isPartitionCol: 'boolean',
      length: 'number',
      seqNumber: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableRequestThemes extends $tea.Model {
  /**
   * @remarks
   * The ID of the associated topic.
   * 
   * @example
   * 101
   */
  themeId?: number;
  /**
   * @remarks
   * The level that corresponds to the topic ID.
   * 
   * @example
   * 101
   */
  themeLevel?: number;
  static names(): { [key: string]: string } {
    return {
      themeId: 'ThemeId',
      themeLevel: 'ThemeLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      themeId: 'number',
      themeLevel: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableResponseBodyTaskInfo extends $tea.Model {
  /**
   * @remarks
   * The details about the status of the current subtask. Valid values:
   * 
   * *   If the current subtask is successful, success is returned.
   * *   If the current subtask fails, the error details are displayed.
   * 
   * @example
   * success
   */
  content?: string;
  /**
   * @remarks
   * The ID of the subtask that you want to run. If this parameter is left empty, all subtasks are complete. You can call the [GetDDLJobStatus](https://help.aliyun.com/document_detail/185659.html) operation to query the status of the subtask based on the subtask ID.
   * 
   * @example
   * abc1
   */
  nextTaskId?: string;
  /**
   * @remarks
   * The status of the current subtask. Valid values:
   * 
   * *   operating: The subtask is running.
   * *   success: The subtask succeeds.
   * *   failure: The subtask fails to run. For more information about the error details, see the Content parameter.
   * 
   * @example
   * success
   */
  status?: string;
  /**
   * @remarks
   * The ID of the current subtask.
   * 
   * @example
   * abc
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      nextTaskId: 'NextTaskId',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      nextTaskId: 'string',
      status: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableAddColumnRequestColumn extends $tea.Model {
  /**
   * @remarks
   * The name of the field.
   * 
   * This parameter is required.
   * 
   * @example
   * abc
   */
  columnName?: string;
  /**
   * @remarks
   * The display name of the field.
   */
  columnNameCn?: string;
  /**
   * @remarks
   * The type of the field. For more information, see MaxCompute field types.
   * 
   * This parameter is required.
   * 
   * @example
   * string
   */
  columnType?: string;
  /**
   * @remarks
   * The comment of the field.
   */
  comment?: string;
  static names(): { [key: string]: string } {
    return {
      columnName: 'ColumnName',
      columnNameCn: 'ColumnNameCn',
      columnType: 'ColumnType',
      comment: 'Comment',
    };
  }

  static types(): { [key: string]: any } {
    return {
      columnName: 'string',
      columnNameCn: 'string',
      columnType: 'string',
      comment: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateTableAddColumnResponseBodyTaskInfo extends $tea.Model {
  /**
   * @remarks
   * The details about the status of the current subtask.
   * 
   * *   If the current subtask is successful, success is returned.
   * *   If the current subtask fails, the error details are displayed.
   * 
   * @example
   * success
   */
  content?: string;
  /**
   * @remarks
   * The ID of the subtask that you want to run. If this parameter is left empty, all subtasks are complete.
   * 
   * @example
   * abc1
   */
  nextTaskId?: string;
  /**
   * @remarks
   * The status of the current subtask. Valid values:
   * 
   * *   operating: The subtask is running.
   * *   success: The subtask succeeds.
   * *   failure: The subtask fails to run. For more information about the error details, see the Content parameter.
   * 
   * @example
   * success
   */
  status?: string;
  /**
   * @remarks
   * The ID of the current subtask.
   * 
   * @example
   * abc2
   */
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      nextTaskId: 'NextTaskId',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      nextTaskId: 'string',
      status: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'ap-northeast-1': "dataworks.ap-northeast-1.aliyuncs.com",
      'ap-south-1': "dataworks.ap-south-1.aliyuncs.com",
      'ap-southeast-1': "dataworks.ap-southeast-1.aliyuncs.com",
      'ap-southeast-2': "dataworks.ap-southeast-2.aliyuncs.com",
      'ap-southeast-3': "dataworks.ap-southeast-3.aliyuncs.com",
      'ap-southeast-5': "dataworks.ap-southeast-5.aliyuncs.com",
      'cn-beijing': "dataworks.cn-beijing.aliyuncs.com",
      'cn-chengdu': "dataworks.cn-chengdu.aliyuncs.com",
      'cn-hangzhou': "dataworks.cn-hangzhou.aliyuncs.com",
      'cn-hongkong': "dataworks.cn-hongkong.aliyuncs.com",
      'cn-huhehaote': "dataworks.aliyuncs.com",
      'cn-qingdao': "dataworks.aliyuncs.com",
      'cn-shanghai': "dataworks.cn-shanghai.aliyuncs.com",
      'cn-shenzhen': "dataworks.cn-shenzhen.aliyuncs.com",
      'cn-zhangjiakou': "dataworks.aliyuncs.com",
      'eu-central-1': "dataworks.eu-central-1.aliyuncs.com",
      'eu-west-1': "dataworks.eu-west-1.aliyuncs.com",
      'me-east-1': "dataworks.me-east-1.aliyuncs.com",
      'us-east-1': "dataworks.us-east-1.aliyuncs.com",
      'us-west-1': "dataworks.us-west-1.aliyuncs.com",
      'cn-hangzhou-finance': "dataworks.aliyuncs.com",
      'cn-shenzhen-finance-1': "dataworks.aliyuncs.com",
      'cn-shanghai-finance-1': "dataworks.aliyuncs.com",
      'cn-north-2-gov-1': "dataworks.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("dataworks-public", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * Unpublishes a DataService Studio API.
   * 
   * @param request - AbolishDataServiceApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AbolishDataServiceApiResponse
   */
  async abolishDataServiceApiWithOptions(request: AbolishDataServiceApiRequest, runtime: $Util.RuntimeOptions): Promise<AbolishDataServiceApiResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiId)) {
      body["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AbolishDataServiceApi",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AbolishDataServiceApiResponse>(await this.callApi(params, req, runtime), new AbolishDataServiceApiResponse({}));
  }

  /**
   * Unpublishes a DataService Studio API.
   * 
   * @param request - AbolishDataServiceApiRequest
   * @returns AbolishDataServiceApiResponse
   */
  async abolishDataServiceApi(request: AbolishDataServiceApiRequest): Promise<AbolishDataServiceApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.abolishDataServiceApiWithOptions(request, runtime);
  }

  /**
   * Adds an entity to a collection.
   * 
   * @param request - AddMetaCollectionEntityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddMetaCollectionEntityResponse
   */
  async addMetaCollectionEntityWithOptions(request: AddMetaCollectionEntityRequest, runtime: $Util.RuntimeOptions): Promise<AddMetaCollectionEntityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.collectionQualifiedName)) {
      query["CollectionQualifiedName"] = request.collectionQualifiedName;
    }

    if (!Util.isUnset(request.entityQualifiedName)) {
      query["EntityQualifiedName"] = request.entityQualifiedName;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddMetaCollectionEntity",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddMetaCollectionEntityResponse>(await this.callApi(params, req, runtime), new AddMetaCollectionEntityResponse({}));
  }

  /**
   * Adds an entity to a collection.
   * 
   * @param request - AddMetaCollectionEntityRequest
   * @returns AddMetaCollectionEntityResponse
   */
  async addMetaCollectionEntity(request: AddMetaCollectionEntityRequest): Promise<AddMetaCollectionEntityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addMetaCollectionEntityWithOptions(request, runtime);
  }

  /**
   * Assigns a role to a member of a DataWorks workspace. Before you call this operation, you must add your account to a DataWorks workspace as a member.
   * 
   * @remarks
   * For information about how to add an account to a DataWorks workspace as a member, see [Manage members and roles](https://help.aliyun.com/document_detail/136941.html).
   * 
   * @param request - AddProjectMemberToRoleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddProjectMemberToRoleResponse
   */
  async addProjectMemberToRoleWithOptions(request: AddProjectMemberToRoleRequest, runtime: $Util.RuntimeOptions): Promise<AddProjectMemberToRoleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.roleCode)) {
      query["RoleCode"] = request.roleCode;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddProjectMemberToRole",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddProjectMemberToRoleResponse>(await this.callApi(params, req, runtime), new AddProjectMemberToRoleResponse({}));
  }

  /**
   * Assigns a role to a member of a DataWorks workspace. Before you call this operation, you must add your account to a DataWorks workspace as a member.
   * 
   * @remarks
   * For information about how to add an account to a DataWorks workspace as a member, see [Manage members and roles](https://help.aliyun.com/document_detail/136941.html).
   * 
   * @param request - AddProjectMemberToRoleRequest
   * @returns AddProjectMemberToRoleResponse
   */
  async addProjectMemberToRole(request: AddProjectMemberToRoleRequest): Promise<AddProjectMemberToRoleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addProjectMemberToRoleWithOptions(request, runtime);
  }

  /**
   * Adds a sensitive field that is defined based on the category and sensitivity level of data in Data Security Guard.
   * 
   * @param request - AddRecognizeRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddRecognizeRuleResponse
   */
  async addRecognizeRuleWithOptions(request: AddRecognizeRuleRequest, runtime: $Util.RuntimeOptions): Promise<AddRecognizeRuleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accountName)) {
      body["AccountName"] = request.accountName;
    }

    if (!Util.isUnset(request.colExclude)) {
      body["ColExclude"] = request.colExclude;
    }

    if (!Util.isUnset(request.colScan)) {
      body["ColScan"] = request.colScan;
    }

    if (!Util.isUnset(request.commentScan)) {
      body["CommentScan"] = request.commentScan;
    }

    if (!Util.isUnset(request.contentScan)) {
      body["ContentScan"] = request.contentScan;
    }

    if (!Util.isUnset(request.hitThreshold)) {
      body["HitThreshold"] = request.hitThreshold;
    }

    if (!Util.isUnset(request.level)) {
      body["Level"] = request.level;
    }

    if (!Util.isUnset(request.levelName)) {
      body["LevelName"] = request.levelName;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeParent)) {
      body["NodeParent"] = request.nodeParent;
    }

    if (!Util.isUnset(request.operationType)) {
      body["OperationType"] = request.operationType;
    }

    if (!Util.isUnset(request.recognizeRules)) {
      body["RecognizeRules"] = request.recognizeRules;
    }

    if (!Util.isUnset(request.recognizeRulesType)) {
      body["RecognizeRulesType"] = request.recognizeRulesType;
    }

    if (!Util.isUnset(request.sensitiveDescription)) {
      body["SensitiveDescription"] = request.sensitiveDescription;
    }

    if (!Util.isUnset(request.sensitiveName)) {
      body["SensitiveName"] = request.sensitiveName;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    if (!Util.isUnset(request.templateId)) {
      body["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddRecognizeRule",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddRecognizeRuleResponse>(await this.callApi(params, req, runtime), new AddRecognizeRuleResponse({}));
  }

  /**
   * Adds a sensitive field that is defined based on the category and sensitivity level of data in Data Security Guard.
   * 
   * @param request - AddRecognizeRuleRequest
   * @returns AddRecognizeRuleResponse
   */
  async addRecognizeRule(request: AddRecognizeRuleRequest): Promise<AddRecognizeRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addRecognizeRuleWithOptions(request, runtime);
  }

  /**
   * Adds a metatable to a specified category.
   * 
   * @param request - AddToMetaCategoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns AddToMetaCategoryResponse
   */
  async addToMetaCategoryWithOptions(request: AddToMetaCategoryRequest, runtime: $Util.RuntimeOptions): Promise<AddToMetaCategoryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.categoryId)) {
      query["CategoryId"] = request.categoryId;
    }

    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddToMetaCategory",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddToMetaCategoryResponse>(await this.callApi(params, req, runtime), new AddToMetaCategoryResponse({}));
  }

  /**
   * Adds a metatable to a specified category.
   * 
   * @param request - AddToMetaCategoryRequest
   * @returns AddToMetaCategoryResponse
   */
  async addToMetaCategory(request: AddToMetaCategoryRequest): Promise<AddToMetaCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addToMetaCategoryWithOptions(request, runtime);
  }

  /**
   * Processes a permission request order.
   * 
   * @param request - ApprovePermissionApplyOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ApprovePermissionApplyOrderResponse
   */
  async approvePermissionApplyOrderWithOptions(request: ApprovePermissionApplyOrderRequest, runtime: $Util.RuntimeOptions): Promise<ApprovePermissionApplyOrderResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.approveAction)) {
      query["ApproveAction"] = request.approveAction;
    }

    if (!Util.isUnset(request.approveComment)) {
      query["ApproveComment"] = request.approveComment;
    }

    if (!Util.isUnset(request.flowId)) {
      query["FlowId"] = request.flowId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ApprovePermissionApplyOrder",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApprovePermissionApplyOrderResponse>(await this.callApi(params, req, runtime), new ApprovePermissionApplyOrderResponse({}));
  }

  /**
   * Processes a permission request order.
   * 
   * @param request - ApprovePermissionApplyOrderRequest
   * @returns ApprovePermissionApplyOrderResponse
   */
  async approvePermissionApplyOrder(request: ApprovePermissionApplyOrderRequest): Promise<ApprovePermissionApplyOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.approvePermissionApplyOrderWithOptions(request, runtime);
  }

  /**
   * Sends the processing result of an extension point event by an extension to DataWorks.
   * 
   * @param request - CallbackExtensionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CallbackExtensionResponse
   */
  async callbackExtensionWithOptions(request: CallbackExtensionRequest, runtime: $Util.RuntimeOptions): Promise<CallbackExtensionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.checkMessage)) {
      body["CheckMessage"] = request.checkMessage;
    }

    if (!Util.isUnset(request.checkResult)) {
      body["CheckResult"] = request.checkResult;
    }

    if (!Util.isUnset(request.extensionCode)) {
      body["ExtensionCode"] = request.extensionCode;
    }

    if (!Util.isUnset(request.messageId)) {
      body["MessageId"] = request.messageId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CallbackExtension",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CallbackExtensionResponse>(await this.callApi(params, req, runtime), new CallbackExtensionResponse({}));
  }

  /**
   * Sends the processing result of an extension point event by an extension to DataWorks.
   * 
   * @param request - CallbackExtensionRequest
   * @returns CallbackExtensionResponse
   */
  async callbackExtension(request: CallbackExtensionRequest): Promise<CallbackExtensionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.callbackExtensionWithOptions(request, runtime);
  }

  /**
   * Changes the resource group to which a resource belongs.
   * 
   * @param request - ChangeResourceManagerResourceGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ChangeResourceManagerResourceGroupResponse
   */
  async changeResourceManagerResourceGroupWithOptions(request: ChangeResourceManagerResourceGroupRequest, runtime: $Util.RuntimeOptions): Promise<ChangeResourceManagerResourceGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceManagerResourceGroupId)) {
      query["ResourceManagerResourceGroupId"] = request.resourceManagerResourceGroupId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeResourceManagerResourceGroup",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeResourceManagerResourceGroupResponse>(await this.callApi(params, req, runtime), new ChangeResourceManagerResourceGroupResponse({}));
  }

  /**
   * Changes the resource group to which a resource belongs.
   * 
   * @param request - ChangeResourceManagerResourceGroupRequest
   * @returns ChangeResourceManagerResourceGroupResponse
   */
  async changeResourceManagerResourceGroup(request: ChangeResourceManagerResourceGroupRequest): Promise<ChangeResourceManagerResourceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeResourceManagerResourceGroupWithOptions(request, runtime);
  }

  /**
   * Returns the check events of a file. After you commit your file that is created on the DataStudio page, the system checks the file and returns check events before the system deploys the file. You must determine whether the check can be continued based on the events. You can call this operation to return the check events for the file that you want to deploy to DataWorks.
   * 
   * @param request - CheckFileDeploymentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckFileDeploymentResponse
   */
  async checkFileDeploymentWithOptions(request: CheckFileDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<CheckFileDeploymentResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.checkDetailUrl)) {
      body["CheckDetailUrl"] = request.checkDetailUrl;
    }

    if (!Util.isUnset(request.checkerInstanceId)) {
      body["CheckerInstanceId"] = request.checkerInstanceId;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CheckFileDeployment",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckFileDeploymentResponse>(await this.callApi(params, req, runtime), new CheckFileDeploymentResponse({}));
  }

  /**
   * Returns the check events of a file. After you commit your file that is created on the DataStudio page, the system checks the file and returns check events before the system deploys the file. You must determine whether the check can be continued based on the events. You can call this operation to return the check events for the file that you want to deploy to DataWorks.
   * 
   * @param request - CheckFileDeploymentRequest
   * @returns CheckFileDeploymentResponse
   */
  async checkFileDeployment(request: CheckFileDeploymentRequest): Promise<CheckFileDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkFileDeploymentWithOptions(request, runtime);
  }

  /**
   * Checks whether a partition in a MaxCompute metatable exists.
   * 
   * @param request - CheckMetaPartitionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckMetaPartitionResponse
   */
  async checkMetaPartitionWithOptions(request: CheckMetaPartitionRequest, runtime: $Util.RuntimeOptions): Promise<CheckMetaPartitionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dataSourceType)) {
      query["DataSourceType"] = request.dataSourceType;
    }

    if (!Util.isUnset(request.databaseName)) {
      query["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.partition)) {
      query["Partition"] = request.partition;
    }

    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CheckMetaPartition",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckMetaPartitionResponse>(await this.callApi(params, req, runtime), new CheckMetaPartitionResponse({}));
  }

  /**
   * Checks whether a partition in a MaxCompute metatable exists.
   * 
   * @param request - CheckMetaPartitionRequest
   * @returns CheckMetaPartitionResponse
   */
  async checkMetaPartition(request: CheckMetaPartitionRequest): Promise<CheckMetaPartitionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkMetaPartitionWithOptions(request, runtime);
  }

  /**
   * Checks whether a metatable exists.
   * 
   * @param request - CheckMetaTableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CheckMetaTableResponse
   */
  async checkMetaTableWithOptions(request: CheckMetaTableRequest, runtime: $Util.RuntimeOptions): Promise<CheckMetaTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dataSourceType)) {
      query["DataSourceType"] = request.dataSourceType;
    }

    if (!Util.isUnset(request.databaseName)) {
      query["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CheckMetaTable",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckMetaTableResponse>(await this.callApi(params, req, runtime), new CheckMetaTableResponse({}));
  }

  /**
   * Checks whether a metatable exists.
   * 
   * @param request - CheckMetaTableRequest
   * @returns CheckMetaTableResponse
   */
  async checkMetaTable(request: CheckMetaTableRequest): Promise<CheckMetaTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkMetaTableWithOptions(request, runtime);
  }

  /**
   * Creates a baseline.
   * 
   * @param request - CreateBaselineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateBaselineResponse
   */
  async createBaselineWithOptions(request: CreateBaselineRequest, runtime: $Util.RuntimeOptions): Promise<CreateBaselineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alertMarginThreshold)) {
      body["AlertMarginThreshold"] = request.alertMarginThreshold;
    }

    if (!Util.isUnset(request.baselineName)) {
      body["BaselineName"] = request.baselineName;
    }

    if (!Util.isUnset(request.baselineType)) {
      body["BaselineType"] = request.baselineType;
    }

    if (!Util.isUnset(request.nodeIds)) {
      body["NodeIds"] = request.nodeIds;
    }

    if (!Util.isUnset(request.overtimeSettings)) {
      body["OvertimeSettings"] = request.overtimeSettings;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.priority)) {
      body["Priority"] = request.priority;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateBaseline",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateBaselineResponse>(await this.callApi(params, req, runtime), new CreateBaselineResponse({}));
  }

  /**
   * Creates a baseline.
   * 
   * @param request - CreateBaselineRequest
   * @returns CreateBaselineResponse
   */
  async createBaseline(request: CreateBaselineRequest): Promise<CreateBaselineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createBaselineWithOptions(request, runtime);
  }

  /**
   * @param request - CreateBusinessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateBusinessResponse
   */
  async createBusinessWithOptions(request: CreateBusinessRequest, runtime: $Util.RuntimeOptions): Promise<CreateBusinessResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.businessName)) {
      body["BusinessName"] = request.businessName;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    if (!Util.isUnset(request.useType)) {
      body["UseType"] = request.useType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateBusiness",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateBusinessResponse>(await this.callApi(params, req, runtime), new CreateBusinessResponse({}));
  }

  /**
   * @param request - CreateBusinessRequest
   * @returns CreateBusinessResponse
   */
  async createBusiness(request: CreateBusinessRequest): Promise<CreateBusinessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createBusinessWithOptions(request, runtime);
  }

  /**
   * Adds a data source.
   * 
   * @deprecated OpenAPI CreateConnection is deprecated
   * 
   * @param request - CreateConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateConnectionResponse
   */
  // Deprecated
  async createConnectionWithOptions(request: CreateConnectionRequest, runtime: $Util.RuntimeOptions): Promise<CreateConnectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.connectionType)) {
      query["ConnectionType"] = request.connectionType;
    }

    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.subType)) {
      query["SubType"] = request.subType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateConnection",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateConnectionResponse>(await this.callApi(params, req, runtime), new CreateConnectionResponse({}));
  }

  /**
   * Adds a data source.
   * 
   * @deprecated OpenAPI CreateConnection is deprecated
   * 
   * @param request - CreateConnectionRequest
   * @returns CreateConnectionResponse
   */
  // Deprecated
  async createConnection(request: CreateConnectionRequest): Promise<CreateConnectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createConnectionWithOptions(request, runtime);
  }

  /**
   * Creates an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @remarks
   * You can configure alert rules only for tasks that can be used for real-time data synchronization.
   * 
   * @param tmpReq - CreateDIAlarmRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDIAlarmRuleResponse
   */
  async createDIAlarmRuleWithOptions(tmpReq: CreateDIAlarmRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateDIAlarmRuleResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDIAlarmRuleShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.notificationSettings)) {
      request.notificationSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notificationSettings, "NotificationSettings", "json");
    }

    if (!Util.isUnset(tmpReq.triggerConditions)) {
      request.triggerConditionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.triggerConditions, "TriggerConditions", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.DIJobId)) {
      body["DIJobId"] = request.DIJobId;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.enabled)) {
      body["Enabled"] = request.enabled;
    }

    if (!Util.isUnset(request.metricType)) {
      body["MetricType"] = request.metricType;
    }

    if (!Util.isUnset(request.notificationSettingsShrink)) {
      body["NotificationSettings"] = request.notificationSettingsShrink;
    }

    if (!Util.isUnset(request.triggerConditionsShrink)) {
      body["TriggerConditions"] = request.triggerConditionsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDIAlarmRule",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDIAlarmRuleResponse>(await this.callApi(params, req, runtime), new CreateDIAlarmRuleResponse({}));
  }

  /**
   * Creates an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @remarks
   * You can configure alert rules only for tasks that can be used for real-time data synchronization.
   * 
   * @param request - CreateDIAlarmRuleRequest
   * @returns CreateDIAlarmRuleResponse
   */
  async createDIAlarmRule(request: CreateDIAlarmRuleRequest): Promise<CreateDIAlarmRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDIAlarmRuleWithOptions(request, runtime);
  }

  /**
   * Creates a synchronization task of a new version in Data Integration. The following types of synchronization tasks are supported: real-time synchronization of all data in a MySQL database to Hologres and batch synchronization of all data in a MySQL database to Hive.
   * 
   * @param tmpReq - CreateDIJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDIJobResponse
   */
  async createDIJobWithOptions(tmpReq: CreateDIJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateDIJobResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateDIJobShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.destinationDataSourceSettings)) {
      request.destinationDataSourceSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.destinationDataSourceSettings, "DestinationDataSourceSettings", "json");
    }

    if (!Util.isUnset(tmpReq.jobSettings)) {
      request.jobSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.jobSettings, "JobSettings", "json");
    }

    if (!Util.isUnset(tmpReq.resourceSettings)) {
      request.resourceSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceSettings, "ResourceSettings", "json");
    }

    if (!Util.isUnset(tmpReq.sourceDataSourceSettings)) {
      request.sourceDataSourceSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sourceDataSourceSettings, "SourceDataSourceSettings", "json");
    }

    if (!Util.isUnset(tmpReq.tableMappings)) {
      request.tableMappingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tableMappings, "TableMappings", "json");
    }

    if (!Util.isUnset(tmpReq.transformationRules)) {
      request.transformationRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transformationRules, "TransformationRules", "json");
    }

    let query = { };
    if (!Util.isUnset(request.systemDebug)) {
      query["SystemDebug"] = request.systemDebug;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.destinationDataSourceSettingsShrink)) {
      body["DestinationDataSourceSettings"] = request.destinationDataSourceSettingsShrink;
    }

    if (!Util.isUnset(request.destinationDataSourceType)) {
      body["DestinationDataSourceType"] = request.destinationDataSourceType;
    }

    if (!Util.isUnset(request.jobName)) {
      body["JobName"] = request.jobName;
    }

    if (!Util.isUnset(request.jobSettingsShrink)) {
      body["JobSettings"] = request.jobSettingsShrink;
    }

    if (!Util.isUnset(request.migrationType)) {
      body["MigrationType"] = request.migrationType;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.resourceSettingsShrink)) {
      body["ResourceSettings"] = request.resourceSettingsShrink;
    }

    if (!Util.isUnset(request.sourceDataSourceSettingsShrink)) {
      body["SourceDataSourceSettings"] = request.sourceDataSourceSettingsShrink;
    }

    if (!Util.isUnset(request.sourceDataSourceType)) {
      body["SourceDataSourceType"] = request.sourceDataSourceType;
    }

    if (!Util.isUnset(request.tableMappingsShrink)) {
      body["TableMappings"] = request.tableMappingsShrink;
    }

    if (!Util.isUnset(request.transformationRulesShrink)) {
      body["TransformationRules"] = request.transformationRulesShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDIJob",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDIJobResponse>(await this.callApi(params, req, runtime), new CreateDIJobResponse({}));
  }

  /**
   * Creates a synchronization task of a new version in Data Integration. The following types of synchronization tasks are supported: real-time synchronization of all data in a MySQL database to Hologres and batch synchronization of all data in a MySQL database to Hive.
   * 
   * @param request - CreateDIJobRequest
   * @returns CreateDIJobResponse
   */
  async createDIJob(request: CreateDIJobRequest): Promise<CreateDIJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDIJobWithOptions(request, runtime);
  }

  /**
   * Creates a data synchronization task.
   * 
   * @param request - CreateDISyncTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDISyncTaskResponse
   */
  async createDISyncTaskWithOptions(request: CreateDISyncTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateDISyncTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskParam)) {
      query["TaskParam"] = request.taskParam;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.taskContent)) {
      body["TaskContent"] = request.taskContent;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDISyncTask",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDISyncTaskResponse>(await this.callApi(params, req, runtime), new CreateDISyncTaskResponse({}));
  }

  /**
   * Creates a data synchronization task.
   * 
   * @param request - CreateDISyncTaskRequest
   * @returns CreateDISyncTaskResponse
   */
  async createDISyncTask(request: CreateDISyncTaskRequest): Promise<CreateDISyncTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDISyncTaskWithOptions(request, runtime);
  }

  /**
   * @deprecated OpenAPI CreateDagComplement is deprecated
   * 
   * @param request - CreateDagComplementRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDagComplementResponse
   */
  // Deprecated
  async createDagComplementWithOptions(request: CreateDagComplementRequest, runtime: $Util.RuntimeOptions): Promise<CreateDagComplementResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizBeginTime)) {
      body["BizBeginTime"] = request.bizBeginTime;
    }

    if (!Util.isUnset(request.bizEndTime)) {
      body["BizEndTime"] = request.bizEndTime;
    }

    if (!Util.isUnset(request.endBizDate)) {
      body["EndBizDate"] = request.endBizDate;
    }

    if (!Util.isUnset(request.excludeNodeIds)) {
      body["ExcludeNodeIds"] = request.excludeNodeIds;
    }

    if (!Util.isUnset(request.includeNodeIds)) {
      body["IncludeNodeIds"] = request.includeNodeIds;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.nodeParams)) {
      body["NodeParams"] = request.nodeParams;
    }

    if (!Util.isUnset(request.parallelism)) {
      body["Parallelism"] = request.parallelism;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.rootNodeId)) {
      body["RootNodeId"] = request.rootNodeId;
    }

    if (!Util.isUnset(request.startBizDate)) {
      body["StartBizDate"] = request.startBizDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDagComplement",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDagComplementResponse>(await this.callApi(params, req, runtime), new CreateDagComplementResponse({}));
  }

  /**
   * @deprecated OpenAPI CreateDagComplement is deprecated
   * 
   * @param request - CreateDagComplementRequest
   * @returns CreateDagComplementResponse
   */
  // Deprecated
  async createDagComplement(request: CreateDagComplementRequest): Promise<CreateDagComplementResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDagComplementWithOptions(request, runtime);
  }

  /**
   * @deprecated OpenAPI CreateDagTest is deprecated
   * 
   * @param request - CreateDagTestRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDagTestResponse
   */
  // Deprecated
  async createDagTestWithOptions(request: CreateDagTestRequest, runtime: $Util.RuntimeOptions): Promise<CreateDagTestResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizdate)) {
      body["Bizdate"] = request.bizdate;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeParams)) {
      body["NodeParams"] = request.nodeParams;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDagTest",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDagTestResponse>(await this.callApi(params, req, runtime), new CreateDagTestResponse({}));
  }

  /**
   * @deprecated OpenAPI CreateDagTest is deprecated
   * 
   * @param request - CreateDagTestRequest
   * @returns CreateDagTestResponse
   */
  // Deprecated
  async createDagTest(request: CreateDagTestRequest): Promise<CreateDagTestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDagTestWithOptions(request, runtime);
  }

  /**
   * Creates an API.
   * 
   * @param request - CreateDataServiceApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDataServiceApiResponse
   */
  async createDataServiceApiWithOptions(request: CreateDataServiceApiRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataServiceApiResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiDescription)) {
      body["ApiDescription"] = request.apiDescription;
    }

    if (!Util.isUnset(request.apiMode)) {
      body["ApiMode"] = request.apiMode;
    }

    if (!Util.isUnset(request.apiName)) {
      body["ApiName"] = request.apiName;
    }

    if (!Util.isUnset(request.apiPath)) {
      body["ApiPath"] = request.apiPath;
    }

    if (!Util.isUnset(request.folderId)) {
      body["FolderId"] = request.folderId;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.protocols)) {
      body["Protocols"] = request.protocols;
    }

    if (!Util.isUnset(request.registrationDetails)) {
      body["RegistrationDetails"] = request.registrationDetails;
    }

    if (!Util.isUnset(request.requestContentType)) {
      body["RequestContentType"] = request.requestContentType;
    }

    if (!Util.isUnset(request.requestMethod)) {
      body["RequestMethod"] = request.requestMethod;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      body["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.responseContentType)) {
      body["ResponseContentType"] = request.responseContentType;
    }

    if (!Util.isUnset(request.scriptDetails)) {
      body["ScriptDetails"] = request.scriptDetails;
    }

    if (!Util.isUnset(request.sqlMode)) {
      body["SqlMode"] = request.sqlMode;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.timeout)) {
      body["Timeout"] = request.timeout;
    }

    if (!Util.isUnset(request.visibleRange)) {
      body["VisibleRange"] = request.visibleRange;
    }

    if (!Util.isUnset(request.wizardDetails)) {
      body["WizardDetails"] = request.wizardDetails;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataServiceApi",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataServiceApiResponse>(await this.callApi(params, req, runtime), new CreateDataServiceApiResponse({}));
  }

  /**
   * Creates an API.
   * 
   * @param request - CreateDataServiceApiRequest
   * @returns CreateDataServiceApiResponse
   */
  async createDataServiceApi(request: CreateDataServiceApiRequest): Promise<CreateDataServiceApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataServiceApiWithOptions(request, runtime);
  }

  /**
   * Grants the access permissions on an API in DataService Studio.
   * 
   * @param request - CreateDataServiceApiAuthorityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDataServiceApiAuthorityResponse
   */
  async createDataServiceApiAuthorityWithOptions(request: CreateDataServiceApiAuthorityRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataServiceApiAuthorityResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiId)) {
      body["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.authorizedProjectId)) {
      body["AuthorizedProjectId"] = request.authorizedProjectId;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataServiceApiAuthority",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataServiceApiAuthorityResponse>(await this.callApi(params, req, runtime), new CreateDataServiceApiAuthorityResponse({}));
  }

  /**
   * Grants the access permissions on an API in DataService Studio.
   * 
   * @param request - CreateDataServiceApiAuthorityRequest
   * @returns CreateDataServiceApiAuthorityResponse
   */
  async createDataServiceApiAuthority(request: CreateDataServiceApiAuthorityRequest): Promise<CreateDataServiceApiAuthorityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataServiceApiAuthorityWithOptions(request, runtime);
  }

  /**
   * Creates a folder in DataService Studio.
   * 
   * @param request - CreateDataServiceFolderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDataServiceFolderResponse
   */
  async createDataServiceFolderWithOptions(request: CreateDataServiceFolderRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataServiceFolderResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.folderName)) {
      body["FolderName"] = request.folderName;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.parentId)) {
      body["ParentId"] = request.parentId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataServiceFolder",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataServiceFolderResponse>(await this.callApi(params, req, runtime), new CreateDataServiceFolderResponse({}));
  }

  /**
   * Creates a folder in DataService Studio.
   * 
   * @param request - CreateDataServiceFolderRequest
   * @returns CreateDataServiceFolderResponse
   */
  async createDataServiceFolder(request: CreateDataServiceFolderRequest): Promise<CreateDataServiceFolderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataServiceFolderWithOptions(request, runtime);
  }

  /**
   * Creates a business process.
   * 
   * @param request - CreateDataServiceGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDataServiceGroupResponse
   */
  async createDataServiceGroupWithOptions(request: CreateDataServiceGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataServiceGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiGatewayGroupId)) {
      body["ApiGatewayGroupId"] = request.apiGatewayGroupId;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.groupName)) {
      body["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataServiceGroup",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataServiceGroupResponse>(await this.callApi(params, req, runtime), new CreateDataServiceGroupResponse({}));
  }

  /**
   * Creates a business process.
   * 
   * @param request - CreateDataServiceGroupRequest
   * @returns CreateDataServiceGroupResponse
   */
  async createDataServiceGroup(request: CreateDataServiceGroupRequest): Promise<CreateDataServiceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataServiceGroupWithOptions(request, runtime);
  }

  /**
   * Adds a data source to DataWorks.
   * 
   * @param request - CreateDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateDataSourceResponse
   */
  async createDataSourceWithOptions(request: CreateDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<CreateDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.dataSourceType)) {
      query["DataSourceType"] = request.dataSourceType;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.subType)) {
      query["SubType"] = request.subType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateDataSource",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateDataSourceResponse>(await this.callApi(params, req, runtime), new CreateDataSourceResponse({}));
  }

  /**
   * Adds a data source to DataWorks.
   * 
   * @param request - CreateDataSourceRequest
   * @returns CreateDataSourceResponse
   */
  async createDataSource(request: CreateDataSourceRequest): Promise<CreateDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createDataSourceWithOptions(request, runtime);
  }

  /**
   * Creates an export task. You can use this operation to create an export task but cannot use this operation to start the created export task.
   * 
   * @param request - CreateExportMigrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateExportMigrationResponse
   */
  async createExportMigrationWithOptions(request: CreateExportMigrationRequest, runtime: $Util.RuntimeOptions): Promise<CreateExportMigrationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.exportMode)) {
      body["ExportMode"] = request.exportMode;
    }

    if (!Util.isUnset(request.exportObjectStatus)) {
      body["ExportObjectStatus"] = request.exportObjectStatus;
    }

    if (!Util.isUnset(request.incrementalSince)) {
      body["IncrementalSince"] = request.incrementalSince;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateExportMigration",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateExportMigrationResponse>(await this.callApi(params, req, runtime), new CreateExportMigrationResponse({}));
  }

  /**
   * Creates an export task. You can use this operation to create an export task but cannot use this operation to start the created export task.
   * 
   * @param request - CreateExportMigrationRequest
   * @returns CreateExportMigrationResponse
   */
  async createExportMigration(request: CreateExportMigrationRequest): Promise<CreateExportMigrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createExportMigrationWithOptions(request, runtime);
  }

  /**
   * Creates a file in DataStudio. You cannot call this operation to create files for Data Integration nodes.
   * 
   * @param request - CreateFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateFileResponse
   */
  async createFileWithOptions(request: CreateFileRequest, runtime: $Util.RuntimeOptions): Promise<CreateFileResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.advancedSettings)) {
      body["AdvancedSettings"] = request.advancedSettings;
    }

    if (!Util.isUnset(request.applyScheduleImmediately)) {
      body["ApplyScheduleImmediately"] = request.applyScheduleImmediately;
    }

    if (!Util.isUnset(request.autoParsing)) {
      body["AutoParsing"] = request.autoParsing;
    }

    if (!Util.isUnset(request.autoRerunIntervalMillis)) {
      body["AutoRerunIntervalMillis"] = request.autoRerunIntervalMillis;
    }

    if (!Util.isUnset(request.autoRerunTimes)) {
      body["AutoRerunTimes"] = request.autoRerunTimes;
    }

    if (!Util.isUnset(request.connectionName)) {
      body["ConnectionName"] = request.connectionName;
    }

    if (!Util.isUnset(request.content)) {
      body["Content"] = request.content;
    }

    if (!Util.isUnset(request.createFolderIfNotExists)) {
      body["CreateFolderIfNotExists"] = request.createFolderIfNotExists;
    }

    if (!Util.isUnset(request.cronExpress)) {
      body["CronExpress"] = request.cronExpress;
    }

    if (!Util.isUnset(request.cycleType)) {
      body["CycleType"] = request.cycleType;
    }

    if (!Util.isUnset(request.dependentNodeIdList)) {
      body["DependentNodeIdList"] = request.dependentNodeIdList;
    }

    if (!Util.isUnset(request.dependentType)) {
      body["DependentType"] = request.dependentType;
    }

    if (!Util.isUnset(request.endEffectDate)) {
      body["EndEffectDate"] = request.endEffectDate;
    }

    if (!Util.isUnset(request.fileDescription)) {
      body["FileDescription"] = request.fileDescription;
    }

    if (!Util.isUnset(request.fileFolderPath)) {
      body["FileFolderPath"] = request.fileFolderPath;
    }

    if (!Util.isUnset(request.fileName)) {
      body["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.fileType)) {
      body["FileType"] = request.fileType;
    }

    if (!Util.isUnset(request.ignoreParentSkipRunningProperty)) {
      body["IgnoreParentSkipRunningProperty"] = request.ignoreParentSkipRunningProperty;
    }

    if (!Util.isUnset(request.inputList)) {
      body["InputList"] = request.inputList;
    }

    if (!Util.isUnset(request.inputParameters)) {
      body["InputParameters"] = request.inputParameters;
    }

    if (!Util.isUnset(request.outputParameters)) {
      body["OutputParameters"] = request.outputParameters;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.paraValue)) {
      body["ParaValue"] = request.paraValue;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    if (!Util.isUnset(request.rerunMode)) {
      body["RerunMode"] = request.rerunMode;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      body["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.resourceGroupIdentifier)) {
      body["ResourceGroupIdentifier"] = request.resourceGroupIdentifier;
    }

    if (!Util.isUnset(request.schedulerType)) {
      body["SchedulerType"] = request.schedulerType;
    }

    if (!Util.isUnset(request.startEffectDate)) {
      body["StartEffectDate"] = request.startEffectDate;
    }

    if (!Util.isUnset(request.startImmediately)) {
      body["StartImmediately"] = request.startImmediately;
    }

    if (!Util.isUnset(request.stop)) {
      body["Stop"] = request.stop;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateFile",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateFileResponse>(await this.callApi(params, req, runtime), new CreateFileResponse({}));
  }

  /**
   * Creates a file in DataStudio. You cannot call this operation to create files for Data Integration nodes.
   * 
   * @param request - CreateFileRequest
   * @returns CreateFileResponse
   */
  async createFile(request: CreateFileRequest): Promise<CreateFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFileWithOptions(request, runtime);
  }

  /**
   * The operation that you want to perform. Set the value to **CreateFolder**.
   * 
   * @param request - CreateFolderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateFolderResponse
   */
  async createFolderWithOptions(request: CreateFolderRequest, runtime: $Util.RuntimeOptions): Promise<CreateFolderResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.folderPath)) {
      body["FolderPath"] = request.folderPath;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateFolder",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateFolderResponse>(await this.callApi(params, req, runtime), new CreateFolderResponse({}));
  }

  /**
   * The operation that you want to perform. Set the value to **CreateFolder**.
   * 
   * @param request - CreateFolderRequest
   * @returns CreateFolderResponse
   */
  async createFolder(request: CreateFolderRequest): Promise<CreateFolderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFolderWithOptions(request, runtime);
  }

  /**
   * Creates an import task. The import task contains the import packages of data sources, nodes, and tables.
   * 
   * @remarks
   * The import package must be uploaded. Example of the upload method:
   *         Config config = new Config();
   *         config.setAccessKeyId(accessId);
   *         config.setAccessKeySecret(accessKey);
   *         config.setEndpoint(popEndpoint);
   *         config.setRegionId(regionId);
   *         
   *         Client client = new Client(config);
   *         CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest();
   *         request.setName("test_migration_api_" + System.currentTimeMillis());
   *         request.setProjectId(123456L); 
   *         request.setPackageType("DATAWORKS_MODEL");
   *         request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip"));
   *         RuntimeOptions runtime = new RuntimeOptions();
   *         CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime);
   *         ...
   * 
   * @param request - CreateImportMigrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateImportMigrationResponse
   */
  async createImportMigrationWithOptions(request: CreateImportMigrationRequest, runtime: $Util.RuntimeOptions): Promise<CreateImportMigrationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.calculateEngineMap)) {
      body["CalculateEngineMap"] = request.calculateEngineMap;
    }

    if (!Util.isUnset(request.commitRule)) {
      body["CommitRule"] = request.commitRule;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.packageFile)) {
      body["PackageFile"] = request.packageFile;
    }

    if (!Util.isUnset(request.packageType)) {
      body["PackageType"] = request.packageType;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.resourceGroupMap)) {
      body["ResourceGroupMap"] = request.resourceGroupMap;
    }

    if (!Util.isUnset(request.workspaceMap)) {
      body["WorkspaceMap"] = request.workspaceMap;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateImportMigration",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateImportMigrationResponse>(await this.callApi(params, req, runtime), new CreateImportMigrationResponse({}));
  }

  /**
   * Creates an import task. The import task contains the import packages of data sources, nodes, and tables.
   * 
   * @remarks
   * The import package must be uploaded. Example of the upload method:
   *         Config config = new Config();
   *         config.setAccessKeyId(accessId);
   *         config.setAccessKeySecret(accessKey);
   *         config.setEndpoint(popEndpoint);
   *         config.setRegionId(regionId);
   *         
   *         Client client = new Client(config);
   *         CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest();
   *         request.setName("test_migration_api_" + System.currentTimeMillis());
   *         request.setProjectId(123456L); 
   *         request.setPackageType("DATAWORKS_MODEL");
   *         request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip"));
   *         RuntimeOptions runtime = new RuntimeOptions();
   *         CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime);
   *         ...
   * 
   * @param request - CreateImportMigrationRequest
   * @returns CreateImportMigrationResponse
   */
  async createImportMigration(request: CreateImportMigrationRequest): Promise<CreateImportMigrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createImportMigrationWithOptions(request, runtime);
  }

  async createImportMigrationAdvance(request: CreateImportMigrationAdvanceRequest, runtime: $Util.RuntimeOptions): Promise<CreateImportMigrationResponse> {
    // Step 0: init client
    let accessKeyId = await this._credential.getAccessKeyId();
    let accessKeySecret = await this._credential.getAccessKeySecret();
    let securityToken = await this._credential.getSecurityToken();
    let credentialType = this._credential.getType();
    let openPlatformEndpoint = this._openPlatformEndpoint;
    if (Util.empty(openPlatformEndpoint)) {
      openPlatformEndpoint = "openplatform.aliyuncs.com";
    }

    if (Util.isUnset(credentialType)) {
      credentialType = "access_key";
    }

    let authConfig = new $OpenApi.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      securityToken: securityToken,
      type: credentialType,
      endpoint: openPlatformEndpoint,
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let authClient = new OpenPlatform(authConfig);
    let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
      product: "dataworks-public",
      regionId: this._regionId,
    });
    let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({ });
    let ossConfig = new $OSS.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      type: "access_key",
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let ossClient : OSS = new OSS(ossConfig);
    let fileObj = new $FileForm.FileField({ });
    let ossHeader = new $OSS.PostObjectRequestHeader({ });
    let uploadRequest = new $OSS.PostObjectRequest({ });
    let ossRuntime = new $OSSUtil.RuntimeOptions({ });
    OpenApiUtil.convert(runtime, ossRuntime);
    let createImportMigrationReq = new CreateImportMigrationRequest({ });
    OpenApiUtil.convert(request, createImportMigrationReq);
    if (!Util.isUnset(request.packageFileObject)) {
      authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
      ossConfig.accessKeyId = authResponse.body.accessKeyId;
      ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
      ossClient = new OSS(ossConfig);
      fileObj = new $FileForm.FileField({
        filename: authResponse.body.objectKey,
        content: request.packageFileObject,
        contentType: "",
      });
      ossHeader = new $OSS.PostObjectRequestHeader({
        accessKeyId: authResponse.body.accessKeyId,
        policy: authResponse.body.encodedPolicy,
        signature: authResponse.body.signature,
        key: authResponse.body.objectKey,
        file: fileObj,
        successActionStatus: "201",
      });
      uploadRequest = new $OSS.PostObjectRequest({
        bucketName: authResponse.body.bucket,
        header: ossHeader,
      });
      await ossClient.postObject(uploadRequest, ossRuntime);
      createImportMigrationReq.packageFile = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
    }

    let createImportMigrationResp = await this.createImportMigrationWithOptions(createImportMigrationReq, runtime);
    return createImportMigrationResp;
  }

  /**
   * Triggers a manually triggered workflow to run. Before you call this operation, make sure that the manually triggered workflow is committed and deployed. You can find the manually triggered workflow on the Operation Center page only after the manually triggered workflow is committed and deployed.
   * 
   * @deprecated OpenAPI CreateManualDag is deprecated
   * 
   * @param request - CreateManualDagRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateManualDagResponse
   */
  // Deprecated
  async createManualDagWithOptions(request: CreateManualDagRequest, runtime: $Util.RuntimeOptions): Promise<CreateManualDagResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizDate)) {
      body["BizDate"] = request.bizDate;
    }

    if (!Util.isUnset(request.dagParameters)) {
      body["DagParameters"] = request.dagParameters;
    }

    if (!Util.isUnset(request.excludeNodeIds)) {
      body["ExcludeNodeIds"] = request.excludeNodeIds;
    }

    if (!Util.isUnset(request.flowName)) {
      body["FlowName"] = request.flowName;
    }

    if (!Util.isUnset(request.includeNodeIds)) {
      body["IncludeNodeIds"] = request.includeNodeIds;
    }

    if (!Util.isUnset(request.nodeParameters)) {
      body["NodeParameters"] = request.nodeParameters;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateManualDag",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateManualDagResponse>(await this.callApi(params, req, runtime), new CreateManualDagResponse({}));
  }

  /**
   * Triggers a manually triggered workflow to run. Before you call this operation, make sure that the manually triggered workflow is committed and deployed. You can find the manually triggered workflow on the Operation Center page only after the manually triggered workflow is committed and deployed.
   * 
   * @deprecated OpenAPI CreateManualDag is deprecated
   * 
   * @param request - CreateManualDagRequest
   * @returns CreateManualDagResponse
   */
  // Deprecated
  async createManualDag(request: CreateManualDagRequest): Promise<CreateManualDagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createManualDagWithOptions(request, runtime);
  }

  /**
   * Creates a category.
   * 
   * @param request - CreateMetaCategoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMetaCategoryResponse
   */
  async createMetaCategoryWithOptions(request: CreateMetaCategoryRequest, runtime: $Util.RuntimeOptions): Promise<CreateMetaCategoryResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.comment)) {
      body["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.parentId)) {
      body["ParentId"] = request.parentId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateMetaCategory",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMetaCategoryResponse>(await this.callApi(params, req, runtime), new CreateMetaCategoryResponse({}));
  }

  /**
   * Creates a category.
   * 
   * @param request - CreateMetaCategoryRequest
   * @returns CreateMetaCategoryResponse
   */
  async createMetaCategory(request: CreateMetaCategoryRequest): Promise<CreateMetaCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMetaCategoryWithOptions(request, runtime);
  }

  /**
   * Creates a collection.
   * 
   * @remarks
   * Collections are classified into various types. The names of collections of the same type must be different.
   * 
   * @param request - CreateMetaCollectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateMetaCollectionResponse
   */
  async createMetaCollectionWithOptions(request: CreateMetaCollectionRequest, runtime: $Util.RuntimeOptions): Promise<CreateMetaCollectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.collectionType)) {
      query["CollectionType"] = request.collectionType;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.parentQualifiedName)) {
      query["ParentQualifiedName"] = request.parentQualifiedName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMetaCollection",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMetaCollectionResponse>(await this.callApi(params, req, runtime), new CreateMetaCollectionResponse({}));
  }

  /**
   * Creates a collection.
   * 
   * @remarks
   * Collections are classified into various types. The names of collections of the same type must be different.
   * 
   * @param request - CreateMetaCollectionRequest
   * @returns CreateMetaCollectionResponse
   */
  async createMetaCollection(request: CreateMetaCollectionRequest): Promise<CreateMetaCollectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMetaCollectionWithOptions(request, runtime);
  }

  /**
   * Creates a permission request order.
   * 
   * @param request - CreatePermissionApplyOrderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreatePermissionApplyOrderResponse
   */
  async createPermissionApplyOrderWithOptions(request: CreatePermissionApplyOrderRequest, runtime: $Util.RuntimeOptions): Promise<CreatePermissionApplyOrderResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applyObject)) {
      query["ApplyObject"] = request.applyObject;
    }

    if (!Util.isUnset(request.applyReason)) {
      query["ApplyReason"] = request.applyReason;
    }

    if (!Util.isUnset(request.applyUserIds)) {
      query["ApplyUserIds"] = request.applyUserIds;
    }

    if (!Util.isUnset(request.deadline)) {
      query["Deadline"] = request.deadline;
    }

    if (!Util.isUnset(request.engineType)) {
      query["EngineType"] = request.engineType;
    }

    if (!Util.isUnset(request.maxComputeProjectName)) {
      query["MaxComputeProjectName"] = request.maxComputeProjectName;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.workspaceId)) {
      query["WorkspaceId"] = request.workspaceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreatePermissionApplyOrder",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePermissionApplyOrderResponse>(await this.callApi(params, req, runtime), new CreatePermissionApplyOrderResponse({}));
  }

  /**
   * Creates a permission request order.
   * 
   * @param request - CreatePermissionApplyOrderRequest
   * @returns CreatePermissionApplyOrderResponse
   */
  async createPermissionApplyOrder(request: CreatePermissionApplyOrderRequest): Promise<CreatePermissionApplyOrderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPermissionApplyOrderWithOptions(request, runtime);
  }

  /**
   * Creates a DataWorks workspace.
   * 
   * @param tmpReq - CreateProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateProjectResponse
   */
  async createProjectWithOptions(tmpReq: CreateProjectRequest, runtime: $Util.RuntimeOptions): Promise<CreateProjectResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateProjectShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.disableDevelopment)) {
      query["DisableDevelopment"] = request.disableDevelopment;
    }

    if (!Util.isUnset(request.isAllowDownload)) {
      query["IsAllowDownload"] = request.isAllowDownload;
    }

    if (!Util.isUnset(request.projectDescription)) {
      query["ProjectDescription"] = request.projectDescription;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      query["ProjectIdentifier"] = request.projectIdentifier;
    }

    if (!Util.isUnset(request.projectMode)) {
      query["ProjectMode"] = request.projectMode;
    }

    if (!Util.isUnset(request.projectName)) {
      query["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.resourceManagerResourceGroupId)) {
      query["ResourceManagerResourceGroupId"] = request.resourceManagerResourceGroupId;
    }

    if (!Util.isUnset(request.tagsShrink)) {
      query["Tags"] = request.tagsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProject",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProjectResponse>(await this.callApi(params, req, runtime), new CreateProjectResponse({}));
  }

  /**
   * Creates a DataWorks workspace.
   * 
   * @param request - CreateProjectRequest
   * @returns CreateProjectResponse
   */
  async createProject(request: CreateProjectRequest): Promise<CreateProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProjectWithOptions(request, runtime);
  }

  /**
   * Adds a user to a DataWorks workspace.
   * 
   * @param request - CreateProjectMemberRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateProjectMemberResponse
   */
  async createProjectMemberWithOptions(request: CreateProjectMemberRequest, runtime: $Util.RuntimeOptions): Promise<CreateProjectMemberResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.roleCode)) {
      query["RoleCode"] = request.roleCode;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateProjectMember",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateProjectMemberResponse>(await this.callApi(params, req, runtime), new CreateProjectMemberResponse({}));
  }

  /**
   * Adds a user to a DataWorks workspace.
   * 
   * @param request - CreateProjectMemberRequest
   * @returns CreateProjectMemberResponse
   */
  async createProjectMember(request: CreateProjectMemberRequest): Promise<CreateProjectMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createProjectMemberWithOptions(request, runtime);
  }

  /**
   * Creates a partition filter expression.
   * 
   * @param request - CreateQualityEntityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateQualityEntityResponse
   */
  async createQualityEntityWithOptions(request: CreateQualityEntityRequest, runtime: $Util.RuntimeOptions): Promise<CreateQualityEntityResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.entityLevel)) {
      body["EntityLevel"] = request.entityLevel;
    }

    if (!Util.isUnset(request.envType)) {
      body["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.matchExpression)) {
      body["MatchExpression"] = request.matchExpression;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.tableName)) {
      body["TableName"] = request.tableName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateQualityEntity",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateQualityEntityResponse>(await this.callApi(params, req, runtime), new CreateQualityEntityResponse({}));
  }

  /**
   * Creates a partition filter expression.
   * 
   * @param request - CreateQualityEntityRequest
   * @returns CreateQualityEntityResponse
   */
  async createQualityEntity(request: CreateQualityEntityRequest): Promise<CreateQualityEntityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createQualityEntityWithOptions(request, runtime);
  }

  /**
   * Creates a subscriber for a partition filter expression.
   * 
   * @param request - CreateQualityFollowerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateQualityFollowerResponse
   */
  async createQualityFollowerWithOptions(request: CreateQualityFollowerRequest, runtime: $Util.RuntimeOptions): Promise<CreateQualityFollowerResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alarmMode)) {
      body["AlarmMode"] = request.alarmMode;
    }

    if (!Util.isUnset(request.entityId)) {
      body["EntityId"] = request.entityId;
    }

    if (!Util.isUnset(request.follower)) {
      body["Follower"] = request.follower;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateQualityFollower",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateQualityFollowerResponse>(await this.callApi(params, req, runtime), new CreateQualityFollowerResponse({}));
  }

  /**
   * Creates a subscriber for a partition filter expression.
   * 
   * @param request - CreateQualityFollowerRequest
   * @returns CreateQualityFollowerResponse
   */
  async createQualityFollower(request: CreateQualityFollowerRequest): Promise<CreateQualityFollowerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createQualityFollowerWithOptions(request, runtime);
  }

  /**
   * Associates a node with a partition filter expression.
   * 
   * @param request - CreateQualityRelativeNodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateQualityRelativeNodeResponse
   */
  async createQualityRelativeNodeWithOptions(request: CreateQualityRelativeNodeRequest, runtime: $Util.RuntimeOptions): Promise<CreateQualityRelativeNodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.envType)) {
      body["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.matchExpression)) {
      body["MatchExpression"] = request.matchExpression;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.tableName)) {
      body["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.targetNodeProjectId)) {
      body["TargetNodeProjectId"] = request.targetNodeProjectId;
    }

    if (!Util.isUnset(request.targetNodeProjectName)) {
      body["TargetNodeProjectName"] = request.targetNodeProjectName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateQualityRelativeNode",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateQualityRelativeNodeResponse>(await this.callApi(params, req, runtime), new CreateQualityRelativeNodeResponse({}));
  }

  /**
   * Associates a node with a partition filter expression.
   * 
   * @param request - CreateQualityRelativeNodeRequest
   * @returns CreateQualityRelativeNodeResponse
   */
  async createQualityRelativeNode(request: CreateQualityRelativeNodeRequest): Promise<CreateQualityRelativeNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createQualityRelativeNodeWithOptions(request, runtime);
  }

  /**
   * Creates a monitoring rule.
   * 
   * @param request - CreateQualityRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateQualityRuleResponse
   */
  async createQualityRuleWithOptions(request: CreateQualityRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateQualityRuleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.blockType)) {
      body["BlockType"] = request.blockType;
    }

    if (!Util.isUnset(request.checker)) {
      body["Checker"] = request.checker;
    }

    if (!Util.isUnset(request.comment)) {
      body["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.criticalThreshold)) {
      body["CriticalThreshold"] = request.criticalThreshold;
    }

    if (!Util.isUnset(request.entityId)) {
      body["EntityId"] = request.entityId;
    }

    if (!Util.isUnset(request.expectValue)) {
      body["ExpectValue"] = request.expectValue;
    }

    if (!Util.isUnset(request.methodName)) {
      body["MethodName"] = request.methodName;
    }

    if (!Util.isUnset(request.operator)) {
      body["Operator"] = request.operator;
    }

    if (!Util.isUnset(request.predictType)) {
      body["PredictType"] = request.predictType;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.property)) {
      body["Property"] = request.property;
    }

    if (!Util.isUnset(request.propertyType)) {
      body["PropertyType"] = request.propertyType;
    }

    if (!Util.isUnset(request.ruleName)) {
      body["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleType)) {
      body["RuleType"] = request.ruleType;
    }

    if (!Util.isUnset(request.taskSetting)) {
      body["TaskSetting"] = request.taskSetting;
    }

    if (!Util.isUnset(request.templateId)) {
      body["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.trend)) {
      body["Trend"] = request.trend;
    }

    if (!Util.isUnset(request.warningThreshold)) {
      body["WarningThreshold"] = request.warningThreshold;
    }

    if (!Util.isUnset(request.whereCondition)) {
      body["WhereCondition"] = request.whereCondition;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateQualityRule",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateQualityRuleResponse>(await this.callApi(params, req, runtime), new CreateQualityRuleResponse({}));
  }

  /**
   * Creates a monitoring rule.
   * 
   * @param request - CreateQualityRuleRequest
   * @returns CreateQualityRuleResponse
   */
  async createQualityRule(request: CreateQualityRuleRequest): Promise<CreateQualityRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createQualityRuleWithOptions(request, runtime);
  }

  /**
   * Creates a custom alert rule.
   * 
   * @param request - CreateRemindRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateRemindResponse
   */
  async createRemindWithOptions(request: CreateRemindRequest, runtime: $Util.RuntimeOptions): Promise<CreateRemindResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alertInterval)) {
      body["AlertInterval"] = request.alertInterval;
    }

    if (!Util.isUnset(request.alertMethods)) {
      body["AlertMethods"] = request.alertMethods;
    }

    if (!Util.isUnset(request.alertTargets)) {
      body["AlertTargets"] = request.alertTargets;
    }

    if (!Util.isUnset(request.alertUnit)) {
      body["AlertUnit"] = request.alertUnit;
    }

    if (!Util.isUnset(request.baselineIds)) {
      body["BaselineIds"] = request.baselineIds;
    }

    if (!Util.isUnset(request.bizProcessIds)) {
      body["BizProcessIds"] = request.bizProcessIds;
    }

    if (!Util.isUnset(request.detail)) {
      body["Detail"] = request.detail;
    }

    if (!Util.isUnset(request.dndEnd)) {
      body["DndEnd"] = request.dndEnd;
    }

    if (!Util.isUnset(request.maxAlertTimes)) {
      body["MaxAlertTimes"] = request.maxAlertTimes;
    }

    if (!Util.isUnset(request.nodeIds)) {
      body["NodeIds"] = request.nodeIds;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.remindName)) {
      body["RemindName"] = request.remindName;
    }

    if (!Util.isUnset(request.remindType)) {
      body["RemindType"] = request.remindType;
    }

    if (!Util.isUnset(request.remindUnit)) {
      body["RemindUnit"] = request.remindUnit;
    }

    if (!Util.isUnset(request.robotUrls)) {
      body["RobotUrls"] = request.robotUrls;
    }

    if (!Util.isUnset(request.webhooks)) {
      body["Webhooks"] = request.webhooks;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateRemind",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateRemindResponse>(await this.callApi(params, req, runtime), new CreateRemindResponse({}));
  }

  /**
   * Creates a custom alert rule.
   * 
   * @param request - CreateRemindRequest
   * @returns CreateRemindResponse
   */
  async createRemind(request: CreateRemindRequest): Promise<CreateRemindResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRemindWithOptions(request, runtime);
  }

  /**
   * 支持用户指定自己的文件（比如jar，py，arhive，file等）创建数据开发资源文件
   * 
   * @param request - CreateResourceFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateResourceFileResponse
   */
  async createResourceFileWithOptions(request: CreateResourceFileRequest, runtime: $Util.RuntimeOptions): Promise<CreateResourceFileResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["Content"] = request.content;
    }

    if (!Util.isUnset(request.fileDescription)) {
      body["FileDescription"] = request.fileDescription;
    }

    if (!Util.isUnset(request.fileFolderPath)) {
      body["FileFolderPath"] = request.fileFolderPath;
    }

    if (!Util.isUnset(request.fileName)) {
      body["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.fileType)) {
      body["FileType"] = request.fileType;
    }

    if (!Util.isUnset(request.originResourceName)) {
      body["OriginResourceName"] = request.originResourceName;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.registerToCalcEngine)) {
      body["RegisterToCalcEngine"] = request.registerToCalcEngine;
    }

    if (!Util.isUnset(request.resourceFile)) {
      body["ResourceFile"] = request.resourceFile;
    }

    if (!Util.isUnset(request.storageURL)) {
      body["StorageURL"] = request.storageURL;
    }

    if (!Util.isUnset(request.uploadMode)) {
      body["UploadMode"] = request.uploadMode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateResourceFile",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateResourceFileResponse>(await this.callApi(params, req, runtime), new CreateResourceFileResponse({}));
  }

  /**
   * 支持用户指定自己的文件（比如jar，py，arhive，file等）创建数据开发资源文件
   * 
   * @param request - CreateResourceFileRequest
   * @returns CreateResourceFileResponse
   */
  async createResourceFile(request: CreateResourceFileRequest): Promise<CreateResourceFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createResourceFileWithOptions(request, runtime);
  }

  async createResourceFileAdvance(request: CreateResourceFileAdvanceRequest, runtime: $Util.RuntimeOptions): Promise<CreateResourceFileResponse> {
    // Step 0: init client
    let accessKeyId = await this._credential.getAccessKeyId();
    let accessKeySecret = await this._credential.getAccessKeySecret();
    let securityToken = await this._credential.getSecurityToken();
    let credentialType = this._credential.getType();
    let openPlatformEndpoint = this._openPlatformEndpoint;
    if (Util.empty(openPlatformEndpoint)) {
      openPlatformEndpoint = "openplatform.aliyuncs.com";
    }

    if (Util.isUnset(credentialType)) {
      credentialType = "access_key";
    }

    let authConfig = new $OpenApi.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      securityToken: securityToken,
      type: credentialType,
      endpoint: openPlatformEndpoint,
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let authClient = new OpenPlatform(authConfig);
    let authRequest = new $OpenPlatform.AuthorizeFileUploadRequest({
      product: "dataworks-public",
      regionId: this._regionId,
    });
    let authResponse = new $OpenPlatform.AuthorizeFileUploadResponse({ });
    let ossConfig = new $OSS.Config({
      accessKeyId: accessKeyId,
      accessKeySecret: accessKeySecret,
      type: "access_key",
      protocol: this._protocol,
      regionId: this._regionId,
    });
    let ossClient : OSS = new OSS(ossConfig);
    let fileObj = new $FileForm.FileField({ });
    let ossHeader = new $OSS.PostObjectRequestHeader({ });
    let uploadRequest = new $OSS.PostObjectRequest({ });
    let ossRuntime = new $OSSUtil.RuntimeOptions({ });
    OpenApiUtil.convert(runtime, ossRuntime);
    let createResourceFileReq = new CreateResourceFileRequest({ });
    OpenApiUtil.convert(request, createResourceFileReq);
    if (!Util.isUnset(request.resourceFileObject)) {
      authResponse = await authClient.authorizeFileUploadWithOptions(authRequest, runtime);
      ossConfig.accessKeyId = authResponse.body.accessKeyId;
      ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, this._endpointType);
      ossClient = new OSS(ossConfig);
      fileObj = new $FileForm.FileField({
        filename: authResponse.body.objectKey,
        content: request.resourceFileObject,
        contentType: "",
      });
      ossHeader = new $OSS.PostObjectRequestHeader({
        accessKeyId: authResponse.body.accessKeyId,
        policy: authResponse.body.encodedPolicy,
        signature: authResponse.body.signature,
        key: authResponse.body.objectKey,
        file: fileObj,
        successActionStatus: "201",
      });
      uploadRequest = new $OSS.PostObjectRequest({
        bucketName: authResponse.body.bucket,
        header: ossHeader,
      });
      await ossClient.postObject(uploadRequest, ossRuntime);
      createResourceFileReq.resourceFile = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
    }

    let createResourceFileResp = await this.createResourceFileWithOptions(createResourceFileReq, runtime);
    return createResourceFileResp;
  }

  /**
   * Creates a MaxCompute table or view.
   * 
   * @param request - CreateTableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTableResponse
   */
  async createTableWithOptions(request: CreateTableRequest, runtime: $Util.RuntimeOptions): Promise<CreateTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appGuid)) {
      query["AppGuid"] = request.appGuid;
    }

    if (!Util.isUnset(request.categoryId)) {
      query["CategoryId"] = request.categoryId;
    }

    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.externalTableType)) {
      query["ExternalTableType"] = request.externalTableType;
    }

    if (!Util.isUnset(request.hasPart)) {
      query["HasPart"] = request.hasPart;
    }

    if (!Util.isUnset(request.isView)) {
      query["IsView"] = request.isView;
    }

    if (!Util.isUnset(request.lifeCycle)) {
      query["LifeCycle"] = request.lifeCycle;
    }

    if (!Util.isUnset(request.location)) {
      query["Location"] = request.location;
    }

    if (!Util.isUnset(request.logicalLevelId)) {
      query["LogicalLevelId"] = request.logicalLevelId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.physicsLevelId)) {
      query["PhysicsLevelId"] = request.physicsLevelId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.schema)) {
      query["Schema"] = request.schema;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.visibility)) {
      query["Visibility"] = request.visibility;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.columns)) {
      body["Columns"] = request.columns;
    }

    if (!Util.isUnset(request.endpoint)) {
      body["Endpoint"] = request.endpoint;
    }

    if (!Util.isUnset(request.envType)) {
      body["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.themes)) {
      body["Themes"] = request.themes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateTable",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTableResponse>(await this.callApi(params, req, runtime), new CreateTableResponse({}));
  }

  /**
   * Creates a MaxCompute table or view.
   * 
   * @param request - CreateTableRequest
   * @returns CreateTableResponse
   */
  async createTable(request: CreateTableRequest): Promise<CreateTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTableWithOptions(request, runtime);
  }

  /**
   * Creates a table level. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - CreateTableLevelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTableLevelResponse
   */
  async createTableLevelWithOptions(request: CreateTableLevelRequest, runtime: $Util.RuntimeOptions): Promise<CreateTableLevelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.levelType)) {
      query["LevelType"] = request.levelType;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateTableLevel",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTableLevelResponse>(await this.callApi(params, req, runtime), new CreateTableLevelResponse({}));
  }

  /**
   * Creates a table level. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - CreateTableLevelRequest
   * @returns CreateTableLevelResponse
   */
  async createTableLevel(request: CreateTableLevelRequest): Promise<CreateTableLevelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTableLevelWithOptions(request, runtime);
  }

  /**
   * Creates a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - CreateTableThemeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateTableThemeResponse
   */
  async createTableThemeWithOptions(request: CreateTableThemeRequest, runtime: $Util.RuntimeOptions): Promise<CreateTableThemeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.level)) {
      query["Level"] = request.level;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.parentId)) {
      query["ParentId"] = request.parentId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateTableTheme",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTableThemeResponse>(await this.callApi(params, req, runtime), new CreateTableThemeResponse({}));
  }

  /**
   * Creates a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - CreateTableThemeRequest
   * @returns CreateTableThemeResponse
   */
  async createTableTheme(request: CreateTableThemeRequest): Promise<CreateTableThemeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTableThemeWithOptions(request, runtime);
  }

  /**
   * @param request - CreateUdfFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns CreateUdfFileResponse
   */
  async createUdfFileWithOptions(request: CreateUdfFileRequest, runtime: $Util.RuntimeOptions): Promise<CreateUdfFileResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.className)) {
      body["ClassName"] = request.className;
    }

    if (!Util.isUnset(request.cmdDescription)) {
      body["CmdDescription"] = request.cmdDescription;
    }

    if (!Util.isUnset(request.createFolderIfNotExists)) {
      body["CreateFolderIfNotExists"] = request.createFolderIfNotExists;
    }

    if (!Util.isUnset(request.example)) {
      body["Example"] = request.example;
    }

    if (!Util.isUnset(request.fileFolderPath)) {
      body["FileFolderPath"] = request.fileFolderPath;
    }

    if (!Util.isUnset(request.fileName)) {
      body["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.functionType)) {
      body["FunctionType"] = request.functionType;
    }

    if (!Util.isUnset(request.parameterDescription)) {
      body["ParameterDescription"] = request.parameterDescription;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    if (!Util.isUnset(request.resources)) {
      body["Resources"] = request.resources;
    }

    if (!Util.isUnset(request.returnValue)) {
      body["ReturnValue"] = request.returnValue;
    }

    if (!Util.isUnset(request.udfDescription)) {
      body["UdfDescription"] = request.udfDescription;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateUdfFile",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateUdfFileResponse>(await this.callApi(params, req, runtime), new CreateUdfFileResponse({}));
  }

  /**
   * @param request - CreateUdfFileRequest
   * @returns CreateUdfFileResponse
   */
  async createUdfFile(request: CreateUdfFileRequest): Promise<CreateUdfFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createUdfFileWithOptions(request, runtime);
  }

  /**
   * Deletes a baseline based on its ID. You can delete a baseline only if the nodes in the baseline does not have ancestor nodes. You can call the UpdateBaseline operation to delete the relationships between the nodes and their ancestor nodes.
   * 
   * @param request - DeleteBaselineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteBaselineResponse
   */
  async deleteBaselineWithOptions(request: DeleteBaselineRequest, runtime: $Util.RuntimeOptions): Promise<DeleteBaselineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.baselineId)) {
      body["BaselineId"] = request.baselineId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteBaseline",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteBaselineResponse>(await this.callApi(params, req, runtime), new DeleteBaselineResponse({}));
  }

  /**
   * Deletes a baseline based on its ID. You can delete a baseline only if the nodes in the baseline does not have ancestor nodes. You can call the UpdateBaseline operation to delete the relationships between the nodes and their ancestor nodes.
   * 
   * @param request - DeleteBaselineRequest
   * @returns DeleteBaselineResponse
   */
  async deleteBaseline(request: DeleteBaselineRequest): Promise<DeleteBaselineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteBaselineWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteBusinessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteBusinessResponse
   */
  async deleteBusinessWithOptions(request: DeleteBusinessRequest, runtime: $Util.RuntimeOptions): Promise<DeleteBusinessResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.businessId)) {
      body["BusinessId"] = request.businessId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteBusiness",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteBusinessResponse>(await this.callApi(params, req, runtime), new DeleteBusinessResponse({}));
  }

  /**
   * @param request - DeleteBusinessRequest
   * @returns DeleteBusinessResponse
   */
  async deleteBusiness(request: DeleteBusinessRequest): Promise<DeleteBusinessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteBusinessWithOptions(request, runtime);
  }

  /**
   * Removes a data source.
   * 
   * @deprecated OpenAPI DeleteConnection is deprecated
   * 
   * @param request - DeleteConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteConnectionResponse
   */
  // Deprecated
  async deleteConnectionWithOptions(request: DeleteConnectionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteConnectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.connectionId)) {
      query["ConnectionId"] = request.connectionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteConnection",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteConnectionResponse>(await this.callApi(params, req, runtime), new DeleteConnectionResponse({}));
  }

  /**
   * Removes a data source.
   * 
   * @deprecated OpenAPI DeleteConnection is deprecated
   * 
   * @param request - DeleteConnectionRequest
   * @returns DeleteConnectionResponse
   */
  // Deprecated
  async deleteConnection(request: DeleteConnectionRequest): Promise<DeleteConnectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteConnectionWithOptions(request, runtime);
  }

  /**
   * Deletes an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @remarks
   * You can configure alert rules only for tasks whose MigrationType is set to RealtimeIncremental.
   * 
   * @param request - DeleteDIAlarmRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDIAlarmRuleResponse
   */
  async deleteDIAlarmRuleWithOptions(request: DeleteDIAlarmRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDIAlarmRuleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.DIAlarmRuleId)) {
      body["DIAlarmRuleId"] = request.DIAlarmRuleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDIAlarmRule",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDIAlarmRuleResponse>(await this.callApi(params, req, runtime), new DeleteDIAlarmRuleResponse({}));
  }

  /**
   * Deletes an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @remarks
   * You can configure alert rules only for tasks whose MigrationType is set to RealtimeIncremental.
   * 
   * @param request - DeleteDIAlarmRuleRequest
   * @returns DeleteDIAlarmRuleResponse
   */
  async deleteDIAlarmRule(request: DeleteDIAlarmRuleRequest): Promise<DeleteDIAlarmRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDIAlarmRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @param request - DeleteDIJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDIJobResponse
   */
  async deleteDIJobWithOptions(request: DeleteDIJobRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDIJobResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.DIJobId)) {
      body["DIJobId"] = request.DIJobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDIJob",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDIJobResponse>(await this.callApi(params, req, runtime), new DeleteDIJobResponse({}));
  }

  /**
   * Deletes a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @param request - DeleteDIJobRequest
   * @returns DeleteDIJobResponse
   */
  async deleteDIJob(request: DeleteDIJobRequest): Promise<DeleteDIJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDIJobWithOptions(request, runtime);
  }

  /**
   * Deletes a synchronization task. You can call this operation to delete only a real-time synchronization task.
   * 
   * @remarks
   * If you want to delete a batch synchronization task, call the DeleteFile operation. For more information, see [Delete a synchronization task](https://help.aliyun.com/document_detail/321443.html).
   * 
   * @param request - DeleteDISyncTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDISyncTaskResponse
   */
  async deleteDISyncTaskWithOptions(request: DeleteDISyncTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDISyncTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileId)) {
      query["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDISyncTask",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDISyncTaskResponse>(await this.callApi(params, req, runtime), new DeleteDISyncTaskResponse({}));
  }

  /**
   * Deletes a synchronization task. You can call this operation to delete only a real-time synchronization task.
   * 
   * @remarks
   * If you want to delete a batch synchronization task, call the DeleteFile operation. For more information, see [Delete a synchronization task](https://help.aliyun.com/document_detail/321443.html).
   * 
   * @param request - DeleteDISyncTaskRequest
   * @returns DeleteDISyncTaskResponse
   */
  async deleteDISyncTask(request: DeleteDISyncTaskRequest): Promise<DeleteDISyncTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDISyncTaskWithOptions(request, runtime);
  }

  /**
   * Deletes an API in DataService Studio.
   * 
   * @param request - DeleteDataServiceApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDataServiceApiResponse
   */
  async deleteDataServiceApiWithOptions(request: DeleteDataServiceApiRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDataServiceApiResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiId)) {
      body["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDataServiceApi",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDataServiceApiResponse>(await this.callApi(params, req, runtime), new DeleteDataServiceApiResponse({}));
  }

  /**
   * Deletes an API in DataService Studio.
   * 
   * @param request - DeleteDataServiceApiRequest
   * @returns DeleteDataServiceApiResponse
   */
  async deleteDataServiceApi(request: DeleteDataServiceApiRequest): Promise<DeleteDataServiceApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDataServiceApiWithOptions(request, runtime);
  }

  /**
   * Revokes the access permissions on an API.
   * 
   * @param request - DeleteDataServiceApiAuthorityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDataServiceApiAuthorityResponse
   */
  async deleteDataServiceApiAuthorityWithOptions(request: DeleteDataServiceApiAuthorityRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDataServiceApiAuthorityResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiId)) {
      body["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.authorizedProjectId)) {
      body["AuthorizedProjectId"] = request.authorizedProjectId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDataServiceApiAuthority",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDataServiceApiAuthorityResponse>(await this.callApi(params, req, runtime), new DeleteDataServiceApiAuthorityResponse({}));
  }

  /**
   * Revokes the access permissions on an API.
   * 
   * @param request - DeleteDataServiceApiAuthorityRequest
   * @returns DeleteDataServiceApiAuthorityResponse
   */
  async deleteDataServiceApiAuthority(request: DeleteDataServiceApiAuthorityRequest): Promise<DeleteDataServiceApiAuthorityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDataServiceApiAuthorityWithOptions(request, runtime);
  }

  /**
   * Removes a data source.
   * 
   * @param request - DeleteDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteDataSourceResponse
   */
  async deleteDataSourceWithOptions(request: DeleteDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<DeleteDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataSourceId)) {
      query["DataSourceId"] = request.dataSourceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteDataSource",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteDataSourceResponse>(await this.callApi(params, req, runtime), new DeleteDataSourceResponse({}));
  }

  /**
   * Removes a data source.
   * 
   * @param request - DeleteDataSourceRequest
   * @returns DeleteDataSourceResponse
   */
  async deleteDataSource(request: DeleteDataSourceRequest): Promise<DeleteDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteDataSourceWithOptions(request, runtime);
  }

  /**
   * Deletes a file from DataStudio. If the file has been committed, an asynchronous process is triggered to delete the file in the scheduling system. The value of the DeploymentId parameter returned is used to call the GetDeployment operation to poll the status of the asynchronous process.
   * 
   * @param request - DeleteFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteFileResponse
   */
  async deleteFileWithOptions(request: DeleteFileRequest, runtime: $Util.RuntimeOptions): Promise<DeleteFileResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.fileId)) {
      body["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFile",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteFileResponse>(await this.callApi(params, req, runtime), new DeleteFileResponse({}));
  }

  /**
   * Deletes a file from DataStudio. If the file has been committed, an asynchronous process is triggered to delete the file in the scheduling system. The value of the DeploymentId parameter returned is used to call the GetDeployment operation to poll the status of the asynchronous process.
   * 
   * @param request - DeleteFileRequest
   * @returns DeleteFileResponse
   */
  async deleteFile(request: DeleteFileRequest): Promise<DeleteFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteFileWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteFolderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteFolderResponse
   */
  async deleteFolderWithOptions(request: DeleteFolderRequest, runtime: $Util.RuntimeOptions): Promise<DeleteFolderResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.folderId)) {
      body["FolderId"] = request.folderId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFolder",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteFolderResponse>(await this.callApi(params, req, runtime), new DeleteFolderResponse({}));
  }

  /**
   * @param request - DeleteFolderRequest
   * @returns DeleteFolderResponse
   */
  async deleteFolder(request: DeleteFolderRequest): Promise<DeleteFolderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteFolderWithOptions(request, runtime);
  }

  /**
   * Removes a table from a specified category.
   * 
   * @param request - DeleteFromMetaCategoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteFromMetaCategoryResponse
   */
  async deleteFromMetaCategoryWithOptions(request: DeleteFromMetaCategoryRequest, runtime: $Util.RuntimeOptions): Promise<DeleteFromMetaCategoryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.categoryId)) {
      query["CategoryId"] = request.categoryId;
    }

    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFromMetaCategory",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteFromMetaCategoryResponse>(await this.callApi(params, req, runtime), new DeleteFromMetaCategoryResponse({}));
  }

  /**
   * Removes a table from a specified category.
   * 
   * @param request - DeleteFromMetaCategoryRequest
   * @returns DeleteFromMetaCategoryResponse
   */
  async deleteFromMetaCategory(request: DeleteFromMetaCategoryRequest): Promise<DeleteFromMetaCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteFromMetaCategoryWithOptions(request, runtime);
  }

  /**
   * Deletes the lineage between entities. You can call this operation to delete only custom lineages that are registered by users.
   * 
   * @remarks
   * This operation is in the trial phase. Users who need to call this operation can apply for it. The users can call this operation after the administrator adds the users to the trial list.
   * 
   * @param request - DeleteLineageRelationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteLineageRelationResponse
   */
  async deleteLineageRelationWithOptions(request: DeleteLineageRelationRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLineageRelationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.destEntityQualifiedName)) {
      query["DestEntityQualifiedName"] = request.destEntityQualifiedName;
    }

    if (!Util.isUnset(request.relationshipGuid)) {
      query["RelationshipGuid"] = request.relationshipGuid;
    }

    if (!Util.isUnset(request.relationshipType)) {
      query["RelationshipType"] = request.relationshipType;
    }

    if (!Util.isUnset(request.srcEntityQualifiedName)) {
      query["SrcEntityQualifiedName"] = request.srcEntityQualifiedName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLineageRelation",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLineageRelationResponse>(await this.callApi(params, req, runtime), new DeleteLineageRelationResponse({}));
  }

  /**
   * Deletes the lineage between entities. You can call this operation to delete only custom lineages that are registered by users.
   * 
   * @remarks
   * This operation is in the trial phase. Users who need to call this operation can apply for it. The users can call this operation after the administrator adds the users to the trial list.
   * 
   * @param request - DeleteLineageRelationRequest
   * @returns DeleteLineageRelationResponse
   */
  async deleteLineageRelation(request: DeleteLineageRelationRequest): Promise<DeleteLineageRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLineageRelationWithOptions(request, runtime);
  }

  /**
   * Deletes a category.
   * 
   * @param request - DeleteMetaCategoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMetaCategoryResponse
   */
  async deleteMetaCategoryWithOptions(request: DeleteMetaCategoryRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMetaCategoryResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMetaCategory",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMetaCategoryResponse>(await this.callApi(params, req, runtime), new DeleteMetaCategoryResponse({}));
  }

  /**
   * Deletes a category.
   * 
   * @param request - DeleteMetaCategoryRequest
   * @returns DeleteMetaCategoryResponse
   */
  async deleteMetaCategory(request: DeleteMetaCategoryRequest): Promise<DeleteMetaCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMetaCategoryWithOptions(request, runtime);
  }

  /**
   * Deletes a collection.
   * 
   * @param request - DeleteMetaCollectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMetaCollectionResponse
   */
  async deleteMetaCollectionWithOptions(request: DeleteMetaCollectionRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMetaCollectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.qualifiedName)) {
      query["QualifiedName"] = request.qualifiedName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMetaCollection",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMetaCollectionResponse>(await this.callApi(params, req, runtime), new DeleteMetaCollectionResponse({}));
  }

  /**
   * Deletes a collection.
   * 
   * @param request - DeleteMetaCollectionRequest
   * @returns DeleteMetaCollectionResponse
   */
  async deleteMetaCollection(request: DeleteMetaCollectionRequest): Promise<DeleteMetaCollectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMetaCollectionWithOptions(request, runtime);
  }

  /**
   * Deletes an entity from a collection.
   * 
   * @param request - DeleteMetaCollectionEntityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteMetaCollectionEntityResponse
   */
  async deleteMetaCollectionEntityWithOptions(request: DeleteMetaCollectionEntityRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMetaCollectionEntityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.collectionQualifiedName)) {
      query["CollectionQualifiedName"] = request.collectionQualifiedName;
    }

    if (!Util.isUnset(request.entityQualifiedName)) {
      query["EntityQualifiedName"] = request.entityQualifiedName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMetaCollectionEntity",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMetaCollectionEntityResponse>(await this.callApi(params, req, runtime), new DeleteMetaCollectionEntityResponse({}));
  }

  /**
   * Deletes an entity from a collection.
   * 
   * @param request - DeleteMetaCollectionEntityRequest
   * @returns DeleteMetaCollectionEntityResponse
   */
  async deleteMetaCollectionEntity(request: DeleteMetaCollectionEntityRequest): Promise<DeleteMetaCollectionEntityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMetaCollectionEntityWithOptions(request, runtime);
  }

  /**
   * Removes a user from a DataWorks workspace.
   * 
   * @param request - DeleteProjectMemberRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteProjectMemberResponse
   */
  async deleteProjectMemberWithOptions(request: DeleteProjectMemberRequest, runtime: $Util.RuntimeOptions): Promise<DeleteProjectMemberResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteProjectMember",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteProjectMemberResponse>(await this.callApi(params, req, runtime), new DeleteProjectMemberResponse({}));
  }

  /**
   * Removes a user from a DataWorks workspace.
   * 
   * @param request - DeleteProjectMemberRequest
   * @returns DeleteProjectMemberResponse
   */
  async deleteProjectMember(request: DeleteProjectMemberRequest): Promise<DeleteProjectMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteProjectMemberWithOptions(request, runtime);
  }

  /**
   * Deletes a partition filter expression.
   * 
   * @param request - DeleteQualityEntityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteQualityEntityResponse
   */
  async deleteQualityEntityWithOptions(request: DeleteQualityEntityRequest, runtime: $Util.RuntimeOptions): Promise<DeleteQualityEntityResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.entityId)) {
      body["EntityId"] = request.entityId;
    }

    if (!Util.isUnset(request.envType)) {
      body["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteQualityEntity",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteQualityEntityResponse>(await this.callApi(params, req, runtime), new DeleteQualityEntityResponse({}));
  }

  /**
   * Deletes a partition filter expression.
   * 
   * @param request - DeleteQualityEntityRequest
   * @returns DeleteQualityEntityResponse
   */
  async deleteQualityEntity(request: DeleteQualityEntityRequest): Promise<DeleteQualityEntityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteQualityEntityWithOptions(request, runtime);
  }

  /**
   * Deletes a subscriber of a partition filter expression.
   * 
   * @remarks
   * In Data Quality, you must configure monitoring rules based on a partition filter expression. Data Quality uses these rules to detect changes in source data and dirty data generated during the process of extract, transform, and load (ETL). This way, you can prevent tasks from producing unexpected dirty data that affects the smooth running of tasks and business decision-making. You can go to the Manage Subscriptions page to add subscribers for a partition filter expression. When the monitoring rule that is created based on the partition filter expression is triggered, the subscribers can receive notifications and troubleshoot errors at the earliest opportunity. For more information, see [Configure monitoring rules](https://help.aliyun.com/document_detail/73690.html).
   * 
   * @param request - DeleteQualityFollowerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteQualityFollowerResponse
   */
  async deleteQualityFollowerWithOptions(request: DeleteQualityFollowerRequest, runtime: $Util.RuntimeOptions): Promise<DeleteQualityFollowerResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.followerId)) {
      body["FollowerId"] = request.followerId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteQualityFollower",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteQualityFollowerResponse>(await this.callApi(params, req, runtime), new DeleteQualityFollowerResponse({}));
  }

  /**
   * Deletes a subscriber of a partition filter expression.
   * 
   * @remarks
   * In Data Quality, you must configure monitoring rules based on a partition filter expression. Data Quality uses these rules to detect changes in source data and dirty data generated during the process of extract, transform, and load (ETL). This way, you can prevent tasks from producing unexpected dirty data that affects the smooth running of tasks and business decision-making. You can go to the Manage Subscriptions page to add subscribers for a partition filter expression. When the monitoring rule that is created based on the partition filter expression is triggered, the subscribers can receive notifications and troubleshoot errors at the earliest opportunity. For more information, see [Configure monitoring rules](https://help.aliyun.com/document_detail/73690.html).
   * 
   * @param request - DeleteQualityFollowerRequest
   * @returns DeleteQualityFollowerResponse
   */
  async deleteQualityFollower(request: DeleteQualityFollowerRequest): Promise<DeleteQualityFollowerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteQualityFollowerWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteQualityRelativeNodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteQualityRelativeNodeResponse
   */
  async deleteQualityRelativeNodeWithOptions(request: DeleteQualityRelativeNodeRequest, runtime: $Util.RuntimeOptions): Promise<DeleteQualityRelativeNodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.envType)) {
      body["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.matchExpression)) {
      body["MatchExpression"] = request.matchExpression;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.tableName)) {
      body["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.targetNodeProjectId)) {
      body["TargetNodeProjectId"] = request.targetNodeProjectId;
    }

    if (!Util.isUnset(request.targetNodeProjectName)) {
      body["TargetNodeProjectName"] = request.targetNodeProjectName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteQualityRelativeNode",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteQualityRelativeNodeResponse>(await this.callApi(params, req, runtime), new DeleteQualityRelativeNodeResponse({}));
  }

  /**
   * @param request - DeleteQualityRelativeNodeRequest
   * @returns DeleteQualityRelativeNodeResponse
   */
  async deleteQualityRelativeNode(request: DeleteQualityRelativeNodeRequest): Promise<DeleteQualityRelativeNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteQualityRelativeNodeWithOptions(request, runtime);
  }

  /**
   * Deletes a monitoring rule.
   * 
   * @param request - DeleteQualityRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteQualityRuleResponse
   */
  async deleteQualityRuleWithOptions(request: DeleteQualityRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteQualityRuleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.ruleId)) {
      body["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteQualityRule",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteQualityRuleResponse>(await this.callApi(params, req, runtime), new DeleteQualityRuleResponse({}));
  }

  /**
   * Deletes a monitoring rule.
   * 
   * @param request - DeleteQualityRuleRequest
   * @returns DeleteQualityRuleResponse
   */
  async deleteQualityRule(request: DeleteQualityRuleRequest): Promise<DeleteQualityRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteQualityRuleWithOptions(request, runtime);
  }

  /**
   * Deletes sensitive field types.
   * 
   * @param request - DeleteRecognizeRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRecognizeRuleResponse
   */
  async deleteRecognizeRuleWithOptions(request: DeleteRecognizeRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRecognizeRuleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.sensitiveId)) {
      body["SensitiveId"] = request.sensitiveId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRecognizeRule",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRecognizeRuleResponse>(await this.callApi(params, req, runtime), new DeleteRecognizeRuleResponse({}));
  }

  /**
   * Deletes sensitive field types.
   * 
   * @param request - DeleteRecognizeRuleRequest
   * @returns DeleteRecognizeRuleResponse
   */
  async deleteRecognizeRule(request: DeleteRecognizeRuleRequest): Promise<DeleteRecognizeRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRecognizeRuleWithOptions(request, runtime);
  }

  /**
   * Deletes a custom alert rule.
   * 
   * @param request - DeleteRemindRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteRemindResponse
   */
  async deleteRemindWithOptions(request: DeleteRemindRequest, runtime: $Util.RuntimeOptions): Promise<DeleteRemindResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.remindId)) {
      body["RemindId"] = request.remindId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteRemind",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteRemindResponse>(await this.callApi(params, req, runtime), new DeleteRemindResponse({}));
  }

  /**
   * Deletes a custom alert rule.
   * 
   * @param request - DeleteRemindRequest
   * @returns DeleteRemindResponse
   */
  async deleteRemind(request: DeleteRemindRequest): Promise<DeleteRemindResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteRemindWithOptions(request, runtime);
  }

  /**
   * @param request - DeleteTableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTableResponse
   */
  async deleteTableWithOptions(request: DeleteTableRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appGuid)) {
      query["AppGuid"] = request.appGuid;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.schema)) {
      query["Schema"] = request.schema;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTable",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTableResponse>(await this.callApi(params, req, runtime), new DeleteTableResponse({}));
  }

  /**
   * @param request - DeleteTableRequest
   * @returns DeleteTableResponse
   */
  async deleteTable(request: DeleteTableRequest): Promise<DeleteTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTableWithOptions(request, runtime);
  }

  /**
   * Deletes a table level. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - DeleteTableLevelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTableLevelResponse
   */
  async deleteTableLevelWithOptions(request: DeleteTableLevelRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTableLevelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.levelId)) {
      query["LevelId"] = request.levelId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTableLevel",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTableLevelResponse>(await this.callApi(params, req, runtime), new DeleteTableLevelResponse({}));
  }

  /**
   * Deletes a table level. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - DeleteTableLevelRequest
   * @returns DeleteTableLevelResponse
   */
  async deleteTableLevel(request: DeleteTableLevelRequest): Promise<DeleteTableLevelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTableLevelWithOptions(request, runtime);
  }

  /**
   * Deletes a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - DeleteTableThemeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeleteTableThemeResponse
   */
  async deleteTableThemeWithOptions(request: DeleteTableThemeRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTableThemeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.themeId)) {
      query["ThemeId"] = request.themeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTableTheme",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTableThemeResponse>(await this.callApi(params, req, runtime), new DeleteTableThemeResponse({}));
  }

  /**
   * Deletes a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - DeleteTableThemeRequest
   * @returns DeleteTableThemeResponse
   */
  async deleteTableTheme(request: DeleteTableThemeRequest): Promise<DeleteTableThemeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTableThemeWithOptions(request, runtime);
  }

  /**
   * Deploys a real-time synchronization task.
   * 
   * @param request - DeployDISyncTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeployDISyncTaskResponse
   */
  async deployDISyncTaskWithOptions(request: DeployDISyncTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeployDISyncTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileId)) {
      query["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeployDISyncTask",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeployDISyncTaskResponse>(await this.callApi(params, req, runtime), new DeployDISyncTaskResponse({}));
  }

  /**
   * Deploys a real-time synchronization task.
   * 
   * @param request - DeployDISyncTaskRequest
   * @returns DeployDISyncTaskResponse
   */
  async deployDISyncTask(request: DeployDISyncTaskRequest): Promise<DeployDISyncTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deployDISyncTaskWithOptions(request, runtime);
  }

  /**
   * Deploys a file to the production environment.
   * 
   * @param request - DeployFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DeployFileResponse
   */
  async deployFileWithOptions(request: DeployFileRequest, runtime: $Util.RuntimeOptions): Promise<DeployFileResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.comment)) {
      body["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.fileId)) {
      body["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeployFile",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeployFileResponse>(await this.callApi(params, req, runtime), new DeployFileResponse({}));
  }

  /**
   * Deploys a file to the production environment.
   * 
   * @param request - DeployFileRequest
   * @returns DeployFileResponse
   */
  async deployFile(request: DeployFileRequest): Promise<DeployFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deployFileWithOptions(request, runtime);
  }

  /**
   * Masks data.
   * 
   * @param request - DesensitizeDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DesensitizeDataResponse
   */
  async desensitizeDataWithOptions(request: DesensitizeDataRequest, runtime: $Util.RuntimeOptions): Promise<DesensitizeDataResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DesensitizeData",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DesensitizeDataResponse>(await this.callApi(params, req, runtime), new DesensitizeDataResponse({}));
  }

  /**
   * Masks data.
   * 
   * @param request - DesensitizeDataRequest
   * @returns DesensitizeDataResponse
   */
  async desensitizeData(request: DesensitizeDataRequest): Promise<DesensitizeDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.desensitizeDataWithOptions(request, runtime);
  }

  /**
   * Adds or modifies a data masking rule.
   * 
   * @param tmpReq - DsgDesensPlanAddOrUpdateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgDesensPlanAddOrUpdateResponse
   */
  async dsgDesensPlanAddOrUpdateWithOptions(tmpReq: DsgDesensPlanAddOrUpdateRequest, runtime: $Util.RuntimeOptions): Promise<DsgDesensPlanAddOrUpdateResponse> {
    Util.validateModel(tmpReq);
    let request = new DsgDesensPlanAddOrUpdateShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.desensRules)) {
      request.desensRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.desensRules, "DesensRules", "json");
    }

    let query = { };
    if (!Util.isUnset(request.desensRulesShrink)) {
      query["DesensRules"] = request.desensRulesShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgDesensPlanAddOrUpdate",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgDesensPlanAddOrUpdateResponse>(await this.callApi(params, req, runtime), new DsgDesensPlanAddOrUpdateResponse({}));
  }

  /**
   * Adds or modifies a data masking rule.
   * 
   * @param request - DsgDesensPlanAddOrUpdateRequest
   * @returns DsgDesensPlanAddOrUpdateResponse
   */
  async dsgDesensPlanAddOrUpdate(request: DsgDesensPlanAddOrUpdateRequest): Promise<DsgDesensPlanAddOrUpdateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgDesensPlanAddOrUpdateWithOptions(request, runtime);
  }

  /**
   * Deletes a data masking rule created in Data Security Guard.
   * 
   * @param tmpReq - DsgDesensPlanDeleteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgDesensPlanDeleteResponse
   */
  async dsgDesensPlanDeleteWithOptions(tmpReq: DsgDesensPlanDeleteRequest, runtime: $Util.RuntimeOptions): Promise<DsgDesensPlanDeleteResponse> {
    Util.validateModel(tmpReq);
    let request = new DsgDesensPlanDeleteShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.ids)) {
      request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, "Ids", "json");
    }

    let query = { };
    if (!Util.isUnset(request.idsShrink)) {
      query["Ids"] = request.idsShrink;
    }

    if (!Util.isUnset(request.sceneCode)) {
      query["SceneCode"] = request.sceneCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgDesensPlanDelete",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgDesensPlanDeleteResponse>(await this.callApi(params, req, runtime), new DsgDesensPlanDeleteResponse({}));
  }

  /**
   * Deletes a data masking rule created in Data Security Guard.
   * 
   * @param request - DsgDesensPlanDeleteRequest
   * @returns DsgDesensPlanDeleteResponse
   */
  async dsgDesensPlanDelete(request: DsgDesensPlanDeleteRequest): Promise<DsgDesensPlanDeleteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgDesensPlanDeleteWithOptions(request, runtime);
  }

  /**
   * Queries a list of data masking rules.
   * 
   * @param request - DsgDesensPlanQueryListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgDesensPlanQueryListResponse
   */
  async dsgDesensPlanQueryListWithOptions(request: DsgDesensPlanQueryListRequest, runtime: $Util.RuntimeOptions): Promise<DsgDesensPlanQueryListResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgDesensPlanQueryList",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgDesensPlanQueryListResponse>(await this.callApi(params, req, runtime), new DsgDesensPlanQueryListResponse({}));
  }

  /**
   * Queries a list of data masking rules.
   * 
   * @param request - DsgDesensPlanQueryListRequest
   * @returns DsgDesensPlanQueryListResponse
   */
  async dsgDesensPlanQueryList(request: DsgDesensPlanQueryListRequest): Promise<DsgDesensPlanQueryListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgDesensPlanQueryListWithOptions(request, runtime);
  }

  /**
   * Modifies the status of a data masking rule.
   * 
   * @param tmpReq - DsgDesensPlanUpdateStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgDesensPlanUpdateStatusResponse
   */
  async dsgDesensPlanUpdateStatusWithOptions(tmpReq: DsgDesensPlanUpdateStatusRequest, runtime: $Util.RuntimeOptions): Promise<DsgDesensPlanUpdateStatusResponse> {
    Util.validateModel(tmpReq);
    let request = new DsgDesensPlanUpdateStatusShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.ids)) {
      request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, "Ids", "json");
    }

    let query = { };
    if (!Util.isUnset(request.idsShrink)) {
      query["Ids"] = request.idsShrink;
    }

    if (!Util.isUnset(request.sceneCode)) {
      query["SceneCode"] = request.sceneCode;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgDesensPlanUpdateStatus",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgDesensPlanUpdateStatusResponse>(await this.callApi(params, req, runtime), new DsgDesensPlanUpdateStatusResponse({}));
  }

  /**
   * Modifies the status of a data masking rule.
   * 
   * @param request - DsgDesensPlanUpdateStatusRequest
   * @returns DsgDesensPlanUpdateStatusResponse
   */
  async dsgDesensPlanUpdateStatus(request: DsgDesensPlanUpdateStatusRequest): Promise<DsgDesensPlanUpdateStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgDesensPlanUpdateStatusWithOptions(request, runtime);
  }

  /**
   * Queries a list of compute engines of different types in the current tenant.
   * 
   * @param request - DsgPlatformQueryProjectsAndSchemaFromMetaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgPlatformQueryProjectsAndSchemaFromMetaResponse
   */
  async dsgPlatformQueryProjectsAndSchemaFromMetaWithOptions(request: DsgPlatformQueryProjectsAndSchemaFromMetaRequest, runtime: $Util.RuntimeOptions): Promise<DsgPlatformQueryProjectsAndSchemaFromMetaResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgPlatformQueryProjectsAndSchemaFromMeta",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgPlatformQueryProjectsAndSchemaFromMetaResponse>(await this.callApi(params, req, runtime), new DsgPlatformQueryProjectsAndSchemaFromMetaResponse({}));
  }

  /**
   * Queries a list of compute engines of different types in the current tenant.
   * 
   * @param request - DsgPlatformQueryProjectsAndSchemaFromMetaRequest
   * @returns DsgPlatformQueryProjectsAndSchemaFromMetaResponse
   */
  async dsgPlatformQueryProjectsAndSchemaFromMeta(request: DsgPlatformQueryProjectsAndSchemaFromMetaRequest): Promise<DsgPlatformQueryProjectsAndSchemaFromMetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgPlatformQueryProjectsAndSchemaFromMetaWithOptions(request, runtime);
  }

  /**
   * Queries a list of available sensitive field type templates and the data masking rules supported by the templates. You can refer to the response parameters of this operation to configure a data masking rule.
   * 
   * @param request - DsgQueryDefaultTemplatesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgQueryDefaultTemplatesResponse
   */
  async dsgQueryDefaultTemplatesWithOptions(request: DsgQueryDefaultTemplatesRequest, runtime: $Util.RuntimeOptions): Promise<DsgQueryDefaultTemplatesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgQueryDefaultTemplates",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgQueryDefaultTemplatesResponse>(await this.callApi(params, req, runtime), new DsgQueryDefaultTemplatesResponse({}));
  }

  /**
   * Queries a list of available sensitive field type templates and the data masking rules supported by the templates. You can refer to the response parameters of this operation to configure a data masking rule.
   * 
   * @param request - DsgQueryDefaultTemplatesRequest
   * @returns DsgQueryDefaultTemplatesResponse
   */
  async dsgQueryDefaultTemplates(request: DsgQueryDefaultTemplatesRequest): Promise<DsgQueryDefaultTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgQueryDefaultTemplatesWithOptions(request, runtime);
  }

  /**
   * Queries the identification results of sensitive data.
   * 
   * @remarks
   * The query capability of the API operation is similar to the query feature in Data Security Guard in the DataWorks console. The API operation can be used to query the identification results of sensitive data of a tenant based on the association with the tenant ID.
   * *   You can search for a specific identification result based on filter conditions such as data source type and workspace.
   * *   You can sort the identification results of sensitive data of a tenant based on the values of a field in ascending or descending order.
   * *   This operation supports paged query.
   * 
   * @param request - DsgQuerySensResultRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgQuerySensResultResponse
   */
  async dsgQuerySensResultWithOptions(request: DsgQuerySensResultRequest, runtime: $Util.RuntimeOptions): Promise<DsgQuerySensResultResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.col)) {
      body["Col"] = request.col;
    }

    if (!Util.isUnset(request.dbType)) {
      body["DbType"] = request.dbType;
    }

    if (!Util.isUnset(request.level)) {
      body["Level"] = request.level;
    }

    if (!Util.isUnset(request.nodeName)) {
      body["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.order)) {
      body["Order"] = request.order;
    }

    if (!Util.isUnset(request.orderField)) {
      body["OrderField"] = request.orderField;
    }

    if (!Util.isUnset(request.pageNo)) {
      body["PageNo"] = request.pageNo;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.schemaName)) {
      body["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.sensStatus)) {
      body["SensStatus"] = request.sensStatus;
    }

    if (!Util.isUnset(request.sensitiveId)) {
      body["SensitiveId"] = request.sensitiveId;
    }

    if (!Util.isUnset(request.sensitiveName)) {
      body["SensitiveName"] = request.sensitiveName;
    }

    if (!Util.isUnset(request.table)) {
      body["Table"] = request.table;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DsgQuerySensResult",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgQuerySensResultResponse>(await this.callApi(params, req, runtime), new DsgQuerySensResultResponse({}));
  }

  /**
   * Queries the identification results of sensitive data.
   * 
   * @remarks
   * The query capability of the API operation is similar to the query feature in Data Security Guard in the DataWorks console. The API operation can be used to query the identification results of sensitive data of a tenant based on the association with the tenant ID.
   * *   You can search for a specific identification result based on filter conditions such as data source type and workspace.
   * *   You can sort the identification results of sensitive data of a tenant based on the values of a field in ascending or descending order.
   * *   This operation supports paged query.
   * 
   * @param request - DsgQuerySensResultRequest
   * @returns DsgQuerySensResultResponse
   */
  async dsgQuerySensResult(request: DsgQuerySensResultRequest): Promise<DsgQuerySensResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgQuerySensResultWithOptions(request, runtime);
  }

  /**
   * Starts a sensitive data identification task in Data Security Guard.
   * 
   * @param tmpReq - DsgRunSensIdentifyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgRunSensIdentifyResponse
   */
  async dsgRunSensIdentifyWithOptions(tmpReq: DsgRunSensIdentifyRequest, runtime: $Util.RuntimeOptions): Promise<DsgRunSensIdentifyResponse> {
    Util.validateModel(tmpReq);
    let request = new DsgRunSensIdentifyShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.esMetaParams)) {
      request.esMetaParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.esMetaParams, "EsMetaParams", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.esMetaParamsShrink)) {
      body["EsMetaParams"] = request.esMetaParamsShrink;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DsgRunSensIdentify",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgRunSensIdentifyResponse>(await this.callApi(params, req, runtime), new DsgRunSensIdentifyResponse({}));
  }

  /**
   * Starts a sensitive data identification task in Data Security Guard.
   * 
   * @param request - DsgRunSensIdentifyRequest
   * @returns DsgRunSensIdentifyResponse
   */
  async dsgRunSensIdentify(request: DsgRunSensIdentifyRequest): Promise<DsgRunSensIdentifyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgRunSensIdentifyWithOptions(request, runtime);
  }

  /**
   * Adds or modifies a level-2 data masking scenario.
   * 
   * @param tmpReq - DsgSceneAddOrUpdateSceneRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgSceneAddOrUpdateSceneResponse
   */
  async dsgSceneAddOrUpdateSceneWithOptions(tmpReq: DsgSceneAddOrUpdateSceneRequest, runtime: $Util.RuntimeOptions): Promise<DsgSceneAddOrUpdateSceneResponse> {
    Util.validateModel(tmpReq);
    let request = new DsgSceneAddOrUpdateSceneShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.scenes)) {
      request.scenesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scenes, "scenes", "json");
    }

    let query = { };
    if (!Util.isUnset(request.scenesShrink)) {
      query["scenes"] = request.scenesShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgSceneAddOrUpdateScene",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgSceneAddOrUpdateSceneResponse>(await this.callApi(params, req, runtime), new DsgSceneAddOrUpdateSceneResponse({}));
  }

  /**
   * Adds or modifies a level-2 data masking scenario.
   * 
   * @param request - DsgSceneAddOrUpdateSceneRequest
   * @returns DsgSceneAddOrUpdateSceneResponse
   */
  async dsgSceneAddOrUpdateScene(request: DsgSceneAddOrUpdateSceneRequest): Promise<DsgSceneAddOrUpdateSceneResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgSceneAddOrUpdateSceneWithOptions(request, runtime);
  }

  /**
   * Queries a list of data masking scenarios.
   * 
   * @param request - DsgSceneQuerySceneListByNameRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgSceneQuerySceneListByNameResponse
   */
  async dsgSceneQuerySceneListByNameWithOptions(request: DsgSceneQuerySceneListByNameRequest, runtime: $Util.RuntimeOptions): Promise<DsgSceneQuerySceneListByNameResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgSceneQuerySceneListByName",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgSceneQuerySceneListByNameResponse>(await this.callApi(params, req, runtime), new DsgSceneQuerySceneListByNameResponse({}));
  }

  /**
   * Queries a list of data masking scenarios.
   * 
   * @param request - DsgSceneQuerySceneListByNameRequest
   * @returns DsgSceneQuerySceneListByNameResponse
   */
  async dsgSceneQuerySceneListByName(request: DsgSceneQuerySceneListByNameRequest): Promise<DsgSceneQuerySceneListByNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgSceneQuerySceneListByNameWithOptions(request, runtime);
  }

  /**
   * Deletes a level-2 data masking scenario created in Data Security Guard.
   * 
   * @param tmpReq - DsgScenedDeleteSceneRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgScenedDeleteSceneResponse
   */
  async dsgScenedDeleteSceneWithOptions(tmpReq: DsgScenedDeleteSceneRequest, runtime: $Util.RuntimeOptions): Promise<DsgScenedDeleteSceneResponse> {
    Util.validateModel(tmpReq);
    let request = new DsgScenedDeleteSceneShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.ids)) {
      request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, "Ids", "json");
    }

    let query = { };
    if (!Util.isUnset(request.idsShrink)) {
      query["Ids"] = request.idsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgScenedDeleteScene",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgScenedDeleteSceneResponse>(await this.callApi(params, req, runtime), new DsgScenedDeleteSceneResponse({}));
  }

  /**
   * Deletes a level-2 data masking scenario created in Data Security Guard.
   * 
   * @param request - DsgScenedDeleteSceneRequest
   * @returns DsgScenedDeleteSceneResponse
   */
  async dsgScenedDeleteScene(request: DsgScenedDeleteSceneRequest): Promise<DsgScenedDeleteSceneResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgScenedDeleteSceneWithOptions(request, runtime);
  }

  /**
   * Stops a sensitive data identification task.
   * 
   * @param request - DsgStopSensIdentifyRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgStopSensIdentifyResponse
   */
  async dsgStopSensIdentifyWithOptions(request: DsgStopSensIdentifyRequest, runtime: $Util.RuntimeOptions): Promise<DsgStopSensIdentifyResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.jobId)) {
      body["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DsgStopSensIdentify",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgStopSensIdentifyResponse>(await this.callApi(params, req, runtime), new DsgStopSensIdentifyResponse({}));
  }

  /**
   * Stops a sensitive data identification task.
   * 
   * @param request - DsgStopSensIdentifyRequest
   * @returns DsgStopSensIdentifyResponse
   */
  async dsgStopSensIdentify(request: DsgStopSensIdentifyRequest): Promise<DsgStopSensIdentifyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgStopSensIdentifyWithOptions(request, runtime);
  }

  /**
   * Adds or modifies a user group.
   * 
   * @param tmpReq - DsgUserGroupAddOrUpdateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgUserGroupAddOrUpdateResponse
   */
  async dsgUserGroupAddOrUpdateWithOptions(tmpReq: DsgUserGroupAddOrUpdateRequest, runtime: $Util.RuntimeOptions): Promise<DsgUserGroupAddOrUpdateResponse> {
    Util.validateModel(tmpReq);
    let request = new DsgUserGroupAddOrUpdateShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.userGroups)) {
      request.userGroupsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userGroups, "UserGroups", "json");
    }

    let query = { };
    if (!Util.isUnset(request.userGroupsShrink)) {
      query["UserGroups"] = request.userGroupsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgUserGroupAddOrUpdate",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgUserGroupAddOrUpdateResponse>(await this.callApi(params, req, runtime), new DsgUserGroupAddOrUpdateResponse({}));
  }

  /**
   * Adds or modifies a user group.
   * 
   * @param request - DsgUserGroupAddOrUpdateRequest
   * @returns DsgUserGroupAddOrUpdateResponse
   */
  async dsgUserGroupAddOrUpdate(request: DsgUserGroupAddOrUpdateRequest): Promise<DsgUserGroupAddOrUpdateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgUserGroupAddOrUpdateWithOptions(request, runtime);
  }

  /**
   * Deletes a user group configured in Data Security Guard.
   * 
   * @param tmpReq - DsgUserGroupDeleteRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgUserGroupDeleteResponse
   */
  async dsgUserGroupDeleteWithOptions(tmpReq: DsgUserGroupDeleteRequest, runtime: $Util.RuntimeOptions): Promise<DsgUserGroupDeleteResponse> {
    Util.validateModel(tmpReq);
    let request = new DsgUserGroupDeleteShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.ids)) {
      request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, "Ids", "json");
    }

    let query = { };
    if (!Util.isUnset(request.idsShrink)) {
      query["Ids"] = request.idsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgUserGroupDelete",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgUserGroupDeleteResponse>(await this.callApi(params, req, runtime), new DsgUserGroupDeleteResponse({}));
  }

  /**
   * Deletes a user group configured in Data Security Guard.
   * 
   * @param request - DsgUserGroupDeleteRequest
   * @returns DsgUserGroupDeleteResponse
   */
  async dsgUserGroupDelete(request: DsgUserGroupDeleteRequest): Promise<DsgUserGroupDeleteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgUserGroupDeleteWithOptions(request, runtime);
  }

  /**
   * Queries a list of MaxCompute roles that can be selected by the members of a user group when the user group is created or modified by the tenant in Data Security Guard.
   * 
   * @param request - DsgUserGroupGetOdpsRoleGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgUserGroupGetOdpsRoleGroupsResponse
   */
  async dsgUserGroupGetOdpsRoleGroupsWithOptions(request: DsgUserGroupGetOdpsRoleGroupsRequest, runtime: $Util.RuntimeOptions): Promise<DsgUserGroupGetOdpsRoleGroupsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgUserGroupGetOdpsRoleGroups",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgUserGroupGetOdpsRoleGroupsResponse>(await this.callApi(params, req, runtime), new DsgUserGroupGetOdpsRoleGroupsResponse({}));
  }

  /**
   * Queries a list of MaxCompute roles that can be selected by the members of a user group when the user group is created or modified by the tenant in Data Security Guard.
   * 
   * @param request - DsgUserGroupGetOdpsRoleGroupsRequest
   * @returns DsgUserGroupGetOdpsRoleGroupsResponse
   */
  async dsgUserGroupGetOdpsRoleGroups(request: DsgUserGroupGetOdpsRoleGroupsRequest): Promise<DsgUserGroupGetOdpsRoleGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgUserGroupGetOdpsRoleGroupsWithOptions(request, runtime);
  }

  /**
   * Queries a list of user groups in Data Security Guard.
   * 
   * @param request - DsgUserGroupQueryListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgUserGroupQueryListResponse
   */
  async dsgUserGroupQueryListWithOptions(request: DsgUserGroupQueryListRequest, runtime: $Util.RuntimeOptions): Promise<DsgUserGroupQueryListResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgUserGroupQueryList",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgUserGroupQueryListResponse>(await this.callApi(params, req, runtime), new DsgUserGroupQueryListResponse({}));
  }

  /**
   * Queries a list of user groups in Data Security Guard.
   * 
   * @param request - DsgUserGroupQueryListRequest
   * @returns DsgUserGroupQueryListResponse
   */
  async dsgUserGroupQueryList(request: DsgUserGroupQueryListRequest): Promise<DsgUserGroupQueryListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgUserGroupQueryListWithOptions(request, runtime);
  }

  /**
   * Queries a list of users or roles of the current tenant.
   * 
   * @param request - DsgUserGroupQueryUserListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgUserGroupQueryUserListResponse
   */
  async dsgUserGroupQueryUserListWithOptions(runtime: $Util.RuntimeOptions): Promise<DsgUserGroupQueryUserListResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DsgUserGroupQueryUserList",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgUserGroupQueryUserListResponse>(await this.callApi(params, req, runtime), new DsgUserGroupQueryUserListResponse({}));
  }

  /**
   * Queries a list of users or roles of the current tenant.
   * @returns DsgUserGroupQueryUserListResponse
   */
  async dsgUserGroupQueryUserList(): Promise<DsgUserGroupQueryUserListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgUserGroupQueryUserListWithOptions(runtime);
  }

  /**
   * Adds or modifies a data masking whitelist.
   * 
   * @param tmpReq - DsgWhiteListAddOrUpdateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgWhiteListAddOrUpdateResponse
   */
  async dsgWhiteListAddOrUpdateWithOptions(tmpReq: DsgWhiteListAddOrUpdateRequest, runtime: $Util.RuntimeOptions): Promise<DsgWhiteListAddOrUpdateResponse> {
    Util.validateModel(tmpReq);
    let request = new DsgWhiteListAddOrUpdateShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.whiteLists)) {
      request.whiteListsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.whiteLists, "WhiteLists", "json");
    }

    let query = { };
    if (!Util.isUnset(request.whiteListsShrink)) {
      query["WhiteLists"] = request.whiteListsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgWhiteListAddOrUpdate",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgWhiteListAddOrUpdateResponse>(await this.callApi(params, req, runtime), new DsgWhiteListAddOrUpdateResponse({}));
  }

  /**
   * Adds or modifies a data masking whitelist.
   * 
   * @param request - DsgWhiteListAddOrUpdateRequest
   * @returns DsgWhiteListAddOrUpdateResponse
   */
  async dsgWhiteListAddOrUpdate(request: DsgWhiteListAddOrUpdateRequest): Promise<DsgWhiteListAddOrUpdateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgWhiteListAddOrUpdateWithOptions(request, runtime);
  }

  /**
   * Deletes a data masking whitelist configured in Data Security Guard.
   * 
   * @param tmpReq - DsgWhiteListDeleteListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgWhiteListDeleteListResponse
   */
  async dsgWhiteListDeleteListWithOptions(tmpReq: DsgWhiteListDeleteListRequest, runtime: $Util.RuntimeOptions): Promise<DsgWhiteListDeleteListResponse> {
    Util.validateModel(tmpReq);
    let request = new DsgWhiteListDeleteListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.ids)) {
      request.idsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ids, "Ids", "json");
    }

    let query = { };
    if (!Util.isUnset(request.idsShrink)) {
      query["Ids"] = request.idsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgWhiteListDeleteList",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgWhiteListDeleteListResponse>(await this.callApi(params, req, runtime), new DsgWhiteListDeleteListResponse({}));
  }

  /**
   * Deletes a data masking whitelist configured in Data Security Guard.
   * 
   * @param request - DsgWhiteListDeleteListRequest
   * @returns DsgWhiteListDeleteListResponse
   */
  async dsgWhiteListDeleteList(request: DsgWhiteListDeleteListRequest): Promise<DsgWhiteListDeleteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgWhiteListDeleteListWithOptions(request, runtime);
  }

  /**
   * Queries a data masking whitelist.
   * 
   * @param request - DsgWhiteListQueryListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns DsgWhiteListQueryListResponse
   */
  async dsgWhiteListQueryListWithOptions(request: DsgWhiteListQueryListRequest, runtime: $Util.RuntimeOptions): Promise<DsgWhiteListQueryListResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DsgWhiteListQueryList",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DsgWhiteListQueryListResponse>(await this.callApi(params, req, runtime), new DsgWhiteListQueryListResponse({}));
  }

  /**
   * Queries a data masking whitelist.
   * 
   * @param request - DsgWhiteListQueryListRequest
   * @returns DsgWhiteListQueryListResponse
   */
  async dsgWhiteListQueryList(request: DsgWhiteListQueryListRequest): Promise<DsgWhiteListQueryListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.dsgWhiteListQueryListWithOptions(request, runtime);
  }

  /**
   * Edits a sensitive field that is defined based on the category and sensitivity level of data in Data Security Guard.
   * 
   * @param request - EditRecognizeRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EditRecognizeRuleResponse
   */
  async editRecognizeRuleWithOptions(request: EditRecognizeRuleRequest, runtime: $Util.RuntimeOptions): Promise<EditRecognizeRuleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accountName)) {
      body["AccountName"] = request.accountName;
    }

    if (!Util.isUnset(request.colExclude)) {
      body["ColExclude"] = request.colExclude;
    }

    if (!Util.isUnset(request.colScan)) {
      body["ColScan"] = request.colScan;
    }

    if (!Util.isUnset(request.commentScan)) {
      body["CommentScan"] = request.commentScan;
    }

    if (!Util.isUnset(request.contentScan)) {
      body["ContentScan"] = request.contentScan;
    }

    if (!Util.isUnset(request.hitThreshold)) {
      body["HitThreshold"] = request.hitThreshold;
    }

    if (!Util.isUnset(request.levelName)) {
      body["LevelName"] = request.levelName;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeParent)) {
      body["NodeParent"] = request.nodeParent;
    }

    if (!Util.isUnset(request.operationType)) {
      body["OperationType"] = request.operationType;
    }

    if (!Util.isUnset(request.recognizeRules)) {
      body["RecognizeRules"] = request.recognizeRules;
    }

    if (!Util.isUnset(request.recognizeRulesType)) {
      body["RecognizeRulesType"] = request.recognizeRulesType;
    }

    if (!Util.isUnset(request.sensitiveDescription)) {
      body["SensitiveDescription"] = request.sensitiveDescription;
    }

    if (!Util.isUnset(request.sensitiveId)) {
      body["SensitiveId"] = request.sensitiveId;
    }

    if (!Util.isUnset(request.sensitiveName)) {
      body["SensitiveName"] = request.sensitiveName;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    if (!Util.isUnset(request.templateId)) {
      body["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.level)) {
      body["level"] = request.level;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "EditRecognizeRule",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EditRecognizeRuleResponse>(await this.callApi(params, req, runtime), new EditRecognizeRuleResponse({}));
  }

  /**
   * Edits a sensitive field that is defined based on the category and sensitivity level of data in Data Security Guard.
   * 
   * @param request - EditRecognizeRuleRequest
   * @returns EditRecognizeRuleResponse
   */
  async editRecognizeRule(request: EditRecognizeRuleRequest): Promise<EditRecognizeRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.editRecognizeRuleWithOptions(request, runtime);
  }

  /**
   * @param request - EstablishRelationTableToBusinessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns EstablishRelationTableToBusinessResponse
   */
  async establishRelationTableToBusinessWithOptions(request: EstablishRelationTableToBusinessRequest, runtime: $Util.RuntimeOptions): Promise<EstablishRelationTableToBusinessResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.businessId)) {
      body["BusinessId"] = request.businessId;
    }

    if (!Util.isUnset(request.folderId)) {
      body["FolderId"] = request.folderId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    if (!Util.isUnset(request.tableGuid)) {
      body["TableGuid"] = request.tableGuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "EstablishRelationTableToBusiness",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EstablishRelationTableToBusinessResponse>(await this.callApi(params, req, runtime), new EstablishRelationTableToBusinessResponse({}));
  }

  /**
   * @param request - EstablishRelationTableToBusinessRequest
   * @returns EstablishRelationTableToBusinessResponse
   */
  async establishRelationTableToBusiness(request: EstablishRelationTableToBusinessRequest): Promise<EstablishRelationTableToBusinessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.establishRelationTableToBusinessWithOptions(request, runtime);
  }

  /**
   * Exports a list of data sources.
   * 
   * @param request - ExportDataSourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ExportDataSourcesResponse
   */
  async exportDataSourcesWithOptions(request: ExportDataSourcesRequest, runtime: $Util.RuntimeOptions): Promise<ExportDataSourcesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExportDataSources",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExportDataSourcesResponse>(await this.callApi(params, req, runtime), new ExportDataSourcesResponse({}));
  }

  /**
   * Exports a list of data sources.
   * 
   * @param request - ExportDataSourcesRequest
   * @returns ExportDataSourcesResponse
   */
  async exportDataSources(request: ExportDataSourcesRequest): Promise<ExportDataSourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.exportDataSourcesWithOptions(request, runtime);
  }

  /**
   * Generates an ID for an asynchronous thread that is used to create a synchronization task in Data Integration.
   * 
   * @remarks
   * DataWorks allows you to use the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to directly create a batch synchronization task in Data Integration. To create a real-time synchronization task or another type of synchronization task, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can use the parameters as request parameters of [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) and call the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a real-time synchronization task or another type of synchronization task. DataWorks allows you to create real-time synchronization tasks and other types of synchronization tasks in Data Integration only in asynchronous mode.
   * 
   * @param request - GenerateDISyncTaskConfigForCreatingRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GenerateDISyncTaskConfigForCreatingResponse
   */
  async generateDISyncTaskConfigForCreatingWithOptions(request: GenerateDISyncTaskConfigForCreatingRequest, runtime: $Util.RuntimeOptions): Promise<GenerateDISyncTaskConfigForCreatingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.taskParam)) {
      query["TaskParam"] = request.taskParam;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GenerateDISyncTaskConfigForCreating",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GenerateDISyncTaskConfigForCreatingResponse>(await this.callApi(params, req, runtime), new GenerateDISyncTaskConfigForCreatingResponse({}));
  }

  /**
   * Generates an ID for an asynchronous thread that is used to create a synchronization task in Data Integration.
   * 
   * @remarks
   * DataWorks allows you to use the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to directly create a batch synchronization task in Data Integration. To create a real-time synchronization task or another type of synchronization task, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can use the parameters as request parameters of [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) and call the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a real-time synchronization task or another type of synchronization task. DataWorks allows you to create real-time synchronization tasks and other types of synchronization tasks in Data Integration only in asynchronous mode.
   * 
   * @param request - GenerateDISyncTaskConfigForCreatingRequest
   * @returns GenerateDISyncTaskConfigForCreatingResponse
   */
  async generateDISyncTaskConfigForCreating(request: GenerateDISyncTaskConfigForCreatingRequest): Promise<GenerateDISyncTaskConfigForCreatingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.generateDISyncTaskConfigForCreatingWithOptions(request, runtime);
  }

  /**
   * Generates the JSON for an asynchronous thread that is used to update a real-time synchronization task in Data Integration.
   * 
   * @remarks
   * DataWorks allows you to use only the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization task in Data Integration. To update a real-time synchronization task, you must first call the GenerateDISyncTaskConfigForUpdating operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the UpdateDISyncTask operation and use the parameters as request parameters to update a real-time synchronization task in Data Integration. DataWorks allows you to create or update real-time synchronization tasks in Data Integration only in asynchronous mode.
   * 
   * @param request - GenerateDISyncTaskConfigForUpdatingRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GenerateDISyncTaskConfigForUpdatingResponse
   */
  async generateDISyncTaskConfigForUpdatingWithOptions(request: GenerateDISyncTaskConfigForUpdatingRequest, runtime: $Util.RuntimeOptions): Promise<GenerateDISyncTaskConfigForUpdatingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clientToken)) {
      query["ClientToken"] = request.clientToken;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    if (!Util.isUnset(request.taskParam)) {
      query["TaskParam"] = request.taskParam;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GenerateDISyncTaskConfigForUpdating",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GenerateDISyncTaskConfigForUpdatingResponse>(await this.callApi(params, req, runtime), new GenerateDISyncTaskConfigForUpdatingResponse({}));
  }

  /**
   * Generates the JSON for an asynchronous thread that is used to update a real-time synchronization task in Data Integration.
   * 
   * @remarks
   * DataWorks allows you to use only the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization task in Data Integration. To update a real-time synchronization task, you must first call the GenerateDISyncTaskConfigForUpdating operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the UpdateDISyncTask operation and use the parameters as request parameters to update a real-time synchronization task in Data Integration. DataWorks allows you to create or update real-time synchronization tasks in Data Integration only in asynchronous mode.
   * 
   * @param request - GenerateDISyncTaskConfigForUpdatingRequest
   * @returns GenerateDISyncTaskConfigForUpdatingResponse
   */
  async generateDISyncTaskConfigForUpdating(request: GenerateDISyncTaskConfigForUpdatingRequest): Promise<GenerateDISyncTaskConfigForUpdatingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.generateDISyncTaskConfigForUpdatingWithOptions(request, runtime);
  }

  /**
   * Queries alert information based on the alert ID that is specified by the AlertId parameter.
   * 
   * @param request - GetAlertMessageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetAlertMessageResponse
   */
  async getAlertMessageWithOptions(request: GetAlertMessageRequest, runtime: $Util.RuntimeOptions): Promise<GetAlertMessageResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alertId)) {
      body["AlertId"] = request.alertId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetAlertMessage",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAlertMessageResponse>(await this.callApi(params, req, runtime), new GetAlertMessageResponse({}));
  }

  /**
   * Queries alert information based on the alert ID that is specified by the AlertId parameter.
   * 
   * @param request - GetAlertMessageRequest
   * @returns GetAlertMessageResponse
   */
  async getAlertMessage(request: GetAlertMessageRequest): Promise<GetAlertMessageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAlertMessageWithOptions(request, runtime);
  }

  /**
   * Queries the information about a baseline based on its ID.
   * 
   * @param request - GetBaselineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetBaselineResponse
   */
  async getBaselineWithOptions(request: GetBaselineRequest, runtime: $Util.RuntimeOptions): Promise<GetBaselineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.baselineId)) {
      body["BaselineId"] = request.baselineId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetBaseline",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetBaselineResponse>(await this.callApi(params, req, runtime), new GetBaselineResponse({}));
  }

  /**
   * Queries the information about a baseline based on its ID.
   * 
   * @param request - GetBaselineRequest
   * @returns GetBaselineResponse
   */
  async getBaseline(request: GetBaselineRequest): Promise<GetBaselineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getBaselineWithOptions(request, runtime);
  }

  /**
   * Queries the configurations of a baseline.
   * 
   * @param request - GetBaselineConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetBaselineConfigResponse
   */
  async getBaselineConfigWithOptions(request: GetBaselineConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetBaselineConfigResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.baselineId)) {
      body["BaselineId"] = request.baselineId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetBaselineConfig",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetBaselineConfigResponse>(await this.callApi(params, req, runtime), new GetBaselineConfigResponse({}));
  }

  /**
   * Queries the configurations of a baseline.
   * 
   * @param request - GetBaselineConfigRequest
   * @returns GetBaselineConfigResponse
   */
  async getBaselineConfig(request: GetBaselineConfigRequest): Promise<GetBaselineConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getBaselineConfigWithOptions(request, runtime);
  }

  /**
   * The information about the events that are associated with the instance.
   * 
   * @param request - GetBaselineKeyPathRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetBaselineKeyPathResponse
   */
  async getBaselineKeyPathWithOptions(request: GetBaselineKeyPathRequest, runtime: $Util.RuntimeOptions): Promise<GetBaselineKeyPathResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.baselineId)) {
      body["BaselineId"] = request.baselineId;
    }

    if (!Util.isUnset(request.bizdate)) {
      body["Bizdate"] = request.bizdate;
    }

    if (!Util.isUnset(request.inGroupId)) {
      body["InGroupId"] = request.inGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetBaselineKeyPath",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetBaselineKeyPathResponse>(await this.callApi(params, req, runtime), new GetBaselineKeyPathResponse({}));
  }

  /**
   * The information about the events that are associated with the instance.
   * 
   * @param request - GetBaselineKeyPathRequest
   * @returns GetBaselineKeyPathResponse
   */
  async getBaselineKeyPath(request: GetBaselineKeyPathRequest): Promise<GetBaselineKeyPathResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getBaselineKeyPathWithOptions(request, runtime);
  }

  /**
   * Queries the details of a baseline instance.
   * 
   * @param request - GetBaselineStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetBaselineStatusResponse
   */
  async getBaselineStatusWithOptions(request: GetBaselineStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetBaselineStatusResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.baselineId)) {
      body["BaselineId"] = request.baselineId;
    }

    if (!Util.isUnset(request.bizdate)) {
      body["Bizdate"] = request.bizdate;
    }

    if (!Util.isUnset(request.inGroupId)) {
      body["InGroupId"] = request.inGroupId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetBaselineStatus",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetBaselineStatusResponse>(await this.callApi(params, req, runtime), new GetBaselineStatusResponse({}));
  }

  /**
   * Queries the details of a baseline instance.
   * 
   * @param request - GetBaselineStatusRequest
   * @returns GetBaselineStatusResponse
   */
  async getBaselineStatus(request: GetBaselineStatusRequest): Promise<GetBaselineStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getBaselineStatusWithOptions(request, runtime);
  }

  /**
   * @param request - GetBusinessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetBusinessResponse
   */
  async getBusinessWithOptions(request: GetBusinessRequest, runtime: $Util.RuntimeOptions): Promise<GetBusinessResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.businessId)) {
      body["BusinessId"] = request.businessId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetBusiness",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetBusinessResponse>(await this.callApi(params, req, runtime), new GetBusinessResponse({}));
  }

  /**
   * @param request - GetBusinessRequest
   * @returns GetBusinessResponse
   */
  async getBusiness(request: GetBusinessRequest): Promise<GetBusinessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getBusinessWithOptions(request, runtime);
  }

  /**
   * Queries the status of a table creation, update, or deletion task.
   * 
   * @param request - GetDDLJobStatusRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDDLJobStatusResponse
   */
  async getDDLJobStatusWithOptions(request: GetDDLJobStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetDDLJobStatusResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDDLJobStatus",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDDLJobStatusResponse>(await this.callApi(params, req, runtime), new GetDDLJobStatusResponse({}));
  }

  /**
   * Queries the status of a table creation, update, or deletion task.
   * 
   * @param request - GetDDLJobStatusRequest
   * @returns GetDDLJobStatusResponse
   */
  async getDDLJobStatus(request: GetDDLJobStatusRequest): Promise<GetDDLJobStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDDLJobStatusWithOptions(request, runtime);
  }

  /**
   * Queries the details of an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @remarks
   * You can configure alert rules only for tasks that can be used for real-time data synchronization.
   * 
   * @param request - GetDIAlarmRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDIAlarmRuleResponse
   */
  async getDIAlarmRuleWithOptions(request: GetDIAlarmRuleRequest, runtime: $Util.RuntimeOptions): Promise<GetDIAlarmRuleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.DIAlarmRuleId)) {
      body["DIAlarmRuleId"] = request.DIAlarmRuleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDIAlarmRule",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDIAlarmRuleResponse>(await this.callApi(params, req, runtime), new GetDIAlarmRuleResponse({}));
  }

  /**
   * Queries the details of an alert rule for a Data Integration task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @remarks
   * You can configure alert rules only for tasks that can be used for real-time data synchronization.
   * 
   * @param request - GetDIAlarmRuleRequest
   * @returns GetDIAlarmRuleResponse
   */
  async getDIAlarmRule(request: GetDIAlarmRuleRequest): Promise<GetDIAlarmRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDIAlarmRuleWithOptions(request, runtime);
  }

  /**
   * Queries the information about a new-version synchronization task created in Data Integration. The following types of synchronization tasks are supported: real-time synchronization of all data in a MySQL database to Hologres.
   * 
   * @param request - GetDIJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDIJobResponse
   */
  async getDIJobWithOptions(request: GetDIJobRequest, runtime: $Util.RuntimeOptions): Promise<GetDIJobResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.DIJobId)) {
      body["DIJobId"] = request.DIJobId;
    }

    if (!Util.isUnset(request.withDetails)) {
      body["WithDetails"] = request.withDetails;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDIJob",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDIJobResponse>(await this.callApi(params, req, runtime), new GetDIJobResponse({}));
  }

  /**
   * Queries the information about a new-version synchronization task created in Data Integration. The following types of synchronization tasks are supported: real-time synchronization of all data in a MySQL database to Hologres.
   * 
   * @param request - GetDIJobRequest
   * @returns GetDIJobResponse
   */
  async getDIJob(request: GetDIJobRequest): Promise<GetDIJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDIJobWithOptions(request, runtime);
  }

  /**
   * Queries the status of a real-time synchronization task or a data synchronization solution.
   * 
   * @param request - GetDISyncInstanceInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDISyncInstanceInfoResponse
   */
  async getDISyncInstanceInfoWithOptions(request: GetDISyncInstanceInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetDISyncInstanceInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileId)) {
      query["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDISyncInstanceInfo",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDISyncInstanceInfoResponse>(await this.callApi(params, req, runtime), new GetDISyncInstanceInfoResponse({}));
  }

  /**
   * Queries the status of a real-time synchronization task or a data synchronization solution.
   * 
   * @param request - GetDISyncInstanceInfoRequest
   * @returns GetDISyncInstanceInfoResponse
   */
  async getDISyncInstanceInfo(request: GetDISyncInstanceInfoRequest): Promise<GetDISyncInstanceInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDISyncInstanceInfoWithOptions(request, runtime);
  }

  /**
   * Queries the details of a real-time synchronization task or a data synchronization solution.
   * 
   * @param request - GetDISyncTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDISyncTaskResponse
   */
  async getDISyncTaskWithOptions(request: GetDISyncTaskRequest, runtime: $Util.RuntimeOptions): Promise<GetDISyncTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileId)) {
      query["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDISyncTask",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDISyncTaskResponse>(await this.callApi(params, req, runtime), new GetDISyncTaskResponse({}));
  }

  /**
   * Queries the details of a real-time synchronization task or a data synchronization solution.
   * 
   * @param request - GetDISyncTaskRequest
   * @returns GetDISyncTaskResponse
   */
  async getDISyncTask(request: GetDISyncTaskRequest): Promise<GetDISyncTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDISyncTaskWithOptions(request, runtime);
  }

  /**
   * Queries the information about a directed acyclic graph (DAG). You can call the GetDag operation to query the information about the DAG for a manually triggered workflow, a manually triggered node, or a data backfill instance. However, you cannot query the information about the DAG for an auto triggered node or an auto triggered workflow.
   * 
   * @remarks
   * Supported DAG types:
   * *   MANUAL: DAG for a manually triggered workflow
   * *   SMOKE_TEST: DAG for a smoke testing workflow
   * *   SUPPLY_DATA: DAG for a data backfill instance
   * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
   * Supported DAG states:
   * *   CREATED
   * *   RUNNING
   * *   FAILURE
   * *   SUCCESS
   * 
   * @param request - GetDagRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDagResponse
   */
  async getDagWithOptions(request: GetDagRequest, runtime: $Util.RuntimeOptions): Promise<GetDagResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dagId)) {
      body["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDag",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDagResponse>(await this.callApi(params, req, runtime), new GetDagResponse({}));
  }

  /**
   * Queries the information about a directed acyclic graph (DAG). You can call the GetDag operation to query the information about the DAG for a manually triggered workflow, a manually triggered node, or a data backfill instance. However, you cannot query the information about the DAG for an auto triggered node or an auto triggered workflow.
   * 
   * @remarks
   * Supported DAG types:
   * *   MANUAL: DAG for a manually triggered workflow
   * *   SMOKE_TEST: DAG for a smoke testing workflow
   * *   SUPPLY_DATA: DAG for a data backfill instance
   * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
   * Supported DAG states:
   * *   CREATED
   * *   RUNNING
   * *   FAILURE
   * *   SUCCESS
   * 
   * @param request - GetDagRequest
   * @returns GetDagResponse
   */
  async getDag(request: GetDagRequest): Promise<GetDagResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDagWithOptions(request, runtime);
  }

  /**
   * Queries the details of a DataService Studio API in the development state.
   * 
   * @param request - GetDataServiceApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataServiceApiResponse
   */
  async getDataServiceApiWithOptions(request: GetDataServiceApiRequest, runtime: $Util.RuntimeOptions): Promise<GetDataServiceApiResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiId)) {
      body["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDataServiceApi",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataServiceApiResponse>(await this.callApi(params, req, runtime), new GetDataServiceApiResponse({}));
  }

  /**
   * Queries the details of a DataService Studio API in the development state.
   * 
   * @param request - GetDataServiceApiRequest
   * @returns GetDataServiceApiResponse
   */
  async getDataServiceApi(request: GetDataServiceApiRequest): Promise<GetDataServiceApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataServiceApiWithOptions(request, runtime);
  }

  /**
   * Queries the test results of an API in DataService Studio.
   * 
   * @param request - GetDataServiceApiTestRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataServiceApiTestResponse
   */
  async getDataServiceApiTestWithOptions(request: GetDataServiceApiTestRequest, runtime: $Util.RuntimeOptions): Promise<GetDataServiceApiTestResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataServiceApiTest",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataServiceApiTestResponse>(await this.callApi(params, req, runtime), new GetDataServiceApiTestResponse({}));
  }

  /**
   * Queries the test results of an API in DataService Studio.
   * 
   * @param request - GetDataServiceApiTestRequest
   * @returns GetDataServiceApiTestResponse
   */
  async getDataServiceApiTest(request: GetDataServiceApiTestRequest): Promise<GetDataServiceApiTestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataServiceApiTestWithOptions(request, runtime);
  }

  /**
   * Queries the details of an application.
   * 
   * @param request - GetDataServiceApplicationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataServiceApplicationResponse
   */
  async getDataServiceApplicationWithOptions(request: GetDataServiceApplicationRequest, runtime: $Util.RuntimeOptions): Promise<GetDataServiceApplicationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.applicationId)) {
      body["ApplicationId"] = request.applicationId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDataServiceApplication",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataServiceApplicationResponse>(await this.callApi(params, req, runtime), new GetDataServiceApplicationResponse({}));
  }

  /**
   * Queries the details of an application.
   * 
   * @param request - GetDataServiceApplicationRequest
   * @returns GetDataServiceApplicationResponse
   */
  async getDataServiceApplication(request: GetDataServiceApplicationRequest): Promise<GetDataServiceApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataServiceApplicationWithOptions(request, runtime);
  }

  /**
   * Queries a folder.
   * 
   * @param request - GetDataServiceFolderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataServiceFolderResponse
   */
  async getDataServiceFolderWithOptions(request: GetDataServiceFolderRequest, runtime: $Util.RuntimeOptions): Promise<GetDataServiceFolderResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.folderId)) {
      body["FolderId"] = request.folderId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDataServiceFolder",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataServiceFolderResponse>(await this.callApi(params, req, runtime), new GetDataServiceFolderResponse({}));
  }

  /**
   * Queries a folder.
   * 
   * @param request - GetDataServiceFolderRequest
   * @returns GetDataServiceFolderResponse
   */
  async getDataServiceFolder(request: GetDataServiceFolderRequest): Promise<GetDataServiceFolderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataServiceFolderWithOptions(request, runtime);
  }

  /**
   * Queries a business process.
   * 
   * @param request - GetDataServiceGroupRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataServiceGroupResponse
   */
  async getDataServiceGroupWithOptions(request: GetDataServiceGroupRequest, runtime: $Util.RuntimeOptions): Promise<GetDataServiceGroupResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDataServiceGroup",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataServiceGroupResponse>(await this.callApi(params, req, runtime), new GetDataServiceGroupResponse({}));
  }

  /**
   * Queries a business process.
   * 
   * @param request - GetDataServiceGroupRequest
   * @returns GetDataServiceGroupResponse
   */
  async getDataServiceGroup(request: GetDataServiceGroupRequest): Promise<GetDataServiceGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataServiceGroupWithOptions(request, runtime);
  }

  /**
   * Queries the information about a DataService Studio API in the published state.
   * 
   * @param request - GetDataServicePublishedApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataServicePublishedApiResponse
   */
  async getDataServicePublishedApiWithOptions(request: GetDataServicePublishedApiRequest, runtime: $Util.RuntimeOptions): Promise<GetDataServicePublishedApiResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiId)) {
      body["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDataServicePublishedApi",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataServicePublishedApiResponse>(await this.callApi(params, req, runtime), new GetDataServicePublishedApiResponse({}));
  }

  /**
   * Queries the information about a DataService Studio API in the published state.
   * 
   * @param request - GetDataServicePublishedApiRequest
   * @returns GetDataServicePublishedApiResponse
   */
  async getDataServicePublishedApi(request: GetDataServicePublishedApiRequest): Promise<GetDataServicePublishedApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataServicePublishedApiWithOptions(request, runtime);
  }

  /**
   * Queries the metadata of a specified data source.
   * 
   * @param request - GetDataSourceMetaRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDataSourceMetaResponse
   */
  async getDataSourceMetaWithOptions(request: GetDataSourceMetaRequest, runtime: $Util.RuntimeOptions): Promise<GetDataSourceMetaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasourceName)) {
      query["DatasourceName"] = request.datasourceName;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetDataSourceMeta",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDataSourceMetaResponse>(await this.callApi(params, req, runtime), new GetDataSourceMetaResponse({}));
  }

  /**
   * Queries the metadata of a specified data source.
   * 
   * @param request - GetDataSourceMetaRequest
   * @returns GetDataSourceMetaResponse
   */
  async getDataSourceMeta(request: GetDataSourceMetaRequest): Promise<GetDataSourceMetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDataSourceMetaWithOptions(request, runtime);
  }

  /**
   * Queries the information about a deployment package.
   * 
   * @param request - GetDeploymentRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetDeploymentResponse
   */
  async getDeploymentWithOptions(request: GetDeploymentRequest, runtime: $Util.RuntimeOptions): Promise<GetDeploymentResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deploymentId)) {
      body["DeploymentId"] = request.deploymentId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetDeployment",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetDeploymentResponse>(await this.callApi(params, req, runtime), new GetDeploymentResponse({}));
  }

  /**
   * Queries the information about a deployment package.
   * 
   * @param request - GetDeploymentRequest
   * @returns GetDeploymentResponse
   */
  async getDeployment(request: GetDeploymentRequest): Promise<GetDeploymentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getDeploymentWithOptions(request, runtime);
  }

  /**
   * Queries the details of an extension.
   * 
   * @param request - GetExtensionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetExtensionResponse
   */
  async getExtensionWithOptions(request: GetExtensionRequest, runtime: $Util.RuntimeOptions): Promise<GetExtensionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.extensionCode)) {
      query["ExtensionCode"] = request.extensionCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetExtension",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetExtensionResponse>(await this.callApi(params, req, runtime), new GetExtensionResponse({}));
  }

  /**
   * Queries the details of an extension.
   * 
   * @param request - GetExtensionRequest
   * @returns GetExtensionResponse
   */
  async getExtension(request: GetExtensionRequest): Promise<GetExtensionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getExtensionWithOptions(request, runtime);
  }

  /**
   * Queries the information about a file.
   * 
   * @param request - GetFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetFileResponse
   */
  async getFileWithOptions(request: GetFileRequest, runtime: $Util.RuntimeOptions): Promise<GetFileResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.fileId)) {
      body["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetFile",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFileResponse>(await this.callApi(params, req, runtime), new GetFileResponse({}));
  }

  /**
   * Queries the information about a file.
   * 
   * @param request - GetFileRequest
   * @returns GetFileResponse
   */
  async getFile(request: GetFileRequest): Promise<GetFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getFileWithOptions(request, runtime);
  }

  /**
   * Queries the distribution of node types.
   * 
   * @param request - GetFileTypeStatisticRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetFileTypeStatisticResponse
   */
  async getFileTypeStatisticWithOptions(request: GetFileTypeStatisticRequest, runtime: $Util.RuntimeOptions): Promise<GetFileTypeStatisticResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetFileTypeStatistic",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFileTypeStatisticResponse>(await this.callApi(params, req, runtime), new GetFileTypeStatisticResponse({}));
  }

  /**
   * Queries the distribution of node types.
   * 
   * @param request - GetFileTypeStatisticRequest
   * @returns GetFileTypeStatisticResponse
   */
  async getFileTypeStatistic(request: GetFileTypeStatisticRequest): Promise<GetFileTypeStatisticResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getFileTypeStatisticWithOptions(request, runtime);
  }

  /**
   * Queries the information about a file version.
   * 
   * @param request - GetFileVersionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetFileVersionResponse
   */
  async getFileVersionWithOptions(request: GetFileVersionRequest, runtime: $Util.RuntimeOptions): Promise<GetFileVersionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.fileId)) {
      body["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.fileVersion)) {
      body["FileVersion"] = request.fileVersion;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetFileVersion",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFileVersionResponse>(await this.callApi(params, req, runtime), new GetFileVersionResponse({}));
  }

  /**
   * Queries the information about a file version.
   * 
   * @param request - GetFileVersionRequest
   * @returns GetFileVersionResponse
   */
  async getFileVersion(request: GetFileVersionRequest): Promise<GetFileVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getFileVersionWithOptions(request, runtime);
  }

  /**
   * @param request - GetFolderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetFolderResponse
   */
  async getFolderWithOptions(request: GetFolderRequest, runtime: $Util.RuntimeOptions): Promise<GetFolderResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.folderId)) {
      body["FolderId"] = request.folderId;
    }

    if (!Util.isUnset(request.folderPath)) {
      body["FolderPath"] = request.folderPath;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetFolder",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFolderResponse>(await this.callApi(params, req, runtime), new GetFolderResponse({}));
  }

  /**
   * @param request - GetFolderRequest
   * @returns GetFolderResponse
   */
  async getFolder(request: GetFolderRequest): Promise<GetFolderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getFolderWithOptions(request, runtime);
  }

  /**
   * Queries the data snapshot of an extension point based on the ID of a message in DataWorks OpenEvent when the related extension point event is triggered.
   * 
   * @param request - GetIDEEventDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetIDEEventDetailResponse
   */
  async getIDEEventDetailWithOptions(request: GetIDEEventDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetIDEEventDetailResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.messageId)) {
      body["MessageId"] = request.messageId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetIDEEventDetail",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetIDEEventDetailResponse>(await this.callApi(params, req, runtime), new GetIDEEventDetailResponse({}));
  }

  /**
   * Queries the data snapshot of an extension point based on the ID of a message in DataWorks OpenEvent when the related extension point event is triggered.
   * 
   * @param request - GetIDEEventDetailRequest
   * @returns GetIDEEventDetailResponse
   */
  async getIDEEventDetail(request: GetIDEEventDetailRequest): Promise<GetIDEEventDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getIDEEventDetailWithOptions(request, runtime);
  }

  /**
   * Queries the information about an instance.
   * 
   * @param request - GetInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetInstanceResponse
   */
  async getInstanceWithOptions(request: GetInstanceRequest, runtime: $Util.RuntimeOptions): Promise<GetInstanceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetInstance",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInstanceResponse>(await this.callApi(params, req, runtime), new GetInstanceResponse({}));
  }

  /**
   * Queries the information about an instance.
   * 
   * @param request - GetInstanceRequest
   * @returns GetInstanceResponse
   */
  async getInstance(request: GetInstanceRequest): Promise<GetInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInstanceWithOptions(request, runtime);
  }

  /**
   * Queries the ranking of the running durations of instances.
   * 
   * @deprecated OpenAPI GetInstanceConsumeTimeRank is deprecated
   * 
   * @param request - GetInstanceConsumeTimeRankRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetInstanceConsumeTimeRankResponse
   */
  // Deprecated
  async getInstanceConsumeTimeRankWithOptions(request: GetInstanceConsumeTimeRankRequest, runtime: $Util.RuntimeOptions): Promise<GetInstanceConsumeTimeRankResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizdate)) {
      body["Bizdate"] = request.bizdate;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetInstanceConsumeTimeRank",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInstanceConsumeTimeRankResponse>(await this.callApi(params, req, runtime), new GetInstanceConsumeTimeRankResponse({}));
  }

  /**
   * Queries the ranking of the running durations of instances.
   * 
   * @deprecated OpenAPI GetInstanceConsumeTimeRank is deprecated
   * 
   * @param request - GetInstanceConsumeTimeRankRequest
   * @returns GetInstanceConsumeTimeRankResponse
   */
  // Deprecated
  async getInstanceConsumeTimeRank(request: GetInstanceConsumeTimeRankRequest): Promise<GetInstanceConsumeTimeRankResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInstanceConsumeTimeRankWithOptions(request, runtime);
  }

  /**
   * Queries the quantity trend of auto triggered instances.
   * 
   * @deprecated OpenAPI GetInstanceCountTrend is deprecated
   * 
   * @param request - GetInstanceCountTrendRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetInstanceCountTrendResponse
   */
  // Deprecated
  async getInstanceCountTrendWithOptions(request: GetInstanceCountTrendRequest, runtime: $Util.RuntimeOptions): Promise<GetInstanceCountTrendResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.beginDate)) {
      body["BeginDate"] = request.beginDate;
    }

    if (!Util.isUnset(request.endDate)) {
      body["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetInstanceCountTrend",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInstanceCountTrendResponse>(await this.callApi(params, req, runtime), new GetInstanceCountTrendResponse({}));
  }

  /**
   * Queries the quantity trend of auto triggered instances.
   * 
   * @deprecated OpenAPI GetInstanceCountTrend is deprecated
   * 
   * @param request - GetInstanceCountTrendRequest
   * @returns GetInstanceCountTrendResponse
   */
  // Deprecated
  async getInstanceCountTrend(request: GetInstanceCountTrendRequest): Promise<GetInstanceCountTrendResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInstanceCountTrendWithOptions(request, runtime);
  }

  /**
   * Queries the ranking of nodes on which errors occur within the last month.
   * 
   * @deprecated OpenAPI GetInstanceErrorRank is deprecated
   * 
   * @param request - GetInstanceErrorRankRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetInstanceErrorRankResponse
   */
  // Deprecated
  async getInstanceErrorRankWithOptions(request: GetInstanceErrorRankRequest, runtime: $Util.RuntimeOptions): Promise<GetInstanceErrorRankResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetInstanceErrorRank",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInstanceErrorRankResponse>(await this.callApi(params, req, runtime), new GetInstanceErrorRankResponse({}));
  }

  /**
   * Queries the ranking of nodes on which errors occur within the last month.
   * 
   * @deprecated OpenAPI GetInstanceErrorRank is deprecated
   * 
   * @param request - GetInstanceErrorRankRequest
   * @returns GetInstanceErrorRankResponse
   */
  // Deprecated
  async getInstanceErrorRank(request: GetInstanceErrorRankRequest): Promise<GetInstanceErrorRankResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInstanceErrorRankWithOptions(request, runtime);
  }

  /**
   * Queries the logs of an instance.
   * 
   * @remarks
   * You may not obtain the instance logs that were generated more than seven days ago.
   * 
   * @param request - GetInstanceLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetInstanceLogResponse
   */
  async getInstanceLogWithOptions(request: GetInstanceLogRequest, runtime: $Util.RuntimeOptions): Promise<GetInstanceLogResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceHistoryId)) {
      body["InstanceHistoryId"] = request.instanceHistoryId;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetInstanceLog",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInstanceLogResponse>(await this.callApi(params, req, runtime), new GetInstanceLogResponse({}));
  }

  /**
   * Queries the logs of an instance.
   * 
   * @remarks
   * You may not obtain the instance logs that were generated more than seven days ago.
   * 
   * @param request - GetInstanceLogRequest
   * @returns GetInstanceLogResponse
   */
  async getInstanceLog(request: GetInstanceLogRequest): Promise<GetInstanceLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInstanceLogWithOptions(request, runtime);
  }

  /**
   * Queries the statistics of instances in different states.
   * 
   * @deprecated OpenAPI GetInstanceStatusCount is deprecated
   * 
   * @param request - GetInstanceStatusCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetInstanceStatusCountResponse
   */
  // Deprecated
  async getInstanceStatusCountWithOptions(request: GetInstanceStatusCountRequest, runtime: $Util.RuntimeOptions): Promise<GetInstanceStatusCountResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizDate)) {
      body["BizDate"] = request.bizDate;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetInstanceStatusCount",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInstanceStatusCountResponse>(await this.callApi(params, req, runtime), new GetInstanceStatusCountResponse({}));
  }

  /**
   * Queries the statistics of instances in different states.
   * 
   * @deprecated OpenAPI GetInstanceStatusCount is deprecated
   * 
   * @param request - GetInstanceStatusCountRequest
   * @returns GetInstanceStatusCountResponse
   */
  // Deprecated
  async getInstanceStatusCount(request: GetInstanceStatusCountRequest): Promise<GetInstanceStatusCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInstanceStatusCountWithOptions(request, runtime);
  }

  /**
   * Queries the number of instances that are in each state.
   * 
   * @param request - GetInstanceStatusStatisticRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetInstanceStatusStatisticResponse
   */
  async getInstanceStatusStatisticWithOptions(request: GetInstanceStatusStatisticRequest, runtime: $Util.RuntimeOptions): Promise<GetInstanceStatusStatisticResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizDate)) {
      body["BizDate"] = request.bizDate;
    }

    if (!Util.isUnset(request.dagType)) {
      body["DagType"] = request.dagType;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.schedulerPeriod)) {
      body["SchedulerPeriod"] = request.schedulerPeriod;
    }

    if (!Util.isUnset(request.schedulerType)) {
      body["SchedulerType"] = request.schedulerType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetInstanceStatusStatistic",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInstanceStatusStatisticResponse>(await this.callApi(params, req, runtime), new GetInstanceStatusStatisticResponse({}));
  }

  /**
   * Queries the number of instances that are in each state.
   * 
   * @param request - GetInstanceStatusStatisticRequest
   * @returns GetInstanceStatusStatisticResponse
   */
  async getInstanceStatusStatistic(request: GetInstanceStatusStatisticRequest): Promise<GetInstanceStatusStatisticResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInstanceStatusStatisticWithOptions(request, runtime);
  }

  /**
   * Queries the information about instances in a manually triggered workflow.
   * 
   * @deprecated OpenAPI GetManualDagInstances is deprecated
   * 
   * @param request - GetManualDagInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetManualDagInstancesResponse
   */
  // Deprecated
  async getManualDagInstancesWithOptions(request: GetManualDagInstancesRequest, runtime: $Util.RuntimeOptions): Promise<GetManualDagInstancesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dagId)) {
      body["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetManualDagInstances",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetManualDagInstancesResponse>(await this.callApi(params, req, runtime), new GetManualDagInstancesResponse({}));
  }

  /**
   * Queries the information about instances in a manually triggered workflow.
   * 
   * @deprecated OpenAPI GetManualDagInstances is deprecated
   * 
   * @param request - GetManualDagInstancesRequest
   * @returns GetManualDagInstancesResponse
   */
  // Deprecated
  async getManualDagInstances(request: GetManualDagInstancesRequest): Promise<GetManualDagInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getManualDagInstancesWithOptions(request, runtime);
  }

  /**
   * Queries the information about a category tree.
   * 
   * @param request - GetMetaCategoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaCategoryResponse
   */
  async getMetaCategoryWithOptions(request: GetMetaCategoryRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaCategoryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.parentCategoryId)) {
      query["ParentCategoryId"] = request.parentCategoryId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaCategory",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaCategoryResponse>(await this.callApi(params, req, runtime), new GetMetaCategoryResponse({}));
  }

  /**
   * Queries the information about a category tree.
   * 
   * @param request - GetMetaCategoryRequest
   * @returns GetMetaCategoryResponse
   */
  async getMetaCategory(request: GetMetaCategoryRequest): Promise<GetMetaCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaCategoryWithOptions(request, runtime);
  }

  /**
   * Queries the information about a collection.
   * 
   * @param request - GetMetaCollectionDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaCollectionDetailResponse
   */
  async getMetaCollectionDetailWithOptions(request: GetMetaCollectionDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaCollectionDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.qualifiedName)) {
      query["QualifiedName"] = request.qualifiedName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaCollectionDetail",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaCollectionDetailResponse>(await this.callApi(params, req, runtime), new GetMetaCollectionDetailResponse({}));
  }

  /**
   * Queries the information about a collection.
   * 
   * @param request - GetMetaCollectionDetailRequest
   * @returns GetMetaCollectionDetailResponse
   */
  async getMetaCollectionDetail(request: GetMetaCollectionDetailRequest): Promise<GetMetaCollectionDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaCollectionDetailWithOptions(request, runtime);
  }

  /**
   * Queries the lineage of a field in a metatable.
   * 
   * @param request - GetMetaColumnLineageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaColumnLineageResponse
   */
  async getMetaColumnLineageWithOptions(request: GetMetaColumnLineageRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaColumnLineageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.columnGuid)) {
      query["ColumnGuid"] = request.columnGuid;
    }

    if (!Util.isUnset(request.columnName)) {
      query["ColumnName"] = request.columnName;
    }

    if (!Util.isUnset(request.dataSourceType)) {
      query["DataSourceType"] = request.dataSourceType;
    }

    if (!Util.isUnset(request.databaseName)) {
      query["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.direction)) {
      query["Direction"] = request.direction;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaColumnLineage",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaColumnLineageResponse>(await this.callApi(params, req, runtime), new GetMetaColumnLineageResponse({}));
  }

  /**
   * Queries the lineage of a field in a metatable.
   * 
   * @param request - GetMetaColumnLineageRequest
   * @returns GetMetaColumnLineageResponse
   */
  async getMetaColumnLineage(request: GetMetaColumnLineageRequest): Promise<GetMetaColumnLineageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaColumnLineageWithOptions(request, runtime);
  }

  /**
   * Queries the basic metadata information about a compute engine instance.
   * 
   * @remarks
   * The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
   * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID of the EMR cluster.
   * 
   * @param request - GetMetaDBInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaDBInfoResponse
   */
  async getMetaDBInfoWithOptions(request: GetMetaDBInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaDBInfoResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaDBInfo",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaDBInfoResponse>(await this.callApi(params, req, runtime), new GetMetaDBInfoResponse({}));
  }

  /**
   * Queries the basic metadata information about a compute engine instance.
   * 
   * @remarks
   * The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
   * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID of the EMR cluster.
   * 
   * @param request - GetMetaDBInfoRequest
   * @returns GetMetaDBInfoResponse
   */
  async getMetaDBInfo(request: GetMetaDBInfoRequest): Promise<GetMetaDBInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaDBInfoWithOptions(request, runtime);
  }

  /**
   * Queries metatables in a compute engine instance.
   * 
   * @param request - GetMetaDBTableListRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaDBTableListResponse
   */
  async getMetaDBTableListWithOptions(request: GetMetaDBTableListRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaDBTableListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appGuid)) {
      query["AppGuid"] = request.appGuid;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dataSourceType)) {
      query["DataSourceType"] = request.dataSourceType;
    }

    if (!Util.isUnset(request.databaseName)) {
      query["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaDBTableList",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaDBTableListResponse>(await this.callApi(params, req, runtime), new GetMetaDBTableListResponse({}));
  }

  /**
   * Queries metatables in a compute engine instance.
   * 
   * @param request - GetMetaDBTableListRequest
   * @returns GetMetaDBTableListResponse
   */
  async getMetaDBTableList(request: GetMetaDBTableListRequest): Promise<GetMetaDBTableListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaDBTableListWithOptions(request, runtime);
  }

  /**
   * Queries the basic information about a metatable.
   * 
   * @param request - GetMetaTableBasicInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaTableBasicInfoResponse
   */
  async getMetaTableBasicInfoWithOptions(request: GetMetaTableBasicInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableBasicInfoResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableBasicInfo",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableBasicInfoResponse>(await this.callApi(params, req, runtime), new GetMetaTableBasicInfoResponse({}));
  }

  /**
   * Queries the basic information about a metatable.
   * 
   * @param request - GetMetaTableBasicInfoRequest
   * @returns GetMetaTableBasicInfoResponse
   */
  async getMetaTableBasicInfo(request: GetMetaTableBasicInfoRequest): Promise<GetMetaTableBasicInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableBasicInfoWithOptions(request, runtime);
  }

  /**
   * Queries the change logs of a metatable.
   * 
   * @remarks
   * > This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - GetMetaTableChangeLogRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaTableChangeLogResponse
   */
  async getMetaTableChangeLogWithOptions(request: GetMetaTableChangeLogRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableChangeLogResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.changeType)) {
      body["ChangeType"] = request.changeType;
    }

    if (!Util.isUnset(request.endDate)) {
      body["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.objectType)) {
      body["ObjectType"] = request.objectType;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startDate)) {
      body["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.tableGuid)) {
      body["TableGuid"] = request.tableGuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableChangeLog",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableChangeLogResponse>(await this.callApi(params, req, runtime), new GetMetaTableChangeLogResponse({}));
  }

  /**
   * Queries the change logs of a metatable.
   * 
   * @remarks
   * > This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - GetMetaTableChangeLogRequest
   * @returns GetMetaTableChangeLogResponse
   */
  async getMetaTableChangeLog(request: GetMetaTableChangeLogRequest): Promise<GetMetaTableChangeLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableChangeLogWithOptions(request, runtime);
  }

  /**
   * Queries the field information of a metatable.
   * 
   * @param request - GetMetaTableColumnRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaTableColumnResponse
   */
  async getMetaTableColumnWithOptions(request: GetMetaTableColumnRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableColumnResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableColumn",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableColumnResponse>(await this.callApi(params, req, runtime), new GetMetaTableColumnResponse({}));
  }

  /**
   * Queries the field information of a metatable.
   * 
   * @param request - GetMetaTableColumnRequest
   * @returns GetMetaTableColumnResponse
   */
  async getMetaTableColumn(request: GetMetaTableColumnRequest): Promise<GetMetaTableColumnResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableColumnWithOptions(request, runtime);
  }

  /**
   * Queries the complete information about a metatable, including information about fields in the metatable.
   * 
   * @param request - GetMetaTableFullInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaTableFullInfoResponse
   */
  async getMetaTableFullInfoWithOptions(request: GetMetaTableFullInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableFullInfoResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableFullInfo",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableFullInfoResponse>(await this.callApi(params, req, runtime), new GetMetaTableFullInfoResponse({}));
  }

  /**
   * Queries the complete information about a metatable, including information about fields in the metatable.
   * 
   * @param request - GetMetaTableFullInfoRequest
   * @returns GetMetaTableFullInfoResponse
   */
  async getMetaTableFullInfo(request: GetMetaTableFullInfoRequest): Promise<GetMetaTableFullInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableFullInfoWithOptions(request, runtime);
  }

  /**
   * Queries the instructions on how to use a table.
   * 
   * @param request - GetMetaTableIntroWikiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaTableIntroWikiResponse
   */
  async getMetaTableIntroWikiWithOptions(request: GetMetaTableIntroWikiRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableIntroWikiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.wikiVersion)) {
      query["WikiVersion"] = request.wikiVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableIntroWiki",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableIntroWikiResponse>(await this.callApi(params, req, runtime), new GetMetaTableIntroWikiResponse({}));
  }

  /**
   * Queries the instructions on how to use a table.
   * 
   * @param request - GetMetaTableIntroWikiRequest
   * @returns GetMetaTableIntroWikiResponse
   */
  async getMetaTableIntroWiki(request: GetMetaTableIntroWikiRequest): Promise<GetMetaTableIntroWikiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableIntroWikiWithOptions(request, runtime);
  }

  /**
   * Queries the lineage of a metatable.
   * 
   * @param request - GetMetaTableLineageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaTableLineageResponse
   */
  async getMetaTableLineageWithOptions(request: GetMetaTableLineageRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableLineageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dataSourceType)) {
      query["DataSourceType"] = request.dataSourceType;
    }

    if (!Util.isUnset(request.databaseName)) {
      query["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.direction)) {
      query["Direction"] = request.direction;
    }

    if (!Util.isUnset(request.nextPrimaryKey)) {
      query["NextPrimaryKey"] = request.nextPrimaryKey;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableLineage",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableLineageResponse>(await this.callApi(params, req, runtime), new GetMetaTableLineageResponse({}));
  }

  /**
   * Queries the lineage of a metatable.
   * 
   * @param request - GetMetaTableLineageRequest
   * @returns GetMetaTableLineageResponse
   */
  async getMetaTableLineage(request: GetMetaTableLineageRequest): Promise<GetMetaTableLineageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableLineageWithOptions(request, runtime);
  }

  /**
   * Queries metatables in a specified category.
   * 
   * @param request - GetMetaTableListByCategoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaTableListByCategoryResponse
   */
  async getMetaTableListByCategoryWithOptions(request: GetMetaTableListByCategoryRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableListByCategoryResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableListByCategory",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableListByCategoryResponse>(await this.callApi(params, req, runtime), new GetMetaTableListByCategoryResponse({}));
  }

  /**
   * Queries metatables in a specified category.
   * 
   * @param request - GetMetaTableListByCategoryRequest
   * @returns GetMetaTableListByCategoryResponse
   */
  async getMetaTableListByCategory(request: GetMetaTableListByCategoryRequest): Promise<GetMetaTableListByCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableListByCategoryWithOptions(request, runtime);
  }

  /**
   * Queries the output information of a metatable.
   * 
   * @param request - GetMetaTableOutputRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaTableOutputResponse
   */
  async getMetaTableOutputWithOptions(request: GetMetaTableOutputRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableOutputResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endDate)) {
      query["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startDate)) {
      query["StartDate"] = request.startDate;
    }

    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableOutput",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableOutputResponse>(await this.callApi(params, req, runtime), new GetMetaTableOutputResponse({}));
  }

  /**
   * Queries the output information of a metatable.
   * 
   * @param request - GetMetaTableOutputRequest
   * @returns GetMetaTableOutputResponse
   */
  async getMetaTableOutput(request: GetMetaTableOutputRequest): Promise<GetMetaTableOutputResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableOutputWithOptions(request, runtime);
  }

  /**
   * Obtains a list of partitions in a metatable.
   * 
   * @remarks
   * You can call this operation to query only the partitions of a metatable in a MaxCompute or E-MapReduce (EMR) compute engine. If you query partitions of a metatable in an EMR compute engine, only DataLake clusters that use Data Lake Formation (DLF) to manage metadata and Hadoop clusters whose cluster version is earlier than 3.41.0 or 5.7.0 are supported.
   * 
   * @param tmpReq - GetMetaTablePartitionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaTablePartitionResponse
   */
  async getMetaTablePartitionWithOptions(tmpReq: GetMetaTablePartitionRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTablePartitionResponse> {
    Util.validateModel(tmpReq);
    let request = new GetMetaTablePartitionShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.sortCriterion)) {
      request.sortCriterionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sortCriterion, "SortCriterion", "json");
    }

    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dataSourceType)) {
      query["DataSourceType"] = request.dataSourceType;
    }

    if (!Util.isUnset(request.databaseName)) {
      query["DatabaseName"] = request.databaseName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sortCriterionShrink)) {
      query["SortCriterion"] = request.sortCriterionShrink;
    }

    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTablePartition",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTablePartitionResponse>(await this.callApi(params, req, runtime), new GetMetaTablePartitionResponse({}));
  }

  /**
   * Obtains a list of partitions in a metatable.
   * 
   * @remarks
   * You can call this operation to query only the partitions of a metatable in a MaxCompute or E-MapReduce (EMR) compute engine. If you query partitions of a metatable in an EMR compute engine, only DataLake clusters that use Data Lake Formation (DLF) to manage metadata and Hadoop clusters whose cluster version is earlier than 3.41.0 or 5.7.0 are supported.
   * 
   * @param request - GetMetaTablePartitionRequest
   * @returns GetMetaTablePartitionResponse
   */
  async getMetaTablePartition(request: GetMetaTablePartitionRequest): Promise<GetMetaTablePartitionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTablePartitionWithOptions(request, runtime);
  }

  /**
   * 获取Table的产出任务列表
   * 
   * @param request - GetMetaTableProducingTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaTableProducingTasksResponse
   */
  async getMetaTableProducingTasksWithOptions(request: GetMetaTableProducingTasksRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableProducingTasksResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dataSourceType)) {
      query["DataSourceType"] = request.dataSourceType;
    }

    if (!Util.isUnset(request.dbName)) {
      query["DbName"] = request.dbName;
    }

    if (!Util.isUnset(request.schemaName)) {
      query["SchemaName"] = request.schemaName;
    }

    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableProducingTasks",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableProducingTasksResponse>(await this.callApi(params, req, runtime), new GetMetaTableProducingTasksResponse({}));
  }

  /**
   * 获取Table的产出任务列表
   * 
   * @param request - GetMetaTableProducingTasksRequest
   * @returns GetMetaTableProducingTasksResponse
   */
  async getMetaTableProducingTasks(request: GetMetaTableProducingTasksRequest): Promise<GetMetaTableProducingTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableProducingTasksWithOptions(request, runtime);
  }

  /**
   * Queries the information about the themes and levels of a metatable.
   * 
   * @param request - GetMetaTableThemeLevelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMetaTableThemeLevelResponse
   */
  async getMetaTableThemeLevelWithOptions(request: GetMetaTableThemeLevelRequest, runtime: $Util.RuntimeOptions): Promise<GetMetaTableThemeLevelResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetMetaTableThemeLevel",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMetaTableThemeLevelResponse>(await this.callApi(params, req, runtime), new GetMetaTableThemeLevelResponse({}));
  }

  /**
   * Queries the information about the themes and levels of a metatable.
   * 
   * @param request - GetMetaTableThemeLevelRequest
   * @returns GetMetaTableThemeLevelResponse
   */
  async getMetaTableThemeLevel(request: GetMetaTableThemeLevelRequest): Promise<GetMetaTableThemeLevelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMetaTableThemeLevelWithOptions(request, runtime);
  }

  /**
   * Queries the progress of a migration task.
   * 
   * @param request - GetMigrationProcessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMigrationProcessResponse
   */
  async getMigrationProcessWithOptions(request: GetMigrationProcessRequest, runtime: $Util.RuntimeOptions): Promise<GetMigrationProcessResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.migrationId)) {
      body["MigrationId"] = request.migrationId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetMigrationProcess",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMigrationProcessResponse>(await this.callApi(params, req, runtime), new GetMigrationProcessResponse({}));
  }

  /**
   * Queries the progress of a migration task.
   * 
   * @param request - GetMigrationProcessRequest
   * @returns GetMigrationProcessResponse
   */
  async getMigrationProcess(request: GetMigrationProcessRequest): Promise<GetMigrationProcessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMigrationProcessWithOptions(request, runtime);
  }

  /**
   * Queries the information about a migration task.
   * 
   * @param request - GetMigrationSummaryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetMigrationSummaryResponse
   */
  async getMigrationSummaryWithOptions(request: GetMigrationSummaryRequest, runtime: $Util.RuntimeOptions): Promise<GetMigrationSummaryResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.migrationId)) {
      body["MigrationId"] = request.migrationId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetMigrationSummary",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMigrationSummaryResponse>(await this.callApi(params, req, runtime), new GetMigrationSummaryResponse({}));
  }

  /**
   * Queries the information about a migration task.
   * 
   * @param request - GetMigrationSummaryRequest
   * @returns GetMigrationSummaryResponse
   */
  async getMigrationSummary(request: GetMigrationSummaryRequest): Promise<GetMigrationSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMigrationSummaryWithOptions(request, runtime);
  }

  /**
   * Indicates whether the request is successful.
   * 
   * @param request - GetNodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetNodeResponse
   */
  async getNodeWithOptions(request: GetNodeRequest, runtime: $Util.RuntimeOptions): Promise<GetNodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetNode",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNodeResponse>(await this.callApi(params, req, runtime), new GetNodeResponse({}));
  }

  /**
   * Indicates whether the request is successful.
   * 
   * @param request - GetNodeRequest
   * @returns GetNodeResponse
   */
  async getNode(request: GetNodeRequest): Promise<GetNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getNodeWithOptions(request, runtime);
  }

  /**
   * Queries a list of instances.
   * 
   * @param request - GetNodeChildrenRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetNodeChildrenResponse
   */
  async getNodeChildrenWithOptions(request: GetNodeChildrenRequest, runtime: $Util.RuntimeOptions): Promise<GetNodeChildrenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetNodeChildren",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNodeChildrenResponse>(await this.callApi(params, req, runtime), new GetNodeChildrenResponse({}));
  }

  /**
   * Queries a list of instances.
   * 
   * @param request - GetNodeChildrenRequest
   * @returns GetNodeChildrenResponse
   */
  async getNodeChildren(request: GetNodeChildrenRequest): Promise<GetNodeChildrenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getNodeChildrenWithOptions(request, runtime);
  }

  /**
   * Queries the code of a node.
   * 
   * @param request - GetNodeCodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetNodeCodeResponse
   */
  async getNodeCodeWithOptions(request: GetNodeCodeRequest, runtime: $Util.RuntimeOptions): Promise<GetNodeCodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetNodeCode",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNodeCodeResponse>(await this.callApi(params, req, runtime), new GetNodeCodeResponse({}));
  }

  /**
   * Queries the code of a node.
   * 
   * @param request - GetNodeCodeRequest
   * @returns GetNodeCodeResponse
   */
  async getNodeCode(request: GetNodeCodeRequest): Promise<GetNodeCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getNodeCodeWithOptions(request, runtime);
  }

  /**
   * Queries the nodes associated with a baseline.
   * 
   * @deprecated OpenAPI GetNodeOnBaseline is deprecated
   * 
   * @param request - GetNodeOnBaselineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetNodeOnBaselineResponse
   */
  // Deprecated
  async getNodeOnBaselineWithOptions(request: GetNodeOnBaselineRequest, runtime: $Util.RuntimeOptions): Promise<GetNodeOnBaselineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.baselineId)) {
      body["BaselineId"] = request.baselineId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetNodeOnBaseline",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNodeOnBaselineResponse>(await this.callApi(params, req, runtime), new GetNodeOnBaselineResponse({}));
  }

  /**
   * Queries the nodes associated with a baseline.
   * 
   * @deprecated OpenAPI GetNodeOnBaseline is deprecated
   * 
   * @param request - GetNodeOnBaselineRequest
   * @returns GetNodeOnBaselineResponse
   */
  // Deprecated
  async getNodeOnBaseline(request: GetNodeOnBaselineRequest): Promise<GetNodeOnBaselineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getNodeOnBaselineWithOptions(request, runtime);
  }

  /**
   * Queries the ancestor nodes of a node.
   * 
   * @param request - GetNodeParentsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetNodeParentsResponse
   */
  async getNodeParentsWithOptions(request: GetNodeParentsRequest, runtime: $Util.RuntimeOptions): Promise<GetNodeParentsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetNodeParents",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNodeParentsResponse>(await this.callApi(params, req, runtime), new GetNodeParentsResponse({}));
  }

  /**
   * Queries the ancestor nodes of a node.
   * 
   * @param request - GetNodeParentsRequest
   * @returns GetNodeParentsResponse
   */
  async getNodeParents(request: GetNodeParentsRequest): Promise<GetNodeParentsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getNodeParentsWithOptions(request, runtime);
  }

  /**
   * Queries the information about node types, including the code and name of a node type.
   * 
   * @deprecated OpenAPI GetNodeTypeListInfo is deprecated
   * 
   * @param request - GetNodeTypeListInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetNodeTypeListInfoResponse
   */
  // Deprecated
  async getNodeTypeListInfoWithOptions(request: GetNodeTypeListInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetNodeTypeListInfoResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.keyword)) {
      body["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.locale)) {
      body["Locale"] = request.locale;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetNodeTypeListInfo",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetNodeTypeListInfoResponse>(await this.callApi(params, req, runtime), new GetNodeTypeListInfoResponse({}));
  }

  /**
   * Queries the information about node types, including the code and name of a node type.
   * 
   * @deprecated OpenAPI GetNodeTypeListInfo is deprecated
   * 
   * @param request - GetNodeTypeListInfoRequest
   * @returns GetNodeTypeListInfoResponse
   */
  // Deprecated
  async getNodeTypeListInfo(request: GetNodeTypeListInfoRequest): Promise<GetNodeTypeListInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getNodeTypeListInfoWithOptions(request, runtime);
  }

  /**
   * Queries the records that are generated on a specified date for access to the high-risk sensitive data in all the DataWorks workspaces of a tenant.
   * 
   * @param request - GetOpRiskDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOpRiskDataResponse
   */
  async getOpRiskDataWithOptions(request: GetOpRiskDataRequest, runtime: $Util.RuntimeOptions): Promise<GetOpRiskDataResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOpRiskData",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOpRiskDataResponse>(await this.callApi(params, req, runtime), new GetOpRiskDataResponse({}));
  }

  /**
   * Queries the records that are generated on a specified date for access to the high-risk sensitive data in all the DataWorks workspaces of a tenant.
   * 
   * @param request - GetOpRiskDataRequest
   * @returns GetOpRiskDataResponse
   */
  async getOpRiskData(request: GetOpRiskDataRequest): Promise<GetOpRiskDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOpRiskDataWithOptions(request, runtime);
  }

  /**
   * Queries the records that are generated on a specified date for access to sensitive data in all the DataWorks workspaces of a tenant.
   * 
   * @param request - GetOpSensitiveDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOpSensitiveDataResponse
   */
  async getOpSensitiveDataWithOptions(request: GetOpSensitiveDataRequest, runtime: $Util.RuntimeOptions): Promise<GetOpSensitiveDataResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOpSensitiveData",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOpSensitiveDataResponse>(await this.callApi(params, req, runtime), new GetOpSensitiveDataResponse({}));
  }

  /**
   * Queries the records that are generated on a specified date for access to sensitive data in all the DataWorks workspaces of a tenant.
   * 
   * @param request - GetOpSensitiveDataRequest
   * @returns GetOpSensitiveDataResponse
   */
  async getOpSensitiveData(request: GetOpSensitiveDataRequest): Promise<GetOpSensitiveDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOpSensitiveDataWithOptions(request, runtime);
  }

  /**
   * Queries the option settings of an extension in a workspace.
   * 
   * @param request - GetOptionValueForProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetOptionValueForProjectResponse
   */
  async getOptionValueForProjectWithOptions(request: GetOptionValueForProjectRequest, runtime: $Util.RuntimeOptions): Promise<GetOptionValueForProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.extensionCode)) {
      body["ExtensionCode"] = request.extensionCode;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetOptionValueForProject",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOptionValueForProjectResponse>(await this.callApi(params, req, runtime), new GetOptionValueForProjectResponse({}));
  }

  /**
   * Queries the option settings of an extension in a workspace.
   * 
   * @param request - GetOptionValueForProjectRequest
   * @returns GetOptionValueForProjectResponse
   */
  async getOptionValueForProject(request: GetOptionValueForProjectRequest): Promise<GetOptionValueForProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOptionValueForProjectWithOptions(request, runtime);
  }

  /**
   * Queries the details of a permission request order.
   * 
   * @param request - GetPermissionApplyOrderDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetPermissionApplyOrderDetailResponse
   */
  async getPermissionApplyOrderDetailWithOptions(request: GetPermissionApplyOrderDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetPermissionApplyOrderDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.flowId)) {
      query["FlowId"] = request.flowId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPermissionApplyOrderDetail",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPermissionApplyOrderDetailResponse>(await this.callApi(params, req, runtime), new GetPermissionApplyOrderDetailResponse({}));
  }

  /**
   * Queries the details of a permission request order.
   * 
   * @param request - GetPermissionApplyOrderDetailRequest
   * @returns GetPermissionApplyOrderDetailResponse
   */
  async getPermissionApplyOrderDetail(request: GetPermissionApplyOrderDetailRequest): Promise<GetPermissionApplyOrderDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPermissionApplyOrderDetailWithOptions(request, runtime);
  }

  /**
   * Queries the information about a DataWorks workspace.
   * 
   * @param request - GetProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetProjectResponse
   */
  async getProjectWithOptions(request: GetProjectRequest, runtime: $Util.RuntimeOptions): Promise<GetProjectResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      query["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetProject",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetProjectResponse>(await this.callApi(params, req, runtime), new GetProjectResponse({}));
  }

  /**
   * Queries the information about a DataWorks workspace.
   * 
   * @param request - GetProjectRequest
   * @returns GetProjectResponse
   */
  async getProject(request: GetProjectRequest): Promise<GetProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getProjectWithOptions(request, runtime);
  }

  /**
   * Queries the information about a DataWorks workspace.
   * 
   * @deprecated OpenAPI GetProjectDetail is deprecated
   * 
   * @param request - GetProjectDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetProjectDetailResponse
   */
  // Deprecated
  async getProjectDetailWithOptions(request: GetProjectDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetProjectDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetProjectDetail",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetProjectDetailResponse>(await this.callApi(params, req, runtime), new GetProjectDetailResponse({}));
  }

  /**
   * Queries the information about a DataWorks workspace.
   * 
   * @deprecated OpenAPI GetProjectDetail is deprecated
   * 
   * @param request - GetProjectDetailRequest
   * @returns GetProjectDetailResponse
   */
  // Deprecated
  async getProjectDetail(request: GetProjectDetailRequest): Promise<GetProjectDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getProjectDetailWithOptions(request, runtime);
  }

  /**
   * @param request - GetQualityEntityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetQualityEntityResponse
   */
  async getQualityEntityWithOptions(request: GetQualityEntityRequest, runtime: $Util.RuntimeOptions): Promise<GetQualityEntityResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.envType)) {
      body["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.matchExpression)) {
      body["MatchExpression"] = request.matchExpression;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.tableName)) {
      body["TableName"] = request.tableName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetQualityEntity",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetQualityEntityResponse>(await this.callApi(params, req, runtime), new GetQualityEntityResponse({}));
  }

  /**
   * @param request - GetQualityEntityRequest
   * @returns GetQualityEntityResponse
   */
  async getQualityEntity(request: GetQualityEntityRequest): Promise<GetQualityEntityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getQualityEntityWithOptions(request, runtime);
  }

  /**
   * @param request - GetQualityFollowerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetQualityFollowerResponse
   */
  async getQualityFollowerWithOptions(request: GetQualityFollowerRequest, runtime: $Util.RuntimeOptions): Promise<GetQualityFollowerResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.entityId)) {
      body["EntityId"] = request.entityId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetQualityFollower",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetQualityFollowerResponse>(await this.callApi(params, req, runtime), new GetQualityFollowerResponse({}));
  }

  /**
   * @param request - GetQualityFollowerRequest
   * @returns GetQualityFollowerResponse
   */
  async getQualityFollower(request: GetQualityFollowerRequest): Promise<GetQualityFollowerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getQualityFollowerWithOptions(request, runtime);
  }

  /**
   * Queries the information about a monitoring rule.
   * 
   * @param request - GetQualityRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetQualityRuleResponse
   */
  async getQualityRuleWithOptions(request: GetQualityRuleRequest, runtime: $Util.RuntimeOptions): Promise<GetQualityRuleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.ruleId)) {
      body["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetQualityRule",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetQualityRuleResponse>(await this.callApi(params, req, runtime), new GetQualityRuleResponse({}));
  }

  /**
   * Queries the information about a monitoring rule.
   * 
   * @param request - GetQualityRuleRequest
   * @returns GetQualityRuleResponse
   */
  async getQualityRule(request: GetQualityRuleRequest): Promise<GetQualityRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getQualityRuleWithOptions(request, runtime);
  }

  /**
   * Queries the details of a custom alert rule.
   * 
   * @remarks
   * ## Debugging
   * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=GetRemind\\&type=RPC\\&version=2020-05-18)
   * 
   * @param request - GetRemindRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetRemindResponse
   */
  async getRemindWithOptions(request: GetRemindRequest, runtime: $Util.RuntimeOptions): Promise<GetRemindResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.remindId)) {
      body["RemindId"] = request.remindId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetRemind",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRemindResponse>(await this.callApi(params, req, runtime), new GetRemindResponse({}));
  }

  /**
   * Queries the details of a custom alert rule.
   * 
   * @remarks
   * ## Debugging
   * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=GetRemind\\&type=RPC\\&version=2020-05-18)
   * 
   * @param request - GetRemindRequest
   * @returns GetRemindResponse
   */
  async getRemind(request: GetRemindRequest): Promise<GetRemindResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRemindWithOptions(request, runtime);
  }

  /**
   * Queries the latest sensitive data in all the DataWorks workspaces of a tenant.
   * 
   * @param request - GetSensitiveDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSensitiveDataResponse
   */
  async getSensitiveDataWithOptions(request: GetSensitiveDataRequest, runtime: $Util.RuntimeOptions): Promise<GetSensitiveDataResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSensitiveData",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSensitiveDataResponse>(await this.callApi(params, req, runtime), new GetSensitiveDataResponse({}));
  }

  /**
   * Queries the latest sensitive data in all the DataWorks workspaces of a tenant.
   * 
   * @param request - GetSensitiveDataRequest
   * @returns GetSensitiveDataResponse
   */
  async getSensitiveData(request: GetSensitiveDataRequest): Promise<GetSensitiveDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSensitiveDataWithOptions(request, runtime);
  }

  /**
   * Queries the statistics of instances in different periods of a day.
   * 
   * @deprecated OpenAPI GetSuccessInstanceTrend is deprecated
   * 
   * @param request - GetSuccessInstanceTrendRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetSuccessInstanceTrendResponse
   */
  // Deprecated
  async getSuccessInstanceTrendWithOptions(request: GetSuccessInstanceTrendRequest, runtime: $Util.RuntimeOptions): Promise<GetSuccessInstanceTrendResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetSuccessInstanceTrend",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSuccessInstanceTrendResponse>(await this.callApi(params, req, runtime), new GetSuccessInstanceTrendResponse({}));
  }

  /**
   * Queries the statistics of instances in different periods of a day.
   * 
   * @deprecated OpenAPI GetSuccessInstanceTrend is deprecated
   * 
   * @param request - GetSuccessInstanceTrendRequest
   * @returns GetSuccessInstanceTrendResponse
   */
  // Deprecated
  async getSuccessInstanceTrend(request: GetSuccessInstanceTrendRequest): Promise<GetSuccessInstanceTrendResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSuccessInstanceTrendWithOptions(request, runtime);
  }

  /**
   * Queries the information about an event.
   * 
   * @remarks
   * ***
   * 
   * @param request - GetTopicRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTopicResponse
   */
  async getTopicWithOptions(request: GetTopicRequest, runtime: $Util.RuntimeOptions): Promise<GetTopicResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.topicId)) {
      body["TopicId"] = request.topicId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetTopic",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTopicResponse>(await this.callApi(params, req, runtime), new GetTopicResponse({}));
  }

  /**
   * Queries the information about an event.
   * 
   * @remarks
   * ***
   * 
   * @param request - GetTopicRequest
   * @returns GetTopicResponse
   */
  async getTopic(request: GetTopicRequest): Promise<GetTopicResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTopicWithOptions(request, runtime);
  }

  /**
   * @param request - GetTopicInfluenceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns GetTopicInfluenceResponse
   */
  async getTopicInfluenceWithOptions(request: GetTopicInfluenceRequest, runtime: $Util.RuntimeOptions): Promise<GetTopicInfluenceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.topicId)) {
      body["TopicId"] = request.topicId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetTopicInfluence",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTopicInfluenceResponse>(await this.callApi(params, req, runtime), new GetTopicInfluenceResponse({}));
  }

  /**
   * @param request - GetTopicInfluenceRequest
   * @returns GetTopicInfluenceResponse
   */
  async getTopicInfluence(request: GetTopicInfluenceRequest): Promise<GetTopicInfluenceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTopicInfluenceWithOptions(request, runtime);
  }

  /**
   * Imports data sources from your on-premises machine to a specific DataWorks workspace.
   * 
   * @remarks
   * You can import self-managed data sources or data sources that are exported from other DataWorks workspaces to a specific DataWorks workspace.
   * *   To import a self-managed data source to a DataWorks workspace, the data source type must be supported by DataWorks. For more information about the types of data sources supported by DataWorks, see [Supported data stores](https://help.aliyun.com/document_detail/181656.html).
   * *   For more information about how to export data sources from DataWorks workspaces to your on-premises machine, see [ExportDataSources](https://help.aliyun.com/document_detail/279570.html).
   * 
   * @param request - ImportDataSourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ImportDataSourcesResponse
   */
  async importDataSourcesWithOptions(request: ImportDataSourcesRequest, runtime: $Util.RuntimeOptions): Promise<ImportDataSourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataSources)) {
      query["DataSources"] = request.dataSources;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ImportDataSources",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ImportDataSourcesResponse>(await this.callApi(params, req, runtime), new ImportDataSourcesResponse({}));
  }

  /**
   * Imports data sources from your on-premises machine to a specific DataWorks workspace.
   * 
   * @remarks
   * You can import self-managed data sources or data sources that are exported from other DataWorks workspaces to a specific DataWorks workspace.
   * *   To import a self-managed data source to a DataWorks workspace, the data source type must be supported by DataWorks. For more information about the types of data sources supported by DataWorks, see [Supported data stores](https://help.aliyun.com/document_detail/181656.html).
   * *   For more information about how to export data sources from DataWorks workspaces to your on-premises machine, see [ExportDataSources](https://help.aliyun.com/document_detail/279570.html).
   * 
   * @param request - ImportDataSourcesRequest
   * @returns ImportDataSourcesResponse
   */
  async importDataSources(request: ImportDataSourcesRequest): Promise<ImportDataSourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.importDataSourcesWithOptions(request, runtime);
  }

  /**
   * Queries a list of alerts.
   * 
   * @param request - ListAlertMessagesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListAlertMessagesResponse
   */
  async listAlertMessagesWithOptions(request: ListAlertMessagesRequest, runtime: $Util.RuntimeOptions): Promise<ListAlertMessagesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alertMethods)) {
      body["AlertMethods"] = request.alertMethods;
    }

    if (!Util.isUnset(request.alertRuleTypes)) {
      body["AlertRuleTypes"] = request.alertRuleTypes;
    }

    if (!Util.isUnset(request.alertUser)) {
      body["AlertUser"] = request.alertUser;
    }

    if (!Util.isUnset(request.baselineId)) {
      body["BaselineId"] = request.baselineId;
    }

    if (!Util.isUnset(request.beginTime)) {
      body["BeginTime"] = request.beginTime;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remindId)) {
      body["RemindId"] = request.remindId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListAlertMessages",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAlertMessagesResponse>(await this.callApi(params, req, runtime), new ListAlertMessagesResponse({}));
  }

  /**
   * Queries a list of alerts.
   * 
   * @param request - ListAlertMessagesRequest
   * @returns ListAlertMessagesResponse
   */
  async listAlertMessages(request: ListAlertMessagesRequest): Promise<ListAlertMessagesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAlertMessagesWithOptions(request, runtime);
  }

  /**
   * Queries a list of baselines.
   * 
   * @param request - ListBaselineConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListBaselineConfigsResponse
   */
  async listBaselineConfigsWithOptions(request: ListBaselineConfigsRequest, runtime: $Util.RuntimeOptions): Promise<ListBaselineConfigsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.baselineTypes)) {
      body["BaselineTypes"] = request.baselineTypes;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.priority)) {
      body["Priority"] = request.priority;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.searchText)) {
      body["SearchText"] = request.searchText;
    }

    if (!Util.isUnset(request.useflag)) {
      body["Useflag"] = request.useflag;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListBaselineConfigs",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListBaselineConfigsResponse>(await this.callApi(params, req, runtime), new ListBaselineConfigsResponse({}));
  }

  /**
   * Queries a list of baselines.
   * 
   * @param request - ListBaselineConfigsRequest
   * @returns ListBaselineConfigsResponse
   */
  async listBaselineConfigs(request: ListBaselineConfigsRequest): Promise<ListBaselineConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listBaselineConfigsWithOptions(request, runtime);
  }

  /**
   * Queries a list of baseline instances.
   * 
   * @param request - ListBaselineStatusesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListBaselineStatusesResponse
   */
  async listBaselineStatusesWithOptions(request: ListBaselineStatusesRequest, runtime: $Util.RuntimeOptions): Promise<ListBaselineStatusesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.baselineTypes)) {
      body["BaselineTypes"] = request.baselineTypes;
    }

    if (!Util.isUnset(request.bizdate)) {
      body["Bizdate"] = request.bizdate;
    }

    if (!Util.isUnset(request.finishStatus)) {
      body["FinishStatus"] = request.finishStatus;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.priority)) {
      body["Priority"] = request.priority;
    }

    if (!Util.isUnset(request.searchText)) {
      body["SearchText"] = request.searchText;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    if (!Util.isUnset(request.topicId)) {
      body["TopicId"] = request.topicId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListBaselineStatuses",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListBaselineStatusesResponse>(await this.callApi(params, req, runtime), new ListBaselineStatusesResponse({}));
  }

  /**
   * Queries a list of baseline instances.
   * 
   * @param request - ListBaselineStatusesRequest
   * @returns ListBaselineStatusesResponse
   */
  async listBaselineStatuses(request: ListBaselineStatusesRequest): Promise<ListBaselineStatusesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listBaselineStatusesWithOptions(request, runtime);
  }

  /**
   * Obtains a list of baselines.
   * 
   * @param request - ListBaselinesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListBaselinesResponse
   */
  async listBaselinesWithOptions(request: ListBaselinesRequest, runtime: $Util.RuntimeOptions): Promise<ListBaselinesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.baselineTypes)) {
      body["BaselineTypes"] = request.baselineTypes;
    }

    if (!Util.isUnset(request.enable)) {
      body["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.priority)) {
      body["Priority"] = request.priority;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.searchText)) {
      body["SearchText"] = request.searchText;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListBaselines",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListBaselinesResponse>(await this.callApi(params, req, runtime), new ListBaselinesResponse({}));
  }

  /**
   * Obtains a list of baselines.
   * 
   * @param request - ListBaselinesRequest
   * @returns ListBaselinesResponse
   */
  async listBaselines(request: ListBaselinesRequest): Promise<ListBaselinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listBaselinesWithOptions(request, runtime);
  }

  /**
   * Queries a list of workflows.
   * 
   * @param request - ListBusinessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListBusinessResponse
   */
  async listBusinessWithOptions(request: ListBusinessRequest, runtime: $Util.RuntimeOptions): Promise<ListBusinessResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.keyword)) {
      body["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListBusiness",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListBusinessResponse>(await this.callApi(params, req, runtime), new ListBusinessResponse({}));
  }

  /**
   * Queries a list of workflows.
   * 
   * @param request - ListBusinessRequest
   * @returns ListBusinessResponse
   */
  async listBusiness(request: ListBusinessRequest): Promise<ListBusinessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listBusinessWithOptions(request, runtime);
  }

  /**
   * Queries a list of compute engines that are associated with a DataWorks workspace.
   * 
   * @param request - ListCalcEnginesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListCalcEnginesResponse
   */
  async listCalcEnginesWithOptions(request: ListCalcEnginesRequest, runtime: $Util.RuntimeOptions): Promise<ListCalcEnginesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.calcEngineType)) {
      query["CalcEngineType"] = request.calcEngineType;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCalcEngines",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCalcEnginesResponse>(await this.callApi(params, req, runtime), new ListCalcEnginesResponse({}));
  }

  /**
   * Queries a list of compute engines that are associated with a DataWorks workspace.
   * 
   * @param request - ListCalcEnginesRequest
   * @returns ListCalcEnginesResponse
   */
  async listCalcEngines(request: ListCalcEnginesRequest): Promise<ListCalcEnginesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCalcEnginesWithOptions(request, runtime);
  }

  /**
   * 列出集群的配置信息
   * 
   * @param request - ListClusterConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListClusterConfigsResponse
   */
  async listClusterConfigsWithOptions(request: ListClusterConfigsRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterConfigsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterConfigs",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClusterConfigsResponse>(await this.callApi(params, req, runtime), new ListClusterConfigsResponse({}));
  }

  /**
   * 列出集群的配置信息
   * 
   * @param request - ListClusterConfigsRequest
   * @returns ListClusterConfigsResponse
   */
  async listClusterConfigs(request: ListClusterConfigsRequest): Promise<ListClusterConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterConfigsWithOptions(request, runtime);
  }

  /**
   * 列出注册到 DataWorks 的集群的信息
   * 
   * @param request - ListClustersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListClustersResponse
   */
  async listClustersWithOptions(request: ListClustersRequest, runtime: $Util.RuntimeOptions): Promise<ListClustersResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClusters",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClustersResponse>(await this.callApi(params, req, runtime), new ListClustersResponse({}));
  }

  /**
   * 列出注册到 DataWorks 的集群的信息
   * 
   * @param request - ListClustersRequest
   * @returns ListClustersResponse
   */
  async listClusters(request: ListClustersRequest): Promise<ListClustersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClustersWithOptions(request, runtime);
  }

  /**
   * Queries a list of data sources.
   * 
   * @deprecated OpenAPI ListConnections is deprecated
   * 
   * @param request - ListConnectionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListConnectionsResponse
   */
  // Deprecated
  async listConnectionsWithOptions(request: ListConnectionsRequest, runtime: $Util.RuntimeOptions): Promise<ListConnectionsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListConnections",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListConnectionsResponse>(await this.callApi(params, req, runtime), new ListConnectionsResponse({}));
  }

  /**
   * Queries a list of data sources.
   * 
   * @deprecated OpenAPI ListConnections is deprecated
   * 
   * @param request - ListConnectionsRequest
   * @returns ListConnectionsResponse
   */
  // Deprecated
  async listConnections(request: ListConnectionsRequest): Promise<ListConnectionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listConnectionsWithOptions(request, runtime);
  }

  /**
   * Queries a list of alert rules for a new-version synchronization task. The following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @remarks
   * You can configure alert rules only for tasks that can be used for real-time data synchronization.
   * 
   * @param request - ListDIAlarmRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDIAlarmRulesResponse
   */
  async listDIAlarmRulesWithOptions(request: ListDIAlarmRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListDIAlarmRulesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.DIJobId)) {
      body["DIJobId"] = request.DIJobId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDIAlarmRules",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDIAlarmRulesResponse>(await this.callApi(params, req, runtime), new ListDIAlarmRulesResponse({}));
  }

  /**
   * Queries a list of alert rules for a new-version synchronization task. The following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @remarks
   * You can configure alert rules only for tasks that can be used for real-time data synchronization.
   * 
   * @param request - ListDIAlarmRulesRequest
   * @returns ListDIAlarmRulesResponse
   */
  async listDIAlarmRules(request: ListDIAlarmRulesRequest): Promise<ListDIAlarmRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDIAlarmRulesWithOptions(request, runtime);
  }

  /**
   * Queries a list of new-version synchronization tasks. The following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @remarks
   * You can call this operation to obtain only the basic information about the tasks. If you want to obtain the details of a task, call the GetDIJob operation.
   * 
   * @param request - ListDIJobsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDIJobsResponse
   */
  async listDIJobsWithOptions(request: ListDIJobsRequest, runtime: $Util.RuntimeOptions): Promise<ListDIJobsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.destinationDataSourceType)) {
      body["DestinationDataSourceType"] = request.destinationDataSourceType;
    }

    if (!Util.isUnset(request.jobName)) {
      body["JobName"] = request.jobName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.sourceDataSourceType)) {
      body["SourceDataSourceType"] = request.sourceDataSourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDIJobs",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDIJobsResponse>(await this.callApi(params, req, runtime), new ListDIJobsResponse({}));
  }

  /**
   * Queries a list of new-version synchronization tasks. The following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @remarks
   * You can call this operation to obtain only the basic information about the tasks. If you want to obtain the details of a task, call the GetDIJob operation.
   * 
   * @param request - ListDIJobsRequest
   * @returns ListDIJobsResponse
   */
  async listDIJobs(request: ListDIJobsRequest): Promise<ListDIJobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDIJobsWithOptions(request, runtime);
  }

  /**
   * Queries the default global configurations of synchronization solutions in a specified DataWorks workspace.
   * 
   * @remarks
   * DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization tasks in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
   * 
   * @param request - ListDIProjectConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDIProjectConfigResponse
   */
  async listDIProjectConfigWithOptions(request: ListDIProjectConfigRequest, runtime: $Util.RuntimeOptions): Promise<ListDIProjectConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.destinationType)) {
      query["DestinationType"] = request.destinationType;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDIProjectConfig",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDIProjectConfigResponse>(await this.callApi(params, req, runtime), new ListDIProjectConfigResponse({}));
  }

  /**
   * Queries the default global configurations of synchronization solutions in a specified DataWorks workspace.
   * 
   * @remarks
   * DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization tasks in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
   * 
   * @param request - ListDIProjectConfigRequest
   * @returns ListDIProjectConfigResponse
   */
  async listDIProjectConfig(request: ListDIProjectConfigRequest): Promise<ListDIProjectConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDIProjectConfigWithOptions(request, runtime);
  }

  /**
   * Queries the details of directed acyclic graphs (DAGs) for a single data backfill instance based on OpSeq.
   * 
   * @remarks
   * Supported DAG types:
   * *   MANUAL: DAG for a manually triggered workflow
   * *   SMOKE_TEST: DAG for a smoke testing workflow
   * *   SUPPLY_DATA: DAG for a data backfill instance
   * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
   * Supported DAG states:
   * *   CREATED: The DAG is created.
   * *   RUNNING: The DAG is running.
   * *   FAILURE: The DAG fails to run.
   * *   SUCCESS: The DAG is successfully run.
   * 
   * @param request - ListDagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDagsResponse
   */
  async listDagsWithOptions(request: ListDagsRequest, runtime: $Util.RuntimeOptions): Promise<ListDagsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.opSeq)) {
      body["OpSeq"] = request.opSeq;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDags",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDagsResponse>(await this.callApi(params, req, runtime), new ListDagsResponse({}));
  }

  /**
   * Queries the details of directed acyclic graphs (DAGs) for a single data backfill instance based on OpSeq.
   * 
   * @remarks
   * Supported DAG types:
   * *   MANUAL: DAG for a manually triggered workflow
   * *   SMOKE_TEST: DAG for a smoke testing workflow
   * *   SUPPLY_DATA: DAG for a data backfill instance
   * *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
   * Supported DAG states:
   * *   CREATED: The DAG is created.
   * *   RUNNING: The DAG is running.
   * *   FAILURE: The DAG fails to run.
   * *   SUCCESS: The DAG is successfully run.
   * 
   * @param request - ListDagsRequest
   * @returns ListDagsResponse
   */
  async listDags(request: ListDagsRequest): Promise<ListDagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDagsWithOptions(request, runtime);
  }

  /**
   * Queries the APIs on which other users are granted the access permissions.
   * 
   * @param request - ListDataServiceApiAuthoritiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataServiceApiAuthoritiesResponse
   */
  async listDataServiceApiAuthoritiesWithOptions(request: ListDataServiceApiAuthoritiesRequest, runtime: $Util.RuntimeOptions): Promise<ListDataServiceApiAuthoritiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiNameKeyword)) {
      body["ApiNameKeyword"] = request.apiNameKeyword;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDataServiceApiAuthorities",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataServiceApiAuthoritiesResponse>(await this.callApi(params, req, runtime), new ListDataServiceApiAuthoritiesResponse({}));
  }

  /**
   * Queries the APIs on which other users are granted the access permissions.
   * 
   * @param request - ListDataServiceApiAuthoritiesRequest
   * @returns ListDataServiceApiAuthoritiesResponse
   */
  async listDataServiceApiAuthorities(request: ListDataServiceApiAuthoritiesRequest): Promise<ListDataServiceApiAuthoritiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataServiceApiAuthoritiesWithOptions(request, runtime);
  }

  /**
   * Queries the test records of a DataService Studio API. This API operation allows you to query only the test records that are generated within the previous month.
   * 
   * @param request - ListDataServiceApiTestRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataServiceApiTestResponse
   */
  async listDataServiceApiTestWithOptions(request: ListDataServiceApiTestRequest, runtime: $Util.RuntimeOptions): Promise<ListDataServiceApiTestResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDataServiceApiTest",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataServiceApiTestResponse>(await this.callApi(params, req, runtime), new ListDataServiceApiTestResponse({}));
  }

  /**
   * Queries the test records of a DataService Studio API. This API operation allows you to query only the test records that are generated within the previous month.
   * 
   * @param request - ListDataServiceApiTestRequest
   * @returns ListDataServiceApiTestResponse
   */
  async listDataServiceApiTest(request: ListDataServiceApiTestRequest): Promise<ListDataServiceApiTestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataServiceApiTestWithOptions(request, runtime);
  }

  /**
   * Queries a list of APIs in the development state.
   * 
   * @param request - ListDataServiceApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataServiceApisResponse
   */
  async listDataServiceApisWithOptions(request: ListDataServiceApisRequest, runtime: $Util.RuntimeOptions): Promise<ListDataServiceApisResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiNameKeyword)) {
      body["ApiNameKeyword"] = request.apiNameKeyword;
    }

    if (!Util.isUnset(request.apiPathKeyword)) {
      body["ApiPathKeyword"] = request.apiPathKeyword;
    }

    if (!Util.isUnset(request.creatorId)) {
      body["CreatorId"] = request.creatorId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDataServiceApis",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataServiceApisResponse>(await this.callApi(params, req, runtime), new ListDataServiceApisResponse({}));
  }

  /**
   * Queries a list of APIs in the development state.
   * 
   * @param request - ListDataServiceApisRequest
   * @returns ListDataServiceApisResponse
   */
  async listDataServiceApis(request: ListDataServiceApisRequest): Promise<ListDataServiceApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataServiceApisWithOptions(request, runtime);
  }

  /**
   * Queries the basic information of applications.
   * 
   * @param request - ListDataServiceApplicationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataServiceApplicationsResponse
   */
  async listDataServiceApplicationsWithOptions(request: ListDataServiceApplicationsRequest, runtime: $Util.RuntimeOptions): Promise<ListDataServiceApplicationsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectIdList)) {
      body["ProjectIdList"] = request.projectIdList;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDataServiceApplications",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataServiceApplicationsResponse>(await this.callApi(params, req, runtime), new ListDataServiceApplicationsResponse({}));
  }

  /**
   * Queries the basic information of applications.
   * 
   * @param request - ListDataServiceApplicationsRequest
   * @returns ListDataServiceApplicationsResponse
   */
  async listDataServiceApplications(request: ListDataServiceApplicationsRequest): Promise<ListDataServiceApplicationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataServiceApplicationsWithOptions(request, runtime);
  }

  /**
   * Queries the APIs that you are authorized to access.
   * 
   * @param request - ListDataServiceAuthorizedApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataServiceAuthorizedApisResponse
   */
  async listDataServiceAuthorizedApisWithOptions(request: ListDataServiceAuthorizedApisRequest, runtime: $Util.RuntimeOptions): Promise<ListDataServiceAuthorizedApisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiNameKeyword)) {
      body["ApiNameKeyword"] = request.apiNameKeyword;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDataServiceAuthorizedApis",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataServiceAuthorizedApisResponse>(await this.callApi(params, req, runtime), new ListDataServiceAuthorizedApisResponse({}));
  }

  /**
   * Queries the APIs that you are authorized to access.
   * 
   * @param request - ListDataServiceAuthorizedApisRequest
   * @returns ListDataServiceAuthorizedApisResponse
   */
  async listDataServiceAuthorizedApis(request: ListDataServiceAuthorizedApisRequest): Promise<ListDataServiceAuthorizedApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataServiceAuthorizedApisWithOptions(request, runtime);
  }

  /**
   * Queries folders.
   * 
   * @param request - ListDataServiceFoldersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataServiceFoldersResponse
   */
  async listDataServiceFoldersWithOptions(request: ListDataServiceFoldersRequest, runtime: $Util.RuntimeOptions): Promise<ListDataServiceFoldersResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.folderNameKeyword)) {
      body["FolderNameKeyword"] = request.folderNameKeyword;
    }

    if (!Util.isUnset(request.groupId)) {
      body["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDataServiceFolders",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataServiceFoldersResponse>(await this.callApi(params, req, runtime), new ListDataServiceFoldersResponse({}));
  }

  /**
   * Queries folders.
   * 
   * @param request - ListDataServiceFoldersRequest
   * @returns ListDataServiceFoldersResponse
   */
  async listDataServiceFolders(request: ListDataServiceFoldersRequest): Promise<ListDataServiceFoldersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataServiceFoldersWithOptions(request, runtime);
  }

  /**
   * Queries business processes.
   * 
   * @param request - ListDataServiceGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataServiceGroupsResponse
   */
  async listDataServiceGroupsWithOptions(request: ListDataServiceGroupsRequest, runtime: $Util.RuntimeOptions): Promise<ListDataServiceGroupsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.groupNameKeyword)) {
      body["GroupNameKeyword"] = request.groupNameKeyword;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDataServiceGroups",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataServiceGroupsResponse>(await this.callApi(params, req, runtime), new ListDataServiceGroupsResponse({}));
  }

  /**
   * Queries business processes.
   * 
   * @param request - ListDataServiceGroupsRequest
   * @returns ListDataServiceGroupsResponse
   */
  async listDataServiceGroups(request: ListDataServiceGroupsRequest): Promise<ListDataServiceGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataServiceGroupsWithOptions(request, runtime);
  }

  /**
   * Queries a list of APIs in the published state.
   * 
   * @param request - ListDataServicePublishedApisRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataServicePublishedApisResponse
   */
  async listDataServicePublishedApisWithOptions(request: ListDataServicePublishedApisRequest, runtime: $Util.RuntimeOptions): Promise<ListDataServicePublishedApisResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiNameKeyword)) {
      body["ApiNameKeyword"] = request.apiNameKeyword;
    }

    if (!Util.isUnset(request.apiPathKeyword)) {
      body["ApiPathKeyword"] = request.apiPathKeyword;
    }

    if (!Util.isUnset(request.creatorId)) {
      body["CreatorId"] = request.creatorId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDataServicePublishedApis",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataServicePublishedApisResponse>(await this.callApi(params, req, runtime), new ListDataServicePublishedApisResponse({}));
  }

  /**
   * Queries a list of APIs in the published state.
   * 
   * @param request - ListDataServicePublishedApisRequest
   * @returns ListDataServicePublishedApisResponse
   */
  async listDataServicePublishedApis(request: ListDataServicePublishedApisRequest): Promise<ListDataServicePublishedApisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataServicePublishedApisWithOptions(request, runtime);
  }

  /**
   * Queries the data sources added to a DataWorks workspace.
   * 
   * @param request - ListDataSourcesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDataSourcesResponse
   */
  async listDataSourcesWithOptions(request: ListDataSourcesRequest, runtime: $Util.RuntimeOptions): Promise<ListDataSourcesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListDataSources",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDataSourcesResponse>(await this.callApi(params, req, runtime), new ListDataSourcesResponse({}));
  }

  /**
   * Queries the data sources added to a DataWorks workspace.
   * 
   * @param request - ListDataSourcesRequest
   * @returns ListDataSourcesResponse
   */
  async listDataSources(request: ListDataSourcesRequest): Promise<ListDataSourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDataSourcesWithOptions(request, runtime);
  }

  /**
   * Queries a list of deployment packages. This operation is equivalent to viewing a list of deployment packages on the Deployment Packages page of the DataWorks console.
   * 
   * @param request - ListDeploymentsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListDeploymentsResponse
   */
  async listDeploymentsWithOptions(request: ListDeploymentsRequest, runtime: $Util.RuntimeOptions): Promise<ListDeploymentsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.creator)) {
      body["Creator"] = request.creator;
    }

    if (!Util.isUnset(request.endCreateTime)) {
      body["EndCreateTime"] = request.endCreateTime;
    }

    if (!Util.isUnset(request.endExecuteTime)) {
      body["EndExecuteTime"] = request.endExecuteTime;
    }

    if (!Util.isUnset(request.executor)) {
      body["Executor"] = request.executor;
    }

    if (!Util.isUnset(request.keyword)) {
      body["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListDeployments",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListDeploymentsResponse>(await this.callApi(params, req, runtime), new ListDeploymentsResponse({}));
  }

  /**
   * Queries a list of deployment packages. This operation is equivalent to viewing a list of deployment packages on the Deployment Packages page of the DataWorks console.
   * 
   * @param request - ListDeploymentsRequest
   * @returns ListDeploymentsResponse
   */
  async listDeployments(request: ListDeploymentsRequest): Promise<ListDeploymentsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listDeploymentsWithOptions(request, runtime);
  }

  /**
   * Queries a list of built-in and custom extensions that are enabled in a workspace.
   * 
   * @remarks
   * For information about codes of extension point events, see [Development references: Extension point event codes](https://help.aliyun.com/document_detail/463357.html).
   * 
   * @param request - ListEnabledExtensionsForProjectRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEnabledExtensionsForProjectResponse
   */
  async listEnabledExtensionsForProjectWithOptions(request: ListEnabledExtensionsForProjectRequest, runtime: $Util.RuntimeOptions): Promise<ListEnabledExtensionsForProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.eventCode)) {
      body["EventCode"] = request.eventCode;
    }

    if (!Util.isUnset(request.fileType)) {
      body["FileType"] = request.fileType;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListEnabledExtensionsForProject",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEnabledExtensionsForProjectResponse>(await this.callApi(params, req, runtime), new ListEnabledExtensionsForProjectResponse({}));
  }

  /**
   * Queries a list of built-in and custom extensions that are enabled in a workspace.
   * 
   * @remarks
   * For information about codes of extension point events, see [Development references: Extension point event codes](https://help.aliyun.com/document_detail/463357.html).
   * 
   * @param request - ListEnabledExtensionsForProjectRequest
   * @returns ListEnabledExtensionsForProjectResponse
   */
  async listEnabledExtensionsForProject(request: ListEnabledExtensionsForProjectRequest): Promise<ListEnabledExtensionsForProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEnabledExtensionsForProjectWithOptions(request, runtime);
  }

  /**
   * Queries a list of entities by tag. Only entities of the maxcompute-table type are supported.
   * 
   * @param tmpReq - ListEntitiesByTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEntitiesByTagsResponse
   */
  async listEntitiesByTagsWithOptions(tmpReq: ListEntitiesByTagsRequest, runtime: $Util.RuntimeOptions): Promise<ListEntitiesByTagsResponse> {
    Util.validateModel(tmpReq);
    let request = new ListEntitiesByTagsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEntitiesByTags",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEntitiesByTagsResponse>(await this.callApi(params, req, runtime), new ListEntitiesByTagsResponse({}));
  }

  /**
   * Queries a list of entities by tag. Only entities of the maxcompute-table type are supported.
   * 
   * @param request - ListEntitiesByTagsRequest
   * @returns ListEntitiesByTagsResponse
   */
  async listEntitiesByTags(request: ListEntitiesByTagsRequest): Promise<ListEntitiesByTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEntitiesByTagsWithOptions(request, runtime);
  }

  /**
   * Queries a list of tags of an entity. Only entities of the maxcompute-table type are supported.
   * 
   * @param request - ListEntityTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListEntityTagsResponse
   */
  async listEntityTagsWithOptions(request: ListEntityTagsRequest, runtime: $Util.RuntimeOptions): Promise<ListEntityTagsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListEntityTags",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListEntityTagsResponse>(await this.callApi(params, req, runtime), new ListEntityTagsResponse({}));
  }

  /**
   * Queries a list of tags of an entity. Only entities of the maxcompute-table type are supported.
   * 
   * @param request - ListEntityTagsRequest
   * @returns ListEntityTagsResponse
   */
  async listEntityTags(request: ListEntityTagsRequest): Promise<ListEntityTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listEntityTagsWithOptions(request, runtime);
  }

  /**
   * Queries a list of extensions.
   * 
   * @param request - ListExtensionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListExtensionsResponse
   */
  async listExtensionsWithOptions(request: ListExtensionsRequest, runtime: $Util.RuntimeOptions): Promise<ListExtensionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListExtensions",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListExtensionsResponse>(await this.callApi(params, req, runtime), new ListExtensionsResponse({}));
  }

  /**
   * Queries a list of extensions.
   * 
   * @param request - ListExtensionsRequest
   * @returns ListExtensionsResponse
   */
  async listExtensions(request: ListExtensionsRequest): Promise<ListExtensionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listExtensionsWithOptions(request, runtime);
  }

  /**
   * Queries the information about node types, such as the code and name.
   * 
   * @param request - ListFileTypeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListFileTypeResponse
   */
  async listFileTypeWithOptions(request: ListFileTypeRequest, runtime: $Util.RuntimeOptions): Promise<ListFileTypeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.keyword)) {
      body["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.locale)) {
      body["Locale"] = request.locale;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListFileType",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListFileTypeResponse>(await this.callApi(params, req, runtime), new ListFileTypeResponse({}));
  }

  /**
   * Queries the information about node types, such as the code and name.
   * 
   * @param request - ListFileTypeRequest
   * @returns ListFileTypeResponse
   */
  async listFileType(request: ListFileTypeRequest): Promise<ListFileTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFileTypeWithOptions(request, runtime);
  }

  /**
   * @param request - ListFileVersionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListFileVersionsResponse
   */
  async listFileVersionsWithOptions(request: ListFileVersionsRequest, runtime: $Util.RuntimeOptions): Promise<ListFileVersionsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.fileId)) {
      body["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListFileVersions",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListFileVersionsResponse>(await this.callApi(params, req, runtime), new ListFileVersionsResponse({}));
  }

  /**
   * @param request - ListFileVersionsRequest
   * @returns ListFileVersionsResponse
   */
  async listFileVersions(request: ListFileVersionsRequest): Promise<ListFileVersionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFileVersionsWithOptions(request, runtime);
  }

  /**
   * @param request - ListFilesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListFilesResponse
   */
  async listFilesWithOptions(request: ListFilesRequest, runtime: $Util.RuntimeOptions): Promise<ListFilesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.exactFileName)) {
      body["ExactFileName"] = request.exactFileName;
    }

    if (!Util.isUnset(request.fileFolderPath)) {
      body["FileFolderPath"] = request.fileFolderPath;
    }

    if (!Util.isUnset(request.fileIdIn)) {
      body["FileIdIn"] = request.fileIdIn;
    }

    if (!Util.isUnset(request.fileTypes)) {
      body["FileTypes"] = request.fileTypes;
    }

    if (!Util.isUnset(request.keyword)) {
      body["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.needAbsoluteFolderPath)) {
      body["NeedAbsoluteFolderPath"] = request.needAbsoluteFolderPath;
    }

    if (!Util.isUnset(request.needContent)) {
      body["NeedContent"] = request.needContent;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    if (!Util.isUnset(request.useType)) {
      body["UseType"] = request.useType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListFiles",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListFilesResponse>(await this.callApi(params, req, runtime), new ListFilesResponse({}));
  }

  /**
   * @param request - ListFilesRequest
   * @returns ListFilesResponse
   */
  async listFiles(request: ListFilesRequest): Promise<ListFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFilesWithOptions(request, runtime);
  }

  /**
   * Queries a list of folders.
   * 
   * @param request - ListFoldersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListFoldersResponse
   */
  async listFoldersWithOptions(request: ListFoldersRequest, runtime: $Util.RuntimeOptions): Promise<ListFoldersResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.parentFolderPath)) {
      body["ParentFolderPath"] = request.parentFolderPath;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListFolders",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListFoldersResponse>(await this.callApi(params, req, runtime), new ListFoldersResponse({}));
  }

  /**
   * Queries a list of folders.
   * 
   * @param request - ListFoldersRequest
   * @returns ListFoldersResponse
   */
  async listFolders(request: ListFoldersRequest): Promise<ListFoldersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFoldersWithOptions(request, runtime);
  }

  /**
   * Queries information about inner nodes. For example, you can call this operation to query the inner nodes of a node group or a do-while node. You cannot call this operation to query the inner nodes of a PAI node.
   * 
   * @param request - ListInnerNodesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInnerNodesResponse
   */
  async listInnerNodesWithOptions(request: ListInnerNodesRequest, runtime: $Util.RuntimeOptions): Promise<ListInnerNodesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeName)) {
      body["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.outerNodeId)) {
      body["OuterNodeId"] = request.outerNodeId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.programType)) {
      body["ProgramType"] = request.programType;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListInnerNodes",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInnerNodesResponse>(await this.callApi(params, req, runtime), new ListInnerNodesResponse({}));
  }

  /**
   * Queries information about inner nodes. For example, you can call this operation to query the inner nodes of a node group or a do-while node. You cannot call this operation to query the inner nodes of a PAI node.
   * 
   * @param request - ListInnerNodesRequest
   * @returns ListInnerNodesResponse
   */
  async listInnerNodes(request: ListInnerNodesRequest): Promise<ListInnerNodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInnerNodesWithOptions(request, runtime);
  }

  /**
   * Queries the trend of the number of auto triggered node instances within a specified period of time.
   * 
   * @param request - ListInstanceAmountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInstanceAmountResponse
   */
  async listInstanceAmountWithOptions(request: ListInstanceAmountRequest, runtime: $Util.RuntimeOptions): Promise<ListInstanceAmountResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.beginDate)) {
      body["BeginDate"] = request.beginDate;
    }

    if (!Util.isUnset(request.endDate)) {
      body["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListInstanceAmount",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstanceAmountResponse>(await this.callApi(params, req, runtime), new ListInstanceAmountResponse({}));
  }

  /**
   * Queries the trend of the number of auto triggered node instances within a specified period of time.
   * 
   * @param request - ListInstanceAmountRequest
   * @returns ListInstanceAmountResponse
   */
  async listInstanceAmount(request: ListInstanceAmountRequest): Promise<ListInstanceAmountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstanceAmountWithOptions(request, runtime);
  }

  /**
   * Queries information about the historical records of all instances. One historical record is generated if an instance is rerun once.
   * 
   * @param request - ListInstanceHistoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInstanceHistoryResponse
   */
  async listInstanceHistoryWithOptions(request: ListInstanceHistoryRequest, runtime: $Util.RuntimeOptions): Promise<ListInstanceHistoryResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListInstanceHistory",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstanceHistoryResponse>(await this.callApi(params, req, runtime), new ListInstanceHistoryResponse({}));
  }

  /**
   * Queries information about the historical records of all instances. One historical record is generated if an instance is rerun once.
   * 
   * @param request - ListInstanceHistoryRequest
   * @returns ListInstanceHistoryResponse
   */
  async listInstanceHistory(request: ListInstanceHistoryRequest): Promise<ListInstanceHistoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstanceHistoryWithOptions(request, runtime);
  }

  /**
   * The ID of the directed acyclic graph (DAG). You can set this parameter to the value of the DagId parameter returned by the [RunCycleDagNodes](https://help.aliyun.com/document_detail/212961.html), [RunSmokeTest](https://help.aliyun.com/document_detail/212949.html), or [RunManualDagNodes](https://help.aliyun.com/document_detail/212830.html) operation based on your business requirements. The RunManualDagNodes operation is used to backfill data, the RunSmokeTest operation is used to perform smoke testing, and the RunManualDagNodes operation is used to run nodes in a manually triggered workflow.
   * 
   * @param request - ListInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListInstancesResponse
   */
  async listInstancesWithOptions(request: ListInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListInstancesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.beginBizdate)) {
      body["BeginBizdate"] = request.beginBizdate;
    }

    if (!Util.isUnset(request.bizName)) {
      body["BizName"] = request.bizName;
    }

    if (!Util.isUnset(request.bizdate)) {
      body["Bizdate"] = request.bizdate;
    }

    if (!Util.isUnset(request.dagId)) {
      body["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.endBizdate)) {
      body["EndBizdate"] = request.endBizdate;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeName)) {
      body["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.orderBy)) {
      body["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.programType)) {
      body["ProgramType"] = request.programType;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListInstances",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstancesResponse>(await this.callApi(params, req, runtime), new ListInstancesResponse({}));
  }

  /**
   * The ID of the directed acyclic graph (DAG). You can set this parameter to the value of the DagId parameter returned by the [RunCycleDagNodes](https://help.aliyun.com/document_detail/212961.html), [RunSmokeTest](https://help.aliyun.com/document_detail/212949.html), or [RunManualDagNodes](https://help.aliyun.com/document_detail/212830.html) operation based on your business requirements. The RunManualDagNodes operation is used to backfill data, the RunSmokeTest operation is used to perform smoke testing, and the RunManualDagNodes operation is used to run nodes in a manually triggered workflow.
   * 
   * @param request - ListInstancesRequest
   * @returns ListInstancesResponse
   */
  async listInstances(request: ListInstancesRequest): Promise<ListInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstancesWithOptions(request, runtime);
  }

  /**
   * Queries the ancestor or descendant lineage of an entity.
   * 
   * @param request - ListLineageRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListLineageResponse
   */
  async listLineageWithOptions(request: ListLineageRequest, runtime: $Util.RuntimeOptions): Promise<ListLineageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.direction)) {
      query["Direction"] = request.direction;
    }

    if (!Util.isUnset(request.entityQualifiedName)) {
      query["EntityQualifiedName"] = request.entityQualifiedName;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListLineage",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListLineageResponse>(await this.callApi(params, req, runtime), new ListLineageResponse({}));
  }

  /**
   * Queries the ancestor or descendant lineage of an entity.
   * 
   * @param request - ListLineageRequest
   * @returns ListLineageResponse
   */
  async listLineage(request: ListLineageRequest): Promise<ListLineageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listLineageWithOptions(request, runtime);
  }

  /**
   * Queries the information about instances in a manually triggered workflow.
   * 
   * @param request - ListManualDagInstancesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListManualDagInstancesResponse
   */
  async listManualDagInstancesWithOptions(request: ListManualDagInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListManualDagInstancesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.dagId)) {
      body["DagId"] = request.dagId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListManualDagInstances",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListManualDagInstancesResponse>(await this.callApi(params, req, runtime), new ListManualDagInstancesResponse({}));
  }

  /**
   * Queries the information about instances in a manually triggered workflow.
   * 
   * @param request - ListManualDagInstancesRequest
   * @returns ListManualDagInstancesResponse
   */
  async listManualDagInstances(request: ListManualDagInstancesRequest): Promise<ListManualDagInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listManualDagInstancesWithOptions(request, runtime);
  }

  /**
   * 查询DataWorks计量数据
   * 
   * @param request - ListMeasureDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListMeasureDataResponse
   */
  async listMeasureDataWithOptions(request: ListMeasureDataRequest, runtime: $Util.RuntimeOptions): Promise<ListMeasureDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.componentCode)) {
      query["ComponentCode"] = request.componentCode;
    }

    if (!Util.isUnset(request.domainCode)) {
      query["DomainCode"] = request.domainCode;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListMeasureData",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListMeasureDataResponse>(await this.callApi(params, req, runtime), new ListMeasureDataResponse({}));
  }

  /**
   * 查询DataWorks计量数据
   * 
   * @param request - ListMeasureDataRequest
   * @returns ListMeasureDataResponse
   */
  async listMeasureData(request: ListMeasureDataRequest): Promise<ListMeasureDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listMeasureDataWithOptions(request, runtime);
  }

  /**
   * Queries the entities in a collection.
   * 
   * @param request - ListMetaCollectionEntitiesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListMetaCollectionEntitiesResponse
   */
  async listMetaCollectionEntitiesWithOptions(request: ListMetaCollectionEntitiesRequest, runtime: $Util.RuntimeOptions): Promise<ListMetaCollectionEntitiesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.collectionQualifiedName)) {
      query["CollectionQualifiedName"] = request.collectionQualifiedName;
    }

    if (!Util.isUnset(request.entityType)) {
      query["EntityType"] = request.entityType;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListMetaCollectionEntities",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListMetaCollectionEntitiesResponse>(await this.callApi(params, req, runtime), new ListMetaCollectionEntitiesResponse({}));
  }

  /**
   * Queries the entities in a collection.
   * 
   * @param request - ListMetaCollectionEntitiesRequest
   * @returns ListMetaCollectionEntitiesResponse
   */
  async listMetaCollectionEntities(request: ListMetaCollectionEntitiesRequest): Promise<ListMetaCollectionEntitiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listMetaCollectionEntitiesWithOptions(request, runtime);
  }

  /**
   * Queries information about collections. Collections include data albums that are displayed on the Data Map page and categories that are created in the data albums. You can call this API operation to query collections by type.
   * 
   * @remarks
   * The type can be ALBUM or ALBUM_CATEGORY. ALBUM indicates data albums. ALBUM_CATEGORY indicates categories.
   * 
   * @param request - ListMetaCollectionsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListMetaCollectionsResponse
   */
  async listMetaCollectionsWithOptions(request: ListMetaCollectionsRequest, runtime: $Util.RuntimeOptions): Promise<ListMetaCollectionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.administrator)) {
      query["Administrator"] = request.administrator;
    }

    if (!Util.isUnset(request.collectionType)) {
      query["CollectionType"] = request.collectionType;
    }

    if (!Util.isUnset(request.creator)) {
      query["Creator"] = request.creator;
    }

    if (!Util.isUnset(request.follower)) {
      query["Follower"] = request.follower;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.orderBy)) {
      query["OrderBy"] = request.orderBy;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.parentQualifiedName)) {
      query["ParentQualifiedName"] = request.parentQualifiedName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListMetaCollections",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListMetaCollectionsResponse>(await this.callApi(params, req, runtime), new ListMetaCollectionsResponse({}));
  }

  /**
   * Queries information about collections. Collections include data albums that are displayed on the Data Map page and categories that are created in the data albums. You can call this API operation to query collections by type.
   * 
   * @remarks
   * The type can be ALBUM or ALBUM_CATEGORY. ALBUM indicates data albums. ALBUM_CATEGORY indicates categories.
   * 
   * @param request - ListMetaCollectionsRequest
   * @returns ListMetaCollectionsResponse
   */
  async listMetaCollections(request: ListMetaCollectionsRequest): Promise<ListMetaCollectionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listMetaCollectionsWithOptions(request, runtime);
  }

  /**
   * Queries a list of metadatabases.
   * 
   * @param request - ListMetaDBRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListMetaDBResponse
   */
  async listMetaDBWithOptions(request: ListMetaDBRequest, runtime: $Util.RuntimeOptions): Promise<ListMetaDBResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListMetaDB",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListMetaDBResponse>(await this.callApi(params, req, runtime), new ListMetaDBResponse({}));
  }

  /**
   * Queries a list of metadatabases.
   * 
   * @param request - ListMetaDBRequest
   * @returns ListMetaDBResponse
   */
  async listMetaDB(request: ListMetaDBRequest): Promise<ListMetaDBResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listMetaDBWithOptions(request, runtime);
  }

  /**
   * Queries a list of migration tasks.
   * 
   * @param request - ListMigrationsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListMigrationsResponse
   */
  async listMigrationsWithOptions(request: ListMigrationsRequest, runtime: $Util.RuntimeOptions): Promise<ListMigrationsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.migrationType)) {
      body["MigrationType"] = request.migrationType;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListMigrations",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListMigrationsResponse>(await this.callApi(params, req, runtime), new ListMigrationsResponse({}));
  }

  /**
   * Queries a list of migration tasks.
   * 
   * @param request - ListMigrationsRequest
   * @returns ListMigrationsResponse
   */
  async listMigrations(request: ListMigrationsRequest): Promise<ListMigrationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listMigrationsWithOptions(request, runtime);
  }

  /**
   * Queries the information about one level of ancestor or descendant nodes of a node.
   * 
   * @deprecated OpenAPI ListNodeIO is deprecated
   * 
   * @param request - ListNodeIORequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNodeIOResponse
   */
  // Deprecated
  async listNodeIOWithOptions(request: ListNodeIORequest, runtime: $Util.RuntimeOptions): Promise<ListNodeIOResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ioType)) {
      body["IoType"] = request.ioType;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListNodeIO",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListNodeIOResponse>(await this.callApi(params, req, runtime), new ListNodeIOResponse({}));
  }

  /**
   * Queries the information about one level of ancestor or descendant nodes of a node.
   * 
   * @deprecated OpenAPI ListNodeIO is deprecated
   * 
   * @param request - ListNodeIORequest
   * @returns ListNodeIOResponse
   */
  // Deprecated
  async listNodeIO(request: ListNodeIORequest): Promise<ListNodeIOResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listNodeIOWithOptions(request, runtime);
  }

  /**
   * Queries the input and output information about a node. Only the ancestor or descendant nodes at the nearest level can be queried each time.
   * 
   * @param request - ListNodeInputOrOutputRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNodeInputOrOutputResponse
   */
  async listNodeInputOrOutputWithOptions(request: ListNodeInputOrOutputRequest, runtime: $Util.RuntimeOptions): Promise<ListNodeInputOrOutputResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ioType)) {
      body["IoType"] = request.ioType;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListNodeInputOrOutput",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListNodeInputOrOutputResponse>(await this.callApi(params, req, runtime), new ListNodeInputOrOutputResponse({}));
  }

  /**
   * Queries the input and output information about a node. Only the ancestor or descendant nodes at the nearest level can be queried each time.
   * 
   * @param request - ListNodeInputOrOutputRequest
   * @returns ListNodeInputOrOutputResponse
   */
  async listNodeInputOrOutput(request: ListNodeInputOrOutputRequest): Promise<ListNodeInputOrOutputResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listNodeInputOrOutputWithOptions(request, runtime);
  }

  /**
   * The ID of the workspace.
   * 
   * @param request - ListNodesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNodesResponse
   */
  async listNodesWithOptions(request: ListNodesRequest, runtime: $Util.RuntimeOptions): Promise<ListNodesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizName)) {
      body["BizName"] = request.bizName;
    }

    if (!Util.isUnset(request.nodeName)) {
      body["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.programType)) {
      body["ProgramType"] = request.programType;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.schedulerType)) {
      body["SchedulerType"] = request.schedulerType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListNodes",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListNodesResponse>(await this.callApi(params, req, runtime), new ListNodesResponse({}));
  }

  /**
   * The ID of the workspace.
   * 
   * @param request - ListNodesRequest
   * @returns ListNodesResponse
   */
  async listNodes(request: ListNodesRequest): Promise<ListNodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listNodesWithOptions(request, runtime);
  }

  /**
   * Queries nodes in a baseline.
   * 
   * @param request - ListNodesByBaselineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNodesByBaselineResponse
   */
  async listNodesByBaselineWithOptions(request: ListNodesByBaselineRequest, runtime: $Util.RuntimeOptions): Promise<ListNodesByBaselineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.baselineId)) {
      body["BaselineId"] = request.baselineId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListNodesByBaseline",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListNodesByBaselineResponse>(await this.callApi(params, req, runtime), new ListNodesByBaselineResponse({}));
  }

  /**
   * Queries nodes in a baseline.
   * 
   * @param request - ListNodesByBaselineRequest
   * @returns ListNodesByBaselineResponse
   */
  async listNodesByBaseline(request: ListNodesByBaselineRequest): Promise<ListNodesByBaselineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listNodesByBaselineWithOptions(request, runtime);
  }

  /**
   * Queries nodes based on the output of the nodes.
   * 
   * @param request - ListNodesByOutputRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListNodesByOutputResponse
   */
  async listNodesByOutputWithOptions(request: ListNodesByOutputRequest, runtime: $Util.RuntimeOptions): Promise<ListNodesByOutputResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.outputs)) {
      body["Outputs"] = request.outputs;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListNodesByOutput",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListNodesByOutputResponse>(await this.callApi(params, req, runtime), new ListNodesByOutputResponse({}));
  }

  /**
   * Queries nodes based on the output of the nodes.
   * 
   * @param request - ListNodesByOutputRequest
   * @returns ListNodesByOutputResponse
   */
  async listNodesByOutput(request: ListNodesByOutputRequest): Promise<ListNodesByOutputResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listNodesByOutputWithOptions(request, runtime);
  }

  /**
   * Queries a list of permission request orders.
   * 
   * @param request - ListPermissionApplyOrdersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListPermissionApplyOrdersResponse
   */
  async listPermissionApplyOrdersWithOptions(request: ListPermissionApplyOrdersRequest, runtime: $Util.RuntimeOptions): Promise<ListPermissionApplyOrdersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.engineType)) {
      query["EngineType"] = request.engineType;
    }

    if (!Util.isUnset(request.flowStatus)) {
      query["FlowStatus"] = request.flowStatus;
    }

    if (!Util.isUnset(request.maxComputeProjectName)) {
      query["MaxComputeProjectName"] = request.maxComputeProjectName;
    }

    if (!Util.isUnset(request.orderType)) {
      query["OrderType"] = request.orderType;
    }

    if (!Util.isUnset(request.pageNum)) {
      query["PageNum"] = request.pageNum;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryType)) {
      query["QueryType"] = request.queryType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.workspaceId)) {
      query["WorkspaceId"] = request.workspaceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPermissionApplyOrders",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListPermissionApplyOrdersResponse>(await this.callApi(params, req, runtime), new ListPermissionApplyOrdersResponse({}));
  }

  /**
   * Queries a list of permission request orders.
   * 
   * @param request - ListPermissionApplyOrdersRequest
   * @returns ListPermissionApplyOrdersResponse
   */
  async listPermissionApplyOrders(request: ListPermissionApplyOrdersRequest): Promise<ListPermissionApplyOrdersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPermissionApplyOrdersWithOptions(request, runtime);
  }

  /**
   * Queries the distribution of different types of nodes.
   * 
   * @deprecated OpenAPI ListProgramTypeCount is deprecated
   * 
   * @param request - ListProgramTypeCountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProgramTypeCountResponse
   */
  // Deprecated
  async listProgramTypeCountWithOptions(request: ListProgramTypeCountRequest, runtime: $Util.RuntimeOptions): Promise<ListProgramTypeCountResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListProgramTypeCount",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProgramTypeCountResponse>(await this.callApi(params, req, runtime), new ListProgramTypeCountResponse({}));
  }

  /**
   * Queries the distribution of different types of nodes.
   * 
   * @deprecated OpenAPI ListProgramTypeCount is deprecated
   * 
   * @param request - ListProgramTypeCountRequest
   * @returns ListProgramTypeCountResponse
   */
  // Deprecated
  async listProgramTypeCount(request: ListProgramTypeCountRequest): Promise<ListProgramTypeCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProgramTypeCountWithOptions(request, runtime);
  }

  /**
   * Queries the IDs of the workspaces on which a specific Alibaba Cloud account or RAM user has permissions in a specific region.
   * 
   * @remarks
   * An Alibaba Cloud account can assume a role such as the developer, O\\&M engineer, or workspace administrator role in a workspace. For more information, see [Manage members and roles](https://help.aliyun.com/document_detail/136941.html).
   * 
   * @param request - ListProjectIdsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectIdsResponse
   */
  async listProjectIdsWithOptions(request: ListProjectIdsRequest, runtime: $Util.RuntimeOptions): Promise<ListProjectIdsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjectIds",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProjectIdsResponse>(await this.callApi(params, req, runtime), new ListProjectIdsResponse({}));
  }

  /**
   * Queries the IDs of the workspaces on which a specific Alibaba Cloud account or RAM user has permissions in a specific region.
   * 
   * @remarks
   * An Alibaba Cloud account can assume a role such as the developer, O\\&M engineer, or workspace administrator role in a workspace. For more information, see [Manage members and roles](https://help.aliyun.com/document_detail/136941.html).
   * 
   * @param request - ListProjectIdsRequest
   * @returns ListProjectIdsResponse
   */
  async listProjectIds(request: ListProjectIdsRequest): Promise<ListProjectIdsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProjectIdsWithOptions(request, runtime);
  }

  /**
   * Queries a list of existing members in a DataWorks workspace.
   * 
   * @param request - ListProjectMembersRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectMembersResponse
   */
  async listProjectMembersWithOptions(request: ListProjectMembersRequest, runtime: $Util.RuntimeOptions): Promise<ListProjectMembersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjectMembers",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProjectMembersResponse>(await this.callApi(params, req, runtime), new ListProjectMembersResponse({}));
  }

  /**
   * Queries a list of existing members in a DataWorks workspace.
   * 
   * @param request - ListProjectMembersRequest
   * @returns ListProjectMembersResponse
   */
  async listProjectMembers(request: ListProjectMembersRequest): Promise<ListProjectMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProjectMembersWithOptions(request, runtime);
  }

  /**
   * Queries a list of roles in a DataWorks workspace.
   * 
   * @remarks
   * ## Debugging
   * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=ListProjectRoles\\&type=RPC\\&version=2020-05-18)
   * 
   * @param request - ListProjectRolesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectRolesResponse
   */
  async listProjectRolesWithOptions(request: ListProjectRolesRequest, runtime: $Util.RuntimeOptions): Promise<ListProjectRolesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjectRoles",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProjectRolesResponse>(await this.callApi(params, req, runtime), new ListProjectRolesResponse({}));
  }

  /**
   * Queries a list of roles in a DataWorks workspace.
   * 
   * @remarks
   * ## Debugging
   * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=dataworks-public\\&api=ListProjectRoles\\&type=RPC\\&version=2020-05-18)
   * 
   * @param request - ListProjectRolesRequest
   * @returns ListProjectRolesResponse
   */
  async listProjectRoles(request: ListProjectRolesRequest): Promise<ListProjectRolesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProjectRolesWithOptions(request, runtime);
  }

  /**
   * Queries a list of DataWorks workspaces of the tenant to which a user belongs.
   * 
   * @param tmpReq - ListProjectsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListProjectsResponse
   */
  async listProjectsWithOptions(tmpReq: ListProjectsRequest, runtime: $Util.RuntimeOptions): Promise<ListProjectsResponse> {
    Util.validateModel(tmpReq);
    let request = new ListProjectsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = { };
    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceManagerResourceGroupId)) {
      query["ResourceManagerResourceGroupId"] = request.resourceManagerResourceGroupId;
    }

    if (!Util.isUnset(request.tagsShrink)) {
      query["Tags"] = request.tagsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListProjects",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListProjectsResponse>(await this.callApi(params, req, runtime), new ListProjectsResponse({}));
  }

  /**
   * Queries a list of DataWorks workspaces of the tenant to which a user belongs.
   * 
   * @param request - ListProjectsRequest
   * @returns ListProjectsResponse
   */
  async listProjects(request: ListProjectsRequest): Promise<ListProjectsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listProjectsWithOptions(request, runtime);
  }

  /**
   * Queries a list of historical check results based on a partition filter expression.
   * 
   * @remarks
   * ***
   * 
   * @param request - ListQualityResultsByEntityRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListQualityResultsByEntityResponse
   */
  async listQualityResultsByEntityWithOptions(request: ListQualityResultsByEntityRequest, runtime: $Util.RuntimeOptions): Promise<ListQualityResultsByEntityResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endDate)) {
      body["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.entityId)) {
      body["EntityId"] = request.entityId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.startDate)) {
      body["StartDate"] = request.startDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListQualityResultsByEntity",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListQualityResultsByEntityResponse>(await this.callApi(params, req, runtime), new ListQualityResultsByEntityResponse({}));
  }

  /**
   * Queries a list of historical check results based on a partition filter expression.
   * 
   * @remarks
   * ***
   * 
   * @param request - ListQualityResultsByEntityRequest
   * @returns ListQualityResultsByEntityResponse
   */
  async listQualityResultsByEntity(request: ListQualityResultsByEntityRequest): Promise<ListQualityResultsByEntityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listQualityResultsByEntityWithOptions(request, runtime);
  }

  /**
   * Queries monitoring results after the data quality of a data source or a compute engine is monitored based on monitoring rules.
   * 
   * @param request - ListQualityResultsByRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListQualityResultsByRuleResponse
   */
  async listQualityResultsByRuleWithOptions(request: ListQualityResultsByRuleRequest, runtime: $Util.RuntimeOptions): Promise<ListQualityResultsByRuleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.endDate)) {
      body["EndDate"] = request.endDate;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.ruleId)) {
      body["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.startDate)) {
      body["StartDate"] = request.startDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListQualityResultsByRule",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListQualityResultsByRuleResponse>(await this.callApi(params, req, runtime), new ListQualityResultsByRuleResponse({}));
  }

  /**
   * Queries monitoring results after the data quality of a data source or a compute engine is monitored based on monitoring rules.
   * 
   * @param request - ListQualityResultsByRuleRequest
   * @returns ListQualityResultsByRuleResponse
   */
  async listQualityResultsByRule(request: ListQualityResultsByRuleRequest): Promise<ListQualityResultsByRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listQualityResultsByRuleWithOptions(request, runtime);
  }

  /**
   * Queries monitoring rules based on a partition filter expression.
   * 
   * @param request - ListQualityRulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListQualityRulesResponse
   */
  async listQualityRulesWithOptions(request: ListQualityRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListQualityRulesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.entityId)) {
      body["EntityId"] = request.entityId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListQualityRules",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListQualityRulesResponse>(await this.callApi(params, req, runtime), new ListQualityRulesResponse({}));
  }

  /**
   * Queries monitoring rules based on a partition filter expression.
   * 
   * @param request - ListQualityRulesRequest
   * @returns ListQualityRulesResponse
   */
  async listQualityRules(request: ListQualityRulesRequest): Promise<ListQualityRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listQualityRulesWithOptions(request, runtime);
  }

  /**
   * Queries synchronization tasks in Data Integration that use a specific data source.
   * 
   * @param request - ListRefDISyncTasksRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRefDISyncTasksResponse
   */
  async listRefDISyncTasksWithOptions(request: ListRefDISyncTasksRequest, runtime: $Util.RuntimeOptions): Promise<ListRefDISyncTasksResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasourceName)) {
      query["DatasourceName"] = request.datasourceName;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.refType)) {
      query["RefType"] = request.refType;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRefDISyncTasks",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListRefDISyncTasksResponse>(await this.callApi(params, req, runtime), new ListRefDISyncTasksResponse({}));
  }

  /**
   * Queries synchronization tasks in Data Integration that use a specific data source.
   * 
   * @param request - ListRefDISyncTasksRequest
   * @returns ListRefDISyncTasksResponse
   */
  async listRefDISyncTasks(request: ListRefDISyncTasksRequest): Promise<ListRefDISyncTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRefDISyncTasksWithOptions(request, runtime);
  }

  /**
   * Queries a list of custom alert rules.
   * 
   * @param request - ListRemindsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListRemindsResponse
   */
  async listRemindsWithOptions(request: ListRemindsRequest, runtime: $Util.RuntimeOptions): Promise<ListRemindsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alertTarget)) {
      body["AlertTarget"] = request.alertTarget;
    }

    if (!Util.isUnset(request.founder)) {
      body["Founder"] = request.founder;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remindTypes)) {
      body["RemindTypes"] = request.remindTypes;
    }

    if (!Util.isUnset(request.searchText)) {
      body["SearchText"] = request.searchText;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListReminds",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListRemindsResponse>(await this.callApi(params, req, runtime), new ListRemindsResponse({}));
  }

  /**
   * Queries a list of custom alert rules.
   * 
   * @param request - ListRemindsRequest
   * @returns ListRemindsResponse
   */
  async listReminds(request: ListRemindsRequest): Promise<ListRemindsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRemindsWithOptions(request, runtime);
  }

  /**
   * Queries a list of resource groups of a specific type.
   * 
   * @param tmpReq - ListResourceGroupsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListResourceGroupsResponse
   */
  async listResourceGroupsWithOptions(tmpReq: ListResourceGroupsRequest, runtime: $Util.RuntimeOptions): Promise<ListResourceGroupsResponse> {
    Util.validateModel(tmpReq);
    let request = new ListResourceGroupsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = { };
    if (!Util.isUnset(request.bizExtKey)) {
      query["BizExtKey"] = request.bizExtKey;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.resourceGroupType)) {
      query["ResourceGroupType"] = request.resourceGroupType;
    }

    if (!Util.isUnset(request.resourceManagerResourceGroupId)) {
      query["ResourceManagerResourceGroupId"] = request.resourceManagerResourceGroupId;
    }

    if (!Util.isUnset(request.tagsShrink)) {
      query["Tags"] = request.tagsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListResourceGroups",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListResourceGroupsResponse>(await this.callApi(params, req, runtime), new ListResourceGroupsResponse({}));
  }

  /**
   * Queries a list of resource groups of a specific type.
   * 
   * @param request - ListResourceGroupsRequest
   * @returns ListResourceGroupsResponse
   */
  async listResourceGroups(request: ListResourceGroupsRequest): Promise<ListResourceGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listResourceGroupsWithOptions(request, runtime);
  }

  /**
   * Queries a list of on-duty engineers in a shift schedule.
   * 
   * @param request - ListShiftPersonnelsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListShiftPersonnelsResponse
   */
  async listShiftPersonnelsWithOptions(request: ListShiftPersonnelsRequest, runtime: $Util.RuntimeOptions): Promise<ListShiftPersonnelsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.beginTime)) {
      body["BeginTime"] = request.beginTime;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.shiftPersonUID)) {
      body["ShiftPersonUID"] = request.shiftPersonUID;
    }

    if (!Util.isUnset(request.shiftScheduleIdentifier)) {
      body["ShiftScheduleIdentifier"] = request.shiftScheduleIdentifier;
    }

    if (!Util.isUnset(request.userType)) {
      body["UserType"] = request.userType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListShiftPersonnels",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListShiftPersonnelsResponse>(await this.callApi(params, req, runtime), new ListShiftPersonnelsResponse({}));
  }

  /**
   * Queries a list of on-duty engineers in a shift schedule.
   * 
   * @param request - ListShiftPersonnelsRequest
   * @returns ListShiftPersonnelsResponse
   */
  async listShiftPersonnels(request: ListShiftPersonnelsRequest): Promise<ListShiftPersonnelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listShiftPersonnelsWithOptions(request, runtime);
  }

  /**
   * Queries a list of shift schedules in Operation Center.
   * 
   * @param request - ListShiftSchedulesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListShiftSchedulesResponse
   */
  async listShiftSchedulesWithOptions(request: ListShiftSchedulesRequest, runtime: $Util.RuntimeOptions): Promise<ListShiftSchedulesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.shiftScheduleName)) {
      body["ShiftScheduleName"] = request.shiftScheduleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListShiftSchedules",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListShiftSchedulesResponse>(await this.callApi(params, req, runtime), new ListShiftSchedulesResponse({}));
  }

  /**
   * Queries a list of shift schedules in Operation Center.
   * 
   * @param request - ListShiftSchedulesRequest
   * @returns ListShiftSchedulesResponse
   */
  async listShiftSchedules(request: ListShiftSchedulesRequest): Promise<ListShiftSchedulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listShiftSchedulesWithOptions(request, runtime);
  }

  /**
   * Queries the trend of the number of auto triggered node instances that are successfully run every hour on the hour of the current day.
   * 
   * @param request - ListSuccessInstanceAmountRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListSuccessInstanceAmountResponse
   */
  async listSuccessInstanceAmountWithOptions(request: ListSuccessInstanceAmountRequest, runtime: $Util.RuntimeOptions): Promise<ListSuccessInstanceAmountResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListSuccessInstanceAmount",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSuccessInstanceAmountResponse>(await this.callApi(params, req, runtime), new ListSuccessInstanceAmountResponse({}));
  }

  /**
   * Queries the trend of the number of auto triggered node instances that are successfully run every hour on the hour of the current day.
   * 
   * @param request - ListSuccessInstanceAmountRequest
   * @returns ListSuccessInstanceAmountResponse
   */
  async listSuccessInstanceAmount(request: ListSuccessInstanceAmountRequest): Promise<ListSuccessInstanceAmountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSuccessInstanceAmountWithOptions(request, runtime);
  }

  /**
   * Queries a list of table levels. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - ListTableLevelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTableLevelResponse
   */
  async listTableLevelWithOptions(request: ListTableLevelRequest, runtime: $Util.RuntimeOptions): Promise<ListTableLevelResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTableLevel",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTableLevelResponse>(await this.callApi(params, req, runtime), new ListTableLevelResponse({}));
  }

  /**
   * Queries a list of table levels. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - ListTableLevelRequest
   * @returns ListTableLevelResponse
   */
  async listTableLevel(request: ListTableLevelRequest): Promise<ListTableLevelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTableLevelWithOptions(request, runtime);
  }

  /**
   * Queries a list of table themes. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - ListTableThemeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTableThemeResponse
   */
  async listTableThemeWithOptions(request: ListTableThemeRequest, runtime: $Util.RuntimeOptions): Promise<ListTableThemeResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTableTheme",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTableThemeResponse>(await this.callApi(params, req, runtime), new ListTableThemeResponse({}));
  }

  /**
   * Queries a list of table themes. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - ListTableThemeRequest
   * @returns ListTableThemeResponse
   */
  async listTableTheme(request: ListTableThemeRequest): Promise<ListTableThemeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTableThemeWithOptions(request, runtime);
  }

  /**
   * 分页获取租户下面的数据源类型粒度的表名称
   * 
   * @param request - ListTablesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTablesResponse
   */
  async listTablesWithOptions(request: ListTablesRequest, runtime: $Util.RuntimeOptions): Promise<ListTablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dataSourceType)) {
      query["DataSourceType"] = request.dataSourceType;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTables",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTablesResponse>(await this.callApi(params, req, runtime), new ListTablesResponse({}));
  }

  /**
   * 分页获取租户下面的数据源类型粒度的表名称
   * 
   * @param request - ListTablesRequest
   * @returns ListTablesResponse
   */
  async listTables(request: ListTablesRequest): Promise<ListTablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTablesWithOptions(request, runtime);
  }

  /**
   * Queries events.
   * 
   * @param request - ListTopicsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ListTopicsResponse
   */
  async listTopicsWithOptions(request: ListTopicsRequest, runtime: $Util.RuntimeOptions): Promise<ListTopicsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.beginTime)) {
      body["BeginTime"] = request.beginTime;
    }

    if (!Util.isUnset(request.endTime)) {
      body["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.topicStatuses)) {
      body["TopicStatuses"] = request.topicStatuses;
    }

    if (!Util.isUnset(request.topicTypes)) {
      body["TopicTypes"] = request.topicTypes;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ListTopics",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTopicsResponse>(await this.callApi(params, req, runtime), new ListTopicsResponse({}));
  }

  /**
   * Queries events.
   * 
   * @param request - ListTopicsRequest
   * @returns ListTopicsResponse
   */
  async listTopics(request: ListTopicsRequest): Promise<ListTopicsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTopicsWithOptions(request, runtime);
  }

  /**
   * Adds a directory to the left-side navigation pane of DataAnalysis.
   * 
   * @param request - MountDirectoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns MountDirectoryResponse
   */
  async mountDirectoryWithOptions(request: MountDirectoryRequest, runtime: $Util.RuntimeOptions): Promise<MountDirectoryResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.targetId)) {
      body["TargetId"] = request.targetId;
    }

    if (!Util.isUnset(request.targetType)) {
      body["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.targetUserId)) {
      body["TargetUserId"] = request.targetUserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "MountDirectory",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<MountDirectoryResponse>(await this.callApi(params, req, runtime), new MountDirectoryResponse({}));
  }

  /**
   * Adds a directory to the left-side navigation pane of DataAnalysis.
   * 
   * @param request - MountDirectoryRequest
   * @returns MountDirectoryResponse
   */
  async mountDirectory(request: MountDirectoryRequest): Promise<MountDirectoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.mountDirectoryWithOptions(request, runtime);
  }

  /**
   * Undeploys a node.
   * 
   * @param request - OfflineNodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns OfflineNodeResponse
   */
  async offlineNodeWithOptions(request: OfflineNodeRequest, runtime: $Util.RuntimeOptions): Promise<OfflineNodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "OfflineNode",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OfflineNodeResponse>(await this.callApi(params, req, runtime), new OfflineNodeResponse({}));
  }

  /**
   * Undeploys a node.
   * 
   * @param request - OfflineNodeRequest
   * @returns OfflineNodeResponse
   */
  async offlineNode(request: OfflineNodeRequest): Promise<OfflineNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.offlineNodeWithOptions(request, runtime);
  }

  /**
   * Publishes an API.
   * 
   * @param request - PublishDataServiceApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns PublishDataServiceApiResponse
   */
  async publishDataServiceApiWithOptions(request: PublishDataServiceApiRequest, runtime: $Util.RuntimeOptions): Promise<PublishDataServiceApiResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiId)) {
      body["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PublishDataServiceApi",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublishDataServiceApiResponse>(await this.callApi(params, req, runtime), new PublishDataServiceApiResponse({}));
  }

  /**
   * Publishes an API.
   * 
   * @param request - PublishDataServiceApiRequest
   * @returns PublishDataServiceApiResponse
   */
  async publishDataServiceApi(request: PublishDataServiceApiRequest): Promise<PublishDataServiceApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publishDataServiceApiWithOptions(request, runtime);
  }

  /**
   * Queries the execution results of an asynchronous task.
   * 
   * @remarks
   * DataWorks allows you to call only the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a batch synchronization task or the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization task in Data Integration. To create or update a real-time synchronization task, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) or [GenerateDISyncTaskConfigForUpdating](https://help.aliyun.com/document_detail/383464.html) operation to obtain the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the CreateDISyncTask or UpdateDISyncTask operation and use the parameters as request parameters to create or update a real-time synchronization task. DataWorks allows you to create or update real-time synchronization tasks in Data Integration only in asynchronous mode.
   * 
   * @param request - QueryDISyncTaskConfigProcessResultRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryDISyncTaskConfigProcessResultResponse
   */
  async queryDISyncTaskConfigProcessResultWithOptions(request: QueryDISyncTaskConfigProcessResultRequest, runtime: $Util.RuntimeOptions): Promise<QueryDISyncTaskConfigProcessResultResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.asyncProcessId)) {
      query["AsyncProcessId"] = request.asyncProcessId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDISyncTaskConfigProcessResult",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDISyncTaskConfigProcessResultResponse>(await this.callApi(params, req, runtime), new QueryDISyncTaskConfigProcessResultResponse({}));
  }

  /**
   * Queries the execution results of an asynchronous task.
   * 
   * @remarks
   * DataWorks allows you to call only the [CreateDISyncTask](https://help.aliyun.com/document_detail/278725.html) operation to create a batch synchronization task or the [UpdateDISyncTask](https://help.aliyun.com/document_detail/289109.html) operation to update a batch synchronization task in Data Integration. To create or update a real-time synchronization task, you must first call the [GenerateDISyncTaskConfigForCreating](https://help.aliyun.com/document_detail/383463.html) or [GenerateDISyncTaskConfigForUpdating](https://help.aliyun.com/document_detail/383464.html) operation to obtain the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](https://help.aliyun.com/document_detail/383465.html) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the CreateDISyncTask or UpdateDISyncTask operation and use the parameters as request parameters to create or update a real-time synchronization task. DataWorks allows you to create or update real-time synchronization tasks in Data Integration only in asynchronous mode.
   * 
   * @param request - QueryDISyncTaskConfigProcessResultRequest
   * @returns QueryDISyncTaskConfigProcessResultResponse
   */
  async queryDISyncTaskConfigProcessResult(request: QueryDISyncTaskConfigProcessResultRequest): Promise<QueryDISyncTaskConfigProcessResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDISyncTaskConfigProcessResultWithOptions(request, runtime);
  }

  /**
   * Queries the default data category and data sensitivity level template defined by Data Security Guard.
   * 
   * @param request - QueryDefaultTemplateRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryDefaultTemplateResponse
   */
  async queryDefaultTemplateWithOptions(request: QueryDefaultTemplateRequest, runtime: $Util.RuntimeOptions): Promise<QueryDefaultTemplateResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryDefaultTemplate",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDefaultTemplateResponse>(await this.callApi(params, req, runtime), new QueryDefaultTemplateResponse({}));
  }

  /**
   * Queries the default data category and data sensitivity level template defined by Data Security Guard.
   * 
   * @param request - QueryDefaultTemplateRequest
   * @returns QueryDefaultTemplateResponse
   */
  async queryDefaultTemplate(request: QueryDefaultTemplateRequest): Promise<QueryDefaultTemplateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDefaultTemplateWithOptions(request, runtime);
  }

  /**
   * Queries information about objects that are created in Data Modeling by using fast modeling language (FML) statements.
   * 
   * @remarks
   *   Each time you call this API operation, you must use FML statements to query information about objects that are created in Data Modeling.
   * *   The information about the objects can be queried by page, except for data layers, business processes, and data domains. You can add an offset to the end of an FML statement. The num LIMIT num statement specifies the offset when the information about the objects is queried, and the number of pages to return each time. The offset value must be a multiple of the number of pages.
   * *   A maximum of 1,000 entries can be returned each time you call this API operation.
   * 
   * @param request - QueryPublicModelEngineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryPublicModelEngineResponse
   */
  async queryPublicModelEngineWithOptions(request: QueryPublicModelEngineRequest, runtime: $Util.RuntimeOptions): Promise<QueryPublicModelEngineResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.text)) {
      body["Text"] = request.text;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryPublicModelEngine",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryPublicModelEngineResponse>(await this.callApi(params, req, runtime), new QueryPublicModelEngineResponse({}));
  }

  /**
   * Queries information about objects that are created in Data Modeling by using fast modeling language (FML) statements.
   * 
   * @remarks
   *   Each time you call this API operation, you must use FML statements to query information about objects that are created in Data Modeling.
   * *   The information about the objects can be queried by page, except for data layers, business processes, and data domains. You can add an offset to the end of an FML statement. The num LIMIT num statement specifies the offset when the information about the objects is queried, and the number of pages to return each time. The offset value must be a multiple of the number of pages.
   * *   A maximum of 1,000 entries can be returned each time you call this API operation.
   * 
   * @param request - QueryPublicModelEngineRequest
   * @returns QueryPublicModelEngineResponse
   */
  async queryPublicModelEngine(request: QueryPublicModelEngineRequest): Promise<QueryPublicModelEngineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryPublicModelEngineWithOptions(request, runtime);
  }

  /**
   * Queries the type of a sensitive data identification rule.
   * 
   * @param request - QueryRecognizeDataByRuleTypeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryRecognizeDataByRuleTypeResponse
   */
  async queryRecognizeDataByRuleTypeWithOptions(request: QueryRecognizeDataByRuleTypeRequest, runtime: $Util.RuntimeOptions): Promise<QueryRecognizeDataByRuleTypeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.recognizeRulesType)) {
      body["RecognizeRulesType"] = request.recognizeRulesType;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryRecognizeDataByRuleType",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryRecognizeDataByRuleTypeResponse>(await this.callApi(params, req, runtime), new QueryRecognizeDataByRuleTypeResponse({}));
  }

  /**
   * Queries the type of a sensitive data identification rule.
   * 
   * @param request - QueryRecognizeDataByRuleTypeRequest
   * @returns QueryRecognizeDataByRuleTypeResponse
   */
  async queryRecognizeDataByRuleType(request: QueryRecognizeDataByRuleTypeRequest): Promise<QueryRecognizeDataByRuleTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryRecognizeDataByRuleTypeWithOptions(request, runtime);
  }

  /**
   * Queries the details of a specified sensitive field in Data Security Guard.
   * 
   * @param request - QueryRecognizeRuleDetailRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryRecognizeRuleDetailResponse
   */
  async queryRecognizeRuleDetailWithOptions(request: QueryRecognizeRuleDetailRequest, runtime: $Util.RuntimeOptions): Promise<QueryRecognizeRuleDetailResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.sensitiveName)) {
      body["SensitiveName"] = request.sensitiveName;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryRecognizeRuleDetail",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryRecognizeRuleDetailResponse>(await this.callApi(params, req, runtime), new QueryRecognizeRuleDetailResponse({}));
  }

  /**
   * Queries the details of a specified sensitive field in Data Security Guard.
   * 
   * @param request - QueryRecognizeRuleDetailRequest
   * @returns QueryRecognizeRuleDetailResponse
   */
  async queryRecognizeRuleDetail(request: QueryRecognizeRuleDetailRequest): Promise<QueryRecognizeRuleDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryRecognizeRuleDetailWithOptions(request, runtime);
  }

  /**
   * Queries the built-in sensitive data identification rule that is used to configure a sensitive field.
   * 
   * @param request - QueryRecognizeRulesTypeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QueryRecognizeRulesTypeResponse
   */
  async queryRecognizeRulesTypeWithOptions(runtime: $Util.RuntimeOptions): Promise<QueryRecognizeRulesTypeResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "QueryRecognizeRulesType",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryRecognizeRulesTypeResponse>(await this.callApi(params, req, runtime), new QueryRecognizeRulesTypeResponse({}));
  }

  /**
   * Queries the built-in sensitive data identification rule that is used to configure a sensitive field.
   * @returns QueryRecognizeRulesTypeResponse
   */
  async queryRecognizeRulesType(): Promise<QueryRecognizeRulesTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryRecognizeRulesTypeWithOptions(runtime);
  }

  /**
   * Queries data categories.
   * 
   * @param request - QuerySensClassificationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QuerySensClassificationResponse
   */
  async querySensClassificationWithOptions(request: QuerySensClassificationRequest, runtime: $Util.RuntimeOptions): Promise<QuerySensClassificationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.templateId)) {
      body["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySensClassification",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySensClassificationResponse>(await this.callApi(params, req, runtime), new QuerySensClassificationResponse({}));
  }

  /**
   * Queries data categories.
   * 
   * @param request - QuerySensClassificationRequest
   * @returns QuerySensClassificationResponse
   */
  async querySensClassification(request: QuerySensClassificationRequest): Promise<QuerySensClassificationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySensClassificationWithOptions(request, runtime);
  }

  /**
   * Queries data sensitivity levels in Data Security Guard.
   * 
   * @param request - QuerySensLevelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QuerySensLevelResponse
   */
  async querySensLevelWithOptions(request: QuerySensLevelRequest, runtime: $Util.RuntimeOptions): Promise<QuerySensLevelResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.templateId)) {
      body["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["tenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySensLevel",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySensLevelResponse>(await this.callApi(params, req, runtime), new QuerySensLevelResponse({}));
  }

  /**
   * Queries data sensitivity levels in Data Security Guard.
   * 
   * @param request - QuerySensLevelRequest
   * @returns QuerySensLevelResponse
   */
  async querySensLevel(request: QuerySensLevelRequest): Promise<QuerySensLevelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySensLevelWithOptions(request, runtime);
  }

  /**
   * Queries sensitive data identification rules.
   * 
   * @param request - QuerySensNodeInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns QuerySensNodeInfoResponse
   */
  async querySensNodeInfoWithOptions(request: QuerySensNodeInfoRequest, runtime: $Util.RuntimeOptions): Promise<QuerySensNodeInfoResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.pageNo)) {
      body["PageNo"] = request.pageNo;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sensitiveName)) {
      body["SensitiveName"] = request.sensitiveName;
    }

    if (!Util.isUnset(request.templateId)) {
      body["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.status)) {
      body["status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QuerySensNodeInfo",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QuerySensNodeInfoResponse>(await this.callApi(params, req, runtime), new QuerySensNodeInfoResponse({}));
  }

  /**
   * Queries sensitive data identification rules.
   * 
   * @param request - QuerySensNodeInfoRequest
   * @returns QuerySensNodeInfoResponse
   */
  async querySensNodeInfo(request: QuerySensNodeInfoRequest): Promise<QuerySensNodeInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.querySensNodeInfoWithOptions(request, runtime);
  }

  /**
   * Registers the lineage between self-managed entities to DataWorks.
   * 
   * @remarks
   * This operation is in the trial phase. Users who need to call this operation can apply for it. The users can call this operation after the administrator adds the users to the trial list.
   * 
   * @param tmpReq - RegisterLineageRelationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RegisterLineageRelationResponse
   */
  async registerLineageRelationWithOptions(tmpReq: RegisterLineageRelationRequest, runtime: $Util.RuntimeOptions): Promise<RegisterLineageRelationResponse> {
    Util.validateModel(tmpReq);
    let request = new RegisterLineageRelationShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.lineageRelationRegisterVO)) {
      request.lineageRelationRegisterVOShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.lineageRelationRegisterVO, "LineageRelationRegisterVO", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.lineageRelationRegisterVOShrink)) {
      body["LineageRelationRegisterVO"] = request.lineageRelationRegisterVOShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RegisterLineageRelation",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RegisterLineageRelationResponse>(await this.callApi(params, req, runtime), new RegisterLineageRelationResponse({}));
  }

  /**
   * Registers the lineage between self-managed entities to DataWorks.
   * 
   * @remarks
   * This operation is in the trial phase. Users who need to call this operation can apply for it. The users can call this operation after the administrator adds the users to the trial list.
   * 
   * @param request - RegisterLineageRelationRequest
   * @returns RegisterLineageRelationResponse
   */
  async registerLineageRelation(request: RegisterLineageRelationRequest): Promise<RegisterLineageRelationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.registerLineageRelationWithOptions(request, runtime);
  }

  /**
   * Removes tags from an entity. Only entities of the maxcompute-table type are supported.
   * 
   * @param tmpReq - RemoveEntityTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveEntityTagsResponse
   */
  async removeEntityTagsWithOptions(tmpReq: RemoveEntityTagsRequest, runtime: $Util.RuntimeOptions): Promise<RemoveEntityTagsResponse> {
    Util.validateModel(tmpReq);
    let request = new RemoveEntityTagsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tagKeys)) {
      request.tagKeysShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tagKeys, "TagKeys", "json");
    }

    let query = { };
    if (!Util.isUnset(request.qualifiedName)) {
      query["QualifiedName"] = request.qualifiedName;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tagKeysShrink)) {
      body["TagKeys"] = request.tagKeysShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RemoveEntityTags",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveEntityTagsResponse>(await this.callApi(params, req, runtime), new RemoveEntityTagsResponse({}));
  }

  /**
   * Removes tags from an entity. Only entities of the maxcompute-table type are supported.
   * 
   * @param request - RemoveEntityTagsRequest
   * @returns RemoveEntityTagsResponse
   */
  async removeEntityTags(request: RemoveEntityTagsRequest): Promise<RemoveEntityTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeEntityTagsWithOptions(request, runtime);
  }

  /**
   * Removes a role from a user in a DataWorks workspace.
   * 
   * @param request - RemoveProjectMemberFromRoleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RemoveProjectMemberFromRoleResponse
   */
  async removeProjectMemberFromRoleWithOptions(request: RemoveProjectMemberFromRoleRequest, runtime: $Util.RuntimeOptions): Promise<RemoveProjectMemberFromRoleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.roleCode)) {
      query["RoleCode"] = request.roleCode;
    }

    if (!Util.isUnset(request.userId)) {
      query["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveProjectMemberFromRole",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveProjectMemberFromRoleResponse>(await this.callApi(params, req, runtime), new RemoveProjectMemberFromRoleResponse({}));
  }

  /**
   * Removes a role from a user in a DataWorks workspace.
   * 
   * @param request - RemoveProjectMemberFromRoleRequest
   * @returns RemoveProjectMemberFromRoleResponse
   */
  async removeProjectMemberFromRole(request: RemoveProjectMemberFromRoleRequest): Promise<RemoveProjectMemberFromRoleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeProjectMemberFromRoleWithOptions(request, runtime);
  }

  /**
   * Restarts an instance.
   * 
   * @param request - RestartInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RestartInstanceResponse
   */
  async restartInstanceWithOptions(request: RestartInstanceRequest, runtime: $Util.RuntimeOptions): Promise<RestartInstanceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RestartInstance",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RestartInstanceResponse>(await this.callApi(params, req, runtime), new RestartInstanceResponse({}));
  }

  /**
   * Restarts an instance.
   * 
   * @param request - RestartInstanceRequest
   * @returns RestartInstanceResponse
   */
  async restartInstance(request: RestartInstanceRequest): Promise<RestartInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.restartInstanceWithOptions(request, runtime);
  }

  /**
   * Resumes a suspended instance.
   * 
   * @param request - ResumeInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ResumeInstanceResponse
   */
  async resumeInstanceWithOptions(request: ResumeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<ResumeInstanceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ResumeInstance",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResumeInstanceResponse>(await this.callApi(params, req, runtime), new ResumeInstanceResponse({}));
  }

  /**
   * Resumes a suspended instance.
   * 
   * @param request - ResumeInstanceRequest
   * @returns ResumeInstanceResponse
   */
  async resumeInstance(request: ResumeInstanceRequest): Promise<ResumeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resumeInstanceWithOptions(request, runtime);
  }

  /**
   * Revokes permissions on table fields from a user.
   * 
   * @param request - RevokeColumnPermissionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RevokeColumnPermissionResponse
   */
  async revokeColumnPermissionWithOptions(request: RevokeColumnPermissionRequest, runtime: $Util.RuntimeOptions): Promise<RevokeColumnPermissionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.columns)) {
      query["Columns"] = request.columns;
    }

    if (!Util.isUnset(request.maxComputeProjectName)) {
      query["MaxComputeProjectName"] = request.maxComputeProjectName;
    }

    if (!Util.isUnset(request.revokeUserId)) {
      query["RevokeUserId"] = request.revokeUserId;
    }

    if (!Util.isUnset(request.revokeUserName)) {
      query["RevokeUserName"] = request.revokeUserName;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.workspaceId)) {
      query["WorkspaceId"] = request.workspaceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RevokeColumnPermission",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RevokeColumnPermissionResponse>(await this.callApi(params, req, runtime), new RevokeColumnPermissionResponse({}));
  }

  /**
   * Revokes permissions on table fields from a user.
   * 
   * @param request - RevokeColumnPermissionRequest
   * @returns RevokeColumnPermissionResponse
   */
  async revokeColumnPermission(request: RevokeColumnPermissionRequest): Promise<RevokeColumnPermissionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.revokeColumnPermissionWithOptions(request, runtime);
  }

  /**
   * Revokes permissions on a table from a user.
   * 
   * @param request - RevokeTablePermissionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RevokeTablePermissionResponse
   */
  async revokeTablePermissionWithOptions(request: RevokeTablePermissionRequest, runtime: $Util.RuntimeOptions): Promise<RevokeTablePermissionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actions)) {
      query["Actions"] = request.actions;
    }

    if (!Util.isUnset(request.maxComputeProjectName)) {
      query["MaxComputeProjectName"] = request.maxComputeProjectName;
    }

    if (!Util.isUnset(request.revokeUserId)) {
      query["RevokeUserId"] = request.revokeUserId;
    }

    if (!Util.isUnset(request.revokeUserName)) {
      query["RevokeUserName"] = request.revokeUserName;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.workspaceId)) {
      query["WorkspaceId"] = request.workspaceId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RevokeTablePermission",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RevokeTablePermissionResponse>(await this.callApi(params, req, runtime), new RevokeTablePermissionResponse({}));
  }

  /**
   * Revokes permissions on a table from a user.
   * 
   * @param request - RevokeTablePermissionRequest
   * @returns RevokeTablePermissionResponse
   */
  async revokeTablePermission(request: RevokeTablePermissionRequest): Promise<RevokeTablePermissionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.revokeTablePermissionWithOptions(request, runtime);
  }

  /**
   * Creates a workflow to backfill data.
   * 
   * @remarks
   * For more information about data backfill, see [Backfill data](https://help.aliyun.com/document_detail/137937.html).
   * 
   * @param request - RunCycleDagNodesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RunCycleDagNodesResponse
   */
  async runCycleDagNodesWithOptions(request: RunCycleDagNodesRequest, runtime: $Util.RuntimeOptions): Promise<RunCycleDagNodesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alertNoticeType)) {
      body["AlertNoticeType"] = request.alertNoticeType;
    }

    if (!Util.isUnset(request.alertType)) {
      body["AlertType"] = request.alertType;
    }

    if (!Util.isUnset(request.bizBeginTime)) {
      body["BizBeginTime"] = request.bizBeginTime;
    }

    if (!Util.isUnset(request.bizEndTime)) {
      body["BizEndTime"] = request.bizEndTime;
    }

    if (!Util.isUnset(request.concurrentRuns)) {
      body["ConcurrentRuns"] = request.concurrentRuns;
    }

    if (!Util.isUnset(request.endBizDate)) {
      body["EndBizDate"] = request.endBizDate;
    }

    if (!Util.isUnset(request.excludeNodeIds)) {
      body["ExcludeNodeIds"] = request.excludeNodeIds;
    }

    if (!Util.isUnset(request.includeNodeIds)) {
      body["IncludeNodeIds"] = request.includeNodeIds;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.nodeParams)) {
      body["NodeParams"] = request.nodeParams;
    }

    if (!Util.isUnset(request.parallelism)) {
      body["Parallelism"] = request.parallelism;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.rootNodeId)) {
      body["RootNodeId"] = request.rootNodeId;
    }

    if (!Util.isUnset(request.startBizDate)) {
      body["StartBizDate"] = request.startBizDate;
    }

    if (!Util.isUnset(request.startFutureInstanceImmediately)) {
      body["StartFutureInstanceImmediately"] = request.startFutureInstanceImmediately;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RunCycleDagNodes",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RunCycleDagNodesResponse>(await this.callApi(params, req, runtime), new RunCycleDagNodesResponse({}));
  }

  /**
   * Creates a workflow to backfill data.
   * 
   * @remarks
   * For more information about data backfill, see [Backfill data](https://help.aliyun.com/document_detail/137937.html).
   * 
   * @param request - RunCycleDagNodesRequest
   * @returns RunCycleDagNodesResponse
   */
  async runCycleDagNodes(request: RunCycleDagNodesRequest): Promise<RunCycleDagNodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.runCycleDagNodesWithOptions(request, runtime);
  }

  /**
   * Runs nodes in a manually triggered workflow. Before you call this operation, make sure that the manually triggered workflow is committed and deployed. You can find a manually triggered workflow in Operation Center only after the manually triggered workflow is committed and deployed.
   * 
   * @param request - RunManualDagNodesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RunManualDagNodesResponse
   */
  async runManualDagNodesWithOptions(request: RunManualDagNodesRequest, runtime: $Util.RuntimeOptions): Promise<RunManualDagNodesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizDate)) {
      body["BizDate"] = request.bizDate;
    }

    if (!Util.isUnset(request.dagParameters)) {
      body["DagParameters"] = request.dagParameters;
    }

    if (!Util.isUnset(request.endBizDate)) {
      body["EndBizDate"] = request.endBizDate;
    }

    if (!Util.isUnset(request.excludeNodeIds)) {
      body["ExcludeNodeIds"] = request.excludeNodeIds;
    }

    if (!Util.isUnset(request.flowName)) {
      body["FlowName"] = request.flowName;
    }

    if (!Util.isUnset(request.includeNodeIds)) {
      body["IncludeNodeIds"] = request.includeNodeIds;
    }

    if (!Util.isUnset(request.nodeParameters)) {
      body["NodeParameters"] = request.nodeParameters;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.startBizDate)) {
      body["StartBizDate"] = request.startBizDate;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RunManualDagNodes",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RunManualDagNodesResponse>(await this.callApi(params, req, runtime), new RunManualDagNodesResponse({}));
  }

  /**
   * Runs nodes in a manually triggered workflow. Before you call this operation, make sure that the manually triggered workflow is committed and deployed. You can find a manually triggered workflow in Operation Center only after the manually triggered workflow is committed and deployed.
   * 
   * @param request - RunManualDagNodesRequest
   * @returns RunManualDagNodesResponse
   */
  async runManualDagNodes(request: RunManualDagNodesRequest): Promise<RunManualDagNodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.runManualDagNodesWithOptions(request, runtime);
  }

  /**
   * Creates a workflow to perform smoke testing.
   * 
   * @param request - RunSmokeTestRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RunSmokeTestResponse
   */
  async runSmokeTestWithOptions(request: RunSmokeTestRequest, runtime: $Util.RuntimeOptions): Promise<RunSmokeTestResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizdate)) {
      body["Bizdate"] = request.bizdate;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeParams)) {
      body["NodeParams"] = request.nodeParams;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RunSmokeTest",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RunSmokeTestResponse>(await this.callApi(params, req, runtime), new RunSmokeTestResponse({}));
  }

  /**
   * Creates a workflow to perform smoke testing.
   * 
   * @param request - RunSmokeTestRequest
   * @returns RunSmokeTestResponse
   */
  async runSmokeTest(request: RunSmokeTestRequest): Promise<RunSmokeTestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.runSmokeTestWithOptions(request, runtime);
  }

  /**
   * Runs a manually triggered node.
   * 
   * @param request - RunTriggerNodeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns RunTriggerNodeResponse
   */
  async runTriggerNodeWithOptions(request: RunTriggerNodeRequest, runtime: $Util.RuntimeOptions): Promise<RunTriggerNodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.appId)) {
      body["AppId"] = request.appId;
    }

    if (!Util.isUnset(request.bizDate)) {
      body["BizDate"] = request.bizDate;
    }

    if (!Util.isUnset(request.cycleTime)) {
      body["CycleTime"] = request.cycleTime;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RunTriggerNode",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RunTriggerNodeResponse>(await this.callApi(params, req, runtime), new RunTriggerNodeResponse({}));
  }

  /**
   * Runs a manually triggered node.
   * 
   * @param request - RunTriggerNodeRequest
   * @returns RunTriggerNodeResponse
   */
  async runTriggerNode(request: RunTriggerNodeRequest): Promise<RunTriggerNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.runTriggerNodeWithOptions(request, runtime);
  }

  /**
   * Saves the test results of an API.
   * 
   * @param request - SaveDataServiceApiTestResultRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SaveDataServiceApiTestResultResponse
   */
  async saveDataServiceApiTestResultWithOptions(request: SaveDataServiceApiTestResultRequest, runtime: $Util.RuntimeOptions): Promise<SaveDataServiceApiTestResultResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiId)) {
      body["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.autoGenerate)) {
      body["AutoGenerate"] = request.autoGenerate;
    }

    if (!Util.isUnset(request.failResultSample)) {
      body["FailResultSample"] = request.failResultSample;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.resultSample)) {
      body["ResultSample"] = request.resultSample;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SaveDataServiceApiTestResult",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SaveDataServiceApiTestResultResponse>(await this.callApi(params, req, runtime), new SaveDataServiceApiTestResultResponse({}));
  }

  /**
   * Saves the test results of an API.
   * 
   * @param request - SaveDataServiceApiTestResultRequest
   * @returns SaveDataServiceApiTestResultResponse
   */
  async saveDataServiceApiTestResult(request: SaveDataServiceApiTestResultRequest): Promise<SaveDataServiceApiTestResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.saveDataServiceApiTestResultWithOptions(request, runtime);
  }

  /**
   * Checks whether input data contains sensitive data.
   * 
   * @param request - ScanSensitiveDataRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns ScanSensitiveDataResponse
   */
  async scanSensitiveDataWithOptions(request: ScanSensitiveDataRequest, runtime: $Util.RuntimeOptions): Promise<ScanSensitiveDataResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ScanSensitiveData",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ScanSensitiveDataResponse>(await this.callApi(params, req, runtime), new ScanSensitiveDataResponse({}));
  }

  /**
   * Checks whether input data contains sensitive data.
   * 
   * @param request - ScanSensitiveDataRequest
   * @returns ScanSensitiveDataResponse
   */
  async scanSensitiveData(request: ScanSensitiveDataRequest): Promise<ScanSensitiveDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.scanSensitiveDataWithOptions(request, runtime);
  }

  /**
   * Queries metatables based on specific conditions.
   * 
   * @remarks
   * You can call this operation to query only metatables in a MaxCompute or E-MapReduce (EMR) compute engine.
   * 
   * @param request - SearchMetaTablesRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchMetaTablesResponse
   */
  async searchMetaTablesWithOptions(request: SearchMetaTablesRequest, runtime: $Util.RuntimeOptions): Promise<SearchMetaTablesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appGuid)) {
      query["AppGuid"] = request.appGuid;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dataSourceType)) {
      query["DataSourceType"] = request.dataSourceType;
    }

    if (!Util.isUnset(request.entityType)) {
      query["EntityType"] = request.entityType;
    }

    if (!Util.isUnset(request.keyword)) {
      query["Keyword"] = request.keyword;
    }

    if (!Util.isUnset(request.pageNumber)) {
      query["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.schema)) {
      query["Schema"] = request.schema;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SearchMetaTables",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchMetaTablesResponse>(await this.callApi(params, req, runtime), new SearchMetaTablesResponse({}));
  }

  /**
   * Queries metatables based on specific conditions.
   * 
   * @remarks
   * You can call this operation to query only metatables in a MaxCompute or E-MapReduce (EMR) compute engine.
   * 
   * @param request - SearchMetaTablesRequest
   * @returns SearchMetaTablesResponse
   */
  async searchMetaTables(request: SearchMetaTablesRequest): Promise<SearchMetaTablesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchMetaTablesWithOptions(request, runtime);
  }

  /**
   * Queries a node based on the output.
   * 
   * @deprecated OpenAPI SearchNodesByOutput is deprecated
   * 
   * @param request - SearchNodesByOutputRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SearchNodesByOutputResponse
   */
  // Deprecated
  async searchNodesByOutputWithOptions(request: SearchNodesByOutputRequest, runtime: $Util.RuntimeOptions): Promise<SearchNodesByOutputResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.outputs)) {
      body["Outputs"] = request.outputs;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SearchNodesByOutput",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SearchNodesByOutputResponse>(await this.callApi(params, req, runtime), new SearchNodesByOutputResponse({}));
  }

  /**
   * Queries a node based on the output.
   * 
   * @deprecated OpenAPI SearchNodesByOutput is deprecated
   * 
   * @param request - SearchNodesByOutputRequest
   * @returns SearchNodesByOutputResponse
   */
  // Deprecated
  async searchNodesByOutput(request: SearchNodesByOutputRequest): Promise<SearchNodesByOutputResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.searchNodesByOutputWithOptions(request, runtime);
  }

  /**
   * Shares a data source to a specific DataWorks workspace or a specific user.
   * 
   * @deprecated OpenAPI SetDataSourceShare is deprecated
   * 
   * @param request - SetDataSourceShareRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetDataSourceShareResponse
   */
  // Deprecated
  async setDataSourceShareWithOptions(request: SetDataSourceShareRequest, runtime: $Util.RuntimeOptions): Promise<SetDataSourceShareResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasourceName)) {
      query["DatasourceName"] = request.datasourceName;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectPermissions)) {
      query["ProjectPermissions"] = request.projectPermissions;
    }

    if (!Util.isUnset(request.userPermissions)) {
      query["UserPermissions"] = request.userPermissions;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetDataSourceShare",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetDataSourceShareResponse>(await this.callApi(params, req, runtime), new SetDataSourceShareResponse({}));
  }

  /**
   * Shares a data source to a specific DataWorks workspace or a specific user.
   * 
   * @deprecated OpenAPI SetDataSourceShare is deprecated
   * 
   * @param request - SetDataSourceShareRequest
   * @returns SetDataSourceShareResponse
   */
  // Deprecated
  async setDataSourceShare(request: SetDataSourceShareRequest): Promise<SetDataSourceShareResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setDataSourceShareWithOptions(request, runtime);
  }

  /**
   * Configures tags for an entity. Only entities of the maxcompute-table type are supported.
   * 
   * @param tmpReq - SetEntityTagsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetEntityTagsResponse
   */
  async setEntityTagsWithOptions(tmpReq: SetEntityTagsRequest, runtime: $Util.RuntimeOptions): Promise<SetEntityTagsResponse> {
    Util.validateModel(tmpReq);
    let request = new SetEntityTagsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.tags)) {
      request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
    }

    let query = { };
    if (!Util.isUnset(request.qualifiedName)) {
      query["QualifiedName"] = request.qualifiedName;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tagsShrink)) {
      body["Tags"] = request.tagsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SetEntityTags",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetEntityTagsResponse>(await this.callApi(params, req, runtime), new SetEntityTagsResponse({}));
  }

  /**
   * Configures tags for an entity. Only entities of the maxcompute-table type are supported.
   * 
   * @param request - SetEntityTagsRequest
   * @returns SetEntityTagsResponse
   */
  async setEntityTags(request: SetEntityTagsRequest): Promise<SetEntityTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setEntityTagsWithOptions(request, runtime);
  }

  /**
   * Sets the state of a failed instance to successful.
   * 
   * @param request - SetSuccessInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SetSuccessInstanceResponse
   */
  async setSuccessInstanceWithOptions(request: SetSuccessInstanceRequest, runtime: $Util.RuntimeOptions): Promise<SetSuccessInstanceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SetSuccessInstance",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetSuccessInstanceResponse>(await this.callApi(params, req, runtime), new SetSuccessInstanceResponse({}));
  }

  /**
   * Sets the state of a failed instance to successful.
   * 
   * @param request - SetSuccessInstanceRequest
   * @returns SetSuccessInstanceResponse
   */
  async setSuccessInstance(request: SetSuccessInstanceRequest): Promise<SetSuccessInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setSuccessInstanceWithOptions(request, runtime);
  }

  /**
   * Starts a synchronization task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @param tmpReq - StartDIJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartDIJobResponse
   */
  async startDIJobWithOptions(tmpReq: StartDIJobRequest, runtime: $Util.RuntimeOptions): Promise<StartDIJobResponse> {
    Util.validateModel(tmpReq);
    let request = new StartDIJobShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.realtimeStartSettings)) {
      request.realtimeStartSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.realtimeStartSettings, "RealtimeStartSettings", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.DIJobId)) {
      body["DIJobId"] = request.DIJobId;
    }

    if (!Util.isUnset(request.forceToRerun)) {
      body["ForceToRerun"] = request.forceToRerun;
    }

    if (!Util.isUnset(request.realtimeStartSettingsShrink)) {
      body["RealtimeStartSettings"] = request.realtimeStartSettingsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StartDIJob",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartDIJobResponse>(await this.callApi(params, req, runtime), new StartDIJobResponse({}));
  }

  /**
   * Starts a synchronization task of a new version. Only the following type of task is supported: real-time data synchronization from a MySQL database to Hologres.
   * 
   * @param request - StartDIJobRequest
   * @returns StartDIJobResponse
   */
  async startDIJob(request: StartDIJobRequest): Promise<StartDIJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startDIJobWithOptions(request, runtime);
  }

  /**
   * Starts a real-time synchronization task or a synchronization solution.
   * 
   * @param request - StartDISyncInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartDISyncInstanceResponse
   */
  async startDISyncInstanceWithOptions(request: StartDISyncInstanceRequest, runtime: $Util.RuntimeOptions): Promise<StartDISyncInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileId)) {
      query["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.startParam)) {
      query["StartParam"] = request.startParam;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartDISyncInstance",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartDISyncInstanceResponse>(await this.callApi(params, req, runtime), new StartDISyncInstanceResponse({}));
  }

  /**
   * Starts a real-time synchronization task or a synchronization solution.
   * 
   * @param request - StartDISyncInstanceRequest
   * @returns StartDISyncInstanceResponse
   */
  async startDISyncInstance(request: StartDISyncInstanceRequest): Promise<StartDISyncInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startDISyncInstanceWithOptions(request, runtime);
  }

  /**
   * Starts a migration task.
   * 
   * @param request - StartMigrationRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StartMigrationResponse
   */
  async startMigrationWithOptions(request: StartMigrationRequest, runtime: $Util.RuntimeOptions): Promise<StartMigrationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.migrationId)) {
      body["MigrationId"] = request.migrationId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StartMigration",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartMigrationResponse>(await this.callApi(params, req, runtime), new StartMigrationResponse({}));
  }

  /**
   * Starts a migration task.
   * 
   * @param request - StartMigrationRequest
   * @returns StartMigrationResponse
   */
  async startMigration(request: StartMigrationRequest): Promise<StartMigrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startMigrationWithOptions(request, runtime);
  }

  /**
   * Stops a new-version synchronization task. The following type of synchronization task is supported: real-time synchronization of all data in a MySQL database to Hologres.
   * 
   * @param request - StopDIJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopDIJobResponse
   */
  async stopDIJobWithOptions(request: StopDIJobRequest, runtime: $Util.RuntimeOptions): Promise<StopDIJobResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.DIJobId)) {
      body["DIJobId"] = request.DIJobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StopDIJob",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopDIJobResponse>(await this.callApi(params, req, runtime), new StopDIJobResponse({}));
  }

  /**
   * Stops a new-version synchronization task. The following type of synchronization task is supported: real-time synchronization of all data in a MySQL database to Hologres.
   * 
   * @param request - StopDIJobRequest
   * @returns StopDIJobResponse
   */
  async stopDIJob(request: StopDIJobRequest): Promise<StopDIJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopDIJobWithOptions(request, runtime);
  }

  /**
   * Stops a real-time synchronization task.
   * 
   * @param request - StopDISyncInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopDISyncInstanceResponse
   */
  async stopDISyncInstanceWithOptions(request: StopDISyncInstanceRequest, runtime: $Util.RuntimeOptions): Promise<StopDISyncInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileId)) {
      query["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopDISyncInstance",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopDISyncInstanceResponse>(await this.callApi(params, req, runtime), new StopDISyncInstanceResponse({}));
  }

  /**
   * Stops a real-time synchronization task.
   * 
   * @param request - StopDISyncInstanceRequest
   * @returns StopDISyncInstanceResponse
   */
  async stopDISyncInstance(request: StopDISyncInstanceRequest): Promise<StopDISyncInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopDISyncInstanceWithOptions(request, runtime);
  }

  /**
   * Terminates an instance.
   * 
   * @param request - StopInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns StopInstanceResponse
   */
  async stopInstanceWithOptions(request: StopInstanceRequest, runtime: $Util.RuntimeOptions): Promise<StopInstanceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StopInstance",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopInstanceResponse>(await this.callApi(params, req, runtime), new StopInstanceResponse({}));
  }

  /**
   * Terminates an instance.
   * 
   * @param request - StopInstanceRequest
   * @returns StopInstanceResponse
   */
  async stopInstance(request: StopInstanceRequest): Promise<StopInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopInstanceWithOptions(request, runtime);
  }

  /**
   * Submits an API in DataService Studio.
   * 
   * @param request - SubmitDataServiceApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SubmitDataServiceApiResponse
   */
  async submitDataServiceApiWithOptions(request: SubmitDataServiceApiRequest, runtime: $Util.RuntimeOptions): Promise<SubmitDataServiceApiResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiId)) {
      body["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SubmitDataServiceApi",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SubmitDataServiceApiResponse>(await this.callApi(params, req, runtime), new SubmitDataServiceApiResponse({}));
  }

  /**
   * Submits an API in DataService Studio.
   * 
   * @param request - SubmitDataServiceApiRequest
   * @returns SubmitDataServiceApiResponse
   */
  async submitDataServiceApi(request: SubmitDataServiceApiRequest): Promise<SubmitDataServiceApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitDataServiceApiWithOptions(request, runtime);
  }

  /**
   * Commits a file to the development environment of the scheduling system to generate a task.
   * 
   * @param request - SubmitFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SubmitFileResponse
   */
  async submitFileWithOptions(request: SubmitFileRequest, runtime: $Util.RuntimeOptions): Promise<SubmitFileResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.comment)) {
      body["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.fileId)) {
      body["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    if (!Util.isUnset(request.skipAllDeployFileExtensions)) {
      body["SkipAllDeployFileExtensions"] = request.skipAllDeployFileExtensions;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SubmitFile",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SubmitFileResponse>(await this.callApi(params, req, runtime), new SubmitFileResponse({}));
  }

  /**
   * Commits a file to the development environment of the scheduling system to generate a task.
   * 
   * @param request - SubmitFileRequest
   * @returns SubmitFileResponse
   */
  async submitFile(request: SubmitFileRequest): Promise<SubmitFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitFileWithOptions(request, runtime);
  }

  /**
   * Suspends an instance.
   * 
   * @param request - SuspendInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns SuspendInstanceResponse
   */
  async suspendInstanceWithOptions(request: SuspendInstanceRequest, runtime: $Util.RuntimeOptions): Promise<SuspendInstanceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.instanceId)) {
      body["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SuspendInstance",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SuspendInstanceResponse>(await this.callApi(params, req, runtime), new SuspendInstanceResponse({}));
  }

  /**
   * Suspends an instance.
   * 
   * @param request - SuspendInstanceRequest
   * @returns SuspendInstanceResponse
   */
  async suspendInstance(request: SuspendInstanceRequest): Promise<SuspendInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.suspendInstanceWithOptions(request, runtime);
  }

  /**
   * Undeploys a real-time synchronization task.
   * 
   * @param request - TerminateDISyncInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TerminateDISyncInstanceResponse
   */
  async terminateDISyncInstanceWithOptions(request: TerminateDISyncInstanceRequest, runtime: $Util.RuntimeOptions): Promise<TerminateDISyncInstanceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileId)) {
      query["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TerminateDISyncInstance",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TerminateDISyncInstanceResponse>(await this.callApi(params, req, runtime), new TerminateDISyncInstanceResponse({}));
  }

  /**
   * Undeploys a real-time synchronization task.
   * 
   * @param request - TerminateDISyncInstanceRequest
   * @returns TerminateDISyncInstanceResponse
   */
  async terminateDISyncInstance(request: TerminateDISyncInstanceRequest): Promise<TerminateDISyncInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.terminateDISyncInstanceWithOptions(request, runtime);
  }

  /**
   * Tests a DataService Studio API in asynchronous mode. You can call the GetDataServiceApiTest operation to query the test result.
   * 
   * @param request - TestDataServiceApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TestDataServiceApiResponse
   */
  async testDataServiceApiWithOptions(request: TestDataServiceApiRequest, runtime: $Util.RuntimeOptions): Promise<TestDataServiceApiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiId)) {
      query["ApiId"] = request.apiId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bodyContent)) {
      body["BodyContent"] = request.bodyContent;
    }

    if (!Util.isUnset(request.bodyParams)) {
      body["BodyParams"] = request.bodyParams;
    }

    if (!Util.isUnset(request.headParams)) {
      body["HeadParams"] = request.headParams;
    }

    if (!Util.isUnset(request.pathParams)) {
      body["PathParams"] = request.pathParams;
    }

    if (!Util.isUnset(request.queryParam)) {
      body["QueryParam"] = request.queryParam;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "TestDataServiceApi",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TestDataServiceApiResponse>(await this.callApi(params, req, runtime), new TestDataServiceApiResponse({}));
  }

  /**
   * Tests a DataService Studio API in asynchronous mode. You can call the GetDataServiceApiTest operation to query the test result.
   * 
   * @param request - TestDataServiceApiRequest
   * @returns TestDataServiceApiResponse
   */
  async testDataServiceApi(request: TestDataServiceApiRequest): Promise<TestDataServiceApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.testDataServiceApiWithOptions(request, runtime);
  }

  /**
   * Tests the network connectivity between a data source and a resource group.
   * 
   * @param request - TestNetworkConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TestNetworkConnectionResponse
   */
  async testNetworkConnectionWithOptions(request: TestNetworkConnectionRequest, runtime: $Util.RuntimeOptions): Promise<TestNetworkConnectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.datasourceName)) {
      query["DatasourceName"] = request.datasourceName;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.resourceGroup)) {
      query["ResourceGroup"] = request.resourceGroup;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TestNetworkConnection",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TestNetworkConnectionResponse>(await this.callApi(params, req, runtime), new TestNetworkConnectionResponse({}));
  }

  /**
   * Tests the network connectivity between a data source and a resource group.
   * 
   * @param request - TestNetworkConnectionRequest
   * @returns TestNetworkConnectionResponse
   */
  async testNetworkConnection(request: TestNetworkConnectionRequest): Promise<TestNetworkConnectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.testNetworkConnectionWithOptions(request, runtime);
  }

  /**
   * Queries the ranking of the running durations of instances.
   * 
   * @param request - TopTenElapsedTimeInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TopTenElapsedTimeInstanceResponse
   */
  async topTenElapsedTimeInstanceWithOptions(request: TopTenElapsedTimeInstanceRequest, runtime: $Util.RuntimeOptions): Promise<TopTenElapsedTimeInstanceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "TopTenElapsedTimeInstance",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TopTenElapsedTimeInstanceResponse>(await this.callApi(params, req, runtime), new TopTenElapsedTimeInstanceResponse({}));
  }

  /**
   * Queries the ranking of the running durations of instances.
   * 
   * @param request - TopTenElapsedTimeInstanceRequest
   * @returns TopTenElapsedTimeInstanceResponse
   */
  async topTenElapsedTimeInstance(request: TopTenElapsedTimeInstanceRequest): Promise<TopTenElapsedTimeInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.topTenElapsedTimeInstanceWithOptions(request, runtime);
  }

  /**
   * Queries the ranking of nodes on which errors occur within the previous month.
   * 
   * @param request - TopTenErrorTimesInstanceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns TopTenErrorTimesInstanceResponse
   */
  async topTenErrorTimesInstanceWithOptions(request: TopTenErrorTimesInstanceRequest, runtime: $Util.RuntimeOptions): Promise<TopTenErrorTimesInstanceResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "TopTenErrorTimesInstance",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TopTenErrorTimesInstanceResponse>(await this.callApi(params, req, runtime), new TopTenErrorTimesInstanceResponse({}));
  }

  /**
   * Queries the ranking of nodes on which errors occur within the previous month.
   * 
   * @param request - TopTenErrorTimesInstanceRequest
   * @returns TopTenErrorTimesInstanceResponse
   */
  async topTenErrorTimesInstance(request: TopTenErrorTimesInstanceRequest): Promise<TopTenErrorTimesInstanceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.topTenErrorTimesInstanceWithOptions(request, runtime);
  }

  /**
   * Removes a directory from the left-side navigation pane of DataAnalysis.
   * 
   * @param request - UmountDirectoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UmountDirectoryResponse
   */
  async umountDirectoryWithOptions(request: UmountDirectoryRequest, runtime: $Util.RuntimeOptions): Promise<UmountDirectoryResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.targetId)) {
      body["TargetId"] = request.targetId;
    }

    if (!Util.isUnset(request.targetType)) {
      body["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.targetUserId)) {
      body["TargetUserId"] = request.targetUserId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UmountDirectory",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UmountDirectoryResponse>(await this.callApi(params, req, runtime), new UmountDirectoryResponse({}));
  }

  /**
   * Removes a directory from the left-side navigation pane of DataAnalysis.
   * 
   * @param request - UmountDirectoryRequest
   * @returns UmountDirectoryResponse
   */
  async umountDirectory(request: UmountDirectoryRequest): Promise<UmountDirectoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.umountDirectoryWithOptions(request, runtime);
  }

  /**
   * 更新基线
   * 
   * @param tmpReq - UpdateBaselineRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateBaselineResponse
   */
  async updateBaselineWithOptions(tmpReq: UpdateBaselineRequest, runtime: $Util.RuntimeOptions): Promise<UpdateBaselineResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateBaselineShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.alertSettings)) {
      request.alertSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alertSettings, "AlertSettings", "json");
    }

    if (!Util.isUnset(tmpReq.overtimeSettings)) {
      request.overtimeSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.overtimeSettings, "OvertimeSettings", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alertEnabled)) {
      body["AlertEnabled"] = request.alertEnabled;
    }

    if (!Util.isUnset(request.alertMarginThreshold)) {
      body["AlertMarginThreshold"] = request.alertMarginThreshold;
    }

    if (!Util.isUnset(request.alertSettingsShrink)) {
      body["AlertSettings"] = request.alertSettingsShrink;
    }

    if (!Util.isUnset(request.baselineId)) {
      body["BaselineId"] = request.baselineId;
    }

    if (!Util.isUnset(request.baselineName)) {
      body["BaselineName"] = request.baselineName;
    }

    if (!Util.isUnset(request.baselineType)) {
      body["BaselineType"] = request.baselineType;
    }

    if (!Util.isUnset(request.enabled)) {
      body["Enabled"] = request.enabled;
    }

    if (!Util.isUnset(request.nodeIds)) {
      body["NodeIds"] = request.nodeIds;
    }

    if (!Util.isUnset(request.overtimeSettingsShrink)) {
      body["OvertimeSettings"] = request.overtimeSettingsShrink;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.priority)) {
      body["Priority"] = request.priority;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.removeNodeIds)) {
      body["RemoveNodeIds"] = request.removeNodeIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateBaseline",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateBaselineResponse>(await this.callApi(params, req, runtime), new UpdateBaselineResponse({}));
  }

  /**
   * 更新基线
   * 
   * @param request - UpdateBaselineRequest
   * @returns UpdateBaselineResponse
   */
  async updateBaseline(request: UpdateBaselineRequest): Promise<UpdateBaselineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateBaselineWithOptions(request, runtime);
  }

  /**
   * Updates a workflow.
   * 
   * @param request - UpdateBusinessRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateBusinessResponse
   */
  async updateBusinessWithOptions(request: UpdateBusinessRequest, runtime: $Util.RuntimeOptions): Promise<UpdateBusinessResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.businessId)) {
      body["BusinessId"] = request.businessId;
    }

    if (!Util.isUnset(request.businessName)) {
      body["BusinessName"] = request.businessName;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateBusiness",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateBusinessResponse>(await this.callApi(params, req, runtime), new UpdateBusinessResponse({}));
  }

  /**
   * Updates a workflow.
   * 
   * @param request - UpdateBusinessRequest
   * @returns UpdateBusinessResponse
   */
  async updateBusiness(request: UpdateBusinessRequest): Promise<UpdateBusinessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateBusinessWithOptions(request, runtime);
  }

  /**
   * 更新集群的配置信息
   * 
   * @param tmpReq - UpdateClusterConfigsRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateClusterConfigsResponse
   */
  async updateClusterConfigsWithOptions(tmpReq: UpdateClusterConfigsRequest, runtime: $Util.RuntimeOptions): Promise<UpdateClusterConfigsResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateClusterConfigsShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.configValues)) {
      request.configValuesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.configValues, "ConfigValues", "json");
    }

    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.configType)) {
      query["ConfigType"] = request.configType;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.configValuesShrink)) {
      body["ConfigValues"] = request.configValuesShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateClusterConfigs",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateClusterConfigsResponse>(await this.callApi(params, req, runtime), new UpdateClusterConfigsResponse({}));
  }

  /**
   * 更新集群的配置信息
   * 
   * @param request - UpdateClusterConfigsRequest
   * @returns UpdateClusterConfigsResponse
   */
  async updateClusterConfigs(request: UpdateClusterConfigsRequest): Promise<UpdateClusterConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateClusterConfigsWithOptions(request, runtime);
  }

  /**
   * Updates a data source.
   * 
   * @deprecated OpenAPI UpdateConnection is deprecated
   * 
   * @param request - UpdateConnectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateConnectionResponse
   */
  // Deprecated
  async updateConnectionWithOptions(request: UpdateConnectionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateConnectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.connectionId)) {
      query["ConnectionId"] = request.connectionId;
    }

    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateConnection",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "PUT",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateConnectionResponse>(await this.callApi(params, req, runtime), new UpdateConnectionResponse({}));
  }

  /**
   * Updates a data source.
   * 
   * @deprecated OpenAPI UpdateConnection is deprecated
   * 
   * @param request - UpdateConnectionRequest
   * @returns UpdateConnectionResponse
   */
  // Deprecated
  async updateConnection(request: UpdateConnectionRequest): Promise<UpdateConnectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateConnectionWithOptions(request, runtime);
  }

  /**
   * Updates an alert rule for a new-version synchronization task. The following type of task is supported: real-time synchronization of all data in a MySQL database to Hologres.
   * 
   * @remarks
   * You can configure alert rules only for tasks that can be used for real-time data synchronization. You must update all fields in the alert rule.
   * 
   * @param tmpReq - UpdateDIAlarmRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDIAlarmRuleResponse
   */
  async updateDIAlarmRuleWithOptions(tmpReq: UpdateDIAlarmRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDIAlarmRuleResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateDIAlarmRuleShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.notificationSettings)) {
      request.notificationSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notificationSettings, "NotificationSettings", "json");
    }

    if (!Util.isUnset(tmpReq.triggerConditions)) {
      request.triggerConditionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.triggerConditions, "TriggerConditions", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.DIAlarmRuleId)) {
      body["DIAlarmRuleId"] = request.DIAlarmRuleId;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.enabled)) {
      body["Enabled"] = request.enabled;
    }

    if (!Util.isUnset(request.metricType)) {
      body["MetricType"] = request.metricType;
    }

    if (!Util.isUnset(request.notificationSettingsShrink)) {
      body["NotificationSettings"] = request.notificationSettingsShrink;
    }

    if (!Util.isUnset(request.triggerConditionsShrink)) {
      body["TriggerConditions"] = request.triggerConditionsShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDIAlarmRule",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDIAlarmRuleResponse>(await this.callApi(params, req, runtime), new UpdateDIAlarmRuleResponse({}));
  }

  /**
   * Updates an alert rule for a new-version synchronization task. The following type of task is supported: real-time synchronization of all data in a MySQL database to Hologres.
   * 
   * @remarks
   * You can configure alert rules only for tasks that can be used for real-time data synchronization. You must update all fields in the alert rule.
   * 
   * @param request - UpdateDIAlarmRuleRequest
   * @returns UpdateDIAlarmRuleResponse
   */
  async updateDIAlarmRule(request: UpdateDIAlarmRuleRequest): Promise<UpdateDIAlarmRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDIAlarmRuleWithOptions(request, runtime);
  }

  /**
   * Updates a new-version synchronization task. The following type of task is supported: real-time synchronization of all data in a MySQL database to Hologres.
   * 
   * @param tmpReq - UpdateDIJobRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDIJobResponse
   */
  async updateDIJobWithOptions(tmpReq: UpdateDIJobRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDIJobResponse> {
    Util.validateModel(tmpReq);
    let request = new UpdateDIJobShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.jobSettings)) {
      request.jobSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.jobSettings, "JobSettings", "json");
    }

    if (!Util.isUnset(tmpReq.resourceSettings)) {
      request.resourceSettingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceSettings, "ResourceSettings", "json");
    }

    if (!Util.isUnset(tmpReq.tableMappings)) {
      request.tableMappingsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tableMappings, "TableMappings", "json");
    }

    if (!Util.isUnset(tmpReq.transformationRules)) {
      request.transformationRulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.transformationRules, "TransformationRules", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.DIJobId)) {
      body["DIJobId"] = request.DIJobId;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.jobSettingsShrink)) {
      body["JobSettings"] = request.jobSettingsShrink;
    }

    if (!Util.isUnset(request.resourceSettingsShrink)) {
      body["ResourceSettings"] = request.resourceSettingsShrink;
    }

    if (!Util.isUnset(request.tableMappingsShrink)) {
      body["TableMappings"] = request.tableMappingsShrink;
    }

    if (!Util.isUnset(request.transformationRulesShrink)) {
      body["TransformationRules"] = request.transformationRulesShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDIJob",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDIJobResponse>(await this.callApi(params, req, runtime), new UpdateDIJobResponse({}));
  }

  /**
   * Updates a new-version synchronization task. The following type of task is supported: real-time synchronization of all data in a MySQL database to Hologres.
   * 
   * @param request - UpdateDIJobRequest
   * @returns UpdateDIJobResponse
   */
  async updateDIJob(request: UpdateDIJobRequest): Promise<UpdateDIJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDIJobWithOptions(request, runtime);
  }

  /**
   * Modifies the default global configuration of synchronization solutions in a DataWorks workspace.
   * 
   * @remarks
   * DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization tasks in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
   * 
   * @param request - UpdateDIProjectConfigRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDIProjectConfigResponse
   */
  async updateDIProjectConfigWithOptions(request: UpdateDIProjectConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDIProjectConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.destinationType)) {
      query["DestinationType"] = request.destinationType;
    }

    if (!Util.isUnset(request.projectConfig)) {
      query["ProjectConfig"] = request.projectConfig;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDIProjectConfig",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDIProjectConfigResponse>(await this.callApi(params, req, runtime), new UpdateDIProjectConfigResponse({}));
  }

  /**
   * Modifies the default global configuration of synchronization solutions in a DataWorks workspace.
   * 
   * @remarks
   * DataWorks allows you to specify a default global configuration only for the processing rules of DDL messages in synchronization solutions. After you configure the **processing rules of DDL messages** in synchronization solutions, the configuration is used as the default global configuration and applies to all real-time synchronization tasks in the solutions. You can modify the **processing rules of DDL messages** based on your business requirements. For more information about how to configure a synchronization solution, see [Synchronization solutions](https://help.aliyun.com/document_detail/199008.html).
   * 
   * @param request - UpdateDIProjectConfigRequest
   * @returns UpdateDIProjectConfigResponse
   */
  async updateDIProjectConfig(request: UpdateDIProjectConfigRequest): Promise<UpdateDIProjectConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDIProjectConfigWithOptions(request, runtime);
  }

  /**
   * Updates a data synchronization task.
   * 
   * @param request - UpdateDISyncTaskRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDISyncTaskResponse
   */
  async updateDISyncTaskWithOptions(request: UpdateDISyncTaskRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDISyncTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fileId)) {
      query["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.taskContent)) {
      query["TaskContent"] = request.taskContent;
    }

    if (!Util.isUnset(request.taskParam)) {
      query["TaskParam"] = request.taskParam;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDISyncTask",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDISyncTaskResponse>(await this.callApi(params, req, runtime), new UpdateDISyncTaskResponse({}));
  }

  /**
   * Updates a data synchronization task.
   * 
   * @param request - UpdateDISyncTaskRequest
   * @returns UpdateDISyncTaskResponse
   */
  async updateDISyncTask(request: UpdateDISyncTaskRequest): Promise<UpdateDISyncTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDISyncTaskWithOptions(request, runtime);
  }

  /**
   * Updates the information about an API in the development state in DataService Studio.
   * 
   * @param request - UpdateDataServiceApiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDataServiceApiResponse
   */
  async updateDataServiceApiWithOptions(request: UpdateDataServiceApiRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDataServiceApiResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.apiDescription)) {
      body["ApiDescription"] = request.apiDescription;
    }

    if (!Util.isUnset(request.apiId)) {
      body["ApiId"] = request.apiId;
    }

    if (!Util.isUnset(request.apiPath)) {
      body["ApiPath"] = request.apiPath;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.protocols)) {
      body["Protocols"] = request.protocols;
    }

    if (!Util.isUnset(request.registrationDetails)) {
      body["RegistrationDetails"] = request.registrationDetails;
    }

    if (!Util.isUnset(request.requestMethod)) {
      body["RequestMethod"] = request.requestMethod;
    }

    if (!Util.isUnset(request.resourceGroupId)) {
      body["ResourceGroupId"] = request.resourceGroupId;
    }

    if (!Util.isUnset(request.responseContentType)) {
      body["ResponseContentType"] = request.responseContentType;
    }

    if (!Util.isUnset(request.scriptDetails)) {
      body["ScriptDetails"] = request.scriptDetails;
    }

    if (!Util.isUnset(request.tenantId)) {
      body["TenantId"] = request.tenantId;
    }

    if (!Util.isUnset(request.timeout)) {
      body["Timeout"] = request.timeout;
    }

    if (!Util.isUnset(request.visibleRange)) {
      body["VisibleRange"] = request.visibleRange;
    }

    if (!Util.isUnset(request.wizardDetails)) {
      body["WizardDetails"] = request.wizardDetails;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDataServiceApi",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDataServiceApiResponse>(await this.callApi(params, req, runtime), new UpdateDataServiceApiResponse({}));
  }

  /**
   * Updates the information about an API in the development state in DataService Studio.
   * 
   * @param request - UpdateDataServiceApiRequest
   * @returns UpdateDataServiceApiResponse
   */
  async updateDataServiceApi(request: UpdateDataServiceApiRequest): Promise<UpdateDataServiceApiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDataServiceApiWithOptions(request, runtime);
  }

  /**
   * Updates a data source.
   * 
   * @param request - UpdateDataSourceRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateDataSourceResponse
   */
  async updateDataSourceWithOptions(request: UpdateDataSourceRequest, runtime: $Util.RuntimeOptions): Promise<UpdateDataSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.content)) {
      query["Content"] = request.content;
    }

    if (!Util.isUnset(request.dataSourceId)) {
      query["DataSourceId"] = request.dataSourceId;
    }

    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateDataSource",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "PUT",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateDataSourceResponse>(await this.callApi(params, req, runtime), new UpdateDataSourceResponse({}));
  }

  /**
   * Updates a data source.
   * 
   * @param request - UpdateDataSourceRequest
   * @returns UpdateDataSourceResponse
   */
  async updateDataSource(request: UpdateDataSourceRequest): Promise<UpdateDataSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateDataSourceWithOptions(request, runtime);
  }

  /**
   * Updates a file.
   * 
   * @remarks
   * When you debug or call this operation, you must specify new values for the specified parameters to ensure that the values are different from the original configurations of the file. For example, if the original value of a parameter is A, you must change the value of this parameter to B before you commit the node. If you set the parameter to A, an exception that indicates invalid data occurs.
   * 
   * @param request - UpdateFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateFileResponse
   */
  async updateFileWithOptions(request: UpdateFileRequest, runtime: $Util.RuntimeOptions): Promise<UpdateFileResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.advancedSettings)) {
      body["AdvancedSettings"] = request.advancedSettings;
    }

    if (!Util.isUnset(request.applyScheduleImmediately)) {
      body["ApplyScheduleImmediately"] = request.applyScheduleImmediately;
    }

    if (!Util.isUnset(request.autoParsing)) {
      body["AutoParsing"] = request.autoParsing;
    }

    if (!Util.isUnset(request.autoRerunIntervalMillis)) {
      body["AutoRerunIntervalMillis"] = request.autoRerunIntervalMillis;
    }

    if (!Util.isUnset(request.autoRerunTimes)) {
      body["AutoRerunTimes"] = request.autoRerunTimes;
    }

    if (!Util.isUnset(request.connectionName)) {
      body["ConnectionName"] = request.connectionName;
    }

    if (!Util.isUnset(request.content)) {
      body["Content"] = request.content;
    }

    if (!Util.isUnset(request.cronExpress)) {
      body["CronExpress"] = request.cronExpress;
    }

    if (!Util.isUnset(request.cycleType)) {
      body["CycleType"] = request.cycleType;
    }

    if (!Util.isUnset(request.dependentNodeIdList)) {
      body["DependentNodeIdList"] = request.dependentNodeIdList;
    }

    if (!Util.isUnset(request.dependentType)) {
      body["DependentType"] = request.dependentType;
    }

    if (!Util.isUnset(request.endEffectDate)) {
      body["EndEffectDate"] = request.endEffectDate;
    }

    if (!Util.isUnset(request.fileDescription)) {
      body["FileDescription"] = request.fileDescription;
    }

    if (!Util.isUnset(request.fileFolderPath)) {
      body["FileFolderPath"] = request.fileFolderPath;
    }

    if (!Util.isUnset(request.fileId)) {
      body["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.fileName)) {
      body["FileName"] = request.fileName;
    }

    if (!Util.isUnset(request.ignoreParentSkipRunningProperty)) {
      body["IgnoreParentSkipRunningProperty"] = request.ignoreParentSkipRunningProperty;
    }

    if (!Util.isUnset(request.inputList)) {
      body["InputList"] = request.inputList;
    }

    if (!Util.isUnset(request.inputParameters)) {
      body["InputParameters"] = request.inputParameters;
    }

    if (!Util.isUnset(request.outputList)) {
      body["OutputList"] = request.outputList;
    }

    if (!Util.isUnset(request.outputParameters)) {
      body["OutputParameters"] = request.outputParameters;
    }

    if (!Util.isUnset(request.owner)) {
      body["Owner"] = request.owner;
    }

    if (!Util.isUnset(request.paraValue)) {
      body["ParaValue"] = request.paraValue;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    if (!Util.isUnset(request.rerunMode)) {
      body["RerunMode"] = request.rerunMode;
    }

    if (!Util.isUnset(request.resourceGroupIdentifier)) {
      body["ResourceGroupIdentifier"] = request.resourceGroupIdentifier;
    }

    if (!Util.isUnset(request.schedulerType)) {
      body["SchedulerType"] = request.schedulerType;
    }

    if (!Util.isUnset(request.startEffectDate)) {
      body["StartEffectDate"] = request.startEffectDate;
    }

    if (!Util.isUnset(request.startImmediately)) {
      body["StartImmediately"] = request.startImmediately;
    }

    if (!Util.isUnset(request.stop)) {
      body["Stop"] = request.stop;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFile",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateFileResponse>(await this.callApi(params, req, runtime), new UpdateFileResponse({}));
  }

  /**
   * Updates a file.
   * 
   * @remarks
   * When you debug or call this operation, you must specify new values for the specified parameters to ensure that the values are different from the original configurations of the file. For example, if the original value of a parameter is A, you must change the value of this parameter to B before you commit the node. If you set the parameter to A, an exception that indicates invalid data occurs.
   * 
   * @param request - UpdateFileRequest
   * @returns UpdateFileResponse
   */
  async updateFile(request: UpdateFileRequest): Promise<UpdateFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateFileWithOptions(request, runtime);
  }

  /**
   * Updates a folder.
   * 
   * @param request - UpdateFolderRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateFolderResponse
   */
  async updateFolderWithOptions(request: UpdateFolderRequest, runtime: $Util.RuntimeOptions): Promise<UpdateFolderResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.folderId)) {
      body["FolderId"] = request.folderId;
    }

    if (!Util.isUnset(request.folderName)) {
      body["FolderName"] = request.folderName;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFolder",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateFolderResponse>(await this.callApi(params, req, runtime), new UpdateFolderResponse({}));
  }

  /**
   * Updates a folder.
   * 
   * @param request - UpdateFolderRequest
   * @returns UpdateFolderResponse
   */
  async updateFolder(request: UpdateFolderRequest): Promise<UpdateFolderResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateFolderWithOptions(request, runtime);
  }

  /**
   * Returns the check result of an extension point event to DataStudio after the extension point event is triggered during data development and checked by an extension.
   * 
   * @param request - UpdateIDEEventResultRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateIDEEventResultResponse
   */
  async updateIDEEventResultWithOptions(request: UpdateIDEEventResultRequest, runtime: $Util.RuntimeOptions): Promise<UpdateIDEEventResultResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.checkResult)) {
      body["CheckResult"] = request.checkResult;
    }

    if (!Util.isUnset(request.checkResultTip)) {
      body["CheckResultTip"] = request.checkResultTip;
    }

    if (!Util.isUnset(request.extensionCode)) {
      body["ExtensionCode"] = request.extensionCode;
    }

    if (!Util.isUnset(request.messageId)) {
      body["MessageId"] = request.messageId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateIDEEventResult",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateIDEEventResultResponse>(await this.callApi(params, req, runtime), new UpdateIDEEventResultResponse({}));
  }

  /**
   * Returns the check result of an extension point event to DataStudio after the extension point event is triggered during data development and checked by an extension.
   * 
   * @param request - UpdateIDEEventResultRequest
   * @returns UpdateIDEEventResultResponse
   */
  async updateIDEEventResult(request: UpdateIDEEventResultRequest): Promise<UpdateIDEEventResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateIDEEventResultWithOptions(request, runtime);
  }

  /**
   * Updates a category.
   * 
   * @param request - UpdateMetaCategoryRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateMetaCategoryResponse
   */
  async updateMetaCategoryWithOptions(request: UpdateMetaCategoryRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMetaCategoryResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.categoryId)) {
      body["CategoryId"] = request.categoryId;
    }

    if (!Util.isUnset(request.comment)) {
      body["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMetaCategory",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateMetaCategoryResponse>(await this.callApi(params, req, runtime), new UpdateMetaCategoryResponse({}));
  }

  /**
   * Updates a category.
   * 
   * @param request - UpdateMetaCategoryRequest
   * @returns UpdateMetaCategoryResponse
   */
  async updateMetaCategory(request: UpdateMetaCategoryRequest): Promise<UpdateMetaCategoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMetaCategoryWithOptions(request, runtime);
  }

  /**
   * Updates the name and comment of a collection.
   * 
   * @remarks
   * Only the name and comment of a collection can be updated.
   * 
   * @param request - UpdateMetaCollectionRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateMetaCollectionResponse
   */
  async updateMetaCollectionWithOptions(request: UpdateMetaCollectionRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMetaCollectionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.qualifiedName)) {
      query["QualifiedName"] = request.qualifiedName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMetaCollection",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateMetaCollectionResponse>(await this.callApi(params, req, runtime), new UpdateMetaCollectionResponse({}));
  }

  /**
   * Updates the name and comment of a collection.
   * 
   * @remarks
   * Only the name and comment of a collection can be updated.
   * 
   * @param request - UpdateMetaCollectionRequest
   * @returns UpdateMetaCollectionResponse
   */
  async updateMetaCollection(request: UpdateMetaCollectionRequest): Promise<UpdateMetaCollectionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMetaCollectionWithOptions(request, runtime);
  }

  /**
   * Updates the metadata information about a table.
   * 
   * @param request - UpdateMetaTableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateMetaTableResponse
   */
  async updateMetaTableWithOptions(request: UpdateMetaTableRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMetaTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.caption)) {
      query["Caption"] = request.caption;
    }

    if (!Util.isUnset(request.categoryId)) {
      query["CategoryId"] = request.categoryId;
    }

    if (!Util.isUnset(request.envType)) {
      query["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.newOwnerId)) {
      query["NewOwnerId"] = request.newOwnerId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.schema)) {
      query["Schema"] = request.schema;
    }

    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.visibility)) {
      query["Visibility"] = request.visibility;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.addedLabels)) {
      body["AddedLabels"] = request.addedLabels;
    }

    if (!Util.isUnset(request.removedLabels)) {
      body["RemovedLabels"] = request.removedLabels;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMetaTable",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateMetaTableResponse>(await this.callApi(params, req, runtime), new UpdateMetaTableResponse({}));
  }

  /**
   * Updates the metadata information about a table.
   * 
   * @param request - UpdateMetaTableRequest
   * @returns UpdateMetaTableResponse
   */
  async updateMetaTable(request: UpdateMetaTableRequest): Promise<UpdateMetaTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMetaTableWithOptions(request, runtime);
  }

  /**
   * Updates the instructions on how to use a table. If no instruction on how to use the table is available, the instructions that are configured by calling this operation are added.
   * 
   * @param request - UpdateMetaTableIntroWikiRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateMetaTableIntroWikiResponse
   */
  async updateMetaTableIntroWikiWithOptions(request: UpdateMetaTableIntroWikiRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMetaTableIntroWikiResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["Content"] = request.content;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMetaTableIntroWiki",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateMetaTableIntroWikiResponse>(await this.callApi(params, req, runtime), new UpdateMetaTableIntroWikiResponse({}));
  }

  /**
   * Updates the instructions on how to use a table. If no instruction on how to use the table is available, the instructions that are configured by calling this operation are added.
   * 
   * @param request - UpdateMetaTableIntroWikiRequest
   * @returns UpdateMetaTableIntroWikiResponse
   */
  async updateMetaTableIntroWiki(request: UpdateMetaTableIntroWikiRequest): Promise<UpdateMetaTableIntroWikiResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMetaTableIntroWikiWithOptions(request, runtime);
  }

  /**
   * Changes the owner of a node.
   * 
   * @param request - UpdateNodeOwnerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateNodeOwnerResponse
   */
  async updateNodeOwnerWithOptions(request: UpdateNodeOwnerRequest, runtime: $Util.RuntimeOptions): Promise<UpdateNodeOwnerResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.userId)) {
      body["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateNodeOwner",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateNodeOwnerResponse>(await this.callApi(params, req, runtime), new UpdateNodeOwnerResponse({}));
  }

  /**
   * Changes the owner of a node.
   * 
   * @param request - UpdateNodeOwnerRequest
   * @returns UpdateNodeOwnerResponse
   */
  async updateNodeOwner(request: UpdateNodeOwnerRequest): Promise<UpdateNodeOwnerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateNodeOwnerWithOptions(request, runtime);
  }

  /**
   * Freezes or unfreezes a node.
   * 
   * @param request - UpdateNodeRunModeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateNodeRunModeResponse
   */
  async updateNodeRunModeWithOptions(request: UpdateNodeRunModeRequest, runtime: $Util.RuntimeOptions): Promise<UpdateNodeRunModeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.projectEnv)) {
      body["ProjectEnv"] = request.projectEnv;
    }

    if (!Util.isUnset(request.schedulerType)) {
      body["SchedulerType"] = request.schedulerType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateNodeRunMode",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateNodeRunModeResponse>(await this.callApi(params, req, runtime), new UpdateNodeRunModeResponse({}));
  }

  /**
   * Freezes or unfreezes a node.
   * 
   * @param request - UpdateNodeRunModeRequest
   * @returns UpdateNodeRunModeResponse
   */
  async updateNodeRunMode(request: UpdateNodeRunModeRequest): Promise<UpdateNodeRunModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateNodeRunModeWithOptions(request, runtime);
  }

  /**
   * Updates a subscription relationship.
   * 
   * @param request - UpdateQualityFollowerRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateQualityFollowerResponse
   */
  async updateQualityFollowerWithOptions(request: UpdateQualityFollowerRequest, runtime: $Util.RuntimeOptions): Promise<UpdateQualityFollowerResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alarmMode)) {
      body["AlarmMode"] = request.alarmMode;
    }

    if (!Util.isUnset(request.follower)) {
      body["Follower"] = request.follower;
    }

    if (!Util.isUnset(request.followerId)) {
      body["FollowerId"] = request.followerId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateQualityFollower",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateQualityFollowerResponse>(await this.callApi(params, req, runtime), new UpdateQualityFollowerResponse({}));
  }

  /**
   * Updates a subscription relationship.
   * 
   * @param request - UpdateQualityFollowerRequest
   * @returns UpdateQualityFollowerResponse
   */
  async updateQualityFollower(request: UpdateQualityFollowerRequest): Promise<UpdateQualityFollowerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateQualityFollowerWithOptions(request, runtime);
  }

  /**
   * Updates a monitoring rule.
   * 
   * @param request - UpdateQualityRuleRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateQualityRuleResponse
   */
  async updateQualityRuleWithOptions(request: UpdateQualityRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateQualityRuleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.blockType)) {
      body["BlockType"] = request.blockType;
    }

    if (!Util.isUnset(request.checker)) {
      body["Checker"] = request.checker;
    }

    if (!Util.isUnset(request.comment)) {
      body["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.criticalThreshold)) {
      body["CriticalThreshold"] = request.criticalThreshold;
    }

    if (!Util.isUnset(request.entityId)) {
      body["EntityId"] = request.entityId;
    }

    if (!Util.isUnset(request.expectValue)) {
      body["ExpectValue"] = request.expectValue;
    }

    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.methodName)) {
      body["MethodName"] = request.methodName;
    }

    if (!Util.isUnset(request.openSwitch)) {
      body["OpenSwitch"] = request.openSwitch;
    }

    if (!Util.isUnset(request.operator)) {
      body["Operator"] = request.operator;
    }

    if (!Util.isUnset(request.predictType)) {
      body["PredictType"] = request.predictType;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.property)) {
      body["Property"] = request.property;
    }

    if (!Util.isUnset(request.propertyType)) {
      body["PropertyType"] = request.propertyType;
    }

    if (!Util.isUnset(request.ruleName)) {
      body["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleType)) {
      body["RuleType"] = request.ruleType;
    }

    if (!Util.isUnset(request.taskSetting)) {
      body["TaskSetting"] = request.taskSetting;
    }

    if (!Util.isUnset(request.templateId)) {
      body["TemplateId"] = request.templateId;
    }

    if (!Util.isUnset(request.trend)) {
      body["Trend"] = request.trend;
    }

    if (!Util.isUnset(request.warningThreshold)) {
      body["WarningThreshold"] = request.warningThreshold;
    }

    if (!Util.isUnset(request.whereCondition)) {
      body["WhereCondition"] = request.whereCondition;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateQualityRule",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateQualityRuleResponse>(await this.callApi(params, req, runtime), new UpdateQualityRuleResponse({}));
  }

  /**
   * Updates a monitoring rule.
   * 
   * @param request - UpdateQualityRuleRequest
   * @returns UpdateQualityRuleResponse
   */
  async updateQualityRule(request: UpdateQualityRuleRequest): Promise<UpdateQualityRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateQualityRuleWithOptions(request, runtime);
  }

  /**
   * Modifies a custom alert rule.
   * 
   * @param request - UpdateRemindRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateRemindResponse
   */
  async updateRemindWithOptions(request: UpdateRemindRequest, runtime: $Util.RuntimeOptions): Promise<UpdateRemindResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alertInterval)) {
      body["AlertInterval"] = request.alertInterval;
    }

    if (!Util.isUnset(request.alertMethods)) {
      body["AlertMethods"] = request.alertMethods;
    }

    if (!Util.isUnset(request.alertTargets)) {
      body["AlertTargets"] = request.alertTargets;
    }

    if (!Util.isUnset(request.alertUnit)) {
      body["AlertUnit"] = request.alertUnit;
    }

    if (!Util.isUnset(request.baselineIds)) {
      body["BaselineIds"] = request.baselineIds;
    }

    if (!Util.isUnset(request.bizProcessIds)) {
      body["BizProcessIds"] = request.bizProcessIds;
    }

    if (!Util.isUnset(request.detail)) {
      body["Detail"] = request.detail;
    }

    if (!Util.isUnset(request.dndEnd)) {
      body["DndEnd"] = request.dndEnd;
    }

    if (!Util.isUnset(request.maxAlertTimes)) {
      body["MaxAlertTimes"] = request.maxAlertTimes;
    }

    if (!Util.isUnset(request.nodeIds)) {
      body["NodeIds"] = request.nodeIds;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.remindId)) {
      body["RemindId"] = request.remindId;
    }

    if (!Util.isUnset(request.remindName)) {
      body["RemindName"] = request.remindName;
    }

    if (!Util.isUnset(request.remindType)) {
      body["RemindType"] = request.remindType;
    }

    if (!Util.isUnset(request.remindUnit)) {
      body["RemindUnit"] = request.remindUnit;
    }

    if (!Util.isUnset(request.robotUrls)) {
      body["RobotUrls"] = request.robotUrls;
    }

    if (!Util.isUnset(request.useFlag)) {
      body["UseFlag"] = request.useFlag;
    }

    if (!Util.isUnset(request.webhooks)) {
      body["Webhooks"] = request.webhooks;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateRemind",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateRemindResponse>(await this.callApi(params, req, runtime), new UpdateRemindResponse({}));
  }

  /**
   * Modifies a custom alert rule.
   * 
   * @param request - UpdateRemindRequest
   * @returns UpdateRemindResponse
   */
  async updateRemind(request: UpdateRemindRequest): Promise<UpdateRemindResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateRemindWithOptions(request, runtime);
  }

  /**
   * Updates a MaxCompute table.
   * 
   * @param request - UpdateTableRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTableResponse
   */
  async updateTableWithOptions(request: UpdateTableRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appGuid)) {
      query["AppGuid"] = request.appGuid;
    }

    if (!Util.isUnset(request.categoryId)) {
      query["CategoryId"] = request.categoryId;
    }

    if (!Util.isUnset(request.comment)) {
      query["Comment"] = request.comment;
    }

    if (!Util.isUnset(request.createIfNotExists)) {
      query["CreateIfNotExists"] = request.createIfNotExists;
    }

    if (!Util.isUnset(request.externalTableType)) {
      query["ExternalTableType"] = request.externalTableType;
    }

    if (!Util.isUnset(request.hasPart)) {
      query["HasPart"] = request.hasPart;
    }

    if (!Util.isUnset(request.isView)) {
      query["IsView"] = request.isView;
    }

    if (!Util.isUnset(request.lifeCycle)) {
      query["LifeCycle"] = request.lifeCycle;
    }

    if (!Util.isUnset(request.location)) {
      query["Location"] = request.location;
    }

    if (!Util.isUnset(request.logicalLevelId)) {
      query["LogicalLevelId"] = request.logicalLevelId;
    }

    if (!Util.isUnset(request.ownerId)) {
      query["OwnerId"] = request.ownerId;
    }

    if (!Util.isUnset(request.physicsLevelId)) {
      query["PhysicsLevelId"] = request.physicsLevelId;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.schema)) {
      query["Schema"] = request.schema;
    }

    if (!Util.isUnset(request.tableName)) {
      query["TableName"] = request.tableName;
    }

    if (!Util.isUnset(request.visibility)) {
      query["Visibility"] = request.visibility;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.columns)) {
      body["Columns"] = request.columns;
    }

    if (!Util.isUnset(request.endpoint)) {
      body["Endpoint"] = request.endpoint;
    }

    if (!Util.isUnset(request.envType)) {
      body["EnvType"] = request.envType;
    }

    if (!Util.isUnset(request.themes)) {
      body["Themes"] = request.themes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTable",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTableResponse>(await this.callApi(params, req, runtime), new UpdateTableResponse({}));
  }

  /**
   * Updates a MaxCompute table.
   * 
   * @param request - UpdateTableRequest
   * @returns UpdateTableResponse
   */
  async updateTable(request: UpdateTableRequest): Promise<UpdateTableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTableWithOptions(request, runtime);
  }

  /**
   * Updates the fields in a MaxCompute table.
   * 
   * @param request - UpdateTableAddColumnRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTableAddColumnResponse
   */
  async updateTableAddColumnWithOptions(request: UpdateTableAddColumnRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTableAddColumnResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.column)) {
      body["Column"] = request.column;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTableAddColumn",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTableAddColumnResponse>(await this.callApi(params, req, runtime), new UpdateTableAddColumnResponse({}));
  }

  /**
   * Updates the fields in a MaxCompute table.
   * 
   * @param request - UpdateTableAddColumnRequest
   * @returns UpdateTableAddColumnResponse
   */
  async updateTableAddColumn(request: UpdateTableAddColumnRequest): Promise<UpdateTableAddColumnResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTableAddColumnWithOptions(request, runtime);
  }

  /**
   * Updates a table level. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - UpdateTableLevelRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTableLevelResponse
   */
  async updateTableLevelWithOptions(request: UpdateTableLevelRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTableLevelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.levelId)) {
      query["LevelId"] = request.levelId;
    }

    if (!Util.isUnset(request.levelType)) {
      query["LevelType"] = request.levelType;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTableLevel",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTableLevelResponse>(await this.callApi(params, req, runtime), new UpdateTableLevelResponse({}));
  }

  /**
   * Updates a table level. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - UpdateTableLevelRequest
   * @returns UpdateTableLevelResponse
   */
  async updateTableLevel(request: UpdateTableLevelRequest): Promise<UpdateTableLevelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTableLevelWithOptions(request, runtime);
  }

  /**
   * Modifies the information about a table, such as the table folder, level, and category.
   * 
   * @param request - UpdateTableModelInfoRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTableModelInfoResponse
   */
  async updateTableModelInfoWithOptions(request: UpdateTableModelInfoRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTableModelInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.firstLevelThemeId)) {
      query["FirstLevelThemeId"] = request.firstLevelThemeId;
    }

    if (!Util.isUnset(request.levelId)) {
      query["LevelId"] = request.levelId;
    }

    if (!Util.isUnset(request.levelType)) {
      query["LevelType"] = request.levelType;
    }

    if (!Util.isUnset(request.secondLevelThemeId)) {
      query["SecondLevelThemeId"] = request.secondLevelThemeId;
    }

    if (!Util.isUnset(request.tableGuid)) {
      query["TableGuid"] = request.tableGuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTableModelInfo",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTableModelInfoResponse>(await this.callApi(params, req, runtime), new UpdateTableModelInfoResponse({}));
  }

  /**
   * Modifies the information about a table, such as the table folder, level, and category.
   * 
   * @param request - UpdateTableModelInfoRequest
   * @returns UpdateTableModelInfoResponse
   */
  async updateTableModelInfo(request: UpdateTableModelInfoRequest): Promise<UpdateTableModelInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTableModelInfoWithOptions(request, runtime);
  }

  /**
   * Updates a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - UpdateTableThemeRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateTableThemeResponse
   */
  async updateTableThemeWithOptions(request: UpdateTableThemeRequest, runtime: $Util.RuntimeOptions): Promise<UpdateTableThemeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.projectId)) {
      query["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.themeId)) {
      query["ThemeId"] = request.themeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateTableTheme",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateTableThemeResponse>(await this.callApi(params, req, runtime), new UpdateTableThemeResponse({}));
  }

  /**
   * Updates a table theme. This operation will be replaced soon. We recommend that you do not call this operation.
   * 
   * @param request - UpdateTableThemeRequest
   * @returns UpdateTableThemeResponse
   */
  async updateTableTheme(request: UpdateTableThemeRequest): Promise<UpdateTableThemeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateTableThemeWithOptions(request, runtime);
  }

  /**
   * @param request - UpdateUdfFileRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateUdfFileResponse
   */
  async updateUdfFileWithOptions(request: UpdateUdfFileRequest, runtime: $Util.RuntimeOptions): Promise<UpdateUdfFileResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.className)) {
      body["ClassName"] = request.className;
    }

    if (!Util.isUnset(request.cmdDescription)) {
      body["CmdDescription"] = request.cmdDescription;
    }

    if (!Util.isUnset(request.example)) {
      body["Example"] = request.example;
    }

    if (!Util.isUnset(request.fileFolderPath)) {
      body["FileFolderPath"] = request.fileFolderPath;
    }

    if (!Util.isUnset(request.fileId)) {
      body["FileId"] = request.fileId;
    }

    if (!Util.isUnset(request.functionType)) {
      body["FunctionType"] = request.functionType;
    }

    if (!Util.isUnset(request.parameterDescription)) {
      body["ParameterDescription"] = request.parameterDescription;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectIdentifier)) {
      body["ProjectIdentifier"] = request.projectIdentifier;
    }

    if (!Util.isUnset(request.resources)) {
      body["Resources"] = request.resources;
    }

    if (!Util.isUnset(request.returnValue)) {
      body["ReturnValue"] = request.returnValue;
    }

    if (!Util.isUnset(request.udfDescription)) {
      body["UdfDescription"] = request.udfDescription;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateUdfFile",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateUdfFileResponse>(await this.callApi(params, req, runtime), new UpdateUdfFileResponse({}));
  }

  /**
   * @param request - UpdateUdfFileRequest
   * @returns UpdateUdfFileResponse
   */
  async updateUdfFile(request: UpdateUdfFileRequest): Promise<UpdateUdfFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateUdfFileWithOptions(request, runtime);
  }

  /**
   * Returns the processing result sent by an extension after a process in Operation Center is blocked by the extension.
   * 
   * @param request - UpdateWorkbenchEventResultRequest
   * @param runtime - runtime options for this request RuntimeOptions
   * @returns UpdateWorkbenchEventResultResponse
   */
  async updateWorkbenchEventResultWithOptions(request: UpdateWorkbenchEventResultRequest, runtime: $Util.RuntimeOptions): Promise<UpdateWorkbenchEventResultResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkResult)) {
      query["CheckResult"] = request.checkResult;
    }

    if (!Util.isUnset(request.checkResultTip)) {
      query["CheckResultTip"] = request.checkResultTip;
    }

    if (!Util.isUnset(request.extensionCode)) {
      query["ExtensionCode"] = request.extensionCode;
    }

    if (!Util.isUnset(request.messageId)) {
      query["MessageId"] = request.messageId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateWorkbenchEventResult",
      version: "2020-05-18",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateWorkbenchEventResultResponse>(await this.callApi(params, req, runtime), new UpdateWorkbenchEventResultResponse({}));
  }

  /**
   * Returns the processing result sent by an extension after a process in Operation Center is blocked by the extension.
   * 
   * @param request - UpdateWorkbenchEventResultRequest
   * @returns UpdateWorkbenchEventResultResponse
   */
  async updateWorkbenchEventResult(request: UpdateWorkbenchEventResultRequest): Promise<UpdateWorkbenchEventResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateWorkbenchEventResultWithOptions(request, runtime);
  }

}
