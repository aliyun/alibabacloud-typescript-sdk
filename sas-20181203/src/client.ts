// This file is auto-generated, don't edit it
/**
 *
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class QueryIncidentTracingSubNodesCountRequest extends $tea.Model {
  vertexIdAndTypeList?: string[][];
  static names(): { [key: string]: string } {
    return {
      vertexIdAndTypeList: 'VertexIdAndTypeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vertexIdAndTypeList: { 'type': 'array', 'itemType': { 'type': 'array', 'itemType': 'string' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAssetSelectionCriteriaRequest extends $tea.Model {
  criteria?: string;
  criteriaOperation?: string;
  selectionKey?: string;
  targetOperationList?: AddAssetSelectionCriteriaRequestTargetOperationList[];
  static names(): { [key: string]: string } {
    return {
      criteria: 'Criteria',
      criteriaOperation: 'CriteriaOperation',
      selectionKey: 'SelectionKey',
      targetOperationList: 'TargetOperationList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteria: 'string',
      criteriaOperation: 'string',
      selectionKey: 'string',
      targetOperationList: { 'type': 'array', 'itemType': AddAssetSelectionCriteriaRequestTargetOperationList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAssetSelectionCriteriaResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAssetSelectionCriteriaResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddAssetSelectionCriteriaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddAssetSelectionCriteriaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCheckInstanceResultWhiteListRequest extends $tea.Model {
  checkGroupId?: string;
  checkId?: number;
  instanceIds?: string[];
  static names(): { [key: string]: string } {
    return {
      checkGroupId: 'CheckGroupId',
      checkId: 'CheckId',
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkGroupId: 'string',
      checkId: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCheckInstanceResultWhiteListResponseBody extends $tea.Model {
  data?: { [key: string]: any };
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCheckInstanceResultWhiteListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddCheckInstanceResultWhiteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddCheckInstanceResultWhiteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCheckResultWhiteListRequest extends $tea.Model {
  checkIds?: number[];
  static names(): { [key: string]: string } {
    return {
      checkIds: 'CheckIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCheckResultWhiteListResponseBody extends $tea.Model {
  data?: { [key: string]: any };
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddCheckResultWhiteListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddCheckResultWhiteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddCheckResultWhiteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddClientUserDefineRuleRequest extends $tea.Model {
  actionType?: number;
  cmdline?: string;
  filePath?: string;
  IP?: string;
  md5List?: string;
  name?: string;
  newFilePath?: string;
  parentCmdline?: string;
  parentProcPath?: string;
  platform?: string;
  port?: number;
  portStr?: string;
  procPath?: string;
  registryContent?: string;
  registryKey?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      actionType: 'ActionType',
      cmdline: 'Cmdline',
      filePath: 'FilePath',
      IP: 'IP',
      md5List: 'Md5List',
      name: 'Name',
      newFilePath: 'NewFilePath',
      parentCmdline: 'ParentCmdline',
      parentProcPath: 'ParentProcPath',
      platform: 'Platform',
      port: 'Port',
      portStr: 'PortStr',
      procPath: 'ProcPath',
      registryContent: 'RegistryContent',
      registryKey: 'RegistryKey',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionType: 'number',
      cmdline: 'string',
      filePath: 'string',
      IP: 'string',
      md5List: 'string',
      name: 'string',
      newFilePath: 'string',
      parentCmdline: 'string',
      parentProcPath: 'string',
      platform: 'string',
      port: 'number',
      portStr: 'string',
      procPath: 'string',
      registryContent: 'string',
      registryKey: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddClientUserDefineRuleResponseBody extends $tea.Model {
  requestId?: string;
  userDefineRuleAddResult?: AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      userDefineRuleAddResult: 'UserDefineRuleAddResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      userDefineRuleAddResult: AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddClientUserDefineRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddClientUserDefineRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddClientUserDefineRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddContainerDefenseRuleRequest extends $tea.Model {
  description?: string;
  ruleAction?: number;
  ruleId?: number;
  ruleName?: string;
  ruleSwitch?: number;
  ruleType?: number;
  scope?: AddContainerDefenseRuleRequestScope[];
  whitelist?: AddContainerDefenseRuleRequestWhitelist;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      ruleAction: 'RuleAction',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleSwitch: 'RuleSwitch',
      ruleType: 'RuleType',
      scope: 'Scope',
      whitelist: 'Whitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      ruleAction: 'number',
      ruleId: 'number',
      ruleName: 'string',
      ruleSwitch: 'number',
      ruleType: 'number',
      scope: { 'type': 'array', 'itemType': AddContainerDefenseRuleRequestScope },
      whitelist: AddContainerDefenseRuleRequestWhitelist,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddContainerDefenseRuleShrinkRequest extends $tea.Model {
  description?: string;
  ruleAction?: number;
  ruleId?: number;
  ruleName?: string;
  ruleSwitch?: number;
  ruleType?: number;
  scope?: AddContainerDefenseRuleShrinkRequestScope[];
  whitelistShrink?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      ruleAction: 'RuleAction',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleSwitch: 'RuleSwitch',
      ruleType: 'RuleType',
      scope: 'Scope',
      whitelistShrink: 'Whitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      ruleAction: 'number',
      ruleId: 'number',
      ruleName: 'string',
      ruleSwitch: 'number',
      ruleType: 'number',
      scope: { 'type': 'array', 'itemType': AddContainerDefenseRuleShrinkRequestScope },
      whitelistShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddContainerDefenseRuleResponseBody extends $tea.Model {
  code?: string;
  data?: number;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddContainerDefenseRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddContainerDefenseRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddContainerDefenseRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddImageEventOperationRequest extends $tea.Model {
  conditions?: string;
  eventKey?: string;
  eventName?: string;
  eventType?: string;
  operationCode?: string;
  scenarios?: string;
  static names(): { [key: string]: string } {
    return {
      conditions: 'Conditions',
      eventKey: 'EventKey',
      eventName: 'EventName',
      eventType: 'EventType',
      operationCode: 'OperationCode',
      scenarios: 'Scenarios',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditions: 'string',
      eventKey: 'string',
      eventName: 'string',
      eventType: 'string',
      operationCode: 'string',
      scenarios: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddImageEventOperationResponseBody extends $tea.Model {
  code?: string;
  data?: AddImageEventOperationResponseBodyData;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: AddImageEventOperationResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddImageEventOperationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddImageEventOperationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddImageEventOperationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddImageVulWhiteListRequest extends $tea.Model {
  lang?: string;
  reason?: string;
  source?: string;
  target?: string;
  type?: string;
  whitelist?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      reason: 'Reason',
      source: 'Source',
      target: 'Target',
      type: 'Type',
      whitelist: 'Whitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      reason: 'string',
      source: 'string',
      target: 'string',
      type: 'string',
      whitelist: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddImageVulWhiteListResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddImageVulWhiteListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddImageVulWhiteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddImageVulWhiteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddInstallCodeRequest extends $tea.Model {
  expiredDate?: number;
  groupId?: number;
  onlyImage?: boolean;
  os?: string;
  proxyCluster?: string;
  vendorName?: string;
  static names(): { [key: string]: string } {
    return {
      expiredDate: 'ExpiredDate',
      groupId: 'GroupId',
      onlyImage: 'OnlyImage',
      os: 'Os',
      proxyCluster: 'ProxyCluster',
      vendorName: 'VendorName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expiredDate: 'number',
      groupId: 'number',
      onlyImage: 'boolean',
      os: 'string',
      proxyCluster: 'string',
      vendorName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddInstallCodeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddInstallCodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddInstallCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddInstallCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrivateRegistryRequest extends $tea.Model {
  domainName?: string;
  extraParam?: string;
  netType?: number;
  password?: string;
  port?: number;
  protocolType?: number;
  registryHostIp?: string;
  registryRegionId?: string;
  registryType?: string;
  registryVersion?: string;
  transPerHour?: number;
  userName?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      extraParam: 'ExtraParam',
      netType: 'NetType',
      password: 'Password',
      port: 'Port',
      protocolType: 'ProtocolType',
      registryHostIp: 'RegistryHostIp',
      registryRegionId: 'RegistryRegionId',
      registryType: 'RegistryType',
      registryVersion: 'RegistryVersion',
      transPerHour: 'TransPerHour',
      userName: 'UserName',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      extraParam: 'string',
      netType: 'number',
      password: 'string',
      port: 'number',
      protocolType: 'number',
      registryHostIp: 'string',
      registryRegionId: 'string',
      registryType: 'string',
      registryVersion: 'string',
      transPerHour: 'number',
      userName: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrivateRegistryResponseBody extends $tea.Model {
  data?: AddPrivateRegistryResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: AddPrivateRegistryResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrivateRegistryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddPrivateRegistryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddPrivateRegistryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSasModuleTrialRequest extends $tea.Model {
  lang?: string;
  moduleCode?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      moduleCode: 'ModuleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      moduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSasModuleTrialResponseBody extends $tea.Model {
  data?: AddSasModuleTrialResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: AddSasModuleTrialResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSasModuleTrialResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddSasModuleTrialResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddSasModuleTrialResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagWithUuidRequest extends $tea.Model {
  tagName?: string;
  uuidList?: string;
  static names(): { [key: string]: string } {
    return {
      tagName: 'TagName',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagName: 'string',
      uuidList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagWithUuidResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddTagWithUuidResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddTagWithUuidResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddTagWithUuidResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddUninstallClientsByUuidsRequest extends $tea.Model {
  callMethod?: string;
  feedback?: string;
  region?: string;
  sourceIp?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      callMethod: 'CallMethod',
      feedback: 'Feedback',
      region: 'Region',
      sourceIp: 'SourceIp',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      callMethod: 'string',
      feedback: 'string',
      region: 'string',
      sourceIp: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddUninstallClientsByUuidsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddUninstallClientsByUuidsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddUninstallClientsByUuidsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddUninstallClientsByUuidsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddVpcHoneyPotRequest extends $tea.Model {
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddVpcHoneyPotResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddVpcHoneyPotResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AddVpcHoneyPotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddVpcHoneyPotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AdvanceSecurityEventOperationsRequest extends $tea.Model {
  eventName?: string;
  eventType?: string;
  resourceOwnerId?: number;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      eventName: 'EventName',
      eventType: 'EventType',
      resourceOwnerId: 'ResourceOwnerId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventName: 'string',
      eventType: 'string',
      resourceOwnerId: 'number',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AdvanceSecurityEventOperationsResponseBody extends $tea.Model {
  requestId?: string;
  securityEventOperationsResponse?: AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityEventOperationsResponse: 'SecurityEventOperationsResponse',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityEventOperationsResponse: { 'type': 'array', 'itemType': AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AdvanceSecurityEventOperationsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: AdvanceSecurityEventOperationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AdvanceSecurityEventOperationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchOperateCommonOverallConfigRequest extends $tea.Model {
  config?: string;
  typeList?: string[];
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      typeList: 'TypeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      typeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchOperateCommonOverallConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchOperateCommonOverallConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BatchOperateCommonOverallConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchOperateCommonOverallConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindAuthToMachineRequest extends $tea.Model {
  authVersion?: number;
  autoBind?: number;
  bind?: string[];
  bindAll?: boolean;
  criteria?: string;
  logicalExp?: string;
  unBind?: string[];
  static names(): { [key: string]: string } {
    return {
      authVersion: 'AuthVersion',
      autoBind: 'AutoBind',
      bind: 'Bind',
      bindAll: 'BindAll',
      criteria: 'Criteria',
      logicalExp: 'LogicalExp',
      unBind: 'UnBind',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authVersion: 'number',
      autoBind: 'number',
      bind: { 'type': 'array', 'itemType': 'string' },
      bindAll: 'boolean',
      criteria: 'string',
      logicalExp: 'string',
      unBind: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindAuthToMachineResponseBody extends $tea.Model {
  bindCount?: number;
  insufficientCoreCount?: number;
  insufficientEcsCount?: number;
  requestId?: string;
  resultCode?: number;
  unBindCount?: number;
  static names(): { [key: string]: string } {
    return {
      bindCount: 'BindCount',
      insufficientCoreCount: 'InsufficientCoreCount',
      insufficientEcsCount: 'InsufficientEcsCount',
      requestId: 'RequestId',
      resultCode: 'ResultCode',
      unBindCount: 'UnBindCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindCount: 'number',
      insufficientCoreCount: 'number',
      insufficientEcsCount: 'number',
      requestId: 'string',
      resultCode: 'number',
      unBindCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindAuthToMachineResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: BindAuthToMachineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BindAuthToMachineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOnceTaskRequest extends $tea.Model {
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOnceTaskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CancelOnceTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CancelOnceTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CancelOnceTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeAssetRefreshTaskConfigRequest extends $tea.Model {
  assetRefreshConfigs?: ChangeAssetRefreshTaskConfigRequestAssetRefreshConfigs[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      assetRefreshConfigs: 'AssetRefreshConfigs',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetRefreshConfigs: { 'type': 'array', 'itemType': ChangeAssetRefreshTaskConfigRequestAssetRefreshConfigs },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeAssetRefreshTaskConfigResponseBody extends $tea.Model {
  data?: boolean;
  message?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeAssetRefreshTaskConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ChangeAssetRefreshTaskConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeAssetRefreshTaskConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckConfigRequest extends $tea.Model {
  addedCheck?: ChangeCheckConfigRequestAddedCheck[];
  configRequirementIds?: ChangeCheckConfigRequestConfigRequirementIds;
  configStandardIds?: ChangeCheckConfigRequestConfigStandardIds;
  configure?: string;
  cycleDays?: number[];
  enableAddCheck?: boolean;
  enableAutoCheck?: boolean;
  endTime?: number;
  regionId?: string;
  removedCheck?: ChangeCheckConfigRequestRemovedCheck[];
  standardIds?: number[];
  startTime?: number;
  vendors?: string[];
  static names(): { [key: string]: string } {
    return {
      addedCheck: 'AddedCheck',
      configRequirementIds: 'ConfigRequirementIds',
      configStandardIds: 'ConfigStandardIds',
      configure: 'Configure',
      cycleDays: 'CycleDays',
      enableAddCheck: 'EnableAddCheck',
      enableAutoCheck: 'EnableAutoCheck',
      endTime: 'EndTime',
      regionId: 'RegionId',
      removedCheck: 'RemovedCheck',
      standardIds: 'StandardIds',
      startTime: 'StartTime',
      vendors: 'Vendors',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addedCheck: { 'type': 'array', 'itemType': ChangeCheckConfigRequestAddedCheck },
      configRequirementIds: ChangeCheckConfigRequestConfigRequirementIds,
      configStandardIds: ChangeCheckConfigRequestConfigStandardIds,
      configure: 'string',
      cycleDays: { 'type': 'array', 'itemType': 'number' },
      enableAddCheck: 'boolean',
      enableAutoCheck: 'boolean',
      endTime: 'number',
      regionId: 'string',
      removedCheck: { 'type': 'array', 'itemType': ChangeCheckConfigRequestRemovedCheck },
      standardIds: { 'type': 'array', 'itemType': 'number' },
      startTime: 'number',
      vendors: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckConfigShrinkRequest extends $tea.Model {
  addedCheck?: ChangeCheckConfigShrinkRequestAddedCheck[];
  configRequirementIdsShrink?: string;
  configStandardIdsShrink?: string;
  configure?: string;
  cycleDays?: number[];
  enableAddCheck?: boolean;
  enableAutoCheck?: boolean;
  endTime?: number;
  regionId?: string;
  removedCheck?: ChangeCheckConfigShrinkRequestRemovedCheck[];
  standardIds?: number[];
  startTime?: number;
  vendors?: string[];
  static names(): { [key: string]: string } {
    return {
      addedCheck: 'AddedCheck',
      configRequirementIdsShrink: 'ConfigRequirementIds',
      configStandardIdsShrink: 'ConfigStandardIds',
      configure: 'Configure',
      cycleDays: 'CycleDays',
      enableAddCheck: 'EnableAddCheck',
      enableAutoCheck: 'EnableAutoCheck',
      endTime: 'EndTime',
      regionId: 'RegionId',
      removedCheck: 'RemovedCheck',
      standardIds: 'StandardIds',
      startTime: 'StartTime',
      vendors: 'Vendors',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addedCheck: { 'type': 'array', 'itemType': ChangeCheckConfigShrinkRequestAddedCheck },
      configRequirementIdsShrink: 'string',
      configStandardIdsShrink: 'string',
      configure: 'string',
      cycleDays: { 'type': 'array', 'itemType': 'number' },
      enableAddCheck: 'boolean',
      enableAutoCheck: 'boolean',
      endTime: 'number',
      regionId: 'string',
      removedCheck: { 'type': 'array', 'itemType': ChangeCheckConfigShrinkRequestRemovedCheck },
      standardIds: { 'type': 'array', 'itemType': 'number' },
      startTime: 'number',
      vendors: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ChangeCheckConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeCheckConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckCustomConfigRequest extends $tea.Model {
  checkId?: number;
  customConfigs?: ChangeCheckCustomConfigRequestCustomConfigs[];
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      customConfigs: 'CustomConfigs',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      customConfigs: { 'type': 'array', 'itemType': ChangeCheckCustomConfigRequestCustomConfigs },
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckCustomConfigResponseBody extends $tea.Model {
  illegalCustomConfigs?: ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      illegalCustomConfigs: 'IllegalCustomConfigs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      illegalCustomConfigs: { 'type': 'array', 'itemType': ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckCustomConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ChangeCheckCustomConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeCheckCustomConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeSecurityScoreRuleRequest extends $tea.Model {
  resetSecurityScoreRule?: boolean;
  securityScoreRuleList?: ChangeSecurityScoreRuleRequestSecurityScoreRuleList[];
  static names(): { [key: string]: string } {
    return {
      resetSecurityScoreRule: 'ResetSecurityScoreRule',
      securityScoreRuleList: 'SecurityScoreRuleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resetSecurityScoreRule: 'boolean',
      securityScoreRuleList: { 'type': 'array', 'itemType': ChangeSecurityScoreRuleRequestSecurityScoreRuleList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeSecurityScoreRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeSecurityScoreRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ChangeSecurityScoreRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeSecurityScoreRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeUserLangRequest extends $tea.Model {
  userLang?: string;
  static names(): { [key: string]: string } {
    return {
      userLang: 'UserLang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      userLang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeUserLangResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeUserLangResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ChangeUserLangResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ChangeUserLangResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckQuaraFileIdRequest extends $tea.Model {
  quaraFileIds?: string[];
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      quaraFileIds: 'QuaraFileIds',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      quaraFileIds: { 'type': 'array', 'itemType': 'string' },
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckQuaraFileIdResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckQuaraFileIdResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CheckQuaraFileIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckQuaraFileIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSecurityEventIdRequest extends $tea.Model {
  securityEventIds?: string[];
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      securityEventIds: 'SecurityEventIds',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityEventIds: { 'type': 'array', 'itemType': 'string' },
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSecurityEventIdResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckSecurityEventIdResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CheckSecurityEventIdResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckSecurityEventIdResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserHasEcsRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserHasEcsResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckUserHasEcsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CheckUserHasEcsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckUserHasEcsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmVirusEventsRequest extends $tea.Model {
  operationAll?: number;
  operationCode?: string;
  operationRange?: string;
  static names(): { [key: string]: string } {
    return {
      operationAll: 'OperationAll',
      operationCode: 'OperationCode',
      operationRange: 'OperationRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationAll: 'number',
      operationCode: 'string',
      operationRange: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmVirusEventsResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmVirusEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ConfirmVirusEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfirmVirusEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAgentlessScanTaskRequest extends $tea.Model {
  autoDeleteDays?: number;
  releaseAfterScan?: boolean;
  scanDataDisk?: boolean;
  targetType?: number;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      autoDeleteDays: 'AutoDeleteDays',
      releaseAfterScan: 'ReleaseAfterScan',
      scanDataDisk: 'ScanDataDisk',
      targetType: 'TargetType',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autoDeleteDays: 'number',
      releaseAfterScan: 'boolean',
      scanDataDisk: 'boolean',
      targetType: 'number',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAgentlessScanTaskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAgentlessScanTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateAgentlessScanTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAgentlessScanTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntiBruteForceRuleRequest extends $tea.Model {
  defaultRule?: boolean;
  failCount?: number;
  forbiddenTime?: number;
  name?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  span?: number;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      defaultRule: 'DefaultRule',
      failCount: 'FailCount',
      forbiddenTime: 'ForbiddenTime',
      name: 'Name',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
      span: 'Span',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultRule: 'boolean',
      failCount: 'number',
      forbiddenTime: 'number',
      name: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
      span: 'number',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntiBruteForceRuleResponseBody extends $tea.Model {
  createAntiBruteForceRule?: CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      createAntiBruteForceRule: 'CreateAntiBruteForceRule',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createAntiBruteForceRule: CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntiBruteForceRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateAntiBruteForceRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAntiBruteForceRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAssetSelectionConfigRequest extends $tea.Model {
  businessType?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAssetSelectionConfigResponseBody extends $tea.Model {
  data?: CreateAssetSelectionConfigResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: CreateAssetSelectionConfigResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAssetSelectionConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateAssetSelectionConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAssetSelectionConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupPolicyRequest extends $tea.Model {
  name?: string;
  policy?: { [key: string]: any };
  policyRegionId?: string;
  policyVersion?: string;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      policy: 'Policy',
      policyRegionId: 'PolicyRegionId',
      policyVersion: 'PolicyVersion',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      policy: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      policyRegionId: 'string',
      policyVersion: 'string',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupPolicyShrinkRequest extends $tea.Model {
  name?: string;
  policyShrink?: string;
  policyRegionId?: string;
  policyVersion?: string;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      policyShrink: 'Policy',
      policyRegionId: 'PolicyRegionId',
      policyVersion: 'PolicyVersion',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      policyShrink: 'string',
      policyRegionId: 'string',
      policyVersion: 'string',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupPolicyResponseBody extends $tea.Model {
  backupPolicy?: CreateBackupPolicyResponseBodyBackupPolicy;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      backupPolicy: 'BackupPolicy',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupPolicy: CreateBackupPolicyResponseBodyBackupPolicy,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateBackupPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateBackupPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateContainerScanTaskRequest extends $tea.Model {
  clusterId?: string;
  containerIds?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      containerIds: 'ContainerIds',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      containerIds: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateContainerScanTaskResponseBody extends $tea.Model {
  data?: CreateContainerScanTaskResponseBodyData;
  httpStatusCode?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: CreateContainerScanTaskResponseBodyData,
      httpStatusCode: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateContainerScanTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateContainerScanTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateContainerScanTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateContainerScanTaskByAppNameRequest extends $tea.Model {
  appNames?: string;
  clusterId?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      appNames: 'AppNames',
      clusterId: 'ClusterId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appNames: 'string',
      clusterId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateContainerScanTaskByAppNameResponseBody extends $tea.Model {
  data?: CreateContainerScanTaskByAppNameResponseBodyData;
  httpStatusCode?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: CreateContainerScanTaskByAppNameResponseBodyData,
      httpStatusCode: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateContainerScanTaskByAppNameResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateContainerScanTaskByAppNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateContainerScanTaskByAppNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCustomBlockRecordRequest extends $tea.Model {
  blockIp?: string;
  bound?: string;
  expireTime?: number;
  resourceOwnerId?: number;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      blockIp: 'BlockIp',
      bound: 'Bound',
      expireTime: 'ExpireTime',
      resourceOwnerId: 'ResourceOwnerId',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockIp: 'string',
      bound: 'string',
      expireTime: 'number',
      resourceOwnerId: 'number',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCustomBlockRecordResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCustomBlockRecordResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateCustomBlockRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCustomBlockRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCycleTaskRequest extends $tea.Model {
  enable?: number;
  firstDateStr?: number;
  intervalPeriod?: number;
  param?: string;
  periodUnit?: string;
  source?: string;
  targetEndTime?: number;
  targetStartTime?: number;
  taskName?: string;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      firstDateStr: 'FirstDateStr',
      intervalPeriod: 'IntervalPeriod',
      param: 'Param',
      periodUnit: 'PeriodUnit',
      source: 'Source',
      targetEndTime: 'TargetEndTime',
      targetStartTime: 'TargetStartTime',
      taskName: 'TaskName',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'number',
      firstDateStr: 'number',
      intervalPeriod: 'number',
      param: 'string',
      periodUnit: 'string',
      source: 'string',
      targetEndTime: 'number',
      targetStartTime: 'number',
      taskName: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCycleTaskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCycleTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateCycleTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCycleTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileDetectRequest extends $tea.Model {
  downloadUrl?: string;
  hashKey?: string;
  ossKey?: string;
  sourceIp?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      downloadUrl: 'DownloadUrl',
      hashKey: 'HashKey',
      ossKey: 'OssKey',
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadUrl: 'string',
      hashKey: 'string',
      ossKey: 'string',
      sourceIp: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileDetectResponseBody extends $tea.Model {
  hashKey?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      hashKey: 'HashKey',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hashKey: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileDetectResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateFileDetectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFileDetectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileDetectUploadUrlRequest extends $tea.Model {
  hashKeyContextList?: CreateFileDetectUploadUrlRequestHashKeyContextList[];
  hashKeyList?: string[];
  type?: number;
  static names(): { [key: string]: string } {
    return {
      hashKeyContextList: 'HashKeyContextList',
      hashKeyList: 'HashKeyList',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hashKeyContextList: { 'type': 'array', 'itemType': CreateFileDetectUploadUrlRequestHashKeyContextList },
      hashKeyList: { 'type': 'array', 'itemType': 'string' },
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileDetectUploadUrlResponseBody extends $tea.Model {
  requestId?: string;
  uploadUrlList?: CreateFileDetectUploadUrlResponseBodyUploadUrlList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      uploadUrlList: 'UploadUrlList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      uploadUrlList: { 'type': 'array', 'itemType': CreateFileDetectUploadUrlResponseBodyUploadUrlList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileDetectUploadUrlResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateFileDetectUploadUrlResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFileDetectUploadUrlResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileProtectRuleRequest extends $tea.Model {
  alertLevel?: number;
  fileOps?: string[];
  filePaths?: string[];
  procPaths?: string[];
  ruleAction?: string;
  ruleName?: string;
  status?: number;
  switchId?: string;
  static names(): { [key: string]: string } {
    return {
      alertLevel: 'AlertLevel',
      fileOps: 'FileOps',
      filePaths: 'FilePaths',
      procPaths: 'ProcPaths',
      ruleAction: 'RuleAction',
      ruleName: 'RuleName',
      status: 'Status',
      switchId: 'SwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertLevel: 'number',
      fileOps: { 'type': 'array', 'itemType': 'string' },
      filePaths: { 'type': 'array', 'itemType': 'string' },
      procPaths: { 'type': 'array', 'itemType': 'string' },
      ruleAction: 'string',
      ruleName: 'string',
      status: 'number',
      switchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileProtectRuleResponseBody extends $tea.Model {
  requestId?: string;
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileProtectRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateFileProtectRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFileProtectRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileUploadLimitRequest extends $tea.Model {
  limit?: number;
  static names(): { [key: string]: string } {
    return {
      limit: 'Limit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      limit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileUploadLimitResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileUploadLimitResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateFileUploadLimitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFileUploadLimitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotRequest extends $tea.Model {
  honeypotImageId?: string;
  honeypotImageName?: string;
  honeypotName?: string;
  meta?: string;
  nodeId?: string;
  static names(): { [key: string]: string } {
    return {
      honeypotImageId: 'HoneypotImageId',
      honeypotImageName: 'HoneypotImageName',
      honeypotName: 'HoneypotName',
      meta: 'Meta',
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeypotImageId: 'string',
      honeypotImageName: 'string',
      honeypotName: 'string',
      meta: 'string',
      nodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotResponseBody extends $tea.Model {
  code?: string;
  data?: CreateHoneypotResponseBodyData;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: CreateHoneypotResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateHoneypotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHoneypotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotNodeRequest extends $tea.Model {
  allowHoneypotAccessInternet?: boolean;
  availableProbeNum?: number;
  nodeName?: string;
  securityGroupProbeIpList?: string[];
  static names(): { [key: string]: string } {
    return {
      allowHoneypotAccessInternet: 'AllowHoneypotAccessInternet',
      availableProbeNum: 'AvailableProbeNum',
      nodeName: 'NodeName',
      securityGroupProbeIpList: 'SecurityGroupProbeIpList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowHoneypotAccessInternet: 'boolean',
      availableProbeNum: 'number',
      nodeName: 'string',
      securityGroupProbeIpList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotNodeResponseBody extends $tea.Model {
  code?: string;
  honeypotNode?: CreateHoneypotNodeResponseBodyHoneypotNode;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      honeypotNode: 'HoneypotNode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      honeypotNode: CreateHoneypotNodeResponseBodyHoneypotNode,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotNodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateHoneypotNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHoneypotNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotPresetRequest extends $tea.Model {
  honeypotImageName?: string;
  lang?: string;
  meta?: string;
  nodeId?: string;
  presetName?: string;
  static names(): { [key: string]: string } {
    return {
      honeypotImageName: 'HoneypotImageName',
      lang: 'Lang',
      meta: 'Meta',
      nodeId: 'NodeId',
      presetName: 'PresetName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeypotImageName: 'string',
      lang: 'string',
      meta: 'string',
      nodeId: 'string',
      presetName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotPresetResponseBody extends $tea.Model {
  code?: string;
  honeypotPreset?: CreateHoneypotPresetResponseBodyHoneypotPreset;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      honeypotPreset: 'HoneypotPreset',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      honeypotPreset: CreateHoneypotPresetResponseBodyHoneypotPreset,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotPresetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateHoneypotPresetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHoneypotPresetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotProbeRequest extends $tea.Model {
  arp?: boolean;
  businessGroupId?: string;
  controlNodeId?: string;
  displayName?: string;
  honeypotBindList?: CreateHoneypotProbeRequestHoneypotBindList[];
  ping?: boolean;
  probeType?: string;
  probeVersion?: string;
  proxyIp?: string;
  uuid?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      arp: 'Arp',
      businessGroupId: 'BusinessGroupId',
      controlNodeId: 'ControlNodeId',
      displayName: 'DisplayName',
      honeypotBindList: 'HoneypotBindList',
      ping: 'Ping',
      probeType: 'ProbeType',
      probeVersion: 'ProbeVersion',
      proxyIp: 'ProxyIp',
      uuid: 'Uuid',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arp: 'boolean',
      businessGroupId: 'string',
      controlNodeId: 'string',
      displayName: 'string',
      honeypotBindList: { 'type': 'array', 'itemType': CreateHoneypotProbeRequestHoneypotBindList },
      ping: 'boolean',
      probeType: 'string',
      probeVersion: 'string',
      proxyIp: 'string',
      uuid: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotProbeResponseBody extends $tea.Model {
  code?: string;
  honeypotProbe?: CreateHoneypotProbeResponseBodyHoneypotProbe;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      honeypotProbe: 'HoneypotProbe',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      honeypotProbe: CreateHoneypotProbeResponseBodyHoneypotProbe,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotProbeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateHoneypotProbeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHoneypotProbeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotProbeBindRequest extends $tea.Model {
  bindPortList?: CreateHoneypotProbeBindRequestBindPortList[];
  honeypotId?: string;
  lang?: string;
  probeId?: string;
  serviceIpList?: string[];
  static names(): { [key: string]: string } {
    return {
      bindPortList: 'BindPortList',
      honeypotId: 'HoneypotId',
      lang: 'Lang',
      probeId: 'ProbeId',
      serviceIpList: 'ServiceIpList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindPortList: { 'type': 'array', 'itemType': CreateHoneypotProbeBindRequestBindPortList },
      honeypotId: 'string',
      lang: 'string',
      probeId: 'string',
      serviceIpList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotProbeBindResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotProbeBindResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateHoneypotProbeBindResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateHoneypotProbeBindResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInterceptionRuleRequest extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  dstTargetList?: { [key: string]: any };
  interceptType?: number;
  orderIndex?: number;
  ruleName?: string;
  ruleSwitch?: number;
  ruleType?: string;
  srcTarget?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      dstTargetList: 'DstTargetList',
      interceptType: 'InterceptType',
      orderIndex: 'OrderIndex',
      ruleName: 'RuleName',
      ruleSwitch: 'RuleSwitch',
      ruleType: 'RuleType',
      srcTarget: 'SrcTarget',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      dstTargetList: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      interceptType: 'number',
      orderIndex: 'number',
      ruleName: 'string',
      ruleSwitch: 'number',
      ruleType: 'string',
      srcTarget: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInterceptionRuleShrinkRequest extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  dstTargetListShrink?: string;
  interceptType?: number;
  orderIndex?: number;
  ruleName?: string;
  ruleSwitch?: number;
  ruleType?: string;
  srcTargetShrink?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      dstTargetListShrink: 'DstTargetList',
      interceptType: 'InterceptType',
      orderIndex: 'OrderIndex',
      ruleName: 'RuleName',
      ruleSwitch: 'RuleSwitch',
      ruleType: 'RuleType',
      srcTargetShrink: 'SrcTarget',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      dstTargetListShrink: 'string',
      interceptType: 'number',
      orderIndex: 'number',
      ruleName: 'string',
      ruleSwitch: 'number',
      ruleType: 'string',
      srcTargetShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInterceptionRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInterceptionRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateInterceptionRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateInterceptionRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInterceptionTargetRequest extends $tea.Model {
  appName?: string;
  clusterId?: string;
  clusterName?: string;
  imageList?: string[];
  namespace?: string;
  tagList?: string[];
  targetName?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      imageList: 'ImageList',
      namespace: 'Namespace',
      tagList: 'TagList',
      targetName: 'TargetName',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      clusterId: 'string',
      clusterName: 'string',
      imageList: { 'type': 'array', 'itemType': 'string' },
      namespace: 'string',
      tagList: { 'type': 'array', 'itemType': 'string' },
      targetName: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInterceptionTargetResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateInterceptionTargetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateInterceptionTargetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateInterceptionTargetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJenkinsImageRegistryRequest extends $tea.Model {
  domainName?: string;
  extraParam?: string;
  netType?: number;
  password?: string;
  persistenceDay?: number;
  protocolType?: number;
  regionId?: string;
  registryHostIp?: string;
  registryName?: string;
  registryType?: string;
  registryVersion?: string;
  sourceIp?: string;
  transPerHour?: number;
  userName?: string;
  vpcId?: string;
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      extraParam: 'ExtraParam',
      netType: 'NetType',
      password: 'Password',
      persistenceDay: 'PersistenceDay',
      protocolType: 'ProtocolType',
      regionId: 'RegionId',
      registryHostIp: 'RegistryHostIp',
      registryName: 'RegistryName',
      registryType: 'RegistryType',
      registryVersion: 'RegistryVersion',
      sourceIp: 'SourceIp',
      transPerHour: 'TransPerHour',
      userName: 'UserName',
      vpcId: 'VpcId',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      extraParam: 'string',
      netType: 'number',
      password: 'string',
      persistenceDay: 'number',
      protocolType: 'number',
      regionId: 'string',
      registryHostIp: 'string',
      registryName: 'string',
      registryType: 'string',
      registryVersion: 'string',
      sourceIp: 'string',
      transPerHour: 'number',
      userName: 'string',
      vpcId: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJenkinsImageRegistryResponseBody extends $tea.Model {
  data?: CreateJenkinsImageRegistryResponseBodyData;
  httpStatusCode?: number;
  requestId?: string;
  timeCost?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      timeCost: 'TimeCost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: CreateJenkinsImageRegistryResponseBodyData,
      httpStatusCode: 'number',
      requestId: 'string',
      timeCost: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJenkinsImageRegistryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateJenkinsImageRegistryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateJenkinsImageRegistryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMaliciousNoteRequest extends $tea.Model {
  eventId?: number;
  note?: string;
  static names(): { [key: string]: string } {
    return {
      eventId: 'EventId',
      note: 'Note',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventId: 'number',
      note: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMaliciousNoteResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateMaliciousNoteResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateMaliciousNoteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateMaliciousNoteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOpaClusterPluginRequest extends $tea.Model {
  clusterIds?: string[];
  static names(): { [key: string]: string } {
    return {
      clusterIds: 'ClusterIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOpaClusterPluginResponseBody extends $tea.Model {
  installStatus?: CreateOpaClusterPluginResponseBodyInstallStatus[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      installStatus: 'InstallStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      installStatus: { 'type': 'array', 'itemType': CreateOpaClusterPluginResponseBodyInstallStatus },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOpaClusterPluginResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateOpaClusterPluginResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOpaClusterPluginResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAssetGroupRequest extends $tea.Model {
  groupId?: number;
  groupName?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      groupName: 'GroupName',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      groupName: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAssetGroupResponseBody extends $tea.Model {
  groupId?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateAssetGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateOrUpdateAssetGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrUpdateAssetGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateDingTalkRequest extends $tea.Model {
  configList?: string;
  dingTalkLang?: string;
  groupIdList?: string;
  id?: number;
  intervalTime?: number;
  ruleActionName?: string;
  sendUrl?: string;
  static names(): { [key: string]: string } {
    return {
      configList: 'ConfigList',
      dingTalkLang: 'DingTalkLang',
      groupIdList: 'GroupIdList',
      id: 'Id',
      intervalTime: 'IntervalTime',
      ruleActionName: 'RuleActionName',
      sendUrl: 'SendUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configList: 'string',
      dingTalkLang: 'string',
      groupIdList: 'string',
      id: 'number',
      intervalTime: 'number',
      ruleActionName: 'string',
      sendUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateDingTalkResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrUpdateDingTalkResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateOrUpdateDingTalkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrUpdateDingTalkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOssBucketScanTaskRequest extends $tea.Model {
  bucketNameList?: string[];
  excludeKeySuffixList?: string[];
  keySuffixList?: string[];
  scanMode?: number;
  static names(): { [key: string]: string } {
    return {
      bucketNameList: 'BucketNameList',
      excludeKeySuffixList: 'ExcludeKeySuffixList',
      keySuffixList: 'KeySuffixList',
      scanMode: 'ScanMode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketNameList: { 'type': 'array', 'itemType': 'string' },
      excludeKeySuffixList: { 'type': 'array', 'itemType': 'string' },
      keySuffixList: { 'type': 'array', 'itemType': 'string' },
      scanMode: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOssBucketScanTaskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOssBucketScanTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateOssBucketScanTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOssBucketScanTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOssScanConfigRequest extends $tea.Model {
  bucketNameList?: string[];
  enable?: number;
  endTime?: string;
  keySuffixList?: string[];
  scanDayList?: number[];
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      bucketNameList: 'BucketNameList',
      enable: 'Enable',
      endTime: 'EndTime',
      keySuffixList: 'KeySuffixList',
      scanDayList: 'ScanDayList',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketNameList: { 'type': 'array', 'itemType': 'string' },
      enable: 'number',
      endTime: 'string',
      keySuffixList: { 'type': 'array', 'itemType': 'string' },
      scanDayList: { 'type': 'array', 'itemType': 'number' },
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOssScanConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOssScanConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateOssScanConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOssScanConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRestoreJobRequest extends $tea.Model {
  includes?: string;
  snapshotHash?: string;
  snapshotId?: string;
  snapshotVersion?: string;
  sourceType?: string;
  target?: string;
  uuid?: string;
  vaultId?: string;
  static names(): { [key: string]: string } {
    return {
      includes: 'Includes',
      snapshotHash: 'SnapshotHash',
      snapshotId: 'SnapshotId',
      snapshotVersion: 'SnapshotVersion',
      sourceType: 'SourceType',
      target: 'Target',
      uuid: 'Uuid',
      vaultId: 'VaultId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      includes: 'string',
      snapshotHash: 'string',
      snapshotId: 'string',
      snapshotVersion: 'string',
      sourceType: 'string',
      target: 'string',
      uuid: 'string',
      vaultId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRestoreJobResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateRestoreJobResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateRestoreJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateRestoreJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceLinkedRoleRequest extends $tea.Model {
  serviceLinkedRole?: string;
  static names(): { [key: string]: string } {
    return {
      serviceLinkedRole: 'ServiceLinkedRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceLinkedRole: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceLinkedRoleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceLinkedRoleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateServiceLinkedRoleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateServiceLinkedRoleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceTrailRequest extends $tea.Model {
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceTrailResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateServiceTrailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateServiceTrailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateServiceTrailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSimilarSecurityEventsQueryTaskRequest extends $tea.Model {
  resourceOwnerId?: number;
  securityEventId?: number;
  similarEventScenarioCode?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      resourceOwnerId: 'ResourceOwnerId',
      securityEventId: 'SecurityEventId',
      similarEventScenarioCode: 'SimilarEventScenarioCode',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceOwnerId: 'number',
      securityEventId: 'number',
      similarEventScenarioCode: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSimilarSecurityEventsQueryTaskResponseBody extends $tea.Model {
  createSimilarSecurityEventsQueryTaskResponse?: CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      createSimilarSecurityEventsQueryTaskResponse: 'CreateSimilarSecurityEventsQueryTaskResponse',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createSimilarSecurityEventsQueryTaskResponse: CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSimilarSecurityEventsQueryTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateSimilarSecurityEventsQueryTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSimilarSecurityEventsQueryTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSuspEventNoteRequest extends $tea.Model {
  eventId?: number;
  note?: string;
  static names(): { [key: string]: string } {
    return {
      eventId: 'EventId',
      note: 'Note',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventId: 'number',
      note: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSuspEventNoteResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSuspEventNoteResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateSuspEventNoteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSuspEventNoteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUniBackupPolicyRequest extends $tea.Model {
  accountName?: string;
  accountPassword?: string;
  databaseAddByUser?: string;
  databaseType?: string;
  fullPlan?: { [key: string]: any };
  incPlan?: { [key: string]: any };
  instanceId?: string;
  policyName?: string;
  retention?: number;
  speedLimiter?: number;
  uniRegionId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      accountName: 'AccountName',
      accountPassword: 'AccountPassword',
      databaseAddByUser: 'DatabaseAddByUser',
      databaseType: 'DatabaseType',
      fullPlan: 'FullPlan',
      incPlan: 'IncPlan',
      instanceId: 'InstanceId',
      policyName: 'PolicyName',
      retention: 'Retention',
      speedLimiter: 'SpeedLimiter',
      uniRegionId: 'UniRegionId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountName: 'string',
      accountPassword: 'string',
      databaseAddByUser: 'string',
      databaseType: 'string',
      fullPlan: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      incPlan: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      instanceId: 'string',
      policyName: 'string',
      retention: 'number',
      speedLimiter: 'number',
      uniRegionId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUniBackupPolicyShrinkRequest extends $tea.Model {
  accountName?: string;
  accountPassword?: string;
  databaseAddByUser?: string;
  databaseType?: string;
  fullPlanShrink?: string;
  incPlanShrink?: string;
  instanceId?: string;
  policyName?: string;
  retention?: number;
  speedLimiter?: number;
  uniRegionId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      accountName: 'AccountName',
      accountPassword: 'AccountPassword',
      databaseAddByUser: 'DatabaseAddByUser',
      databaseType: 'DatabaseType',
      fullPlanShrink: 'FullPlan',
      incPlanShrink: 'IncPlan',
      instanceId: 'InstanceId',
      policyName: 'PolicyName',
      retention: 'Retention',
      speedLimiter: 'SpeedLimiter',
      uniRegionId: 'UniRegionId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountName: 'string',
      accountPassword: 'string',
      databaseAddByUser: 'string',
      databaseType: 'string',
      fullPlanShrink: 'string',
      incPlanShrink: 'string',
      instanceId: 'string',
      policyName: 'string',
      retention: 'number',
      speedLimiter: 'number',
      uniRegionId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUniBackupPolicyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUniBackupPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateUniBackupPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateUniBackupPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUniRestorePlanRequest extends $tea.Model {
  database?: string;
  instanceUuid?: string;
  policyId?: number;
  resetScn?: string;
  resetTime?: string;
  restoreInfo?: string;
  timePoint?: number;
  static names(): { [key: string]: string } {
    return {
      database: 'Database',
      instanceUuid: 'InstanceUuid',
      policyId: 'PolicyId',
      resetScn: 'ResetScn',
      resetTime: 'ResetTime',
      restoreInfo: 'RestoreInfo',
      timePoint: 'TimePoint',
    };
  }

  static types(): { [key: string]: any } {
    return {
      database: 'string',
      instanceUuid: 'string',
      policyId: 'number',
      resetScn: 'string',
      resetTime: 'string',
      restoreInfo: 'string',
      timePoint: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUniRestorePlanResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateUniRestorePlanResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateUniRestorePlanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateUniRestorePlanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVirusScanOnceTaskRequest extends $tea.Model {
  scanPath?: string[];
  scanType?: string;
  selectionKey?: string;
  static names(): { [key: string]: string } {
    return {
      scanPath: 'ScanPath',
      scanType: 'ScanType',
      selectionKey: 'SelectionKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scanPath: { 'type': 'array', 'itemType': 'string' },
      scanType: 'string',
      selectionKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVirusScanOnceTaskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVirusScanOnceTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateVirusScanOnceTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateVirusScanOnceTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVulAutoRepairConfigRequest extends $tea.Model {
  reason?: string;
  type?: string;
  vulAutoRepairConfigList?: CreateVulAutoRepairConfigRequestVulAutoRepairConfigList[];
  static names(): { [key: string]: string } {
    return {
      reason: 'Reason',
      type: 'Type',
      vulAutoRepairConfigList: 'VulAutoRepairConfigList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reason: 'string',
      type: 'string',
      vulAutoRepairConfigList: { 'type': 'array', 'itemType': CreateVulAutoRepairConfigRequestVulAutoRepairConfigList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVulAutoRepairConfigResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVulAutoRepairConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: CreateVulAutoRepairConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateVulAutoRepairConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntiBruteForceRuleRequest extends $tea.Model {
  ids?: number[];
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntiBruteForceRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntiBruteForceRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteAntiBruteForceRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAntiBruteForceRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBackupPolicyRequest extends $tea.Model {
  id?: number;
  policyVersion?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      policyVersion: 'PolicyVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      policyVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBackupPolicyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBackupPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteBackupPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteBackupPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBackupPolicyMachineRequest extends $tea.Model {
  policyId?: number;
  policyVersion?: string;
  uuid?: string;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      policyVersion: 'PolicyVersion',
      uuid: 'Uuid',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
      policyVersion: 'string',
      uuid: 'string',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBackupPolicyMachineResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBackupPolicyMachineResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteBackupPolicyMachineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteBackupPolicyMachineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBinarySecurityPolicyRequest extends $tea.Model {
  name?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBinarySecurityPolicyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteBinarySecurityPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteBinarySecurityPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteBinarySecurityPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientUserDefineRuleRequest extends $tea.Model {
  idList?: number[];
  static names(): { [key: string]: string } {
    return {
      idList: 'IdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      idList: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientUserDefineRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteClientUserDefineRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteClientUserDefineRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteClientUserDefineRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContainerDefenseRuleRequest extends $tea.Model {
  ruleIds?: number[];
  static names(): { [key: string]: string } {
    return {
      ruleIds: 'RuleIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContainerDefenseRuleResponseBody extends $tea.Model {
  code?: string;
  data?: number;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'number',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteContainerDefenseRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteContainerDefenseRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteContainerDefenseRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomBlockRecordRequest extends $tea.Model {
  id?: number;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomBlockRecordResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCustomBlockRecordResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteCustomBlockRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCustomBlockRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCycleTaskRequest extends $tea.Model {
  configId?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCycleTaskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteCycleTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteCycleTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteCycleTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileProtectRuleRequest extends $tea.Model {
  id?: number[];
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileProtectRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteFileProtectRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteFileProtectRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteFileProtectRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupRequest extends $tea.Model {
  groupId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupResponseBody extends $tea.Model {
  code?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotRequest extends $tea.Model {
  honeypotId?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      honeypotId: 'HoneypotId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeypotId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteHoneypotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHoneypotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotNodeRequest extends $tea.Model {
  lang?: string;
  nodeId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      nodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotNodeResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotNodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteHoneypotNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHoneypotNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotPresetRequest extends $tea.Model {
  honeypotPresetId?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      honeypotPresetId: 'HoneypotPresetId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeypotPresetId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotPresetResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotPresetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteHoneypotPresetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHoneypotPresetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotProbeRequest extends $tea.Model {
  lang?: string;
  probeId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      probeId: 'ProbeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      probeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotProbeResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotProbeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteHoneypotProbeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHoneypotProbeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotProbeBindRequest extends $tea.Model {
  bindId?: string;
  lang?: string;
  probeId?: string;
  static names(): { [key: string]: string } {
    return {
      bindId: 'BindId',
      lang: 'Lang',
      probeId: 'ProbeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindId: 'string',
      lang: 'string',
      probeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotProbeBindResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteHoneypotProbeBindResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteHoneypotProbeBindResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteHoneypotProbeBindResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageEventOperationRequest extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageEventOperationResponseBody extends $tea.Model {
  code?: string;
  data?: DeleteImageEventOperationResponseBodyData;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: DeleteImageEventOperationResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageEventOperationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteImageEventOperationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteImageEventOperationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageVulWhitelistRequest extends $tea.Model {
  ids?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageVulWhitelistResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageVulWhitelistResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteImageVulWhitelistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteImageVulWhitelistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstallCodeRequest extends $tea.Model {
  captchaCode?: string;
  static names(): { [key: string]: string } {
    return {
      captchaCode: 'CaptchaCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      captchaCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstallCodeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInstallCodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteInstallCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteInstallCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInterceptionRuleRequest extends $tea.Model {
  clusterId?: string;
  ruleIds?: number[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      ruleIds: 'RuleIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      ruleIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInterceptionRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInterceptionRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteInterceptionRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteInterceptionRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInterceptionTargetRequest extends $tea.Model {
  targetIds?: string;
  static names(): { [key: string]: string } {
    return {
      targetIds: 'TargetIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInterceptionTargetResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteInterceptionTargetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteInterceptionTargetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteInterceptionTargetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLoginBaseConfigRequest extends $tea.Model {
  config?: string;
  target?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      target: 'Target',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      target: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLoginBaseConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteLoginBaseConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteLoginBaseConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteLoginBaseConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMaliciousNoteRequest extends $tea.Model {
  noteId?: number;
  static names(): { [key: string]: string } {
    return {
      noteId: 'NoteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      noteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMaliciousNoteResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteMaliciousNoteResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteMaliciousNoteResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteMaliciousNoteResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrivateRegistryRequest extends $tea.Model {
  registryId?: number;
  static names(): { [key: string]: string } {
    return {
      registryId: 'RegistryId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      registryId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrivateRegistryResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeletePrivateRegistryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeletePrivateRegistryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeletePrivateRegistryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityEventMarkMissListRequest extends $tea.Model {
  ids?: number[];
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: { 'type': 'array', 'itemType': 'number' },
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityEventMarkMissListResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSecurityEventMarkMissListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteSecurityEventMarkMissListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSecurityEventMarkMissListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteServiceTrailRequest extends $tea.Model {
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteServiceTrailResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteServiceTrailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteServiceTrailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteServiceTrailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStrategyRequest extends $tea.Model {
  id?: string;
  lang?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      lang: 'Lang',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      lang: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStrategyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteStrategyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSuspEventNodeRequest extends $tea.Model {
  noteId?: number;
  static names(): { [key: string]: string } {
    return {
      noteId: 'NoteId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      noteId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSuspEventNodeResponseBody extends $tea.Model {
  code?: string;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteSuspEventNodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteSuspEventNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteSuspEventNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagWithUuidRequest extends $tea.Model {
  tagName?: string;
  uuidList?: string;
  static names(): { [key: string]: string } {
    return {
      tagName: 'TagName',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagName: 'string',
      uuidList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagWithUuidResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTagWithUuidResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteTagWithUuidResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTagWithUuidResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUniBackupPolicyRequest extends $tea.Model {
  policyId?: number;
  policyIds?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      policyIds: 'PolicyIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
      policyIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUniBackupPolicyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteUniBackupPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteUniBackupPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteUniBackupPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVpcHoneyPotRequest extends $tea.Model {
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVpcHoneyPotResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVpcHoneyPotResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteVpcHoneyPotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteVpcHoneyPotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVulWhitelistRequest extends $tea.Model {
  id?: string;
  whitelist?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      whitelist: 'Whitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      whitelist: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVulWhitelistResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteVulWhitelistResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DeleteVulWhitelistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteVulWhitelistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessKeyLeakDetailRequest extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessKeyLeakDetailResponseBody extends $tea.Model {
  accesskeyId?: string;
  asset?: string;
  code?: string;
  dealTime?: string;
  dealType?: string;
  githubFileName?: string;
  githubFileType?: string;
  githubFileUpdateTime?: string;
  githubFileUrl?: string;
  githubRepoName?: string;
  githubRepoUrl?: string;
  githubUser?: string;
  githubUserPicUrl?: string;
  gmtCreate?: string;
  gmtModified?: string;
  remark?: string;
  requestId?: string;
  source?: string;
  tokenValid?: number;
  type?: string;
  whitelistStatus?: string;
  whitelistTime?: number;
  static names(): { [key: string]: string } {
    return {
      accesskeyId: 'AccesskeyId',
      asset: 'Asset',
      code: 'Code',
      dealTime: 'DealTime',
      dealType: 'DealType',
      githubFileName: 'GithubFileName',
      githubFileType: 'GithubFileType',
      githubFileUpdateTime: 'GithubFileUpdateTime',
      githubFileUrl: 'GithubFileUrl',
      githubRepoName: 'GithubRepoName',
      githubRepoUrl: 'GithubRepoUrl',
      githubUser: 'GithubUser',
      githubUserPicUrl: 'GithubUserPicUrl',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      remark: 'Remark',
      requestId: 'RequestId',
      source: 'Source',
      tokenValid: 'TokenValid',
      type: 'Type',
      whitelistStatus: 'WhitelistStatus',
      whitelistTime: 'WhitelistTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accesskeyId: 'string',
      asset: 'string',
      code: 'string',
      dealTime: 'string',
      dealType: 'string',
      githubFileName: 'string',
      githubFileType: 'string',
      githubFileUpdateTime: 'string',
      githubFileUrl: 'string',
      githubRepoName: 'string',
      githubRepoUrl: 'string',
      githubUser: 'string',
      githubUserPicUrl: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      remark: 'string',
      requestId: 'string',
      source: 'string',
      tokenValid: 'number',
      type: 'string',
      whitelistStatus: 'string',
      whitelistTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccessKeyLeakDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAccessKeyLeakDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAccessKeyLeakDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccesskeyLeakListRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  query?: string;
  startTs?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      query: 'Query',
      startTs: 'StartTs',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      query: 'string',
      startTs: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccesskeyLeakListResponseBody extends $tea.Model {
  accessKeyLeakList?: DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList[];
  akLeakCount?: number;
  currentPage?: number;
  gmtLast?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      accessKeyLeakList: 'AccessKeyLeakList',
      akLeakCount: 'AkLeakCount',
      currentPage: 'CurrentPage',
      gmtLast: 'GmtLast',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKeyLeakList: { 'type': 'array', 'itemType': DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList },
      akLeakCount: 'number',
      currentPage: 'number',
      gmtLast: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccesskeyLeakListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAccesskeyLeakListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAccesskeyLeakListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAffectedAssetsRequest extends $tea.Model {
  current?: string;
  levels?: string;
  pageSize?: string;
  static names(): { [key: string]: string } {
    return {
      current: 'Current',
      levels: 'Levels',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'string',
      levels: 'string',
      pageSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAffectedAssetsResponseBody extends $tea.Model {
  assetList?: DescribeAffectedAssetsResponseBodyAssetList[];
  pageInfo?: DescribeAffectedAssetsResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      assetList: 'AssetList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetList: { 'type': 'array', 'itemType': DescribeAffectedAssetsResponseBodyAssetList },
      pageInfo: DescribeAffectedAssetsResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAffectedAssetsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAffectedAssetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAffectedAssetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAffectedMaliciousFileImagesRequest extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  containerId?: string;
  currentPage?: number;
  image?: string;
  imageDigest?: string;
  imageLayer?: string;
  imageTag?: string;
  lang?: string;
  levels?: string;
  maliciousMd5?: string;
  namespace?: string;
  pageSize?: string;
  pod?: string;
  repoId?: string;
  repoInstanceId?: string;
  repoName?: string;
  repoNamespace?: string;
  repoRegionId?: string;
  scanRange?: string[];
  status?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      containerId: 'ContainerId',
      currentPage: 'CurrentPage',
      image: 'Image',
      imageDigest: 'ImageDigest',
      imageLayer: 'ImageLayer',
      imageTag: 'ImageTag',
      lang: 'Lang',
      levels: 'Levels',
      maliciousMd5: 'MaliciousMd5',
      namespace: 'Namespace',
      pageSize: 'PageSize',
      pod: 'Pod',
      repoId: 'RepoId',
      repoInstanceId: 'RepoInstanceId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      repoRegionId: 'RepoRegionId',
      scanRange: 'ScanRange',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      containerId: 'string',
      currentPage: 'number',
      image: 'string',
      imageDigest: 'string',
      imageLayer: 'string',
      imageTag: 'string',
      lang: 'string',
      levels: 'string',
      maliciousMd5: 'string',
      namespace: 'string',
      pageSize: 'string',
      pod: 'string',
      repoId: 'string',
      repoInstanceId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      repoRegionId: 'string',
      scanRange: { 'type': 'array', 'itemType': 'string' },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAffectedMaliciousFileImagesResponseBody extends $tea.Model {
  affectedMaliciousFileImagesResponse?: DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse[];
  pageInfo?: DescribeAffectedMaliciousFileImagesResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      affectedMaliciousFileImagesResponse: 'AffectedMaliciousFileImagesResponse',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectedMaliciousFileImagesResponse: { 'type': 'array', 'itemType': DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse },
      pageInfo: DescribeAffectedMaliciousFileImagesResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAffectedMaliciousFileImagesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAffectedMaliciousFileImagesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAffectedMaliciousFileImagesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAgentInstallStatusRequest extends $tea.Model {
  lang?: string;
  sourceIp?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      sourceIp: 'SourceIp',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      sourceIp: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAgentInstallStatusResponseBody extends $tea.Model {
  aegisClientInvokeStatusResponseList?: DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      aegisClientInvokeStatusResponseList: 'AegisClientInvokeStatusResponseList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aegisClientInvokeStatusResponseList: { 'type': 'array', 'itemType': DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAgentInstallStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAgentInstallStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAgentInstallStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlarmEventDetailRequest extends $tea.Model {
  alarmUniqueInfo?: string;
  from?: string;
  lang?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      alarmUniqueInfo: 'AlarmUniqueInfo',
      from: 'From',
      lang: 'Lang',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmUniqueInfo: 'string',
      from: 'string',
      lang: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlarmEventDetailResponseBody extends $tea.Model {
  data?: DescribeAlarmEventDetailResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeAlarmEventDetailResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlarmEventDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAlarmEventDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAlarmEventDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlarmEventStackInfoRequest extends $tea.Model {
  eventName?: string;
  lang?: string;
  resourceDirectoryAccountId?: number;
  sourceIp?: string;
  uniqueInfo?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      eventName: 'EventName',
      lang: 'Lang',
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
      sourceIp: 'SourceIp',
      uniqueInfo: 'UniqueInfo',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventName: 'string',
      lang: 'string',
      resourceDirectoryAccountId: 'number',
      sourceIp: 'string',
      uniqueInfo: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlarmEventStackInfoResponseBody extends $tea.Model {
  requestId?: string;
  stackInfo?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      stackInfo: 'StackInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      stackInfo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlarmEventStackInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAlarmEventStackInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAlarmEventStackInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllEntityResponseBody extends $tea.Model {
  entityList?: DescribeAllEntityResponseBodyEntityList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      entityList: 'EntityList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      entityList: { 'type': 'array', 'itemType': DescribeAllEntityResponseBodyEntityList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllEntityResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAllEntityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAllEntityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllGroupsRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllGroupsResponseBody extends $tea.Model {
  count?: number;
  groups?: DescribeAllGroupsResponseBodyGroups[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      groups: 'Groups',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      groups: { 'type': 'array', 'itemType': DescribeAllGroupsResponseBodyGroups },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllGroupsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAllGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAllGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllImageBaselineRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllImageBaselineResponseBody extends $tea.Model {
  imageBaselines?: DescribeAllImageBaselineResponseBodyImageBaselines;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      imageBaselines: 'ImageBaselines',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageBaselines: DescribeAllImageBaselineResponseBodyImageBaselines,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllImageBaselineResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAllImageBaselineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAllImageBaselineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntiBruteForceRulesRequest extends $tea.Model {
  currentPage?: number;
  id?: number;
  name?: string;
  pageSize?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      id: 'Id',
      name: 'Name',
      pageSize: 'PageSize',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      id: 'number',
      name: 'string',
      pageSize: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntiBruteForceRulesResponseBody extends $tea.Model {
  pageInfo?: DescribeAntiBruteForceRulesResponseBodyPageInfo;
  requestId?: string;
  rules?: DescribeAntiBruteForceRulesResponseBodyRules[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribeAntiBruteForceRulesResponseBodyPageInfo,
      requestId: 'string',
      rules: { 'type': 'array', 'itemType': DescribeAntiBruteForceRulesResponseBodyRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntiBruteForceRulesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAntiBruteForceRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntiBruteForceRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppVulScanCycleResponseBody extends $tea.Model {
  cycle?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cycle: 'Cycle',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycle: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppVulScanCycleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAppVulScanCycleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAppVulScanCycleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetDetailByUuidRequest extends $tea.Model {
  lang?: string;
  sourceIp?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      sourceIp: 'SourceIp',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      sourceIp: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetDetailByUuidResponseBody extends $tea.Model {
  assetDetail?: DescribeAssetDetailByUuidResponseBodyAssetDetail;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      assetDetail: 'AssetDetail',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetDetail: DescribeAssetDetailByUuidResponseBodyAssetDetail,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetDetailByUuidResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAssetDetailByUuidResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAssetDetailByUuidResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetDetailByUuidsRequest extends $tea.Model {
  lang?: string;
  resourceDirectoryAccountId?: number;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      resourceDirectoryAccountId: 'number',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetDetailByUuidsResponseBody extends $tea.Model {
  assetList?: DescribeAssetDetailByUuidsResponseBodyAssetList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      assetList: 'AssetList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetList: { 'type': 'array', 'itemType': DescribeAssetDetailByUuidsResponseBodyAssetList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetDetailByUuidsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAssetDetailByUuidsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAssetDetailByUuidsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetSummaryResponseBody extends $tea.Model {
  assetsSummary?: DescribeAssetSummaryResponseBodyAssetsSummary;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      assetsSummary: 'AssetsSummary',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetsSummary: DescribeAssetSummaryResponseBodyAssetsSummary,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetSummaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAssetSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAssetSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetsSecurityEventSummaryRequest extends $tea.Model {
  clusterId?: string;
  containerFieldName?: string;
  containerFieldValue?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      containerFieldName: 'ContainerFieldName',
      containerFieldValue: 'ContainerFieldValue',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      containerFieldName: 'string',
      containerFieldValue: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetsSecurityEventSummaryResponseBody extends $tea.Model {
  assets?: DescribeAssetsSecurityEventSummaryResponseBodyAssets[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      assets: 'Assets',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assets: { 'type': 'array', 'itemType': DescribeAssetsSecurityEventSummaryResponseBodyAssets },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetsSecurityEventSummaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAssetsSecurityEventSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAssetsSecurityEventSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAttachRecordsRequest extends $tea.Model {
  applicationId?: string;
  ecsUUIDList?: string[];
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      ecsUUIDList: 'EcsUUIDList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      ecsUUIDList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAttachRecordsResponseBody extends $tea.Model {
  accessList?: DescribeAttachRecordsResponseBodyAccessList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      accessList: 'AccessList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessList: { 'type': 'array', 'itemType': DescribeAttachRecordsResponseBodyAccessList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAttachRecordsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAttachRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAttachRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAttackAnalysisDataRequest extends $tea.Model {
  base64?: string;
  currentPage?: number;
  data?: string;
  endTime?: number;
  lang?: string;
  pageSize?: number;
  startTime?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      base64: 'Base64',
      currentPage: 'CurrentPage',
      data: 'Data',
      endTime: 'EndTime',
      lang: 'Lang',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      base64: 'string',
      currentPage: 'number',
      data: 'string',
      endTime: 'number',
      lang: 'string',
      pageSize: 'number',
      startTime: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAttackAnalysisDataResponseBody extends $tea.Model {
  data?: string;
  page?: number;
  pageSize?: number;
  requestId?: string;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      page: 'Page',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      page: 'number',
      pageSize: 'number',
      requestId: 'string',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAttackAnalysisDataResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAttackAnalysisDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAttackAnalysisDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoDelConfigResponseBody extends $tea.Model {
  days?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      days: 'Days',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      days: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAutoDelConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeAutoDelConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAutoDelConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackUpExportInfoRequest extends $tea.Model {
  currentPage?: number;
  exportType?: string;
  lang?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      exportType: 'ExportType',
      lang: 'Lang',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      exportType: 'string',
      lang: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackUpExportInfoResponseBody extends $tea.Model {
  data?: DescribeBackUpExportInfoResponseBodyData[];
  pageInfo?: DescribeBackUpExportInfoResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeBackUpExportInfoResponseBodyData },
      pageInfo: DescribeBackUpExportInfoResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackUpExportInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeBackUpExportInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBackUpExportInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupClientsRequest extends $tea.Model {
  supportRegionId?: string;
  static names(): { [key: string]: string } {
    return {
      supportRegionId: 'SupportRegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      supportRegionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupClientsResponseBody extends $tea.Model {
  clients?: DescribeBackupClientsResponseBodyClients[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clients: 'Clients',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clients: { 'type': 'array', 'itemType': DescribeBackupClientsResponseBodyClients },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupClientsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeBackupClientsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBackupClientsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupFilesRequest extends $tea.Model {
  currentPage?: string;
  pageSize?: string;
  path?: string;
  snapshotHash?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      path: 'Path',
      snapshotHash: 'SnapshotHash',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'string',
      pageSize: 'string',
      path: 'string',
      snapshotHash: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupFilesResponseBody extends $tea.Model {
  backupFiles?: DescribeBackupFilesResponseBodyBackupFiles[];
  pageInfo?: DescribeBackupFilesResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      backupFiles: 'BackupFiles',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupFiles: { 'type': 'array', 'itemType': DescribeBackupFilesResponseBodyBackupFiles },
      pageInfo: DescribeBackupFilesResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupFilesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeBackupFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBackupFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupMachineStatusRequest extends $tea.Model {
  policyId?: number;
  policyVersion?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
      policyVersion: 'PolicyVersion',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
      policyVersion: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupMachineStatusResponseBody extends $tea.Model {
  backupMachineStatus?: DescribeBackupMachineStatusResponseBodyBackupMachineStatus;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      backupMachineStatus: 'BackupMachineStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupMachineStatus: DescribeBackupMachineStatusResponseBodyBackupMachineStatus,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupMachineStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeBackupMachineStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBackupMachineStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupPoliciesRequest extends $tea.Model {
  currentPage?: number;
  machineRemark?: string;
  name?: string;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      machineRemark: 'MachineRemark',
      name: 'Name',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      machineRemark: 'string',
      name: 'string',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupPoliciesResponseBody extends $tea.Model {
  pageInfo?: DescribeBackupPoliciesResponseBodyPageInfo;
  policies?: DescribeBackupPoliciesResponseBodyPolicies[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      policies: 'Policies',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribeBackupPoliciesResponseBodyPageInfo,
      policies: { 'type': 'array', 'itemType': DescribeBackupPoliciesResponseBodyPolicies },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupPoliciesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeBackupPoliciesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBackupPoliciesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupPolicyRequest extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupPolicyResponseBody extends $tea.Model {
  backupPolicyDetail?: DescribeBackupPolicyResponseBodyBackupPolicyDetail;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      backupPolicyDetail: 'BackupPolicyDetail',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupPolicyDetail: DescribeBackupPolicyResponseBodyBackupPolicyDetail,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeBackupPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBackupPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupRestoreCountResponseBody extends $tea.Model {
  backupRestoreCount?: DescribeBackupRestoreCountResponseBodyBackupRestoreCount;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      backupRestoreCount: 'BackupRestoreCount',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupRestoreCount: DescribeBackupRestoreCountResponseBodyBackupRestoreCount,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupRestoreCountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeBackupRestoreCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBackupRestoreCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBruteForceRecordsRequest extends $tea.Model {
  blockIp?: string;
  currentPage?: number;
  pageSize?: number;
  resourceOwnerId?: number;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      blockIp: 'BlockIp',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockIp: 'string',
      currentPage: 'number',
      pageSize: 'number',
      resourceOwnerId: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBruteForceRecordsResponseBody extends $tea.Model {
  machineList?: DescribeBruteForceRecordsResponseBodyMachineList[];
  pageInfo?: DescribeBruteForceRecordsResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      machineList: 'MachineList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      machineList: { 'type': 'array', 'itemType': DescribeBruteForceRecordsResponseBodyMachineList },
      pageInfo: DescribeBruteForceRecordsResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBruteForceRecordsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeBruteForceRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBruteForceRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBruteForceSummaryRequest extends $tea.Model {
  resourceOwnerId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceOwnerId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBruteForceSummaryResponseBody extends $tea.Model {
  bruteForceSummary?: DescribeBruteForceSummaryResponseBodyBruteForceSummary;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      bruteForceSummary: 'BruteForceSummary',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bruteForceSummary: DescribeBruteForceSummaryResponseBodyBruteForceSummary,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBruteForceSummaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeBruteForceSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBruteForceSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCanFixVulListRequest extends $tea.Model {
  aliasName?: string;
  clusterId?: string;
  clusterName?: string;
  containerId?: string;
  currentPage?: number;
  dealed?: string;
  digest?: string;
  image?: string;
  instanceId?: string;
  name?: string;
  namespace?: string;
  necessity?: string;
  pageSize?: number;
  pod?: string;
  regionId?: string;
  repoId?: string;
  repoInstanceId?: string;
  repoName?: string;
  repoNamespace?: string;
  repoRegionId?: string;
  scanRange?: string[];
  statusList?: string;
  tag?: string;
  type?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      containerId: 'ContainerId',
      currentPage: 'CurrentPage',
      dealed: 'Dealed',
      digest: 'Digest',
      image: 'Image',
      instanceId: 'InstanceId',
      name: 'Name',
      namespace: 'Namespace',
      necessity: 'Necessity',
      pageSize: 'PageSize',
      pod: 'Pod',
      regionId: 'RegionId',
      repoId: 'RepoId',
      repoInstanceId: 'RepoInstanceId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      repoRegionId: 'RepoRegionId',
      scanRange: 'ScanRange',
      statusList: 'StatusList',
      tag: 'Tag',
      type: 'Type',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      clusterId: 'string',
      clusterName: 'string',
      containerId: 'string',
      currentPage: 'number',
      dealed: 'string',
      digest: 'string',
      image: 'string',
      instanceId: 'string',
      name: 'string',
      namespace: 'string',
      necessity: 'string',
      pageSize: 'number',
      pod: 'string',
      regionId: 'string',
      repoId: 'string',
      repoInstanceId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      repoRegionId: 'string',
      scanRange: { 'type': 'array', 'itemType': 'string' },
      statusList: 'string',
      tag: 'string',
      type: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCanFixVulListResponseBody extends $tea.Model {
  requestId?: string;
  vulRecords?: DescribeCanFixVulListResponseBodyVulRecords[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vulRecords: 'VulRecords',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vulRecords: { 'type': 'array', 'itemType': DescribeCanFixVulListResponseBodyVulRecords },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCanFixVulListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCanFixVulListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCanFixVulListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckEcsWarningsRequest extends $tea.Model {
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckEcsWarningsResponseBody extends $tea.Model {
  canTry?: string;
  requestId?: string;
  sasVersion?: string;
  weakPasswordCount?: string;
  static names(): { [key: string]: string } {
    return {
      canTry: 'CanTry',
      requestId: 'RequestId',
      sasVersion: 'SasVersion',
      weakPasswordCount: 'WeakPasswordCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canTry: 'string',
      requestId: 'string',
      sasVersion: 'string',
      weakPasswordCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckEcsWarningsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCheckEcsWarningsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCheckEcsWarningsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckFixDetailsRequest extends $tea.Model {
  checkIds?: string;
  lang?: string;
  riskId?: number;
  static names(): { [key: string]: string } {
    return {
      checkIds: 'CheckIds',
      lang: 'Lang',
      riskId: 'RiskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkIds: 'string',
      lang: 'string',
      riskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckFixDetailsResponseBody extends $tea.Model {
  checkFixDetails?: DescribeCheckFixDetailsResponseBodyCheckFixDetails[];
  count?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      checkFixDetails: 'CheckFixDetails',
      count: 'Count',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkFixDetails: { 'type': 'array', 'itemType': DescribeCheckFixDetailsResponseBodyCheckFixDetails },
      count: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckFixDetailsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCheckFixDetailsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCheckFixDetailsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningDetailRequest extends $tea.Model {
  checkWarningId?: number;
  lang?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      checkWarningId: 'CheckWarningId',
      lang: 'Lang',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkWarningId: 'number',
      lang: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningDetailResponseBody extends $tea.Model {
  advice?: string;
  checkDetailAssetInfo?: { [key: string]: string }[];
  checkDetailColumns?: DescribeCheckWarningDetailResponseBodyCheckDetailColumns[];
  checkId?: number;
  description?: string;
  item?: string;
  level?: string;
  prompt?: string;
  requestId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      checkDetailAssetInfo: 'CheckDetailAssetInfo',
      checkDetailColumns: 'CheckDetailColumns',
      checkId: 'CheckId',
      description: 'Description',
      item: 'Item',
      level: 'Level',
      prompt: 'Prompt',
      requestId: 'RequestId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      checkDetailAssetInfo: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'string' } },
      checkDetailColumns: { 'type': 'array', 'itemType': DescribeCheckWarningDetailResponseBodyCheckDetailColumns },
      checkId: 'number',
      description: 'string',
      item: 'string',
      level: 'string',
      prompt: 'string',
      requestId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCheckWarningDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCheckWarningDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningMachinesRequest extends $tea.Model {
  checkId?: number;
  lang?: string;
  riskId?: number;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      lang: 'Lang',
      riskId: 'RiskId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      lang: 'string',
      riskId: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningMachinesResponseBody extends $tea.Model {
  count?: number;
  machines?: DescribeCheckWarningMachinesResponseBodyMachines[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      machines: 'Machines',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      machines: { 'type': 'array', 'itemType': DescribeCheckWarningMachinesResponseBodyMachines },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningMachinesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCheckWarningMachinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCheckWarningMachinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningSummaryRequest extends $tea.Model {
  clusterId?: string;
  containerFieldName?: string;
  containerFieldValue?: string;
  currentPage?: number;
  groupId?: number;
  lang?: string;
  pageSize?: number;
  riskName?: string;
  riskStatus?: number;
  sourceIp?: string;
  status?: string;
  strategyId?: number;
  targetType?: string;
  typeName?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      containerFieldName: 'ContainerFieldName',
      containerFieldValue: 'ContainerFieldValue',
      currentPage: 'CurrentPage',
      groupId: 'GroupId',
      lang: 'Lang',
      pageSize: 'PageSize',
      riskName: 'RiskName',
      riskStatus: 'RiskStatus',
      sourceIp: 'SourceIp',
      status: 'Status',
      strategyId: 'StrategyId',
      targetType: 'TargetType',
      typeName: 'TypeName',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      containerFieldName: 'string',
      containerFieldValue: 'string',
      currentPage: 'number',
      groupId: 'number',
      lang: 'string',
      pageSize: 'number',
      riskName: 'string',
      riskStatus: 'number',
      sourceIp: 'string',
      status: 'string',
      strategyId: 'number',
      targetType: 'string',
      typeName: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningSummaryResponseBody extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  warningSummarys?: DescribeCheckWarningSummaryResponseBodyWarningSummarys[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      warningSummarys: 'WarningSummarys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      warningSummarys: { 'type': 'array', 'itemType': DescribeCheckWarningSummaryResponseBodyWarningSummarys },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningSummaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCheckWarningSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCheckWarningSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningsRequest extends $tea.Model {
  checkId?: number;
  checkType?: string;
  containerName?: string;
  currentPage?: number;
  lang?: string;
  pageSize?: number;
  riskId?: number;
  riskStatus?: number;
  sourceIp?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      checkType: 'CheckType',
      containerName: 'ContainerName',
      currentPage: 'CurrentPage',
      lang: 'Lang',
      pageSize: 'PageSize',
      riskId: 'RiskId',
      riskStatus: 'RiskStatus',
      sourceIp: 'SourceIp',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      checkType: 'string',
      containerName: 'string',
      currentPage: 'number',
      lang: 'string',
      pageSize: 'number',
      riskId: 'number',
      riskStatus: 'number',
      sourceIp: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningsResponseBody extends $tea.Model {
  checkWarnings?: DescribeCheckWarningsResponseBodyCheckWarnings[];
  count?: number;
  currentPage?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      checkWarnings: 'CheckWarnings',
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkWarnings: { 'type': 'array', 'itemType': DescribeCheckWarningsResponseBodyCheckWarnings },
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCheckWarningsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCheckWarningsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClientConfSetupRequest extends $tea.Model {
  strategyTag?: string;
  strategyTagValue?: string;
  static names(): { [key: string]: string } {
    return {
      strategyTag: 'StrategyTag',
      strategyTagValue: 'StrategyTagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      strategyTag: 'string',
      strategyTagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClientConfSetupResponseBody extends $tea.Model {
  clientConf?: DescribeClientConfSetupResponseBodyClientConf;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clientConf: 'ClientConf',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientConf: DescribeClientConfSetupResponseBodyClientConf,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClientConfSetupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeClientConfSetupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeClientConfSetupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClientConfStrategyRequest extends $tea.Model {
  tag?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClientConfStrategyResponseBody extends $tea.Model {
  requestId?: string;
  targetList?: DescribeClientConfStrategyResponseBodyTargetList[];
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      targetList: 'TargetList',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      targetList: { 'type': 'array', 'itemType': DescribeClientConfStrategyResponseBodyTargetList },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClientConfStrategyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeClientConfStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeClientConfStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudCenterInstancesRequest extends $tea.Model {
  criteria?: string;
  currentPage?: number;
  importance?: number;
  lang?: string;
  logicalExp?: string;
  machineTypes?: string;
  nextToken?: string;
  noGroupTrace?: boolean;
  pageSize?: number;
  regionId?: string;
  resourceDirectoryAccountId?: number;
  useNextToken?: boolean;
  static names(): { [key: string]: string } {
    return {
      criteria: 'Criteria',
      currentPage: 'CurrentPage',
      importance: 'Importance',
      lang: 'Lang',
      logicalExp: 'LogicalExp',
      machineTypes: 'MachineTypes',
      nextToken: 'NextToken',
      noGroupTrace: 'NoGroupTrace',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
      useNextToken: 'UseNextToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteria: 'string',
      currentPage: 'number',
      importance: 'number',
      lang: 'string',
      logicalExp: 'string',
      machineTypes: 'string',
      nextToken: 'string',
      noGroupTrace: 'boolean',
      pageSize: 'number',
      regionId: 'string',
      resourceDirectoryAccountId: 'number',
      useNextToken: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudCenterInstancesResponseBody extends $tea.Model {
  instances?: DescribeCloudCenterInstancesResponseBodyInstances[];
  pageInfo?: DescribeCloudCenterInstancesResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: { 'type': 'array', 'itemType': DescribeCloudCenterInstancesResponseBodyInstances },
      pageInfo: DescribeCloudCenterInstancesResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudCenterInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCloudCenterInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudCenterInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudProductFieldStatisticsResponseBody extends $tea.Model {
  groupedFields?: DescribeCloudProductFieldStatisticsResponseBodyGroupedFields;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupedFields: 'GroupedFields',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupedFields: DescribeCloudProductFieldStatisticsResponseBodyGroupedFields,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudProductFieldStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCloudProductFieldStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudProductFieldStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoRequest extends $tea.Model {
  clusterId?: string;
  targetType?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      targetType: 'TargetType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      targetType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBody extends $tea.Model {
  clusterInfo?: DescribeClusterBasicInfoResponseBodyClusterInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterInfo: 'ClusterInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterInfo: DescribeClusterBasicInfoResponseBodyClusterInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeClusterBasicInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeClusterBasicInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterInfoListRequest extends $tea.Model {
  target?: string;
  targetType?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      target: 'Target',
      targetType: 'TargetType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      target: 'string',
      targetType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterInfoListResponseBody extends $tea.Model {
  clusterList?: DescribeClusterInfoListResponseBodyClusterList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterList: 'ClusterList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterList: { 'type': 'array', 'itemType': DescribeClusterInfoListResponseBodyClusterList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterInfoListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeClusterInfoListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeClusterInfoListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterNetworkRequest extends $tea.Model {
  endTime?: number;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterNetworkResponseBody extends $tea.Model {
  clusterNetwork?: DescribeClusterNetworkResponseBodyClusterNetwork;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterNetwork: 'ClusterNetwork',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterNetwork: DescribeClusterNetworkResponseBodyClusterNetwork,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterNetworkResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeClusterNetworkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeClusterNetworkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterVulStatisticsRequest extends $tea.Model {
  clusterId?: string;
  types?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      types: 'Types',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      types: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterVulStatisticsResponseBody extends $tea.Model {
  requestId?: string;
  vulStat?: DescribeClusterVulStatisticsResponseBodyVulStat;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vulStat: 'VulStat',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vulStat: DescribeClusterVulStatisticsResponseBodyVulStat,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterVulStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeClusterVulStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeClusterVulStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonOverallConfigRequest extends $tea.Model {
  sourceIp?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceIp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonOverallConfigResponseBody extends $tea.Model {
  overallConfig?: DescribeCommonOverallConfigResponseBodyOverallConfig;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      overallConfig: 'OverallConfig',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      overallConfig: DescribeCommonOverallConfigResponseBodyOverallConfig,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonOverallConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCommonOverallConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCommonOverallConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonOverallConfigListRequest extends $tea.Model {
  sourceIp?: string;
  typeList?: string[];
  static names(): { [key: string]: string } {
    return {
      sourceIp: 'SourceIp',
      typeList: 'TypeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceIp: 'string',
      typeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonOverallConfigListResponseBody extends $tea.Model {
  overallList?: DescribeCommonOverallConfigListResponseBodyOverallList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      overallList: 'OverallList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      overallList: { 'type': 'array', 'itemType': DescribeCommonOverallConfigListResponseBodyOverallList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonOverallConfigListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCommonOverallConfigListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCommonOverallConfigListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonTargetConfigRequest extends $tea.Model {
  type?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonTargetConfigResponseBody extends $tea.Model {
  requestId?: string;
  targetList?: DescribeCommonTargetConfigResponseBodyTargetList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      targetList: 'TargetList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      targetList: { 'type': 'array', 'itemType': DescribeCommonTargetConfigResponseBodyTargetList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonTargetConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCommonTargetConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCommonTargetConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonTargetResultListRequest extends $tea.Model {
  sourceIp?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceIp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonTargetResultListResponseBody extends $tea.Model {
  requestId?: string;
  targetConfig?: DescribeCommonTargetResultListResponseBodyTargetConfig;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      targetConfig: 'TargetConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      targetConfig: DescribeCommonTargetResultListResponseBodyTargetConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonTargetResultListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCommonTargetResultListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCommonTargetResultListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConcernNecessityRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConcernNecessityResponseBody extends $tea.Model {
  concernNecessity?: string[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      concernNecessity: 'ConcernNecessity',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      concernNecessity: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConcernNecessityResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeConcernNecessityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeConcernNecessityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerCriteriaRequest extends $tea.Model {
  groupField?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      groupField: 'GroupField',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupField: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerCriteriaResponseBody extends $tea.Model {
  criteriaList?: DescribeContainerCriteriaResponseBodyCriteriaList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      criteriaList: 'CriteriaList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteriaList: { 'type': 'array', 'itemType': DescribeContainerCriteriaResponseBodyCriteriaList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerCriteriaResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeContainerCriteriaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeContainerCriteriaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerInstancesRequest extends $tea.Model {
  criteria?: string;
  currentPage?: number;
  logicalExp?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      criteria: 'Criteria',
      currentPage: 'CurrentPage',
      logicalExp: 'LogicalExp',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteria: 'string',
      currentPage: 'number',
      logicalExp: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerInstancesResponseBody extends $tea.Model {
  containerInstanceList?: DescribeContainerInstancesResponseBodyContainerInstanceList[];
  pageInfo?: DescribeContainerInstancesResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      containerInstanceList: 'ContainerInstanceList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      containerInstanceList: { 'type': 'array', 'itemType': DescribeContainerInstancesResponseBodyContainerInstanceList },
      pageInfo: DescribeContainerInstancesResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeContainerInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeContainerInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerScanConfigRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerScanConfigResponseBody extends $tea.Model {
  data?: DescribeContainerScanConfigResponseBodyData;
  httpStatusCode?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeContainerScanConfigResponseBodyData,
      httpStatusCode: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerScanConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeContainerScanConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeContainerScanConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerStatisticsRequest extends $tea.Model {
  clusterId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerStatisticsResponseBody extends $tea.Model {
  data?: DescribeContainerStatisticsResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeContainerStatisticsResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeContainerStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeContainerStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerTagsRequest extends $tea.Model {
  appName?: string;
  clusterId?: string;
  currentPage?: number;
  fieldName?: string;
  fieldValue?: string;
  namespace?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      clusterId: 'ClusterId',
      currentPage: 'CurrentPage',
      fieldName: 'FieldName',
      fieldValue: 'FieldValue',
      namespace: 'Namespace',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      clusterId: 'string',
      currentPage: 'number',
      fieldName: 'string',
      fieldValue: 'string',
      namespace: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerTagsResponseBody extends $tea.Model {
  requestId?: string;
  tagValues?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tagValues: 'TagValues',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tagValues: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeContainerTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeContainerTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCountNotScannedImageResponseBody extends $tea.Model {
  notScannedCnt?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      notScannedCnt: 'NotScannedCnt',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      notScannedCnt: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCountNotScannedImageResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCountNotScannedImageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCountNotScannedImageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCountScannedImageResponseBody extends $tea.Model {
  requestId?: string;
  scannedCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      scannedCount: 'ScannedCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      scannedCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCountScannedImageResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCountScannedImageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCountScannedImageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCriteriaRequest extends $tea.Model {
  machineTypes?: string;
  supportAutoTag?: boolean;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      machineTypes: 'MachineTypes',
      supportAutoTag: 'SupportAutoTag',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      machineTypes: 'string',
      supportAutoTag: 'boolean',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCriteriaResponseBody extends $tea.Model {
  criteriaList?: DescribeCriteriaResponseBodyCriteriaList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      criteriaList: 'CriteriaList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteriaList: { 'type': 'array', 'itemType': DescribeCriteriaResponseBodyCriteriaList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCriteriaResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCriteriaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCriteriaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomBlockRecordsRequest extends $tea.Model {
  blockIp?: string;
  currentPage?: number;
  pageSize?: number;
  resourceOwnerId?: number;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      blockIp: 'BlockIp',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      resourceOwnerId: 'ResourceOwnerId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockIp: 'string',
      currentPage: 'number',
      pageSize: 'number',
      resourceOwnerId: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomBlockRecordsResponseBody extends $tea.Model {
  pageInfo?: DescribeCustomBlockRecordsResponseBodyPageInfo;
  recordList?: DescribeCustomBlockRecordsResponseBodyRecordList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      recordList: 'RecordList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribeCustomBlockRecordsResponseBodyPageInfo,
      recordList: { 'type': 'array', 'itemType': DescribeCustomBlockRecordsResponseBodyRecordList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomBlockRecordsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCustomBlockRecordsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCustomBlockRecordsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCycleTaskListRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  taskName?: string;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      taskName: 'TaskName',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      taskName: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCycleTaskListResponseBody extends $tea.Model {
  cycleScheduleResponseList?: DescribeCycleTaskListResponseBodyCycleScheduleResponseList[];
  pageInfo?: DescribeCycleTaskListResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cycleScheduleResponseList: 'CycleScheduleResponseList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycleScheduleResponseList: { 'type': 'array', 'itemType': DescribeCycleTaskListResponseBodyCycleScheduleResponseList },
      pageInfo: DescribeCycleTaskListResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCycleTaskListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeCycleTaskListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCycleTaskListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDingTalkRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  ruleActionName?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      ruleActionName: 'RuleActionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      ruleActionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDingTalkResponseBody extends $tea.Model {
  actionList?: DescribeDingTalkResponseBodyActionList[];
  pageInfo?: DescribeDingTalkResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      actionList: 'ActionList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionList: { 'type': 'array', 'itemType': DescribeDingTalkResponseBodyActionList },
      pageInfo: DescribeDingTalkResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDingTalkResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDingTalkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDingTalkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainCountRequest extends $tea.Model {
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainCountResponseBody extends $tea.Model {
  requestId?: string;
  rootDomainsCount?: number;
  subDomainsCount?: number;
  totalDomainsCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      rootDomainsCount: 'RootDomainsCount',
      subDomainsCount: 'SubDomainsCount',
      totalDomainsCount: 'TotalDomainsCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      rootDomainsCount: 'number',
      subDomainsCount: 'number',
      totalDomainsCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainCountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDomainCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainDetailRequest extends $tea.Model {
  domainName?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      domainName: 'DomainName',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainName: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainDetailResponseBody extends $tea.Model {
  alarmCount?: number;
  domain?: string;
  domainDetailItems?: DescribeDomainDetailResponseBodyDomainDetailItems[];
  requestId?: string;
  rootDomain?: string;
  vulCount?: number;
  static names(): { [key: string]: string } {
    return {
      alarmCount: 'AlarmCount',
      domain: 'Domain',
      domainDetailItems: 'DomainDetailItems',
      requestId: 'RequestId',
      rootDomain: 'RootDomain',
      vulCount: 'VulCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmCount: 'number',
      domain: 'string',
      domainDetailItems: { 'type': 'array', 'itemType': DescribeDomainDetailResponseBodyDomainDetailItems },
      requestId: 'string',
      rootDomain: 'string',
      vulCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDomainDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainListRequest extends $tea.Model {
  currentPage?: number;
  domainType?: string;
  fuzzyDomain?: string;
  pageSize?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      domainType: 'DomainType',
      fuzzyDomain: 'FuzzyDomain',
      pageSize: 'PageSize',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      domainType: 'string',
      fuzzyDomain: 'string',
      pageSize: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainListResponseBody extends $tea.Model {
  domainListResponseList?: DescribeDomainListResponseBodyDomainListResponseList[];
  pageInfo?: DescribeDomainListResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      domainListResponseList: 'DomainListResponseList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainListResponseList: { 'type': 'array', 'itemType': DescribeDomainListResponseBodyDomainListResponseList },
      pageInfo: DescribeDomainListResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeDomainListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDomainListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmgUserAgreementResponseBody extends $tea.Model {
  auth?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      auth: 'Auth',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auth: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmgUserAgreementResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeEmgUserAgreementResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEmgUserAgreementResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmgVulItemRequest extends $tea.Model {
  checkType?: number;
  currentPage?: number;
  lang?: string;
  pageSize?: number;
  riskStatus?: string;
  scanType?: string;
  vulName?: string;
  static names(): { [key: string]: string } {
    return {
      checkType: 'CheckType',
      currentPage: 'CurrentPage',
      lang: 'Lang',
      pageSize: 'PageSize',
      riskStatus: 'RiskStatus',
      scanType: 'ScanType',
      vulName: 'VulName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkType: 'number',
      currentPage: 'number',
      lang: 'string',
      pageSize: 'number',
      riskStatus: 'string',
      scanType: 'string',
      vulName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmgVulItemResponseBody extends $tea.Model {
  currentPage?: number;
  groupedVulItems?: DescribeEmgVulItemResponseBodyGroupedVulItems[];
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      groupedVulItems: 'GroupedVulItems',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      groupedVulItems: { 'type': 'array', 'itemType': DescribeEmgVulItemResponseBodyGroupedVulItems },
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmgVulItemResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeEmgVulItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEmgVulItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventLevelCountRequest extends $tea.Model {
  clusterId?: string;
  containerFieldName?: string;
  containerFieldValue?: string;
  containerIds?: string;
  from?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      containerFieldName: 'ContainerFieldName',
      containerFieldValue: 'ContainerFieldValue',
      containerIds: 'ContainerIds',
      from: 'From',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      containerFieldName: 'string',
      containerFieldValue: 'string',
      containerIds: 'string',
      from: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventLevelCountResponseBody extends $tea.Model {
  code?: string;
  eventLevels?: DescribeEventLevelCountResponseBodyEventLevels;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      eventLevels: 'EventLevels',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      eventLevels: DescribeEventLevelCountResponseBodyEventLevels,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventLevelCountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeEventLevelCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEventLevelCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventOnStageRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventOnStageResponseBody extends $tea.Model {
  requestId?: string;
  securityEventStageResponse?: DescribeEventOnStageResponseBodySecurityEventStageResponse;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityEventStageResponse: 'SecurityEventStageResponse',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityEventStageResponse: DescribeEventOnStageResponseBodySecurityEventStageResponse,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventOnStageResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeEventOnStageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEventOnStageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExcludeSystemPathRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExcludeSystemPathResponseBody extends $tea.Model {
  excludePaths?: DescribeExcludeSystemPathResponseBodyExcludePaths[];
  pageInfo?: DescribeExcludeSystemPathResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      excludePaths: 'ExcludePaths',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      excludePaths: { 'type': 'array', 'itemType': DescribeExcludeSystemPathResponseBodyExcludePaths },
      pageInfo: DescribeExcludeSystemPathResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExcludeSystemPathResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeExcludeSystemPathResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeExcludeSystemPathResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExportInfoRequest extends $tea.Model {
  exportId?: number;
  static names(): { [key: string]: string } {
    return {
      exportId: 'ExportId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exportId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExportInfoResponseBody extends $tea.Model {
  currentCount?: number;
  exportStatus?: string;
  fileName?: string;
  id?: number;
  link?: string;
  message?: string;
  progress?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentCount: 'CurrentCount',
      exportStatus: 'ExportStatus',
      fileName: 'FileName',
      id: 'Id',
      link: 'Link',
      message: 'Message',
      progress: 'Progress',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentCount: 'number',
      exportStatus: 'string',
      fileName: 'string',
      id: 'number',
      link: 'string',
      message: 'string',
      progress: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExportInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeExportInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeExportInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedCheckWarningRequest extends $tea.Model {
  lang?: string;
  typeName?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      typeName: 'TypeName',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      typeName: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedCheckWarningResponseBody extends $tea.Model {
  count?: number;
  requestId?: string;
  warningList?: DescribeExposedCheckWarningResponseBodyWarningList[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      requestId: 'RequestId',
      warningList: 'WarningList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      requestId: 'string',
      warningList: { 'type': 'array', 'itemType': DescribeExposedCheckWarningResponseBodyWarningList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedCheckWarningResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeExposedCheckWarningResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeExposedCheckWarningResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceCriteriaRequest extends $tea.Model {
  value?: string;
  static names(): { [key: string]: string } {
    return {
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceCriteriaResponseBody extends $tea.Model {
  criteriaList?: DescribeExposedInstanceCriteriaResponseBodyCriteriaList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      criteriaList: 'CriteriaList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteriaList: { 'type': 'array', 'itemType': DescribeExposedInstanceCriteriaResponseBodyCriteriaList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceCriteriaResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeExposedInstanceCriteriaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeExposedInstanceCriteriaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceDetailRequest extends $tea.Model {
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceDetailResponseBody extends $tea.Model {
  exposedChains?: DescribeExposedInstanceDetailResponseBodyExposedChains[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      exposedChains: 'ExposedChains',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exposedChains: { 'type': 'array', 'itemType': DescribeExposedInstanceDetailResponseBodyExposedChains },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeExposedInstanceDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeExposedInstanceDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceListRequest extends $tea.Model {
  currentPage?: number;
  exposureComponent?: string;
  exposureIp?: string;
  exposurePort?: string;
  groupId?: number;
  healthStatus?: boolean;
  instanceId?: string;
  instanceName?: string;
  pageSize?: number;
  vulStatus?: boolean;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      exposureComponent: 'ExposureComponent',
      exposureIp: 'ExposureIp',
      exposurePort: 'ExposurePort',
      groupId: 'GroupId',
      healthStatus: 'HealthStatus',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      pageSize: 'PageSize',
      vulStatus: 'VulStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      exposureComponent: 'string',
      exposureIp: 'string',
      exposurePort: 'string',
      groupId: 'number',
      healthStatus: 'boolean',
      instanceId: 'string',
      instanceName: 'string',
      pageSize: 'number',
      vulStatus: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceListResponseBody extends $tea.Model {
  exposedInstances?: DescribeExposedInstanceListResponseBodyExposedInstances[];
  pageInfo?: DescribeExposedInstanceListResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      exposedInstances: 'ExposedInstances',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exposedInstances: { 'type': 'array', 'itemType': DescribeExposedInstanceListResponseBodyExposedInstances },
      pageInfo: DescribeExposedInstanceListResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeExposedInstanceListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeExposedInstanceListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedStatisticsResponseBody extends $tea.Model {
  exposedAsapVulCount?: number;
  exposedComponentCount?: number;
  exposedInstanceCount?: number;
  exposedIpCount?: number;
  exposedLaterVulCount?: number;
  exposedNntfVulCount?: number;
  exposedPortCount?: number;
  exposedWeekPasswordMachineCount?: number;
  gatewayAssetCount?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      exposedAsapVulCount: 'ExposedAsapVulCount',
      exposedComponentCount: 'ExposedComponentCount',
      exposedInstanceCount: 'ExposedInstanceCount',
      exposedIpCount: 'ExposedIpCount',
      exposedLaterVulCount: 'ExposedLaterVulCount',
      exposedNntfVulCount: 'ExposedNntfVulCount',
      exposedPortCount: 'ExposedPortCount',
      exposedWeekPasswordMachineCount: 'ExposedWeekPasswordMachineCount',
      gatewayAssetCount: 'GatewayAssetCount',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exposedAsapVulCount: 'number',
      exposedComponentCount: 'number',
      exposedInstanceCount: 'number',
      exposedIpCount: 'number',
      exposedLaterVulCount: 'number',
      exposedNntfVulCount: 'number',
      exposedPortCount: 'number',
      exposedWeekPasswordMachineCount: 'number',
      gatewayAssetCount: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeExposedStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeExposedStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedStatisticsDetailRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  statisticsType?: string;
  statisticsTypeGatewayType?: string;
  statisticsTypeInstanceValue?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      statisticsType: 'StatisticsType',
      statisticsTypeGatewayType: 'StatisticsTypeGatewayType',
      statisticsTypeInstanceValue: 'StatisticsTypeInstanceValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      statisticsType: 'string',
      statisticsTypeGatewayType: 'string',
      statisticsTypeInstanceValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedStatisticsDetailResponseBody extends $tea.Model {
  pageInfo?: DescribeExposedStatisticsDetailResponseBodyPageInfo;
  requestId?: string;
  statisticsDetails?: DescribeExposedStatisticsDetailResponseBodyStatisticsDetails[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      statisticsDetails: 'StatisticsDetails',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribeExposedStatisticsDetailResponseBodyPageInfo,
      requestId: 'string',
      statisticsDetails: { 'type': 'array', 'itemType': DescribeExposedStatisticsDetailResponseBodyStatisticsDetails },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedStatisticsDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeExposedStatisticsDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeExposedStatisticsDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFieldStatisticsRequest extends $tea.Model {
  machineTypes?: string;
  regionId?: string;
  resourceDirectoryAccountId?: number;
  static names(): { [key: string]: string } {
    return {
      machineTypes: 'MachineTypes',
      regionId: 'RegionId',
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      machineTypes: 'string',
      regionId: 'string',
      resourceDirectoryAccountId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFieldStatisticsResponseBody extends $tea.Model {
  groupedFields?: DescribeFieldStatisticsResponseBodyGroupedFields;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupedFields: 'GroupedFields',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupedFields: DescribeFieldStatisticsResponseBodyGroupedFields,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFieldStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeFieldStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFieldStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFrontVulPatchListRequest extends $tea.Model {
  info?: string;
  lang?: string;
  operateType?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      lang: 'Lang',
      operateType: 'OperateType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: 'string',
      lang: 'string',
      operateType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFrontVulPatchListResponseBody extends $tea.Model {
  frontPatchList?: DescribeFrontVulPatchListResponseBodyFrontPatchList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      frontPatchList: 'FrontPatchList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      frontPatchList: { 'type': 'array', 'itemType': DescribeFrontVulPatchListResponseBodyFrontPatchList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFrontVulPatchListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeFrontVulPatchListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFrontVulPatchListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupStructRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupStructResponseBody extends $tea.Model {
  groupFather?: number;
  groupFlag?: number;
  groupId?: number;
  groupIndex?: number;
  groupLevel?: number;
  groupName?: string;
  groups?: string[];
  machineNum?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupFather: 'GroupFather',
      groupFlag: 'GroupFlag',
      groupId: 'GroupId',
      groupIndex: 'GroupIndex',
      groupLevel: 'GroupLevel',
      groupName: 'GroupName',
      groups: 'Groups',
      machineNum: 'MachineNum',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupFather: 'number',
      groupFlag: 'number',
      groupId: 'number',
      groupIndex: 'number',
      groupLevel: 'number',
      groupName: 'string',
      groups: { 'type': 'array', 'itemType': 'string' },
      machineNum: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupStructResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeGroupStructResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGroupStructResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedContainerInstancesRequest extends $tea.Model {
  criteria?: string;
  currentPage?: number;
  fieldValue?: string;
  groupField?: string;
  logicalExp?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      criteria: 'Criteria',
      currentPage: 'CurrentPage',
      fieldValue: 'FieldValue',
      groupField: 'GroupField',
      logicalExp: 'LogicalExp',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteria: 'string',
      currentPage: 'number',
      fieldValue: 'string',
      groupField: 'string',
      logicalExp: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedContainerInstancesResponseBody extends $tea.Model {
  groupedContainerInstanceList?: DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList[];
  pageInfo?: DescribeGroupedContainerInstancesResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupedContainerInstanceList: 'GroupedContainerInstanceList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupedContainerInstanceList: { 'type': 'array', 'itemType': DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList },
      pageInfo: DescribeGroupedContainerInstancesResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedContainerInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeGroupedContainerInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGroupedContainerInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedInstancesRequest extends $tea.Model {
  currentPage?: number;
  fieldValue?: string;
  groupField?: string;
  lang?: string;
  machineTypes?: string;
  noPage?: boolean;
  pageSize?: number;
  saleVersionCheckCode?: string;
  vendor?: number;
  vendors?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      fieldValue: 'FieldValue',
      groupField: 'GroupField',
      lang: 'Lang',
      machineTypes: 'MachineTypes',
      noPage: 'NoPage',
      pageSize: 'PageSize',
      saleVersionCheckCode: 'SaleVersionCheckCode',
      vendor: 'Vendor',
      vendors: 'Vendors',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      fieldValue: 'string',
      groupField: 'string',
      lang: 'string',
      machineTypes: 'string',
      noPage: 'boolean',
      pageSize: 'number',
      saleVersionCheckCode: 'string',
      vendor: 'number',
      vendors: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedInstancesResponseBody extends $tea.Model {
  instances?: DescribeGroupedInstancesResponseBodyInstances[];
  pageInfo?: DescribeGroupedInstancesResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: { 'type': 'array', 'itemType': DescribeGroupedInstancesResponseBodyInstances },
      pageInfo: DescribeGroupedInstancesResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeGroupedInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGroupedInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedMaliciousFilesRequest extends $tea.Model {
  clusterId?: string;
  currentPage?: number;
  fuzzyMaliciousName?: string;
  imageDigest?: string;
  imageLayer?: string;
  imageTag?: string;
  lang?: string;
  levels?: string;
  maliciousMd5?: string;
  pageSize?: string;
  repoId?: string;
  repoInstanceId?: string;
  repoName?: string;
  repoNamespace?: string;
  repoRegionId?: string;
  scanRange?: string[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      currentPage: 'CurrentPage',
      fuzzyMaliciousName: 'FuzzyMaliciousName',
      imageDigest: 'ImageDigest',
      imageLayer: 'ImageLayer',
      imageTag: 'ImageTag',
      lang: 'Lang',
      levels: 'Levels',
      maliciousMd5: 'MaliciousMd5',
      pageSize: 'PageSize',
      repoId: 'RepoId',
      repoInstanceId: 'RepoInstanceId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      repoRegionId: 'RepoRegionId',
      scanRange: 'ScanRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      currentPage: 'number',
      fuzzyMaliciousName: 'string',
      imageDigest: 'string',
      imageLayer: 'string',
      imageTag: 'string',
      lang: 'string',
      levels: 'string',
      maliciousMd5: 'string',
      pageSize: 'string',
      repoId: 'string',
      repoInstanceId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      repoRegionId: 'string',
      scanRange: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedMaliciousFilesResponseBody extends $tea.Model {
  groupedMaliciousFileResponse?: DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse[];
  pageInfo?: DescribeGroupedMaliciousFilesResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupedMaliciousFileResponse: 'GroupedMaliciousFileResponse',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupedMaliciousFileResponse: { 'type': 'array', 'itemType': DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse },
      pageInfo: DescribeGroupedMaliciousFilesResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedMaliciousFilesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeGroupedMaliciousFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGroupedMaliciousFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedTagsRequest extends $tea.Model {
  machineTypes?: string;
  static names(): { [key: string]: string } {
    return {
      machineTypes: 'MachineTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      machineTypes: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedTagsResponseBody extends $tea.Model {
  count?: number;
  groupedFileds?: DescribeGroupedTagsResponseBodyGroupedFileds[];
  httpStatusCode?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      groupedFileds: 'GroupedFileds',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      groupedFileds: { 'type': 'array', 'itemType': DescribeGroupedTagsResponseBodyGroupedFileds },
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeGroupedTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGroupedTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedVulRequest extends $tea.Model {
  aliasName?: string;
  assetType?: string;
  attachTypes?: string;
  containerFieldName?: string;
  currentPage?: number;
  dealed?: string;
  groupId?: string;
  lang?: string;
  necessity?: string;
  pageSize?: number;
  resourceDirectoryAccountId?: number;
  searchTags?: string;
  targetType?: string;
  type?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      assetType: 'AssetType',
      attachTypes: 'AttachTypes',
      containerFieldName: 'ContainerFieldName',
      currentPage: 'CurrentPage',
      dealed: 'Dealed',
      groupId: 'GroupId',
      lang: 'Lang',
      necessity: 'Necessity',
      pageSize: 'PageSize',
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
      searchTags: 'SearchTags',
      targetType: 'TargetType',
      type: 'Type',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      assetType: 'string',
      attachTypes: 'string',
      containerFieldName: 'string',
      currentPage: 'number',
      dealed: 'string',
      groupId: 'string',
      lang: 'string',
      necessity: 'string',
      pageSize: 'number',
      resourceDirectoryAccountId: 'number',
      searchTags: 'string',
      targetType: 'string',
      type: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedVulResponseBody extends $tea.Model {
  currentPage?: number;
  groupedVulItems?: DescribeGroupedVulResponseBodyGroupedVulItems[];
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      groupedVulItems: 'GroupedVulItems',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      groupedVulItems: { 'type': 'array', 'itemType': DescribeGroupedVulResponseBodyGroupedVulItems },
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedVulResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeGroupedVulResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGroupedVulResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHcExportInfoRequest extends $tea.Model {
  exportId?: number;
  static names(): { [key: string]: string } {
    return {
      exportId: 'ExportId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exportId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHcExportInfoResponseBody extends $tea.Model {
  currentCount?: number;
  fileName?: string;
  gmtCreate?: number;
  id?: number;
  link?: string;
  progress?: number;
  requestId?: string;
  resultStatus?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentCount: 'CurrentCount',
      fileName: 'FileName',
      gmtCreate: 'GmtCreate',
      id: 'Id',
      link: 'Link',
      progress: 'Progress',
      requestId: 'RequestId',
      resultStatus: 'ResultStatus',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentCount: 'number',
      fileName: 'string',
      gmtCreate: 'number',
      id: 'number',
      link: 'string',
      progress: 'number',
      requestId: 'string',
      resultStatus: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHcExportInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeHcExportInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHcExportInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHoneyPotAuthRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHoneyPotAuthResponseBody extends $tea.Model {
  honeyPotAuthCount?: number;
  honeyPotCount?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      honeyPotAuthCount: 'HoneyPotAuthCount',
      honeyPotCount: 'HoneyPotCount',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeyPotAuthCount: 'number',
      honeyPotCount: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHoneyPotAuthResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeHoneyPotAuthResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHoneyPotAuthResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHoneyPotSuspStatisticsRequest extends $tea.Model {
  from?: string;
  lang?: string;
  statisticsDays?: number;
  statisticsKeyType?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      lang: 'Lang',
      statisticsDays: 'StatisticsDays',
      statisticsKeyType: 'StatisticsKeyType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      lang: 'string',
      statisticsDays: 'number',
      statisticsKeyType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHoneyPotSuspStatisticsResponseBody extends $tea.Model {
  requestId?: string;
  suspHoneyPotStatisticsResponse?: DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      suspHoneyPotStatisticsResponse: 'SuspHoneyPotStatisticsResponse',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      suspHoneyPotStatisticsResponse: { 'type': 'array', 'itemType': DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHoneyPotSuspStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeHoneyPotSuspStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeHoneyPotSuspStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRequest extends $tea.Model {
  imageInstanceId?: string;
  imageRegionId?: string;
  imageRepoId?: string;
  imageTag?: string;
  static names(): { [key: string]: string } {
    return {
      imageInstanceId: 'ImageInstanceId',
      imageRegionId: 'ImageRegionId',
      imageRepoId: 'ImageRepoId',
      imageTag: 'ImageTag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageInstanceId: 'string',
      imageRegionId: 'string',
      imageRepoId: 'string',
      imageTag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageResponseBody extends $tea.Model {
  data?: DescribeImageResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeImageResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineCheckResultRequest extends $tea.Model {
  criteria?: string;
  criteriaType?: string;
  currentPage?: number;
  imageUuid?: string;
  lang?: string;
  pageSize?: number;
  riskLevel?: string;
  scanRange?: string[];
  static names(): { [key: string]: string } {
    return {
      criteria: 'Criteria',
      criteriaType: 'CriteriaType',
      currentPage: 'CurrentPage',
      imageUuid: 'ImageUuid',
      lang: 'Lang',
      pageSize: 'PageSize',
      riskLevel: 'RiskLevel',
      scanRange: 'ScanRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteria: 'string',
      criteriaType: 'string',
      currentPage: 'number',
      imageUuid: 'string',
      lang: 'string',
      pageSize: 'number',
      riskLevel: 'string',
      scanRange: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineCheckResultResponseBody extends $tea.Model {
  baselineResult?: DescribeImageBaselineCheckResultResponseBodyBaselineResult[];
  pageInfo?: DescribeImageBaselineCheckResultResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      baselineResult: 'BaselineResult',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineResult: { 'type': 'array', 'itemType': DescribeImageBaselineCheckResultResponseBodyBaselineResult },
      pageInfo: DescribeImageBaselineCheckResultResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineCheckResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageBaselineCheckResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageBaselineCheckResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineCheckSummaryRequest extends $tea.Model {
  clusterId?: string;
  criteria?: string;
  criteriaType?: string;
  currentPage?: number;
  lang?: string;
  pageSize?: number;
  riskLevel?: string;
  scanRange?: string[];
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      criteria: 'Criteria',
      criteriaType: 'CriteriaType',
      currentPage: 'CurrentPage',
      lang: 'Lang',
      pageSize: 'PageSize',
      riskLevel: 'RiskLevel',
      scanRange: 'ScanRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      criteria: 'string',
      criteriaType: 'string',
      currentPage: 'number',
      lang: 'string',
      pageSize: 'number',
      riskLevel: 'string',
      scanRange: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineCheckSummaryResponseBody extends $tea.Model {
  baselineResultSummary?: DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary[];
  pageInfo?: DescribeImageBaselineCheckSummaryResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      baselineResultSummary: 'BaselineResultSummary',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineResultSummary: { 'type': 'array', 'itemType': DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary },
      pageInfo: DescribeImageBaselineCheckSummaryResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineCheckSummaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageBaselineCheckSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageBaselineCheckSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineDetailRequest extends $tea.Model {
  baselineItemKey?: string;
  imageUuid?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      baselineItemKey: 'BaselineItemKey',
      imageUuid: 'ImageUuid',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineItemKey: 'string',
      imageUuid: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineDetailResponseBody extends $tea.Model {
  baselineDetail?: DescribeImageBaselineDetailResponseBodyBaselineDetail;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      baselineDetail: 'BaselineDetail',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineDetail: DescribeImageBaselineDetailResponseBodyBaselineDetail,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageBaselineDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageBaselineDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineItemListRequest extends $tea.Model {
  baselineClassKey?: string;
  baselineNameKey?: string;
  currentPage?: number;
  imageUuid?: string;
  lang?: string;
  pageSize?: number;
  scanRange?: string[];
  status?: string;
  uuids?: string[];
  static names(): { [key: string]: string } {
    return {
      baselineClassKey: 'BaselineClassKey',
      baselineNameKey: 'BaselineNameKey',
      currentPage: 'CurrentPage',
      imageUuid: 'ImageUuid',
      lang: 'Lang',
      pageSize: 'PageSize',
      scanRange: 'ScanRange',
      status: 'Status',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineClassKey: 'string',
      baselineNameKey: 'string',
      currentPage: 'number',
      imageUuid: 'string',
      lang: 'string',
      pageSize: 'number',
      scanRange: { 'type': 'array', 'itemType': 'string' },
      status: 'string',
      uuids: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineItemListResponseBody extends $tea.Model {
  baselineItemInfos?: DescribeImageBaselineItemListResponseBodyBaselineItemInfos[];
  pageInfo?: DescribeImageBaselineItemListResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      baselineItemInfos: 'BaselineItemInfos',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineItemInfos: { 'type': 'array', 'itemType': DescribeImageBaselineItemListResponseBodyBaselineItemInfos },
      pageInfo: DescribeImageBaselineItemListResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineItemListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageBaselineItemListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageBaselineItemListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineStrategyRequest extends $tea.Model {
  lang?: string;
  source?: string;
  strategyId?: number;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      source: 'Source',
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      source: 'string',
      strategyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineStrategyResponseBody extends $tea.Model {
  requestId?: string;
  strategy?: DescribeImageBaselineStrategyResponseBodyStrategy;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      strategy: 'Strategy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      strategy: DescribeImageBaselineStrategyResponseBodyStrategy,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineStrategyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageBaselineStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageBaselineStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageCriteriaRequest extends $tea.Model {
  value?: string;
  static names(): { [key: string]: string } {
    return {
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageCriteriaResponseBody extends $tea.Model {
  criteriaList?: DescribeImageCriteriaResponseBodyCriteriaList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      criteriaList: 'CriteriaList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteriaList: { 'type': 'array', 'itemType': DescribeImageCriteriaResponseBodyCriteriaList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageCriteriaResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageCriteriaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageCriteriaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageEventOperationConditionRequest extends $tea.Model {
  eventType?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageEventOperationConditionResponseBody extends $tea.Model {
  code?: string;
  data?: DescribeImageEventOperationConditionResponseBodyData;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: DescribeImageEventOperationConditionResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageEventOperationConditionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageEventOperationConditionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageEventOperationConditionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageEventOperationPageRequest extends $tea.Model {
  currentPage?: number;
  eventKey?: string;
  eventName?: string;
  eventType?: string;
  id?: number;
  lang?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      eventKey: 'EventKey',
      eventName: 'EventName',
      eventType: 'EventType',
      id: 'Id',
      lang: 'Lang',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      eventKey: 'string',
      eventName: 'string',
      eventType: 'string',
      id: 'number',
      lang: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageEventOperationPageResponseBody extends $tea.Model {
  code?: string;
  data?: DescribeImageEventOperationPageResponseBodyData;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: DescribeImageEventOperationPageResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageEventOperationPageResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageEventOperationPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageEventOperationPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFixCycleConfigResponseBody extends $tea.Model {
  data?: DescribeImageFixCycleConfigResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: DescribeImageFixCycleConfigResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFixCycleConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageFixCycleConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageFixCycleConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFixTaskRequest extends $tea.Model {
  currentPage?: number;
  endTime?: number;
  pageSize?: number;
  startTime?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      pageSize: 'PageSize',
      startTime: 'StartTime',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      pageSize: 'number',
      startTime: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFixTaskResponseBody extends $tea.Model {
  buildTasks?: DescribeImageFixTaskResponseBodyBuildTasks[];
  pageInfo?: DescribeImageFixTaskResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      buildTasks: 'BuildTasks',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      buildTasks: { 'type': 'array', 'itemType': DescribeImageFixTaskResponseBodyBuildTasks },
      pageInfo: DescribeImageFixTaskResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFixTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageFixTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageFixTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageGroupedVulListRequest extends $tea.Model {
  aliasName?: string;
  clusterId?: string;
  currentPage?: number;
  cveId?: string;
  groupId?: string;
  imageDigest?: string;
  imageLayer?: string;
  imageTag?: string;
  isLatest?: number;
  lang?: string;
  name?: string;
  necessity?: string;
  pageSize?: number;
  patchId?: number;
  repoId?: string;
  repoInstanceId?: string;
  repoName?: string;
  repoNamespace?: string;
  repoRegionId?: string;
  scanRange?: string[];
  type?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      clusterId: 'ClusterId',
      currentPage: 'CurrentPage',
      cveId: 'CveId',
      groupId: 'GroupId',
      imageDigest: 'ImageDigest',
      imageLayer: 'ImageLayer',
      imageTag: 'ImageTag',
      isLatest: 'IsLatest',
      lang: 'Lang',
      name: 'Name',
      necessity: 'Necessity',
      pageSize: 'PageSize',
      patchId: 'PatchId',
      repoId: 'RepoId',
      repoInstanceId: 'RepoInstanceId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      repoRegionId: 'RepoRegionId',
      scanRange: 'ScanRange',
      type: 'Type',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      clusterId: 'string',
      currentPage: 'number',
      cveId: 'string',
      groupId: 'string',
      imageDigest: 'string',
      imageLayer: 'string',
      imageTag: 'string',
      isLatest: 'number',
      lang: 'string',
      name: 'string',
      necessity: 'string',
      pageSize: 'number',
      patchId: 'number',
      repoId: 'string',
      repoInstanceId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      repoRegionId: 'string',
      scanRange: { 'type': 'array', 'itemType': 'string' },
      type: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageGroupedVulListResponseBody extends $tea.Model {
  currentPage?: number;
  groupedVulItems?: DescribeImageGroupedVulListResponseBodyGroupedVulItems[];
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      groupedVulItems: 'GroupedVulItems',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      groupedVulItems: { 'type': 'array', 'itemType': DescribeImageGroupedVulListResponseBodyGroupedVulItems },
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageGroupedVulListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageGroupedVulListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageGroupedVulListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageInfoListRequest extends $tea.Model {
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageInfoListResponseBody extends $tea.Model {
  imageInfos?: DescribeImageInfoListResponseBodyImageInfos[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      imageInfos: 'ImageInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageInfos: { 'type': 'array', 'itemType': DescribeImageInfoListResponseBodyImageInfos },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageInfoListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageInfoListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageInfoListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageInstancesRequest extends $tea.Model {
  criteria?: string;
  currentPage?: number;
  logicalExp?: string;
  pageSize?: number;
  scanned?: boolean;
  static names(): { [key: string]: string } {
    return {
      criteria: 'Criteria',
      currentPage: 'CurrentPage',
      logicalExp: 'LogicalExp',
      pageSize: 'PageSize',
      scanned: 'Scanned',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteria: 'string',
      currentPage: 'number',
      logicalExp: 'string',
      pageSize: 'number',
      scanned: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageInstancesResponseBody extends $tea.Model {
  imageInstanceList?: DescribeImageInstancesResponseBodyImageInstanceList[];
  pageInfo?: DescribeImageInstancesResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      imageInstanceList: 'ImageInstanceList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageInstanceList: { 'type': 'array', 'itemType': DescribeImageInstancesResponseBodyImageInstanceList },
      pageInfo: DescribeImageInstancesResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageLatestScanTaskRequest extends $tea.Model {
  digest?: string;
  static names(): { [key: string]: string } {
    return {
      digest: 'Digest',
    };
  }

  static types(): { [key: string]: any } {
    return {
      digest: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageLatestScanTaskResponseBody extends $tea.Model {
  requestId?: string;
  task?: DescribeImageLatestScanTaskResponseBodyTask[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      task: 'Task',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      task: { 'type': 'array', 'itemType': DescribeImageLatestScanTaskResponseBodyTask },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageLatestScanTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageLatestScanTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageLatestScanTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageListBySensitiveFileRequest extends $tea.Model {
  currentPage?: number;
  imageDigest?: string;
  lang?: string;
  pageSize?: number;
  repoInstanceId?: string;
  repoName?: string;
  repoNamespace?: string;
  riskLevel?: string;
  scanRange?: string[];
  sensitiveFileKey?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      imageDigest: 'ImageDigest',
      lang: 'Lang',
      pageSize: 'PageSize',
      repoInstanceId: 'RepoInstanceId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      riskLevel: 'RiskLevel',
      scanRange: 'ScanRange',
      sensitiveFileKey: 'SensitiveFileKey',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      imageDigest: 'string',
      lang: 'string',
      pageSize: 'number',
      repoInstanceId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      riskLevel: 'string',
      scanRange: { 'type': 'array', 'itemType': 'string' },
      sensitiveFileKey: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageListBySensitiveFileShrinkRequest extends $tea.Model {
  currentPage?: number;
  imageDigest?: string;
  lang?: string;
  pageSize?: number;
  repoInstanceId?: string;
  repoName?: string;
  repoNamespace?: string;
  riskLevel?: string;
  scanRangeShrink?: string;
  sensitiveFileKey?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      imageDigest: 'ImageDigest',
      lang: 'Lang',
      pageSize: 'PageSize',
      repoInstanceId: 'RepoInstanceId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      riskLevel: 'RiskLevel',
      scanRangeShrink: 'ScanRange',
      sensitiveFileKey: 'SensitiveFileKey',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      imageDigest: 'string',
      lang: 'string',
      pageSize: 'number',
      repoInstanceId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      riskLevel: 'string',
      scanRangeShrink: 'string',
      sensitiveFileKey: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageListBySensitiveFileResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  imageInfos?: DescribeImageListBySensitiveFileResponseBodyImageInfos[];
  message?: string;
  pageInfo?: DescribeImageListBySensitiveFileResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      imageInfos: 'ImageInfos',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      imageInfos: { 'type': 'array', 'itemType': DescribeImageListBySensitiveFileResponseBodyImageInfos },
      message: 'string',
      pageInfo: DescribeImageListBySensitiveFileResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageListBySensitiveFileResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageListBySensitiveFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageListBySensitiveFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageListWithBaselineNameRequest extends $tea.Model {
  baselineNameKey?: string;
  clusterId?: string;
  clusterName?: string;
  containerId?: string;
  criteria?: string;
  criteriaType?: string;
  currentPage?: number;
  image?: string;
  imageDigest?: string;
  lang?: string;
  namespace?: string;
  pageSize?: number;
  pod?: string;
  repoInstanceId?: string;
  repoName?: string;
  repoNamespace?: string;
  scanRange?: string[];
  static names(): { [key: string]: string } {
    return {
      baselineNameKey: 'BaselineNameKey',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      containerId: 'ContainerId',
      criteria: 'Criteria',
      criteriaType: 'CriteriaType',
      currentPage: 'CurrentPage',
      image: 'Image',
      imageDigest: 'ImageDigest',
      lang: 'Lang',
      namespace: 'Namespace',
      pageSize: 'PageSize',
      pod: 'Pod',
      repoInstanceId: 'RepoInstanceId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      scanRange: 'ScanRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineNameKey: 'string',
      clusterId: 'string',
      clusterName: 'string',
      containerId: 'string',
      criteria: 'string',
      criteriaType: 'string',
      currentPage: 'number',
      image: 'string',
      imageDigest: 'string',
      lang: 'string',
      namespace: 'string',
      pageSize: 'number',
      pod: 'string',
      repoInstanceId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      scanRange: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageListWithBaselineNameResponseBody extends $tea.Model {
  imageInfos?: DescribeImageListWithBaselineNameResponseBodyImageInfos[];
  pageInfo?: DescribeImageListWithBaselineNameResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      imageInfos: 'ImageInfos',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageInfos: { 'type': 'array', 'itemType': DescribeImageListWithBaselineNameResponseBodyImageInfos },
      pageInfo: DescribeImageListWithBaselineNameResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageListWithBaselineNameResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageListWithBaselineNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageListWithBaselineNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoCriteriaRequest extends $tea.Model {
  value?: string;
  static names(): { [key: string]: string } {
    return {
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoCriteriaResponseBody extends $tea.Model {
  criteriaList?: DescribeImageRepoCriteriaResponseBodyCriteriaList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      criteriaList: 'CriteriaList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteriaList: { 'type': 'array', 'itemType': DescribeImageRepoCriteriaResponseBodyCriteriaList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoCriteriaResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageRepoCriteriaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageRepoCriteriaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoDetailListRequest extends $tea.Model {
  criteria?: string;
  currentPage?: number;
  logicalExp?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      criteria: 'Criteria',
      currentPage: 'CurrentPage',
      logicalExp: 'LogicalExp',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteria: 'string',
      currentPage: 'number',
      logicalExp: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoDetailListResponseBody extends $tea.Model {
  imageRepoResponses?: DescribeImageRepoDetailListResponseBodyImageRepoResponses[];
  pageInfo?: DescribeImageRepoDetailListResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      imageRepoResponses: 'ImageRepoResponses',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageRepoResponses: { 'type': 'array', 'itemType': DescribeImageRepoDetailListResponseBodyImageRepoResponses },
      pageInfo: DescribeImageRepoDetailListResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoDetailListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageRepoDetailListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageRepoDetailListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoListRequest extends $tea.Model {
  currentPage?: number;
  fieldName?: string;
  fieldValue?: string;
  operateType?: string;
  pageSize?: number;
  repoName?: string;
  repoNamespace?: string;
  targetType?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      fieldName: 'FieldName',
      fieldValue: 'FieldValue',
      operateType: 'OperateType',
      pageSize: 'PageSize',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      targetType: 'TargetType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      fieldName: 'string',
      fieldValue: 'string',
      operateType: 'string',
      pageSize: 'number',
      repoName: 'string',
      repoNamespace: 'string',
      targetType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoListResponseBody extends $tea.Model {
  addTargetCount?: number;
  allTargetCount?: number;
  delTargetCount?: number;
  imageRepoList?: DescribeImageRepoListResponseBodyImageRepoList[];
  pageInfo?: DescribeImageRepoListResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      addTargetCount: 'AddTargetCount',
      allTargetCount: 'AllTargetCount',
      delTargetCount: 'DelTargetCount',
      imageRepoList: 'ImageRepoList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addTargetCount: 'number',
      allTargetCount: 'number',
      delTargetCount: 'number',
      imageRepoList: { 'type': 'array', 'itemType': DescribeImageRepoListResponseBodyImageRepoList },
      pageInfo: DescribeImageRepoListResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageRepoListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageRepoListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageScanAuthCountResponseBody extends $tea.Model {
  imageScan?: DescribeImageScanAuthCountResponseBodyImageScan;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      imageScan: 'ImageScan',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageScan: DescribeImageScanAuthCountResponseBodyImageScan,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageScanAuthCountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageScanAuthCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageScanAuthCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageScanAuthorizationResponseBody extends $tea.Model {
  authStatus?: DescribeImageScanAuthorizationResponseBodyAuthStatus;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      authStatus: 'AuthStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authStatus: DescribeImageScanAuthorizationResponseBodyAuthStatus,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageScanAuthorizationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageScanAuthorizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageScanAuthorizationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSensitiveFileByKeyRequest extends $tea.Model {
  currentPage?: number;
  imageUuid?: string;
  lang?: string;
  pageSize?: number;
  scanRange?: string[];
  sensitiveFileKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      imageUuid: 'ImageUuid',
      lang: 'Lang',
      pageSize: 'PageSize',
      scanRange: 'ScanRange',
      sensitiveFileKey: 'SensitiveFileKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      imageUuid: 'string',
      lang: 'string',
      pageSize: 'number',
      scanRange: { 'type': 'array', 'itemType': 'string' },
      sensitiveFileKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSensitiveFileByKeyShrinkRequest extends $tea.Model {
  currentPage?: number;
  imageUuid?: string;
  lang?: string;
  pageSize?: number;
  scanRangeShrink?: string;
  sensitiveFileKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      imageUuid: 'ImageUuid',
      lang: 'Lang',
      pageSize: 'PageSize',
      scanRangeShrink: 'ScanRange',
      sensitiveFileKey: 'SensitiveFileKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      imageUuid: 'string',
      lang: 'string',
      pageSize: 'number',
      scanRangeShrink: 'string',
      sensitiveFileKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSensitiveFileByKeyResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  pageInfo?: DescribeImageSensitiveFileByKeyResponseBodyPageInfo;
  requestId?: string;
  sensitiveFileList?: DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      sensitiveFileList: 'SensitiveFileList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      pageInfo: DescribeImageSensitiveFileByKeyResponseBodyPageInfo,
      requestId: 'string',
      sensitiveFileList: { 'type': 'array', 'itemType': DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSensitiveFileByKeyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageSensitiveFileByKeyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageSensitiveFileByKeyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSensitiveFileListRequest extends $tea.Model {
  criteria?: string;
  criteriaType?: string;
  currentPage?: number;
  imageUuid?: string;
  lang?: string;
  pageSize?: number;
  riskLevel?: string;
  scanRange?: string[];
  static names(): { [key: string]: string } {
    return {
      criteria: 'Criteria',
      criteriaType: 'CriteriaType',
      currentPage: 'CurrentPage',
      imageUuid: 'ImageUuid',
      lang: 'Lang',
      pageSize: 'PageSize',
      riskLevel: 'RiskLevel',
      scanRange: 'ScanRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteria: 'string',
      criteriaType: 'string',
      currentPage: 'number',
      imageUuid: 'string',
      lang: 'string',
      pageSize: 'number',
      riskLevel: 'string',
      scanRange: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSensitiveFileListShrinkRequest extends $tea.Model {
  criteria?: string;
  criteriaType?: string;
  currentPage?: number;
  imageUuid?: string;
  lang?: string;
  pageSize?: number;
  riskLevel?: string;
  scanRangeShrink?: string;
  static names(): { [key: string]: string } {
    return {
      criteria: 'Criteria',
      criteriaType: 'CriteriaType',
      currentPage: 'CurrentPage',
      imageUuid: 'ImageUuid',
      lang: 'Lang',
      pageSize: 'PageSize',
      riskLevel: 'RiskLevel',
      scanRangeShrink: 'ScanRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteria: 'string',
      criteriaType: 'string',
      currentPage: 'number',
      imageUuid: 'string',
      lang: 'string',
      pageSize: 'number',
      riskLevel: 'string',
      scanRangeShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSensitiveFileListResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  pageInfo?: DescribeImageSensitiveFileListResponseBodyPageInfo;
  requestId?: string;
  sensitiveFileList?: DescribeImageSensitiveFileListResponseBodySensitiveFileList[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      sensitiveFileList: 'SensitiveFileList',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      pageInfo: DescribeImageSensitiveFileListResponseBodyPageInfo,
      requestId: 'string',
      sensitiveFileList: { 'type': 'array', 'itemType': DescribeImageSensitiveFileListResponseBodySensitiveFileList },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSensitiveFileListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageSensitiveFileListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageSensitiveFileListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageStatisticsResponseBody extends $tea.Model {
  instanceCount?: number;
  requestId?: string;
  riskInstanceCount?: number;
  static names(): { [key: string]: string } {
    return {
      instanceCount: 'InstanceCount',
      requestId: 'RequestId',
      riskInstanceCount: 'RiskInstanceCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceCount: 'number',
      requestId: 'string',
      riskInstanceCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageVulListRequest extends $tea.Model {
  aliasName?: string;
  clusterId?: string;
  clusterName?: string;
  containerId?: string;
  currentPage?: number;
  dealed?: string;
  digest?: string;
  image?: string;
  instanceId?: string;
  lang?: string;
  name?: string;
  namespace?: string;
  necessity?: string;
  pageSize?: number;
  pod?: string;
  regionId?: string;
  repoId?: string;
  repoInstanceId?: string;
  repoName?: string;
  repoNamespace?: string;
  repoRegionId?: string;
  scanRange?: string[];
  statusList?: string;
  tag?: string;
  type?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      containerId: 'ContainerId',
      currentPage: 'CurrentPage',
      dealed: 'Dealed',
      digest: 'Digest',
      image: 'Image',
      instanceId: 'InstanceId',
      lang: 'Lang',
      name: 'Name',
      namespace: 'Namespace',
      necessity: 'Necessity',
      pageSize: 'PageSize',
      pod: 'Pod',
      regionId: 'RegionId',
      repoId: 'RepoId',
      repoInstanceId: 'RepoInstanceId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      repoRegionId: 'RepoRegionId',
      scanRange: 'ScanRange',
      statusList: 'StatusList',
      tag: 'Tag',
      type: 'Type',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      clusterId: 'string',
      clusterName: 'string',
      containerId: 'string',
      currentPage: 'number',
      dealed: 'string',
      digest: 'string',
      image: 'string',
      instanceId: 'string',
      lang: 'string',
      name: 'string',
      namespace: 'string',
      necessity: 'string',
      pageSize: 'number',
      pod: 'string',
      regionId: 'string',
      repoId: 'string',
      repoInstanceId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      repoRegionId: 'string',
      scanRange: { 'type': 'array', 'itemType': 'string' },
      statusList: 'string',
      tag: 'string',
      type: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageVulListResponseBody extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  vulRecords?: DescribeImageVulListResponseBodyVulRecords[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      vulRecords: 'VulRecords',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      vulRecords: { 'type': 'array', 'itemType': DescribeImageVulListResponseBodyVulRecords },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageVulListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageVulListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageVulListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageVulWhiteListRequest extends $tea.Model {
  aliasName?: string;
  currentPage?: number;
  lang?: string;
  pageSize?: number;
  source?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      currentPage: 'CurrentPage',
      lang: 'Lang',
      pageSize: 'PageSize',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      currentPage: 'number',
      lang: 'string',
      pageSize: 'number',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageVulWhiteListResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  imageVulWhitelist?: DescribeImageVulWhiteListResponseBodyImageVulWhitelist[];
  message?: string;
  pageInfo?: DescribeImageVulWhiteListResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  timeCost?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      imageVulWhitelist: 'ImageVulWhitelist',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
      timeCost: 'TimeCost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      imageVulWhitelist: { 'type': 'array', 'itemType': DescribeImageVulWhiteListResponseBodyImageVulWhitelist },
      message: 'string',
      pageInfo: DescribeImageVulWhiteListResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
      timeCost: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageVulWhiteListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeImageVulWhiteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeImageVulWhiteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstallCaptchaRequest extends $tea.Model {
  deadline?: string;
  lang?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      deadline: 'Deadline',
      lang: 'Lang',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deadline: 'string',
      lang: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstallCaptchaResponseBody extends $tea.Model {
  captchaCode?: string;
  deadline?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      captchaCode: 'CaptchaCode',
      deadline: 'Deadline',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      captchaCode: 'string',
      deadline: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstallCaptchaResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeInstallCaptchaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstallCaptchaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstallCodeResponseBody extends $tea.Model {
  code?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstallCodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeInstallCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstallCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstallCodesResponseBody extends $tea.Model {
  installCodes?: DescribeInstallCodesResponseBodyInstallCodes[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      installCodes: 'InstallCodes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      installCodes: { 'type': 'array', 'itemType': DescribeInstallCodesResponseBodyInstallCodes },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstallCodesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeInstallCodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstallCodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAntiBruteForceRulesRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  resourceOwnerId?: number;
  sourceIp?: string;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      resourceOwnerId: 'number',
      sourceIp: 'string',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAntiBruteForceRulesResponseBody extends $tea.Model {
  pageInfo?: DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo;
  requestId?: string;
  rules?: DescribeInstanceAntiBruteForceRulesResponseBodyRules[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo,
      requestId: 'string',
      rules: { 'type': 'array', 'itemType': DescribeInstanceAntiBruteForceRulesResponseBodyRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAntiBruteForceRulesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeInstanceAntiBruteForceRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceAntiBruteForceRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceRebootStatusRequest extends $tea.Model {
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceRebootStatusResponseBody extends $tea.Model {
  rebootStatuses?: DescribeInstanceRebootStatusResponseBodyRebootStatuses[];
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      rebootStatuses: 'RebootStatuses',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      rebootStatuses: { 'type': 'array', 'itemType': DescribeInstanceRebootStatusResponseBodyRebootStatuses },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceRebootStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeInstanceRebootStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceRebootStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatisticsRequest extends $tea.Model {
  from?: string;
  lang?: string;
  sourceIp?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      lang: 'Lang',
      sourceIp: 'SourceIp',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      lang: 'string',
      sourceIp: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatisticsResponseBody extends $tea.Model {
  data?: DescribeInstanceStatisticsResponseBodyData[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeInstanceStatisticsResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeInstanceStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInstanceStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIpTagsRequest extends $tea.Model {
  ip?: string;
  securityEventId?: string;
  static names(): { [key: string]: string } {
    return {
      ip: 'Ip',
      securityEventId: 'SecurityEventId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ip: 'string',
      securityEventId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIpTagsResponseBody extends $tea.Model {
  requestId?: string;
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      tags: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeIpTagsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeIpTagsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeIpTagsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatestScanTaskResponseBody extends $tea.Model {
  lastCheckTime?: number;
  requestId?: string;
  riskNum?: number;
  targetInfo?: string;
  uuids?: string[];
  static names(): { [key: string]: string } {
    return {
      lastCheckTime: 'LastCheckTime',
      requestId: 'RequestId',
      riskNum: 'RiskNum',
      targetInfo: 'TargetInfo',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lastCheckTime: 'number',
      requestId: 'string',
      riskNum: 'number',
      targetInfo: 'string',
      uuids: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatestScanTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLatestScanTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLatestScanTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMetaRequest extends $tea.Model {
  from?: string;
  lang?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      lang: 'Lang',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      lang: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMetaResponseBody extends $tea.Model {
  logMetaList?: DescribeLogMetaResponseBodyLogMetaList[];
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      logMetaList: 'LogMetaList',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logMetaList: { 'type': 'array', 'itemType': DescribeLogMetaResponseBodyLogMetaList },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMetaResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLogMetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLogMetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogShipperStatusRequest extends $tea.Model {
  from?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogShipperStatusResponseBody extends $tea.Model {
  logShipperStatus?: DescribeLogShipperStatusResponseBodyLogShipperStatus;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      logShipperStatus: 'LogShipperStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logShipperStatus: DescribeLogShipperStatusResponseBodyLogShipperStatus,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogShipperStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLogShipperStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLogShipperStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLoginBaseConfigsRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  target?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      target: 'Target',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      target: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLoginBaseConfigsResponseBody extends $tea.Model {
  baseConfigs?: DescribeLoginBaseConfigsResponseBodyBaseConfigs[];
  currentPage?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      baseConfigs: 'BaseConfigs',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baseConfigs: { 'type': 'array', 'itemType': DescribeLoginBaseConfigsResponseBodyBaseConfigs },
      currentPage: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLoginBaseConfigsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLoginBaseConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLoginBaseConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLoginSwitchConfigsResponseBody extends $tea.Model {
  configList?: DescribeLoginSwitchConfigsResponseBodyConfigList[];
  count?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      configList: 'ConfigList',
      count: 'Count',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configList: { 'type': 'array', 'itemType': DescribeLoginSwitchConfigsResponseBodyConfigList },
      count: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLoginSwitchConfigsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLoginSwitchConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLoginSwitchConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogstoreStorageRequest extends $tea.Model {
  from?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogstoreStorageResponseBody extends $tea.Model {
  logstore?: string;
  preserve?: number;
  requestId?: string;
  ttl?: number;
  used?: number;
  userProject?: string;
  static names(): { [key: string]: string } {
    return {
      logstore: 'Logstore',
      preserve: 'Preserve',
      requestId: 'RequestId',
      ttl: 'Ttl',
      used: 'Used',
      userProject: 'UserProject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logstore: 'string',
      preserve: 'number',
      requestId: 'string',
      ttl: 'number',
      used: 'number',
      userProject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogstoreStorageResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeLogstoreStorageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLogstoreStorageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMachineCanRebootRequest extends $tea.Model {
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMachineCanRebootResponseBody extends $tea.Model {
  canReboot?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      canReboot: 'CanReboot',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canReboot: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMachineCanRebootResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeMachineCanRebootResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMachineCanRebootResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeModuleConfigResponseBody extends $tea.Model {
  count?: number;
  httpStatusCode?: number;
  moduleConfigList?: DescribeModuleConfigResponseBodyModuleConfigList[];
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      httpStatusCode: 'HttpStatusCode',
      moduleConfigList: 'ModuleConfigList',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      httpStatusCode: 'number',
      moduleConfigList: { 'type': 'array', 'itemType': DescribeModuleConfigResponseBodyModuleConfigList },
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeModuleConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeModuleConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeModuleConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorAccountsResponseBody extends $tea.Model {
  accountIds?: string[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      accountIds: 'AccountIds',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountIds: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMonitorAccountsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeMonitorAccountsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMonitorAccountsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNoticeConfigRequest extends $tea.Model {
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNoticeConfigResponseBody extends $tea.Model {
  noticeConfigList?: DescribeNoticeConfigResponseBodyNoticeConfigList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      noticeConfigList: 'NoticeConfigList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      noticeConfigList: { 'type': 'array', 'itemType': DescribeNoticeConfigResponseBodyNoticeConfigList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNoticeConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeNoticeConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeNoticeConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNsasSuspEventTypeRequest extends $tea.Model {
  containerFieldName?: string;
  containerFieldValue?: string;
  from?: string;
  lang?: string;
  name?: string;
  remark?: string;
  sourceIp?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      containerFieldName: 'ContainerFieldName',
      containerFieldValue: 'ContainerFieldValue',
      from: 'From',
      lang: 'Lang',
      name: 'Name',
      remark: 'Remark',
      sourceIp: 'SourceIp',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      containerFieldName: 'string',
      containerFieldValue: 'string',
      from: 'string',
      lang: 'string',
      name: 'string',
      remark: 'string',
      sourceIp: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNsasSuspEventTypeResponseBody extends $tea.Model {
  eventTypes?: DescribeNsasSuspEventTypeResponseBodyEventTypes[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      eventTypes: 'EventTypes',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventTypes: { 'type': 'array', 'itemType': DescribeNsasSuspEventTypeResponseBodyEventTypes },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNsasSuspEventTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeNsasSuspEventTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeNsasSuspEventTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOfflineMachinesRequest extends $tea.Model {
  currentPage?: number;
  os?: string;
  pageSize?: number;
  regionIdStr?: string;
  regionNo?: string;
  remark?: string;
  sourceIp?: string;
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      os: 'Os',
      pageSize: 'PageSize',
      regionIdStr: 'RegionIdStr',
      regionNo: 'RegionNo',
      remark: 'Remark',
      sourceIp: 'SourceIp',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      os: 'string',
      pageSize: 'number',
      regionIdStr: 'string',
      regionNo: 'string',
      remark: 'string',
      sourceIp: 'string',
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOfflineMachinesResponseBody extends $tea.Model {
  currentPage?: number;
  machineList?: DescribeOfflineMachinesResponseBodyMachineList[];
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      machineList: 'MachineList',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      machineList: { 'type': 'array', 'itemType': DescribeOfflineMachinesResponseBodyMachineList },
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOfflineMachinesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeOfflineMachinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOfflineMachinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOnceTaskRequest extends $tea.Model {
  currentPage?: number;
  endTimeQuery?: number;
  pageSize?: number;
  rootTaskId?: string;
  startTimeQuery?: number;
  taskId?: string;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTimeQuery: 'EndTimeQuery',
      pageSize: 'PageSize',
      rootTaskId: 'RootTaskId',
      startTimeQuery: 'StartTimeQuery',
      taskId: 'TaskId',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTimeQuery: 'number',
      pageSize: 'number',
      rootTaskId: 'string',
      startTimeQuery: 'number',
      taskId: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOnceTaskResponseBody extends $tea.Model {
  pageInfo?: DescribeOnceTaskResponseBodyPageInfo;
  requestId?: string;
  taskManageResponseList?: DescribeOnceTaskResponseBodyTaskManageResponseList[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      taskManageResponseList: 'TaskManageResponseList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribeOnceTaskResponseBodyPageInfo,
      requestId: 'string',
      taskManageResponseList: { 'type': 'array', 'itemType': DescribeOnceTaskResponseBodyTaskManageResponseList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOnceTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeOnceTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOnceTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOnceTaskLeafRecordPageRequest extends $tea.Model {
  currentPage?: number;
  endTime?: number;
  pageSize?: number;
  relateInfo?: boolean;
  source?: string;
  startTime?: number;
  statusList?: string[];
  taskId?: string;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      pageSize: 'PageSize',
      relateInfo: 'RelateInfo',
      source: 'Source',
      startTime: 'StartTime',
      statusList: 'StatusList',
      taskId: 'TaskId',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      pageSize: 'number',
      relateInfo: 'boolean',
      source: 'string',
      startTime: 'number',
      statusList: { 'type': 'array', 'itemType': 'string' },
      taskId: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOnceTaskLeafRecordPageResponseBody extends $tea.Model {
  onceTasks?: DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks[];
  pageInfo?: DescribeOnceTaskLeafRecordPageResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      onceTasks: 'OnceTasks',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      onceTasks: { 'type': 'array', 'itemType': DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks },
      pageInfo: DescribeOnceTaskLeafRecordPageResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOnceTaskLeafRecordPageResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeOnceTaskLeafRecordPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOnceTaskLeafRecordPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyCountRequest extends $tea.Model {
  type?: string;
  uuidList?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      uuidList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyCountResponseBody extends $tea.Model {
  autorun?: number;
  cron?: number;
  database?: number;
  lkm?: number;
  port?: number;
  process?: number;
  requestId?: string;
  sca?: number;
  software?: number;
  user?: number;
  web?: number;
  webserver?: number;
  static names(): { [key: string]: string } {
    return {
      autorun: 'Autorun',
      cron: 'Cron',
      database: 'Database',
      lkm: 'Lkm',
      port: 'Port',
      process: 'Process',
      requestId: 'RequestId',
      sca: 'Sca',
      software: 'Software',
      user: 'User',
      web: 'Web',
      webserver: 'Webserver',
    };
  }

  static types(): { [key: string]: any } {
    return {
      autorun: 'number',
      cron: 'number',
      database: 'number',
      lkm: 'number',
      port: 'number',
      process: 'number',
      requestId: 'string',
      sca: 'number',
      software: 'number',
      user: 'number',
      web: 'number',
      webserver: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyCountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyCronDetailRequest extends $tea.Model {
  currentPage?: number;
  extend?: string;
  pageSize?: number;
  remark?: string;
  source?: string;
  user?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      extend: 'Extend',
      pageSize: 'PageSize',
      remark: 'Remark',
      source: 'Source',
      user: 'User',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      extend: 'string',
      pageSize: 'number',
      remark: 'string',
      source: 'string',
      user: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyCronDetailResponseBody extends $tea.Model {
  pageInfo?: DescribePropertyCronDetailResponseBodyPageInfo;
  propertys?: DescribePropertyCronDetailResponseBodyPropertys[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertys: 'Propertys',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribePropertyCronDetailResponseBodyPageInfo,
      propertys: { 'type': 'array', 'itemType': DescribePropertyCronDetailResponseBodyPropertys },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyCronDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyCronDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyCronDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyCronItemRequest extends $tea.Model {
  currentPage?: number;
  forceFlush?: boolean;
  pageSize?: number;
  source?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      forceFlush: 'ForceFlush',
      pageSize: 'PageSize',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      forceFlush: 'boolean',
      pageSize: 'number',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyCronItemResponseBody extends $tea.Model {
  pageInfo?: DescribePropertyCronItemResponseBodyPageInfo;
  propertyItems?: DescribePropertyCronItemResponseBodyPropertyItems[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertyItems: 'PropertyItems',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribePropertyCronItemResponseBodyPageInfo,
      propertyItems: { 'type': 'array', 'itemType': DescribePropertyCronItemResponseBodyPropertyItems },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyCronItemResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyCronItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyCronItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyPortDetailRequest extends $tea.Model {
  bindIp?: string;
  currentPage?: number;
  extend?: string;
  pageSize?: number;
  port?: string;
  procName?: string;
  remark?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      bindIp: 'BindIp',
      currentPage: 'CurrentPage',
      extend: 'Extend',
      pageSize: 'PageSize',
      port: 'Port',
      procName: 'ProcName',
      remark: 'Remark',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindIp: 'string',
      currentPage: 'number',
      extend: 'string',
      pageSize: 'number',
      port: 'string',
      procName: 'string',
      remark: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyPortDetailResponseBody extends $tea.Model {
  pageInfo?: DescribePropertyPortDetailResponseBodyPageInfo;
  propertys?: DescribePropertyPortDetailResponseBodyPropertys[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertys: 'Propertys',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribePropertyPortDetailResponseBodyPageInfo,
      propertys: { 'type': 'array', 'itemType': DescribePropertyPortDetailResponseBodyPropertys },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyPortDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyPortDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyPortDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyPortItemRequest extends $tea.Model {
  currentPage?: number;
  forceFlush?: boolean;
  pageSize?: number;
  port?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      forceFlush: 'ForceFlush',
      pageSize: 'PageSize',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      forceFlush: 'boolean',
      pageSize: 'number',
      port: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyPortItemResponseBody extends $tea.Model {
  pageInfo?: DescribePropertyPortItemResponseBodyPageInfo;
  propertyItems?: DescribePropertyPortItemResponseBodyPropertyItems[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertyItems: 'PropertyItems',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribePropertyPortItemResponseBodyPageInfo,
      propertyItems: { 'type': 'array', 'itemType': DescribePropertyPortItemResponseBodyPropertyItems },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyPortItemResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyPortItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyPortItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyProcDetailRequest extends $tea.Model {
  cmdline?: string;
  currentPage?: number;
  extend?: string;
  name?: string;
  pageSize?: number;
  procTimeEnd?: number;
  procTimeStart?: number;
  remark?: string;
  user?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      cmdline: 'Cmdline',
      currentPage: 'CurrentPage',
      extend: 'Extend',
      name: 'Name',
      pageSize: 'PageSize',
      procTimeEnd: 'ProcTimeEnd',
      procTimeStart: 'ProcTimeStart',
      remark: 'Remark',
      user: 'User',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cmdline: 'string',
      currentPage: 'number',
      extend: 'string',
      name: 'string',
      pageSize: 'number',
      procTimeEnd: 'number',
      procTimeStart: 'number',
      remark: 'string',
      user: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyProcDetailResponseBody extends $tea.Model {
  pageInfo?: DescribePropertyProcDetailResponseBodyPageInfo;
  propertys?: DescribePropertyProcDetailResponseBodyPropertys[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertys: 'Propertys',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribePropertyProcDetailResponseBodyPageInfo,
      propertys: { 'type': 'array', 'itemType': DescribePropertyProcDetailResponseBodyPropertys },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyProcDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyProcDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyProcDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyProcItemRequest extends $tea.Model {
  currentPage?: number;
  forceFlush?: boolean;
  name?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      forceFlush: 'ForceFlush',
      name: 'Name',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      forceFlush: 'boolean',
      name: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyProcItemResponseBody extends $tea.Model {
  pageInfo?: DescribePropertyProcItemResponseBodyPageInfo;
  propertyItems?: DescribePropertyProcItemResponseBodyPropertyItems[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertyItems: 'PropertyItems',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribePropertyProcItemResponseBodyPageInfo,
      propertyItems: { 'type': 'array', 'itemType': DescribePropertyProcItemResponseBodyPropertyItems },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyProcItemResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyProcItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyProcItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyScaDetailRequest extends $tea.Model {
  biz?: string;
  bizType?: string;
  currentPage?: number;
  lang?: string;
  name?: number;
  pageSize?: number;
  pid?: string;
  port?: string;
  processStartedEnd?: number;
  processStartedStart?: number;
  remark?: string;
  scaName?: string;
  scaNamePattern?: string;
  scaVersion?: string;
  searchInfo?: string;
  searchInfoSub?: string;
  searchItem?: string;
  searchItemSub?: string;
  user?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      biz: 'Biz',
      bizType: 'BizType',
      currentPage: 'CurrentPage',
      lang: 'Lang',
      name: 'Name',
      pageSize: 'PageSize',
      pid: 'Pid',
      port: 'Port',
      processStartedEnd: 'ProcessStartedEnd',
      processStartedStart: 'ProcessStartedStart',
      remark: 'Remark',
      scaName: 'ScaName',
      scaNamePattern: 'ScaNamePattern',
      scaVersion: 'ScaVersion',
      searchInfo: 'SearchInfo',
      searchInfoSub: 'SearchInfoSub',
      searchItem: 'SearchItem',
      searchItemSub: 'SearchItemSub',
      user: 'User',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      biz: 'string',
      bizType: 'string',
      currentPage: 'number',
      lang: 'string',
      name: 'number',
      pageSize: 'number',
      pid: 'string',
      port: 'string',
      processStartedEnd: 'number',
      processStartedStart: 'number',
      remark: 'string',
      scaName: 'string',
      scaNamePattern: 'string',
      scaVersion: 'string',
      searchInfo: 'string',
      searchInfoSub: 'string',
      searchItem: 'string',
      searchItemSub: 'string',
      user: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyScaDetailResponseBody extends $tea.Model {
  pageInfo?: DescribePropertyScaDetailResponseBodyPageInfo;
  propertys?: DescribePropertyScaDetailResponseBodyPropertys[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertys: 'Propertys',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribePropertyScaDetailResponseBodyPageInfo,
      propertys: { 'type': 'array', 'itemType': DescribePropertyScaDetailResponseBodyPropertys },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyScaDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyScaDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyScaDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyScaItemRequest extends $tea.Model {
  biz?: string;
  currentPage?: number;
  forceFlush?: boolean;
  lang?: string;
  pageSize?: number;
  searchInfo?: string;
  searchItem?: string;
  static names(): { [key: string]: string } {
    return {
      biz: 'Biz',
      currentPage: 'CurrentPage',
      forceFlush: 'ForceFlush',
      lang: 'Lang',
      pageSize: 'PageSize',
      searchInfo: 'SearchInfo',
      searchItem: 'SearchItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      biz: 'string',
      currentPage: 'number',
      forceFlush: 'boolean',
      lang: 'string',
      pageSize: 'number',
      searchInfo: 'string',
      searchItem: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyScaItemResponseBody extends $tea.Model {
  pageInfo?: DescribePropertyScaItemResponseBodyPageInfo;
  propertyItems?: DescribePropertyScaItemResponseBodyPropertyItems[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertyItems: 'PropertyItems',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribePropertyScaItemResponseBodyPageInfo,
      propertyItems: { 'type': 'array', 'itemType': DescribePropertyScaItemResponseBodyPropertyItems },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyScaItemResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyScaItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyScaItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyScheduleConfigRequest extends $tea.Model {
  type?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyScheduleConfigResponseBody extends $tea.Model {
  config?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyScheduleConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyScheduleConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyScheduleConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertySoftwareDetailRequest extends $tea.Model {
  currentPage?: number;
  extend?: string;
  installTimeEnd?: number;
  installTimeStart?: number;
  name?: string;
  pageSize?: number;
  path?: string;
  remark?: string;
  softwareVersion?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      extend: 'Extend',
      installTimeEnd: 'InstallTimeEnd',
      installTimeStart: 'InstallTimeStart',
      name: 'Name',
      pageSize: 'PageSize',
      path: 'Path',
      remark: 'Remark',
      softwareVersion: 'SoftwareVersion',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      extend: 'string',
      installTimeEnd: 'number',
      installTimeStart: 'number',
      name: 'string',
      pageSize: 'number',
      path: 'string',
      remark: 'string',
      softwareVersion: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertySoftwareDetailResponseBody extends $tea.Model {
  pageInfo?: DescribePropertySoftwareDetailResponseBodyPageInfo;
  propertys?: DescribePropertySoftwareDetailResponseBodyPropertys[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertys: 'Propertys',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribePropertySoftwareDetailResponseBodyPageInfo,
      propertys: { 'type': 'array', 'itemType': DescribePropertySoftwareDetailResponseBodyPropertys },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertySoftwareDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertySoftwareDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertySoftwareDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertySoftwareItemRequest extends $tea.Model {
  currentPage?: number;
  forceFlush?: boolean;
  name?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      forceFlush: 'ForceFlush',
      name: 'Name',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      forceFlush: 'boolean',
      name: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertySoftwareItemResponseBody extends $tea.Model {
  pageInfo?: DescribePropertySoftwareItemResponseBodyPageInfo;
  propertyItems?: DescribePropertySoftwareItemResponseBodyPropertyItems[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertyItems: 'PropertyItems',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribePropertySoftwareItemResponseBodyPageInfo,
      propertyItems: { 'type': 'array', 'itemType': DescribePropertySoftwareItemResponseBodyPropertyItems },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertySoftwareItemResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertySoftwareItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertySoftwareItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyTypeScaItemRequest extends $tea.Model {
  currentPage?: number;
  lang?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      lang: 'Lang',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      lang: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyTypeScaItemResponseBody extends $tea.Model {
  pageInfo?: DescribePropertyTypeScaItemResponseBodyPageInfo;
  propertyTypeItems?: DescribePropertyTypeScaItemResponseBodyPropertyTypeItems[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertyTypeItems: 'PropertyTypeItems',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribePropertyTypeScaItemResponseBodyPageInfo,
      propertyTypeItems: { 'type': 'array', 'itemType': DescribePropertyTypeScaItemResponseBodyPropertyTypeItems },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyTypeScaItemResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyTypeScaItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyTypeScaItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUsageNewestRequest extends $tea.Model {
  type?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUsageNewestResponseBody extends $tea.Model {
  itemCount?: number;
  newestStatisticItems?: DescribePropertyUsageNewestResponseBodyNewestStatisticItems[];
  requestId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      itemCount: 'ItemCount',
      newestStatisticItems: 'NewestStatisticItems',
      requestId: 'RequestId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemCount: 'number',
      newestStatisticItems: { 'type': 'array', 'itemType': DescribePropertyUsageNewestResponseBodyNewestStatisticItems },
      requestId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUsageNewestResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyUsageNewestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyUsageNewestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUserDetailRequest extends $tea.Model {
  currentPage?: number;
  extend?: string;
  isRoot?: string;
  lastLoginTimeEnd?: number;
  lastLoginTimeStart?: number;
  pageSize?: number;
  remark?: string;
  user?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      extend: 'Extend',
      isRoot: 'IsRoot',
      lastLoginTimeEnd: 'LastLoginTimeEnd',
      lastLoginTimeStart: 'LastLoginTimeStart',
      pageSize: 'PageSize',
      remark: 'Remark',
      user: 'User',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      extend: 'string',
      isRoot: 'string',
      lastLoginTimeEnd: 'number',
      lastLoginTimeStart: 'number',
      pageSize: 'number',
      remark: 'string',
      user: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUserDetailResponseBody extends $tea.Model {
  pageInfo?: DescribePropertyUserDetailResponseBodyPageInfo;
  propertys?: DescribePropertyUserDetailResponseBodyPropertys[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertys: 'Propertys',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribePropertyUserDetailResponseBodyPageInfo,
      propertys: { 'type': 'array', 'itemType': DescribePropertyUserDetailResponseBodyPropertys },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUserDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyUserDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyUserDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUserItemRequest extends $tea.Model {
  currentPage?: number;
  forceFlush?: boolean;
  pageSize?: number;
  user?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      forceFlush: 'ForceFlush',
      pageSize: 'PageSize',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      forceFlush: 'boolean',
      pageSize: 'number',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUserItemResponseBody extends $tea.Model {
  pageInfo?: DescribePropertyUserItemResponseBodyPageInfo;
  propertyItems?: DescribePropertyUserItemResponseBodyPropertyItems[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertyItems: 'PropertyItems',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribePropertyUserItemResponseBodyPageInfo,
      propertyItems: { 'type': 'array', 'itemType': DescribePropertyUserItemResponseBodyPropertyItems },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUserItemResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribePropertyUserItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePropertyUserItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeQuaraFileDownloadInfoRequest extends $tea.Model {
  from?: string;
  quaraFileId?: number;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      quaraFileId: 'QuaraFileId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      quaraFileId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeQuaraFileDownloadInfoResponseBody extends $tea.Model {
  downloadUrl?: string;
  md5?: string;
  path?: string;
  quaraFileId?: number;
  requestId?: string;
  tag?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      downloadUrl: 'DownloadUrl',
      md5: 'Md5',
      path: 'Path',
      quaraFileId: 'QuaraFileId',
      requestId: 'RequestId',
      tag: 'Tag',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadUrl: 'string',
      md5: 'string',
      path: 'string',
      quaraFileId: 'number',
      requestId: 'string',
      tag: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeQuaraFileDownloadInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeQuaraFileDownloadInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeQuaraFileDownloadInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestoreJobsRequest extends $tea.Model {
  currentPage?: number;
  machineRemark?: string;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      machineRemark: 'MachineRemark',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      machineRemark: 'string',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestoreJobsResponseBody extends $tea.Model {
  pageInfo?: DescribeRestoreJobsResponseBodyPageInfo;
  requestId?: string;
  restoreJobs?: DescribeRestoreJobsResponseBodyRestoreJobs[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      restoreJobs: 'RestoreJobs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribeRestoreJobsResponseBodyPageInfo,
      requestId: 'string',
      restoreJobs: { 'type': 'array', 'itemType': DescribeRestoreJobsResponseBodyRestoreJobs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestoreJobsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRestoreJobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRestoreJobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestorePlansRequest extends $tea.Model {
  currentPage?: number;
  instanceName?: string;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceName: 'InstanceName',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceName: 'string',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestorePlansResponseBody extends $tea.Model {
  pageInfo?: DescribeRestorePlansResponseBodyPageInfo;
  requestId?: string;
  restorePlans?: DescribeRestorePlansResponseBodyRestorePlans[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      restorePlans: 'RestorePlans',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribeRestorePlansResponseBodyPageInfo,
      requestId: 'string',
      restorePlans: { 'type': 'array', 'itemType': DescribeRestorePlansResponseBodyRestorePlans },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestorePlansResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRestorePlansResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRestorePlansResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckItemResultRequest extends $tea.Model {
  currentPage?: number;
  itemId?: number;
  lang?: string;
  pageSize?: number;
  resourceOwnerId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      itemId: 'ItemId',
      lang: 'Lang',
      pageSize: 'PageSize',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      itemId: 'number',
      lang: 'string',
      pageSize: 'number',
      resourceOwnerId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckItemResultResponseBody extends $tea.Model {
  pageContentResource?: DescribeRiskCheckItemResultResponseBodyPageContentResource;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageContentResource: 'PageContentResource',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageContentResource: DescribeRiskCheckItemResultResponseBodyPageContentResource,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckItemResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRiskCheckItemResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRiskCheckItemResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckResultRequest extends $tea.Model {
  assetType?: string;
  currentPage?: number;
  groupId?: number;
  itemIds?: string[];
  lang?: string;
  name?: string;
  pageSize?: number;
  queryFlag?: string;
  resourceOwnerId?: number;
  riskLevel?: string;
  sourceIp?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      assetType: 'AssetType',
      currentPage: 'CurrentPage',
      groupId: 'GroupId',
      itemIds: 'ItemIds',
      lang: 'Lang',
      name: 'Name',
      pageSize: 'PageSize',
      queryFlag: 'QueryFlag',
      resourceOwnerId: 'ResourceOwnerId',
      riskLevel: 'RiskLevel',
      sourceIp: 'SourceIp',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetType: 'string',
      currentPage: 'number',
      groupId: 'number',
      itemIds: { 'type': 'array', 'itemType': 'string' },
      lang: 'string',
      name: 'string',
      pageSize: 'number',
      queryFlag: 'string',
      resourceOwnerId: 'number',
      riskLevel: 'string',
      sourceIp: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckResultResponseBody extends $tea.Model {
  count?: number;
  currentPage?: number;
  list?: DescribeRiskCheckResultResponseBodyList[];
  pageCount?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      list: 'List',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      list: { 'type': 'array', 'itemType': DescribeRiskCheckResultResponseBodyList },
      pageCount: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRiskCheckResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRiskCheckResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckSummaryRequest extends $tea.Model {
  lang?: string;
  resourceDirectoryAccountId?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      resourceDirectoryAccountId: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckSummaryResponseBody extends $tea.Model {
  requestId?: string;
  riskCheckSummary?: DescribeRiskCheckSummaryResponseBodyRiskCheckSummary;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      riskCheckSummary: 'RiskCheckSummary',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      riskCheckSummary: DescribeRiskCheckSummaryResponseBodyRiskCheckSummary,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckSummaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRiskCheckSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRiskCheckSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskItemTypeRequest extends $tea.Model {
  lang?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskItemTypeResponseBody extends $tea.Model {
  list?: DescribeRiskItemTypeResponseBodyList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': DescribeRiskItemTypeResponseBodyList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskItemTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRiskItemTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRiskItemTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskListCheckResultRequest extends $tea.Model {
  currentPage?: number;
  instanceIds?: string[];
  lang?: string;
  pageSize?: number;
  resourceOwnerId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      instanceIds: 'InstanceIds',
      lang: 'Lang',
      pageSize: 'PageSize',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      lang: 'string',
      pageSize: 'number',
      resourceOwnerId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskListCheckResultResponseBody extends $tea.Model {
  list?: DescribeRiskListCheckResultResponseBodyList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': DescribeRiskListCheckResultResponseBodyList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskListCheckResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRiskListCheckResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRiskListCheckResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskTypeRequest extends $tea.Model {
  lang?: string;
  source?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      source: 'Source',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      source: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskTypeResponseBody extends $tea.Model {
  requestId?: string;
  riskTypes?: DescribeRiskTypeResponseBodyRiskTypes[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      riskTypes: 'RiskTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      riskTypes: { 'type': 'array', 'itemType': DescribeRiskTypeResponseBodyRiskTypes },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRiskTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRiskTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRisksRequest extends $tea.Model {
  lang?: string;
  limit?: number;
  riskId?: number;
  riskName?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      limit: 'Limit',
      riskId: 'RiskId',
      riskName: 'RiskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      limit: 'number',
      riskId: 'number',
      riskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRisksResponseBody extends $tea.Model {
  requestId?: string;
  risks?: DescribeRisksResponseBodyRisks[];
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      risks: 'Risks',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      risks: { 'type': 'array', 'itemType': DescribeRisksResponseBodyRisks },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRisksResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeRisksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRisksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSasPmAgentListRequest extends $tea.Model {
  lang?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSasPmAgentListResponseBody extends $tea.Model {
  requestId?: string;
  sasPmAgentList?: DescribeSasPmAgentListResponseBodySasPmAgentList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      sasPmAgentList: 'SasPmAgentList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      sasPmAgentList: { 'type': 'array', 'itemType': DescribeSasPmAgentListResponseBodySasPmAgentList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSasPmAgentListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSasPmAgentListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSasPmAgentListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScanTaskProgressRequest extends $tea.Model {
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScanTaskProgressResponseBody extends $tea.Model {
  requestId?: string;
  scanTaskProgress?: string;
  targetInfo?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      scanTaskProgress: 'ScanTaskProgress',
      targetInfo: 'TargetInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      scanTaskProgress: 'string',
      targetInfo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScanTaskProgressResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeScanTaskProgressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeScanTaskProgressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScanTaskStatisticsRequest extends $tea.Model {
  levels?: string;
  static names(): { [key: string]: string } {
    return {
      levels: 'Levels',
    };
  }

  static types(): { [key: string]: any } {
    return {
      levels: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScanTaskStatisticsResponseBody extends $tea.Model {
  dealedRiskNum?: number;
  personalTaskNum?: number;
  requestId?: string;
  totalTaskNum?: number;
  userNum?: number;
  static names(): { [key: string]: string } {
    return {
      dealedRiskNum: 'DealedRiskNum',
      personalTaskNum: 'PersonalTaskNum',
      requestId: 'RequestId',
      totalTaskNum: 'TotalTaskNum',
      userNum: 'UserNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dealedRiskNum: 'number',
      personalTaskNum: 'number',
      requestId: 'string',
      totalTaskNum: 'number',
      userNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeScanTaskStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeScanTaskStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeScanTaskStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSearchConditionRequest extends $tea.Model {
  lang?: string;
  sourceIp?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      sourceIp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSearchConditionResponseBody extends $tea.Model {
  conditionList?: DescribeSearchConditionResponseBodyConditionList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      conditionList: 'ConditionList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditionList: { 'type': 'array', 'itemType': DescribeSearchConditionResponseBodyConditionList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSearchConditionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSearchConditionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSearchConditionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecureSuggestionRequest extends $tea.Model {
  lang?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecureSuggestionResponseBody extends $tea.Model {
  requestId?: string;
  suggestions?: DescribeSecureSuggestionResponseBodySuggestions[];
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      suggestions: 'Suggestions',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      suggestions: { 'type': 'array', 'itemType': DescribeSecureSuggestionResponseBodySuggestions },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecureSuggestionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSecureSuggestionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSecureSuggestionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityCheckScheduleConfigRequest extends $tea.Model {
  lang?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityCheckScheduleConfigResponseBody extends $tea.Model {
  requestId?: string;
  riskCheckJobConfig?: DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      riskCheckJobConfig: 'RiskCheckJobConfig',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      riskCheckJobConfig: DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityCheckScheduleConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSecurityCheckScheduleConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSecurityCheckScheduleConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventMarkMissListRequest extends $tea.Model {
  currentPage?: number;
  eventName?: string;
  pageSize?: number;
  remark?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      eventName: 'EventName',
      pageSize: 'PageSize',
      remark: 'Remark',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      eventName: 'string',
      pageSize: 'number',
      remark: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventMarkMissListResponseBody extends $tea.Model {
  list?: DescribeSecurityEventMarkMissListResponseBodyList[];
  pageInfo?: DescribeSecurityEventMarkMissListResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': DescribeSecurityEventMarkMissListResponseBodyList },
      pageInfo: DescribeSecurityEventMarkMissListResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventMarkMissListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSecurityEventMarkMissListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSecurityEventMarkMissListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventOperationStatusRequest extends $tea.Model {
  resourceOwnerId?: number;
  securityEventIds?: string[];
  sourceIp?: string;
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      resourceOwnerId: 'ResourceOwnerId',
      securityEventIds: 'SecurityEventIds',
      sourceIp: 'SourceIp',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceOwnerId: 'number',
      securityEventIds: { 'type': 'array', 'itemType': 'string' },
      sourceIp: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventOperationStatusResponseBody extends $tea.Model {
  requestId?: string;
  securityEventOperationStatusResponse?: DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityEventOperationStatusResponse: 'SecurityEventOperationStatusResponse',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityEventOperationStatusResponse: DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventOperationStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSecurityEventOperationStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSecurityEventOperationStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventOperationsRequest extends $tea.Model {
  lang?: string;
  resourceOwnerId?: number;
  securityEventId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      resourceOwnerId: 'ResourceOwnerId',
      securityEventId: 'SecurityEventId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      resourceOwnerId: 'number',
      securityEventId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventOperationsResponseBody extends $tea.Model {
  requestId?: string;
  securityEventOperationsResponse?: DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      securityEventOperationsResponse: 'SecurityEventOperationsResponse',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      securityEventOperationsResponse: { 'type': 'array', 'itemType': DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventOperationsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSecurityEventOperationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSecurityEventOperationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityStatInfoRequest extends $tea.Model {
  lang?: string;
  resourceDirectoryAccountId?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      resourceDirectoryAccountId: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityStatInfoResponseBody extends $tea.Model {
  attackEvent?: DescribeSecurityStatInfoResponseBodyAttackEvent;
  healthCheck?: DescribeSecurityStatInfoResponseBodyHealthCheck;
  requestId?: string;
  securityEvent?: DescribeSecurityStatInfoResponseBodySecurityEvent;
  success?: boolean;
  vulnerability?: DescribeSecurityStatInfoResponseBodyVulnerability;
  static names(): { [key: string]: string } {
    return {
      attackEvent: 'AttackEvent',
      healthCheck: 'HealthCheck',
      requestId: 'RequestId',
      securityEvent: 'SecurityEvent',
      success: 'Success',
      vulnerability: 'Vulnerability',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackEvent: DescribeSecurityStatInfoResponseBodyAttackEvent,
      healthCheck: DescribeSecurityStatInfoResponseBodyHealthCheck,
      requestId: 'string',
      securityEvent: DescribeSecurityStatInfoResponseBodySecurityEvent,
      success: 'boolean',
      vulnerability: DescribeSecurityStatInfoResponseBodyVulnerability,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityStatInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSecurityStatInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSecurityStatInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeServiceLinkedRoleStatusRequest extends $tea.Model {
  serviceLinkedRole?: string;
  static names(): { [key: string]: string } {
    return {
      serviceLinkedRole: 'ServiceLinkedRole',
    };
  }

  static types(): { [key: string]: any } {
    return {
      serviceLinkedRole: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeServiceLinkedRoleStatusResponseBody extends $tea.Model {
  requestId?: string;
  roleStatus?: DescribeServiceLinkedRoleStatusResponseBodyRoleStatus;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      roleStatus: 'RoleStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      roleStatus: DescribeServiceLinkedRoleStatusResponseBodyRoleStatus,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeServiceLinkedRoleStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeServiceLinkedRoleStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeServiceLinkedRoleStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSimilarEventScenariosRequest extends $tea.Model {
  resourceOwnerId?: number;
  securityEventId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      resourceOwnerId: 'ResourceOwnerId',
      securityEventId: 'SecurityEventId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceOwnerId: 'number',
      securityEventId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSimilarEventScenariosResponseBody extends $tea.Model {
  requestId?: string;
  scenarios?: DescribeSimilarEventScenariosResponseBodyScenarios[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      scenarios: 'Scenarios',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      scenarios: { 'type': 'array', 'itemType': DescribeSimilarEventScenariosResponseBodyScenarios },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSimilarEventScenariosResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSimilarEventScenariosResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSimilarEventScenariosResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSimilarSecurityEventsRequest extends $tea.Model {
  currentPage?: number;
  lang?: string;
  pageSize?: number;
  resourceOwnerId?: number;
  sourceIp?: string;
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      lang: 'Lang',
      pageSize: 'PageSize',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      lang: 'string',
      pageSize: 'number',
      resourceOwnerId: 'number',
      sourceIp: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSimilarSecurityEventsResponseBody extends $tea.Model {
  pageInfo?: DescribeSimilarSecurityEventsResponseBodyPageInfo;
  requestId?: string;
  securityEventsResponse?: DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      securityEventsResponse: 'SecurityEventsResponse',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribeSimilarSecurityEventsResponseBodyPageInfo,
      requestId: 'string',
      securityEventsResponse: { 'type': 'array', 'itemType': DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSimilarSecurityEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSimilarSecurityEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSimilarSecurityEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsRequest extends $tea.Model {
  apiVersion?: string;
  currentPage?: number;
  isAliYunEcs?: string;
  machineRegion?: string;
  machineRemark?: string;
  nextToken?: string;
  pageSize?: number;
  statusList?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      apiVersion: 'ApiVersion',
      currentPage: 'CurrentPage',
      isAliYunEcs: 'IsAliYunEcs',
      machineRegion: 'MachineRegion',
      machineRemark: 'MachineRemark',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      statusList: 'StatusList',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      apiVersion: 'string',
      currentPage: 'number',
      isAliYunEcs: 'string',
      machineRegion: 'string',
      machineRemark: 'string',
      nextToken: 'string',
      pageSize: 'number',
      statusList: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsResponseBody extends $tea.Model {
  pageInfo?: DescribeSnapshotsResponseBodyPageInfo;
  requestId?: string;
  snapshots?: DescribeSnapshotsResponseBodySnapshots[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      snapshots: 'Snapshots',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribeSnapshotsResponseBodyPageInfo,
      requestId: 'string',
      snapshots: { 'type': 'array', 'itemType': DescribeSnapshotsResponseBodySnapshots },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSnapshotsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSnapshotsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyRequest extends $tea.Model {
  customType?: string;
  lang?: string;
  sourceIp?: string;
  strategyIds?: string;
  static names(): { [key: string]: string } {
    return {
      customType: 'CustomType',
      lang: 'Lang',
      sourceIp: 'SourceIp',
      strategyIds: 'StrategyIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customType: 'string',
      lang: 'string',
      sourceIp: 'string',
      strategyIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyResponseBody extends $tea.Model {
  requestId?: string;
  strategies?: DescribeStrategyResponseBodyStrategies[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      strategies: 'Strategies',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      strategies: { 'type': 'array', 'itemType': DescribeStrategyResponseBodyStrategies },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyDetailRequest extends $tea.Model {
  id?: string;
  lang?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      lang: 'Lang',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      lang: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyDetailResponseBody extends $tea.Model {
  requestId?: string;
  strategy?: DescribeStrategyDetailResponseBodyStrategy;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      strategy: 'Strategy',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      strategy: DescribeStrategyDetailResponseBodyStrategy,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeStrategyDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeStrategyDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyExecDetailRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  sourceIp?: string;
  strategyId?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      sourceIp: 'SourceIp',
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      sourceIp: 'string',
      strategyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyExecDetailResponseBody extends $tea.Model {
  endTime?: string;
  failCount?: number;
  failedEcsList?: DescribeStrategyExecDetailResponseBodyFailedEcsList[];
  inProcessCount?: number;
  percent?: string;
  requestId?: string;
  source?: string;
  startTime?: string;
  successCount?: number;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      failCount: 'FailCount',
      failedEcsList: 'FailedEcsList',
      inProcessCount: 'InProcessCount',
      percent: 'Percent',
      requestId: 'RequestId',
      source: 'Source',
      startTime: 'StartTime',
      successCount: 'SuccessCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      failCount: 'number',
      failedEcsList: { 'type': 'array', 'itemType': DescribeStrategyExecDetailResponseBodyFailedEcsList },
      inProcessCount: 'number',
      percent: 'string',
      requestId: 'string',
      source: 'string',
      startTime: 'string',
      successCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyExecDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeStrategyExecDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeStrategyExecDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyTargetRequest extends $tea.Model {
  config?: string;
  sourceIp?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      sourceIp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyTargetResponseBody extends $tea.Model {
  requestId?: string;
  strategyTargets?: DescribeStrategyTargetResponseBodyStrategyTargets[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      strategyTargets: 'StrategyTargets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      strategyTargets: { 'type': 'array', 'itemType': DescribeStrategyTargetResponseBodyStrategyTargets },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyTargetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeStrategyTargetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeStrategyTargetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSummaryInfoRequest extends $tea.Model {
  lang?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSummaryInfoResponseBody extends $tea.Model {
  aegisClientOfflineCount?: number;
  aegisClientOnlineCount?: number;
  requestId?: string;
  securityScore?: number;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      aegisClientOfflineCount: 'AegisClientOfflineCount',
      aegisClientOnlineCount: 'AegisClientOnlineCount',
      requestId: 'RequestId',
      securityScore: 'SecurityScore',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aegisClientOfflineCount: 'number',
      aegisClientOnlineCount: 'number',
      requestId: 'string',
      securityScore: 'number',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSummaryInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSummaryInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSummaryInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSupportRegionResponseBody extends $tea.Model {
  requestId?: string;
  supportRegion?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      supportRegion: 'SupportRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      supportRegion: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSupportRegionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSupportRegionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSupportRegionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventDetailRequest extends $tea.Model {
  from?: string;
  lang?: string;
  resourceDirectoryAccountId?: number;
  sourceIp?: string;
  suspiciousEventId?: number;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      lang: 'Lang',
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
      sourceIp: 'SourceIp',
      suspiciousEventId: 'SuspiciousEventId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      lang: 'string',
      resourceDirectoryAccountId: 'number',
      sourceIp: 'string',
      suspiciousEventId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventDetailResponseBody extends $tea.Model {
  canBeDealOnLine?: boolean;
  dataSource?: string;
  details?: DescribeSuspEventDetailResponseBodyDetails[];
  eventDesc?: string;
  eventName?: string;
  eventStatus?: string;
  eventTypeDesc?: string;
  id?: number;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  lastTime?: string;
  level?: string;
  operateErrorCode?: string;
  operateMsg?: string;
  requestId?: string;
  saleVersion?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      canBeDealOnLine: 'CanBeDealOnLine',
      dataSource: 'DataSource',
      details: 'Details',
      eventDesc: 'EventDesc',
      eventName: 'EventName',
      eventStatus: 'EventStatus',
      eventTypeDesc: 'EventTypeDesc',
      id: 'Id',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      lastTime: 'LastTime',
      level: 'Level',
      operateErrorCode: 'OperateErrorCode',
      operateMsg: 'OperateMsg',
      requestId: 'RequestId',
      saleVersion: 'SaleVersion',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canBeDealOnLine: 'boolean',
      dataSource: 'string',
      details: { 'type': 'array', 'itemType': DescribeSuspEventDetailResponseBodyDetails },
      eventDesc: 'string',
      eventName: 'string',
      eventStatus: 'string',
      eventTypeDesc: 'string',
      id: 'number',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      lastTime: 'string',
      level: 'string',
      operateErrorCode: 'string',
      operateMsg: 'string',
      requestId: 'string',
      saleVersion: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSuspEventDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSuspEventDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventExportInfoRequest extends $tea.Model {
  exportId?: number;
  static names(): { [key: string]: string } {
    return {
      exportId: 'ExportId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exportId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventExportInfoResponseBody extends $tea.Model {
  exportStatus?: string;
  fileName?: string;
  gmtCreate?: number;
  gmtModified?: number;
  id?: number;
  link?: string;
  progress?: number;
  properties?: string;
  requestId?: string;
  totalCount?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      exportStatus: 'ExportStatus',
      fileName: 'FileName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      link: 'Link',
      progress: 'Progress',
      properties: 'Properties',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exportStatus: 'string',
      fileName: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'number',
      link: 'string',
      progress: 'number',
      properties: 'string',
      requestId: 'string',
      totalCount: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventExportInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSuspEventExportInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSuspEventExportInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventQuaraFilesRequest extends $tea.Model {
  currentPage?: string;
  from?: string;
  groupId?: string;
  groupingId?: number;
  pageSize?: string;
  quaraTag?: string;
  sourceIp?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      from: 'From',
      groupId: 'GroupId',
      groupingId: 'GroupingId',
      pageSize: 'PageSize',
      quaraTag: 'QuaraTag',
      sourceIp: 'SourceIp',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'string',
      from: 'string',
      groupId: 'string',
      groupingId: 'number',
      pageSize: 'string',
      quaraTag: 'string',
      sourceIp: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventQuaraFilesResponseBody extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  quaraFiles?: DescribeSuspEventQuaraFilesResponseBodyQuaraFiles[];
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      quaraFiles: 'QuaraFiles',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      quaraFiles: { 'type': 'array', 'itemType': DescribeSuspEventQuaraFilesResponseBodyQuaraFiles },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventQuaraFilesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSuspEventQuaraFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSuspEventQuaraFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventUserSettingRequest extends $tea.Model {
  from?: string;
  id?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      id: 'Id',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      id: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventUserSettingResponseBody extends $tea.Model {
  levelsOn?: string[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      levelsOn: 'LevelsOn',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      levelsOn: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventUserSettingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSuspEventUserSettingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSuspEventUserSettingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventsRequest extends $tea.Model {
  alarmUniqueInfo?: string;
  assetsTypeList?: string[];
  clusterId?: string;
  containerFieldName?: string;
  containerFieldValue?: string;
  currentPage?: string;
  dealed?: string;
  eventNames?: string;
  from?: string;
  groupId?: number;
  id?: number;
  lang?: string;
  levels?: string;
  name?: string;
  operateErrorCodeList?: string[];
  operateTimeEnd?: string;
  operateTimeStart?: string;
  pageSize?: string;
  parentEventTypes?: string;
  remark?: string;
  resourceDirectoryAccountId?: number;
  sortColumn?: string;
  sortType?: string;
  source?: string;
  sourceIp?: string;
  status?: string;
  tacticId?: string;
  targetType?: string;
  timeEnd?: string;
  timeStart?: string;
  uniqueInfo?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      alarmUniqueInfo: 'AlarmUniqueInfo',
      assetsTypeList: 'AssetsTypeList',
      clusterId: 'ClusterId',
      containerFieldName: 'ContainerFieldName',
      containerFieldValue: 'ContainerFieldValue',
      currentPage: 'CurrentPage',
      dealed: 'Dealed',
      eventNames: 'EventNames',
      from: 'From',
      groupId: 'GroupId',
      id: 'Id',
      lang: 'Lang',
      levels: 'Levels',
      name: 'Name',
      operateErrorCodeList: 'OperateErrorCodeList',
      operateTimeEnd: 'OperateTimeEnd',
      operateTimeStart: 'OperateTimeStart',
      pageSize: 'PageSize',
      parentEventTypes: 'ParentEventTypes',
      remark: 'Remark',
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
      sortColumn: 'SortColumn',
      sortType: 'SortType',
      source: 'Source',
      sourceIp: 'SourceIp',
      status: 'Status',
      tacticId: 'TacticId',
      targetType: 'TargetType',
      timeEnd: 'TimeEnd',
      timeStart: 'TimeStart',
      uniqueInfo: 'UniqueInfo',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmUniqueInfo: 'string',
      assetsTypeList: { 'type': 'array', 'itemType': 'string' },
      clusterId: 'string',
      containerFieldName: 'string',
      containerFieldValue: 'string',
      currentPage: 'string',
      dealed: 'string',
      eventNames: 'string',
      from: 'string',
      groupId: 'number',
      id: 'number',
      lang: 'string',
      levels: 'string',
      name: 'string',
      operateErrorCodeList: { 'type': 'array', 'itemType': 'string' },
      operateTimeEnd: 'string',
      operateTimeStart: 'string',
      pageSize: 'string',
      parentEventTypes: 'string',
      remark: 'string',
      resourceDirectoryAccountId: 'number',
      sortColumn: 'string',
      sortType: 'string',
      source: 'string',
      sourceIp: 'string',
      status: 'string',
      tacticId: 'string',
      targetType: 'string',
      timeEnd: 'string',
      timeStart: 'string',
      uniqueInfo: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventsResponseBody extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  requestId?: string;
  suspEvents?: DescribeSuspEventsResponseBodySuspEvents[];
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      suspEvents: 'SuspEvents',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      requestId: 'string',
      suspEvents: { 'type': 'array', 'itemType': DescribeSuspEventsResponseBodySuspEvents },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSuspEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSuspEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspiciousOverallConfigRequest extends $tea.Model {
  sourceIp?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceIp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspiciousOverallConfigResponseBody extends $tea.Model {
  overallConfig?: DescribeSuspiciousOverallConfigResponseBodyOverallConfig;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      overallConfig: 'OverallConfig',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      overallConfig: DescribeSuspiciousOverallConfigResponseBodyOverallConfig,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspiciousOverallConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSuspiciousOverallConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSuspiciousOverallConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspiciousUUIDConfigRequest extends $tea.Model {
  type?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspiciousUUIDConfigResponseBody extends $tea.Model {
  count?: number;
  requestId?: string;
  UUIDList?: string[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      requestId: 'RequestId',
      UUIDList: 'UUIDList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      requestId: 'string',
      UUIDList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspiciousUUIDConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeSuspiciousUUIDConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSuspiciousUUIDConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTargetRequest extends $tea.Model {
  config?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTargetResponseBody extends $tea.Model {
  requestId?: string;
  targets?: DescribeTargetResponseBodyTargets[];
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      targets: 'Targets',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      targets: { 'type': 'array', 'itemType': DescribeTargetResponseBodyTargets },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTargetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeTargetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTargetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTaskErrorLogRequest extends $tea.Model {
  buildTaskId?: string;
  static names(): { [key: string]: string } {
    return {
      buildTaskId: 'BuildTaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      buildTaskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTaskErrorLogResponseBody extends $tea.Model {
  logs?: DescribeTaskErrorLogResponseBodyLogs[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      logs: 'Logs',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logs: { 'type': 'array', 'itemType': DescribeTaskErrorLogResponseBodyLogs },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTaskErrorLogResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeTaskErrorLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTaskErrorLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTotalStatisticsRequest extends $tea.Model {
  from?: string;
  groupId?: number;
  remark?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      groupId: 'GroupId',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      groupId: 'number',
      remark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTotalStatisticsResponseBody extends $tea.Model {
  account?: number;
  health?: number;
  healthTotal?: number;
  healthdealedTotal?: number;
  healthhighTotal?: number;
  healthlowTotal?: number;
  healthmediumTotal?: number;
  healthseriousTotal?: number;
  newsuspicious?: number;
  online?: boolean;
  patch?: number;
  requestId?: string;
  suspicious?: number;
  suspiciousTotal?: number;
  suspiciousdealedTotal?: number;
  suspicioushighTotal?: number;
  suspiciouslowTotal?: number;
  suspiciousmediumTotal?: number;
  suspiciousseriousTotal?: number;
  trojan?: number;
  vul?: number;
  vulAsapSum?: number;
  vulDealedTotal?: number;
  vulLaterSum?: number;
  vulNntfSum?: number;
  vulTotal?: number;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      health: 'Health',
      healthTotal: 'HealthTotal',
      healthdealedTotal: 'HealthdealedTotal',
      healthhighTotal: 'HealthhighTotal',
      healthlowTotal: 'HealthlowTotal',
      healthmediumTotal: 'HealthmediumTotal',
      healthseriousTotal: 'HealthseriousTotal',
      newsuspicious: 'Newsuspicious',
      online: 'Online',
      patch: 'Patch',
      requestId: 'RequestId',
      suspicious: 'Suspicious',
      suspiciousTotal: 'SuspiciousTotal',
      suspiciousdealedTotal: 'SuspiciousdealedTotal',
      suspicioushighTotal: 'SuspicioushighTotal',
      suspiciouslowTotal: 'SuspiciouslowTotal',
      suspiciousmediumTotal: 'SuspiciousmediumTotal',
      suspiciousseriousTotal: 'SuspiciousseriousTotal',
      trojan: 'Trojan',
      vul: 'Vul',
      vulAsapSum: 'VulAsapSum',
      vulDealedTotal: 'VulDealedTotal',
      vulLaterSum: 'VulLaterSum',
      vulNntfSum: 'VulNntfSum',
      vulTotal: 'VulTotal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'number',
      health: 'number',
      healthTotal: 'number',
      healthdealedTotal: 'number',
      healthhighTotal: 'number',
      healthlowTotal: 'number',
      healthmediumTotal: 'number',
      healthseriousTotal: 'number',
      newsuspicious: 'number',
      online: 'boolean',
      patch: 'number',
      requestId: 'string',
      suspicious: 'number',
      suspiciousTotal: 'number',
      suspiciousdealedTotal: 'number',
      suspicioushighTotal: 'number',
      suspiciouslowTotal: 'number',
      suspiciousmediumTotal: 'number',
      suspiciousseriousTotal: 'number',
      trojan: 'number',
      vul: 'number',
      vulAsapSum: 'number',
      vulDealedTotal: 'number',
      vulLaterSum: 'number',
      vulNntfSum: 'number',
      vulTotal: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTotalStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeTotalStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTotalStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoDetailRequest extends $tea.Model {
  from?: string;
  incidentTime?: number;
  lang?: string;
  sourceIp?: string;
  type?: string;
  uuid?: string;
  vertexId?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      incidentTime: 'IncidentTime',
      lang: 'Lang',
      sourceIp: 'SourceIp',
      type: 'Type',
      uuid: 'Uuid',
      vertexId: 'VertexId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      incidentTime: 'number',
      lang: 'string',
      sourceIp: 'string',
      type: 'string',
      uuid: 'string',
      vertexId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoDetailResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  traceInfoDetail?: DescribeTraceInfoDetailResponseBodyTraceInfoDetail;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
      traceInfoDetail: 'TraceInfoDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
      traceInfoDetail: DescribeTraceInfoDetailResponseBodyTraceInfoDetail,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeTraceInfoDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTraceInfoDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoNodeRequest extends $tea.Model {
  eventName?: string;
  from?: string;
  incidentTime?: number;
  lang?: string;
  sourceIp?: string;
  type?: string;
  uuid?: string;
  vertexId?: string;
  static names(): { [key: string]: string } {
    return {
      eventName: 'EventName',
      from: 'From',
      incidentTime: 'IncidentTime',
      lang: 'Lang',
      sourceIp: 'SourceIp',
      type: 'Type',
      uuid: 'Uuid',
      vertexId: 'VertexId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventName: 'string',
      from: 'string',
      incidentTime: 'number',
      lang: 'string',
      sourceIp: 'string',
      type: 'string',
      uuid: 'string',
      vertexId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoNodeResponseBody extends $tea.Model {
  node?: DescribeTraceInfoNodeResponseBodyNode;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      node: 'Node',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      node: DescribeTraceInfoNodeResponseBodyNode,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoNodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeTraceInfoNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTraceInfoNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupDatabaseRequest extends $tea.Model {
  currentPage?: number;
  databaseType?: string;
  instanceName?: string;
  pageSize?: number;
  queryType?: string;
  uniRegionId?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      databaseType: 'DatabaseType',
      instanceName: 'InstanceName',
      pageSize: 'PageSize',
      queryType: 'QueryType',
      uniRegionId: 'UniRegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      databaseType: 'string',
      instanceName: 'string',
      pageSize: 'number',
      queryType: 'string',
      uniRegionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupDatabaseResponseBody extends $tea.Model {
  databaseList?: DescribeUniBackupDatabaseResponseBodyDatabaseList[];
  pageInfo?: DescribeUniBackupDatabaseResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      databaseList: 'DatabaseList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseList: { 'type': 'array', 'itemType': DescribeUniBackupDatabaseResponseBodyDatabaseList },
      pageInfo: DescribeUniBackupDatabaseResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupDatabaseResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUniBackupDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUniBackupDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupPoliciesRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  policyName?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      policyName: 'PolicyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      policyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupPoliciesResponseBody extends $tea.Model {
  pageInfo?: DescribeUniBackupPoliciesResponseBodyPageInfo;
  requestId?: string;
  uniBackupPolicies?: DescribeUniBackupPoliciesResponseBodyUniBackupPolicies[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      uniBackupPolicies: 'UniBackupPolicies',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribeUniBackupPoliciesResponseBodyPageInfo,
      requestId: 'string',
      uniBackupPolicies: { 'type': 'array', 'itemType': DescribeUniBackupPoliciesResponseBodyUniBackupPolicies },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupPoliciesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUniBackupPoliciesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUniBackupPoliciesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupPolicyDetailRequest extends $tea.Model {
  policyId?: string;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupPolicyDetailResponseBody extends $tea.Model {
  requestId?: string;
  uniBackupPolicyDTO?: DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      uniBackupPolicyDTO: 'UniBackupPolicyDTO',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      uniBackupPolicyDTO: DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupPolicyDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUniBackupPolicyDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUniBackupPolicyDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniRecoverableListRequest extends $tea.Model {
  currentPage?: number;
  database?: string;
  pageSize?: number;
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      database: 'Database',
      pageSize: 'PageSize',
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      database: 'string',
      pageSize: 'number',
      policyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniRecoverableListResponseBody extends $tea.Model {
  count?: number;
  currentPage?: number;
  database?: string;
  pageSize?: number;
  recoverableInfoList?: DescribeUniRecoverableListResponseBodyRecoverableInfoList[];
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      database: 'Database',
      pageSize: 'PageSize',
      recoverableInfoList: 'RecoverableInfoList',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      database: 'string',
      pageSize: 'number',
      recoverableInfoList: { 'type': 'array', 'itemType': DescribeUniRecoverableListResponseBodyRecoverableInfoList },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniRecoverableListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUniRecoverableListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUniRecoverableListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniSupportRegionResponseBody extends $tea.Model {
  requestId?: string;
  uniSupportRegion?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      uniSupportRegion: 'UniSupportRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      uniSupportRegion: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniSupportRegionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUniSupportRegionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUniSupportRegionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserBackupMachinesResponseBody extends $tea.Model {
  machines?: DescribeUserBackupMachinesResponseBodyMachines[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      machines: 'Machines',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      machines: { 'type': 'array', 'itemType': DescribeUserBackupMachinesResponseBodyMachines },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserBackupMachinesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUserBackupMachinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUserBackupMachinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserBaselineAuthorizationRequest extends $tea.Model {
  lang?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserBaselineAuthorizationResponseBody extends $tea.Model {
  requestId?: string;
  userBaselineAuthorization?: DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      userBaselineAuthorization: 'UserBaselineAuthorization',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      userBaselineAuthorization: DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserBaselineAuthorizationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUserBaselineAuthorizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUserBaselineAuthorizationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserLayoutAuthorizationRequest extends $tea.Model {
  lang?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserLayoutAuthorizationResponseBody extends $tea.Model {
  authorized?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      authorized: 'Authorized',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorized: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserLayoutAuthorizationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUserLayoutAuthorizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUserLayoutAuthorizationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUuidsByVulNamesRequest extends $tea.Model {
  dealed?: string;
  fieldName?: string;
  fieldValue?: string;
  groupId?: number;
  lang?: string;
  level?: string;
  necessity?: string;
  remark?: string;
  searchTags?: string;
  statusList?: string;
  tag?: string;
  targetType?: string;
  type?: string;
  vpcInstanceIds?: string;
  vulNames?: string[];
  static names(): { [key: string]: string } {
    return {
      dealed: 'Dealed',
      fieldName: 'FieldName',
      fieldValue: 'FieldValue',
      groupId: 'GroupId',
      lang: 'Lang',
      level: 'Level',
      necessity: 'Necessity',
      remark: 'Remark',
      searchTags: 'SearchTags',
      statusList: 'StatusList',
      tag: 'Tag',
      targetType: 'TargetType',
      type: 'Type',
      vpcInstanceIds: 'VpcInstanceIds',
      vulNames: 'VulNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dealed: 'string',
      fieldName: 'string',
      fieldValue: 'string',
      groupId: 'number',
      lang: 'string',
      level: 'string',
      necessity: 'string',
      remark: 'string',
      searchTags: 'string',
      statusList: 'string',
      tag: 'string',
      targetType: 'string',
      type: 'string',
      vpcInstanceIds: 'string',
      vulNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUuidsByVulNamesResponseBody extends $tea.Model {
  machineInfoStatistics?: DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics[];
  requestId?: string;
  vulCount?: number;
  static names(): { [key: string]: string } {
    return {
      machineInfoStatistics: 'MachineInfoStatistics',
      requestId: 'RequestId',
      vulCount: 'VulCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      machineInfoStatistics: { 'type': 'array', 'itemType': DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics },
      requestId: 'string',
      vulCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUuidsByVulNamesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeUuidsByVulNamesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeUuidsByVulNamesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVendorListResponseBody extends $tea.Model {
  requestId?: string;
  vendorNameList?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vendorNameList: 'VendorNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vendorNameList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVendorListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVendorListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVendorListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVersionConfigRequest extends $tea.Model {
  resourceDirectoryAccountId?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceDirectoryAccountId: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVersionConfigResponseBody extends $tea.Model {
  agentlessCapacity?: number;
  allowPartialBuy?: number;
  appWhiteList?: number;
  appWhiteListAuthCount?: number;
  assetLevel?: number;
  cspmCapacity?: number;
  highestVersion?: number;
  honeypotCapacity?: number;
  imageScanCapacity?: number;
  instanceId?: string;
  isNewContainerVersion?: boolean;
  isNewMultiVersion?: boolean;
  isOverBalance?: boolean;
  isPostpay?: boolean;
  isTrialVersion?: number;
  lastTrailEndTime?: number;
  MVAuthCount?: number;
  MVUnusedAuthCount?: number;
  openTime?: number;
  postPayInstanceId?: string;
  postPayModuleSwitch?: string;
  postPayOpenTime?: number;
  postPayStatus?: number;
  raspCapacity?: number;
  releaseTime?: number;
  requestId?: string;
  sasLog?: number;
  sasScreen?: number;
  slsCapacity?: number;
  threatAnalysisCapacity?: number;
  userDefinedAlarms?: number;
  version?: number;
  vmCores?: number;
  vulFixCapacity?: number;
  webLock?: number;
  webLockAuthCount?: number;
  static names(): { [key: string]: string } {
    return {
      agentlessCapacity: 'AgentlessCapacity',
      allowPartialBuy: 'AllowPartialBuy',
      appWhiteList: 'AppWhiteList',
      appWhiteListAuthCount: 'AppWhiteListAuthCount',
      assetLevel: 'AssetLevel',
      cspmCapacity: 'CspmCapacity',
      highestVersion: 'HighestVersion',
      honeypotCapacity: 'HoneypotCapacity',
      imageScanCapacity: 'ImageScanCapacity',
      instanceId: 'InstanceId',
      isNewContainerVersion: 'IsNewContainerVersion',
      isNewMultiVersion: 'IsNewMultiVersion',
      isOverBalance: 'IsOverBalance',
      isPostpay: 'IsPostpay',
      isTrialVersion: 'IsTrialVersion',
      lastTrailEndTime: 'LastTrailEndTime',
      MVAuthCount: 'MVAuthCount',
      MVUnusedAuthCount: 'MVUnusedAuthCount',
      openTime: 'OpenTime',
      postPayInstanceId: 'PostPayInstanceId',
      postPayModuleSwitch: 'PostPayModuleSwitch',
      postPayOpenTime: 'PostPayOpenTime',
      postPayStatus: 'PostPayStatus',
      raspCapacity: 'RaspCapacity',
      releaseTime: 'ReleaseTime',
      requestId: 'RequestId',
      sasLog: 'SasLog',
      sasScreen: 'SasScreen',
      slsCapacity: 'SlsCapacity',
      threatAnalysisCapacity: 'ThreatAnalysisCapacity',
      userDefinedAlarms: 'UserDefinedAlarms',
      version: 'Version',
      vmCores: 'VmCores',
      vulFixCapacity: 'VulFixCapacity',
      webLock: 'WebLock',
      webLockAuthCount: 'WebLockAuthCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agentlessCapacity: 'number',
      allowPartialBuy: 'number',
      appWhiteList: 'number',
      appWhiteListAuthCount: 'number',
      assetLevel: 'number',
      cspmCapacity: 'number',
      highestVersion: 'number',
      honeypotCapacity: 'number',
      imageScanCapacity: 'number',
      instanceId: 'string',
      isNewContainerVersion: 'boolean',
      isNewMultiVersion: 'boolean',
      isOverBalance: 'boolean',
      isPostpay: 'boolean',
      isTrialVersion: 'number',
      lastTrailEndTime: 'number',
      MVAuthCount: 'number',
      MVUnusedAuthCount: 'number',
      openTime: 'number',
      postPayInstanceId: 'string',
      postPayModuleSwitch: 'string',
      postPayOpenTime: 'number',
      postPayStatus: 'number',
      raspCapacity: 'number',
      releaseTime: 'number',
      requestId: 'string',
      sasLog: 'number',
      sasScreen: 'number',
      slsCapacity: 'number',
      threatAnalysisCapacity: 'number',
      userDefinedAlarms: 'number',
      version: 'number',
      vmCores: 'number',
      vulFixCapacity: 'number',
      webLock: 'number',
      webLockAuthCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVersionConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVersionConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVersionConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHoneyPotCriteriaRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHoneyPotCriteriaResponseBody extends $tea.Model {
  criteriaList?: DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      criteriaList: 'CriteriaList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteriaList: { 'type': 'array', 'itemType': DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHoneyPotCriteriaResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVpcHoneyPotCriteriaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVpcHoneyPotCriteriaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHoneyPotListRequest extends $tea.Model {
  currentPage?: number;
  honeyPotExistence?: boolean;
  pageSize?: number;
  vpcId?: string;
  vpcName?: string;
  vpcRegionId?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      honeyPotExistence: 'HoneyPotExistence',
      pageSize: 'PageSize',
      vpcId: 'VpcId',
      vpcName: 'VpcName',
      vpcRegionId: 'VpcRegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      honeyPotExistence: 'boolean',
      pageSize: 'number',
      vpcId: 'string',
      vpcName: 'string',
      vpcRegionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHoneyPotListResponseBody extends $tea.Model {
  pageInfo?: DescribeVpcHoneyPotListResponseBodyPageInfo;
  requestId?: string;
  vpcHoneyPotDTOList?: DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      vpcHoneyPotDTOList: 'VpcHoneyPotDTOList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: DescribeVpcHoneyPotListResponseBodyPageInfo,
      requestId: 'string',
      vpcHoneyPotDTOList: { 'type': 'array', 'itemType': DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHoneyPotListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVpcHoneyPotListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVpcHoneyPotListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcListResponseBody extends $tea.Model {
  count?: number;
  requestId?: string;
  vpcList?: DescribeVpcListResponseBodyVpcList[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      requestId: 'RequestId',
      vpcList: 'VpcList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      requestId: 'string',
      vpcList: { 'type': 'array', 'itemType': DescribeVpcListResponseBodyVpcList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVpcListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVpcListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulCheckTaskStatusDetailRequest extends $tea.Model {
  taskIds?: string[];
  types?: string[];
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      taskIds: 'TaskIds',
      types: 'Types',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskIds: { 'type': 'array', 'itemType': 'string' },
      types: { 'type': 'array', 'itemType': 'string' },
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulCheckTaskStatusDetailResponseBody extends $tea.Model {
  requestId?: string;
  taskStatuses?: DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses[];
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskStatuses: 'TaskStatuses',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskStatuses: { 'type': 'array', 'itemType': DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulCheckTaskStatusDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVulCheckTaskStatusDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVulCheckTaskStatusDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulConfigRequest extends $tea.Model {
  sourceIp?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceIp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulConfigResponseBody extends $tea.Model {
  requestId?: string;
  targetConfigs?: DescribeVulConfigResponseBodyTargetConfigs[];
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      targetConfigs: 'TargetConfigs',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      targetConfigs: { 'type': 'array', 'itemType': DescribeVulConfigResponseBodyTargetConfigs },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVulConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVulConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulDetailsRequest extends $tea.Model {
  aliasName?: string;
  lang?: string;
  name?: string;
  resourceDirectoryAccountId?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      lang: 'Lang',
      name: 'Name',
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      lang: 'string',
      name: 'string',
      resourceDirectoryAccountId: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulDetailsResponseBody extends $tea.Model {
  cves?: DescribeVulDetailsResponseBodyCves[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      cves: 'Cves',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cves: { 'type': 'array', 'itemType': DescribeVulDetailsResponseBodyCves },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulDetailsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVulDetailsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVulDetailsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulExportInfoRequest extends $tea.Model {
  exportId?: number;
  static names(): { [key: string]: string } {
    return {
      exportId: 'ExportId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exportId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulExportInfoResponseBody extends $tea.Model {
  currentCount?: number;
  exportStatus?: string;
  fileName?: string;
  id?: number;
  link?: string;
  message?: string;
  progress?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentCount: 'CurrentCount',
      exportStatus: 'ExportStatus',
      fileName: 'FileName',
      id: 'Id',
      link: 'Link',
      message: 'Message',
      progress: 'Progress',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentCount: 'number',
      exportStatus: 'string',
      fileName: 'string',
      id: 'number',
      link: 'string',
      message: 'string',
      progress: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulExportInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVulExportInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVulExportInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulFixStatisticsResponseBody extends $tea.Model {
  fixStat?: DescribeVulFixStatisticsResponseBodyFixStat[];
  fixTotal?: DescribeVulFixStatisticsResponseBodyFixTotal;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      fixStat: 'FixStat',
      fixTotal: 'FixTotal',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fixStat: { 'type': 'array', 'itemType': DescribeVulFixStatisticsResponseBodyFixStat },
      fixTotal: DescribeVulFixStatisticsResponseBodyFixTotal,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulFixStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVulFixStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVulFixStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulListRequest extends $tea.Model {
  aliasName?: string;
  attachTypes?: string;
  currentPage?: number;
  dealed?: string;
  groupId?: string;
  lang?: string;
  name?: string;
  necessity?: string;
  nextToken?: string;
  pageSize?: number;
  remark?: string;
  resourceDirectoryAccountId?: number;
  statusList?: string;
  type?: string;
  useNextToken?: boolean;
  uuids?: string;
  vpcInstanceIds?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      attachTypes: 'AttachTypes',
      currentPage: 'CurrentPage',
      dealed: 'Dealed',
      groupId: 'GroupId',
      lang: 'Lang',
      name: 'Name',
      necessity: 'Necessity',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      remark: 'Remark',
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
      statusList: 'StatusList',
      type: 'Type',
      useNextToken: 'UseNextToken',
      uuids: 'Uuids',
      vpcInstanceIds: 'VpcInstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      attachTypes: 'string',
      currentPage: 'number',
      dealed: 'string',
      groupId: 'string',
      lang: 'string',
      name: 'string',
      necessity: 'string',
      nextToken: 'string',
      pageSize: 'number',
      remark: 'string',
      resourceDirectoryAccountId: 'number',
      statusList: 'string',
      type: 'string',
      useNextToken: 'boolean',
      uuids: 'string',
      vpcInstanceIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulListResponseBody extends $tea.Model {
  currentPage?: number;
  nextToken?: string;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  vulRecords?: DescribeVulListResponseBodyVulRecords[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      vulRecords: 'VulRecords',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      nextToken: 'string',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      vulRecords: { 'type': 'array', 'itemType': DescribeVulListResponseBodyVulRecords },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVulListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVulListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulListPageRequest extends $tea.Model {
  currentPage?: number;
  cveId?: string;
  pageSize?: number;
  vulNameLike?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      cveId: 'CveId',
      pageSize: 'PageSize',
      vulNameLike: 'VulNameLike',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      cveId: 'string',
      pageSize: 'number',
      vulNameLike: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulListPageResponseBody extends $tea.Model {
  data?: DescribeVulListPageResponseBodyData[];
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': DescribeVulListPageResponseBodyData },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulListPageResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVulListPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVulListPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulNumStatisticsRequest extends $tea.Model {
  from?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulNumStatisticsResponseBody extends $tea.Model {
  appCnt?: number;
  appNum?: number;
  cmsDealedTotalNum?: number;
  cmsNum?: number;
  cveNum?: number;
  emgNum?: number;
  requestId?: string;
  scaNum?: number;
  sysNum?: number;
  vulAsapSum?: number;
  vulDealedTotalNum?: number;
  vulLaterSum?: number;
  vulNntfSum?: number;
  static names(): { [key: string]: string } {
    return {
      appCnt: 'AppCnt',
      appNum: 'AppNum',
      cmsDealedTotalNum: 'CmsDealedTotalNum',
      cmsNum: 'CmsNum',
      cveNum: 'CveNum',
      emgNum: 'EmgNum',
      requestId: 'RequestId',
      scaNum: 'ScaNum',
      sysNum: 'SysNum',
      vulAsapSum: 'VulAsapSum',
      vulDealedTotalNum: 'VulDealedTotalNum',
      vulLaterSum: 'VulLaterSum',
      vulNntfSum: 'VulNntfSum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appCnt: 'number',
      appNum: 'number',
      cmsDealedTotalNum: 'number',
      cmsNum: 'number',
      cveNum: 'number',
      emgNum: 'number',
      requestId: 'string',
      scaNum: 'number',
      sysNum: 'number',
      vulAsapSum: 'number',
      vulDealedTotalNum: 'number',
      vulLaterSum: 'number',
      vulNntfSum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulNumStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVulNumStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVulNumStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulTargetConfigRequest extends $tea.Model {
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulTargetConfigResponseBody extends $tea.Model {
  requestId?: string;
  targetConfigs?: DescribeVulTargetConfigResponseBodyTargetConfigs[];
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      targetConfigs: 'TargetConfigs',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      targetConfigs: { 'type': 'array', 'itemType': DescribeVulTargetConfigResponseBodyTargetConfigs },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulTargetConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVulTargetConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVulTargetConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulTargetStatisticsRequest extends $tea.Model {
  type?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulTargetStatisticsResponseBody extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  requestId?: string;
  targetStats?: DescribeVulTargetStatisticsResponseBodyTargetStats[];
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      targetStats: 'TargetStats',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      requestId: 'string',
      targetStats: { 'type': 'array', 'itemType': DescribeVulTargetStatisticsResponseBodyTargetStats },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulTargetStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVulTargetStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVulTargetStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulWhitelistRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulWhitelistResponseBody extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  vulWhitelists?: DescribeVulWhitelistResponseBodyVulWhitelists[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      vulWhitelists: 'VulWhitelists',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      vulWhitelists: { 'type': 'array', 'itemType': DescribeVulWhitelistResponseBodyVulWhitelists },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulWhitelistResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeVulWhitelistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeVulWhitelistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWarningExportInfoRequest extends $tea.Model {
  exportId?: number;
  static names(): { [key: string]: string } {
    return {
      exportId: 'ExportId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exportId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWarningExportInfoResponseBody extends $tea.Model {
  currentCount?: number;
  exportStatus?: string;
  fileName?: string;
  id?: number;
  link?: string;
  message?: string;
  progress?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentCount: 'CurrentCount',
      exportStatus: 'ExportStatus',
      fileName: 'FileName',
      id: 'Id',
      link: 'Link',
      message: 'Message',
      progress: 'Progress',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentCount: 'number',
      exportStatus: 'string',
      fileName: 'string',
      id: 'number',
      link: 'string',
      message: 'string',
      progress: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWarningExportInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWarningExportInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWarningExportInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWarningMachinesRequest extends $tea.Model {
  clusterId?: string;
  containerFieldName?: string;
  containerFieldValue?: string;
  currentPage?: number;
  groupId?: number;
  haveRisk?: number;
  lang?: string;
  machineName?: string;
  pageSize?: number;
  riskId?: number;
  sourceIp?: string;
  strategyId?: number;
  targetType?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      containerFieldName: 'ContainerFieldName',
      containerFieldValue: 'ContainerFieldValue',
      currentPage: 'CurrentPage',
      groupId: 'GroupId',
      haveRisk: 'HaveRisk',
      lang: 'Lang',
      machineName: 'MachineName',
      pageSize: 'PageSize',
      riskId: 'RiskId',
      sourceIp: 'SourceIp',
      strategyId: 'StrategyId',
      targetType: 'TargetType',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      containerFieldName: 'string',
      containerFieldValue: 'string',
      currentPage: 'number',
      groupId: 'number',
      haveRisk: 'number',
      lang: 'string',
      machineName: 'string',
      pageSize: 'number',
      riskId: 'number',
      sourceIp: 'string',
      strategyId: 'number',
      targetType: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWarningMachinesResponseBody extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  warningMachines?: DescribeWarningMachinesResponseBodyWarningMachines[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
      warningMachines: 'WarningMachines',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
      warningMachines: { 'type': 'array', 'itemType': DescribeWarningMachinesResponseBodyWarningMachines },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWarningMachinesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWarningMachinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWarningMachinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockBindListRequest extends $tea.Model {
  currentPage?: number;
  lang?: string;
  pageSize?: number;
  remark?: string;
  sourceIp?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      lang: 'Lang',
      pageSize: 'PageSize',
      remark: 'Remark',
      sourceIp: 'SourceIp',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      lang: 'string',
      pageSize: 'number',
      remark: 'string',
      sourceIp: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockBindListResponseBody extends $tea.Model {
  bindList?: DescribeWebLockBindListResponseBodyBindList[];
  currentPage?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      bindList: 'BindList',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindList: { 'type': 'array', 'itemType': DescribeWebLockBindListResponseBodyBindList },
      currentPage: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockBindListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWebLockBindListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebLockBindListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockConfigListRequest extends $tea.Model {
  lang?: string;
  sourceIp?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      sourceIp: 'SourceIp',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      sourceIp: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockConfigListResponseBody extends $tea.Model {
  configList?: DescribeWebLockConfigListResponseBodyConfigList[];
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      configList: 'ConfigList',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configList: { 'type': 'array', 'itemType': DescribeWebLockConfigListResponseBodyConfigList },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockConfigListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWebLockConfigListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebLockConfigListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockExclusiveFileTypeResponseBody extends $tea.Model {
  exclusiveFileType?: string[];
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      exclusiveFileType: 'ExclusiveFileType',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exclusiveFileType: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockExclusiveFileTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWebLockExclusiveFileTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebLockExclusiveFileTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockFileChangeStatisticsRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockFileChangeStatisticsResponseBody extends $tea.Model {
  currentPage?: number;
  list?: DescribeWebLockFileChangeStatisticsResponseBodyList[];
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      list: 'List',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      list: { 'type': 'array', 'itemType': DescribeWebLockFileChangeStatisticsResponseBodyList },
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockFileChangeStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWebLockFileChangeStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebLockFileChangeStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockFileEventsRequest extends $tea.Model {
  currentPage?: number;
  dealed?: string;
  pageSize?: number;
  processName?: string;
  remark?: string;
  tsBegin?: number;
  tsEnd?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      dealed: 'Dealed',
      pageSize: 'PageSize',
      processName: 'ProcessName',
      remark: 'Remark',
      tsBegin: 'TsBegin',
      tsEnd: 'TsEnd',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      dealed: 'string',
      pageSize: 'number',
      processName: 'string',
      remark: 'string',
      tsBegin: 'number',
      tsEnd: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockFileEventsResponseBody extends $tea.Model {
  currentPage?: number;
  list?: DescribeWebLockFileEventsResponseBodyList[];
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      list: 'List',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      list: { 'type': 'array', 'itemType': DescribeWebLockFileEventsResponseBodyList },
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockFileEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWebLockFileEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebLockFileEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockFileTypeSummaryResponseBody extends $tea.Model {
  list?: DescribeWebLockFileTypeSummaryResponseBodyList[];
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': DescribeWebLockFileTypeSummaryResponseBodyList },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockFileTypeSummaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWebLockFileTypeSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebLockFileTypeSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockInclusiveFileTypeResponseBody extends $tea.Model {
  inclusiveFileType?: string[];
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      inclusiveFileType: 'InclusiveFileType',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      inclusiveFileType: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockInclusiveFileTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWebLockInclusiveFileTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebLockInclusiveFileTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockProcessBlockStatisticsRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockProcessBlockStatisticsResponseBody extends $tea.Model {
  currentPage?: number;
  list?: DescribeWebLockProcessBlockStatisticsResponseBodyList[];
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      list: 'List',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      list: { 'type': 'array', 'itemType': DescribeWebLockProcessBlockStatisticsResponseBodyList },
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockProcessBlockStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWebLockProcessBlockStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebLockProcessBlockStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockProcessListRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  processName?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      processName: 'ProcessName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      processName: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockProcessListResponseBody extends $tea.Model {
  currentPage?: number;
  list?: DescribeWebLockProcessListResponseBodyList[];
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      list: 'List',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      list: { 'type': 'array', 'itemType': DescribeWebLockProcessListResponseBodyList },
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockProcessListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWebLockProcessListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebLockProcessListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockStatusRequest extends $tea.Model {
  from?: string;
  lang?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      lang: 'Lang',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      lang: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockStatusResponseBody extends $tea.Model {
  authCount?: number;
  bindCount?: number;
  blockCount?: number;
  dirCount?: number;
  expireTime?: number;
  requestId?: string;
  whiteCount?: number;
  static names(): { [key: string]: string } {
    return {
      authCount: 'AuthCount',
      bindCount: 'BindCount',
      blockCount: 'BlockCount',
      dirCount: 'DirCount',
      expireTime: 'ExpireTime',
      requestId: 'RequestId',
      whiteCount: 'WhiteCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authCount: 'number',
      bindCount: 'number',
      blockCount: 'number',
      dirCount: 'number',
      expireTime: 'number',
      requestId: 'string',
      whiteCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWebLockStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebLockStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockTotalFileChangeCountResponseBody extends $tea.Model {
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockTotalFileChangeCountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWebLockTotalFileChangeCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebLockTotalFileChangeCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebPathRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebPathResponseBody extends $tea.Model {
  configList?: DescribeWebPathResponseBodyConfigList[];
  count?: number;
  currentPage?: number;
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      configList: 'ConfigList',
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configList: { 'type': 'array', 'itemType': DescribeWebPathResponseBodyConfigList },
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebPathResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DescribeWebPathResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeWebPathResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableBruteForceRecordRequest extends $tea.Model {
  blockIp?: string;
  bound?: string;
  id?: number;
  port?: string;
  resourceOwnerId?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      blockIp: 'BlockIp',
      bound: 'Bound',
      id: 'Id',
      port: 'Port',
      resourceOwnerId: 'ResourceOwnerId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockIp: 'string',
      bound: 'string',
      id: 'number',
      port: 'string',
      resourceOwnerId: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableBruteForceRecordResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableBruteForceRecordResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DisableBruteForceRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableBruteForceRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableCustomBlockRecordRequest extends $tea.Model {
  blockIp?: string;
  bound?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      blockIp: 'BlockIp',
      bound: 'Bound',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockIp: 'string',
      bound: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableCustomBlockRecordResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DisableCustomBlockRecordResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: DisableCustomBlockRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DisableCustomBlockRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableBruteForceRecordRequest extends $tea.Model {
  blockIp?: string;
  bound?: string;
  id?: number;
  port?: string;
  resourceOwnerId?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      blockIp: 'BlockIp',
      bound: 'Bound',
      id: 'Id',
      port: 'Port',
      resourceOwnerId: 'ResourceOwnerId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockIp: 'string',
      bound: 'string',
      id: 'number',
      port: 'string',
      resourceOwnerId: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableBruteForceRecordResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableBruteForceRecordResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: EnableBruteForceRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableBruteForceRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableCustomBlockRecordRequest extends $tea.Model {
  blockIp?: string;
  bound?: string;
  resourceOwnerId?: number;
  static names(): { [key: string]: string } {
    return {
      blockIp: 'BlockIp',
      bound: 'Bound',
      resourceOwnerId: 'ResourceOwnerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockIp: 'string',
      bound: 'string',
      resourceOwnerId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableCustomBlockRecordResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class EnableCustomBlockRecordResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: EnableCustomBlockRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: EnableCustomBlockRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecStrategyRequest extends $tea.Model {
  lang?: string;
  strategyId?: number;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      strategyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecStrategyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExecStrategyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ExecStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExecStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportRecordRequest extends $tea.Model {
  exportType?: string;
  lang?: string;
  params?: string;
  static names(): { [key: string]: string } {
    return {
      exportType: 'ExportType',
      lang: 'Lang',
      params: 'Params',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exportType: 'string',
      lang: 'string',
      params: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportRecordResponseBody extends $tea.Model {
  fileName?: string;
  id?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      id: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportRecordResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ExportRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportSuspEventsRequest extends $tea.Model {
  assetsTypeList?: string[];
  clusterId?: string;
  containerFieldName?: string;
  containerFieldValue?: string;
  currentPage?: string;
  dealed?: string;
  from?: string;
  id?: number;
  lang?: string;
  levels?: string;
  name?: string;
  operateErrorCodeList?: string[];
  pageSize?: string;
  parentEventTypes?: string;
  remark?: string;
  sourceIp?: string;
  status?: string;
  targetType?: string;
  timeEnd?: string;
  timeStart?: string;
  uniqueInfo?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      assetsTypeList: 'AssetsTypeList',
      clusterId: 'ClusterId',
      containerFieldName: 'ContainerFieldName',
      containerFieldValue: 'ContainerFieldValue',
      currentPage: 'CurrentPage',
      dealed: 'Dealed',
      from: 'From',
      id: 'Id',
      lang: 'Lang',
      levels: 'Levels',
      name: 'Name',
      operateErrorCodeList: 'OperateErrorCodeList',
      pageSize: 'PageSize',
      parentEventTypes: 'ParentEventTypes',
      remark: 'Remark',
      sourceIp: 'SourceIp',
      status: 'Status',
      targetType: 'TargetType',
      timeEnd: 'TimeEnd',
      timeStart: 'TimeStart',
      uniqueInfo: 'UniqueInfo',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetsTypeList: { 'type': 'array', 'itemType': 'string' },
      clusterId: 'string',
      containerFieldName: 'string',
      containerFieldValue: 'string',
      currentPage: 'string',
      dealed: 'string',
      from: 'string',
      id: 'number',
      lang: 'string',
      levels: 'string',
      name: 'string',
      operateErrorCodeList: { 'type': 'array', 'itemType': 'string' },
      pageSize: 'string',
      parentEventTypes: 'string',
      remark: 'string',
      sourceIp: 'string',
      status: 'string',
      targetType: 'string',
      timeEnd: 'string',
      timeStart: 'string',
      uniqueInfo: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportSuspEventsResponseBody extends $tea.Model {
  fileName?: string;
  id?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      id: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportSuspEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ExportSuspEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportSuspEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportVulRequest extends $tea.Model {
  aliasName?: string;
  attachTypes?: string;
  containerName?: string;
  createTsEnd?: number;
  createTsStart?: number;
  cveId?: string;
  dealed?: string;
  groupId?: string;
  imageName?: string;
  lang?: string;
  necessity?: string;
  path?: string;
  searchTags?: string;
  type?: string;
  uuids?: string;
  vpcInstanceIds?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      attachTypes: 'AttachTypes',
      containerName: 'ContainerName',
      createTsEnd: 'CreateTsEnd',
      createTsStart: 'CreateTsStart',
      cveId: 'CveId',
      dealed: 'Dealed',
      groupId: 'GroupId',
      imageName: 'ImageName',
      lang: 'Lang',
      necessity: 'Necessity',
      path: 'Path',
      searchTags: 'SearchTags',
      type: 'Type',
      uuids: 'Uuids',
      vpcInstanceIds: 'VpcInstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      attachTypes: 'string',
      containerName: 'string',
      createTsEnd: 'number',
      createTsStart: 'number',
      cveId: 'string',
      dealed: 'string',
      groupId: 'string',
      imageName: 'string',
      lang: 'string',
      necessity: 'string',
      path: 'string',
      searchTags: 'string',
      type: 'string',
      uuids: 'string',
      vpcInstanceIds: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportVulResponseBody extends $tea.Model {
  fileName?: string;
  id?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      id: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportVulResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ExportVulResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportVulResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportWarningRequest extends $tea.Model {
  dealed?: string;
  exportType?: string;
  isCleartextPwd?: number;
  isSummaryExport?: number;
  lang?: string;
  riskIds?: string;
  riskLevels?: string;
  riskName?: string;
  sourceIp?: string;
  statusList?: string;
  strategyId?: number;
  subTypeNames?: string;
  typeName?: string;
  typeNames?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      dealed: 'Dealed',
      exportType: 'ExportType',
      isCleartextPwd: 'IsCleartextPwd',
      isSummaryExport: 'IsSummaryExport',
      lang: 'Lang',
      riskIds: 'RiskIds',
      riskLevels: 'RiskLevels',
      riskName: 'RiskName',
      sourceIp: 'SourceIp',
      statusList: 'StatusList',
      strategyId: 'StrategyId',
      subTypeNames: 'SubTypeNames',
      typeName: 'TypeName',
      typeNames: 'TypeNames',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dealed: 'string',
      exportType: 'string',
      isCleartextPwd: 'number',
      isSummaryExport: 'number',
      lang: 'string',
      riskIds: 'string',
      riskLevels: 'string',
      riskName: 'string',
      sourceIp: 'string',
      statusList: 'string',
      strategyId: 'number',
      subTypeNames: 'string',
      typeName: 'string',
      typeNames: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportWarningResponseBody extends $tea.Model {
  fileName?: string;
  id?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      fileName: 'FileName',
      id: 'Id',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileName: 'string',
      id: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ExportWarningResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ExportWarningResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ExportWarningResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FindContainerNetworkConnectRequest extends $tea.Model {
  criteriaType?: string;
  currentPage?: number;
  dstNode?: FindContainerNetworkConnectRequestDstNode;
  endTime?: number;
  pageSize?: number;
  srcNode?: FindContainerNetworkConnectRequestSrcNode;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      criteriaType: 'CriteriaType',
      currentPage: 'CurrentPage',
      dstNode: 'DstNode',
      endTime: 'EndTime',
      pageSize: 'PageSize',
      srcNode: 'SrcNode',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteriaType: 'string',
      currentPage: 'number',
      dstNode: FindContainerNetworkConnectRequestDstNode,
      endTime: 'number',
      pageSize: 'number',
      srcNode: FindContainerNetworkConnectRequestSrcNode,
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FindContainerNetworkConnectShrinkRequest extends $tea.Model {
  criteriaType?: string;
  currentPage?: number;
  dstNodeShrink?: string;
  endTime?: number;
  pageSize?: number;
  srcNodeShrink?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      criteriaType: 'CriteriaType',
      currentPage: 'CurrentPage',
      dstNodeShrink: 'DstNode',
      endTime: 'EndTime',
      pageSize: 'PageSize',
      srcNodeShrink: 'SrcNode',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteriaType: 'string',
      currentPage: 'number',
      dstNodeShrink: 'string',
      endTime: 'number',
      pageSize: 'number',
      srcNodeShrink: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FindContainerNetworkConnectResponseBody extends $tea.Model {
  connects?: FindContainerNetworkConnectResponseBodyConnects[];
  pageInfo?: FindContainerNetworkConnectResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      connects: 'Connects',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      connects: { 'type': 'array', 'itemType': FindContainerNetworkConnectResponseBodyConnects },
      pageInfo: FindContainerNetworkConnectResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FindContainerNetworkConnectResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: FindContainerNetworkConnectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: FindContainerNetworkConnectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FixCheckWarningsRequest extends $tea.Model {
  checkParams?: string;
  lang?: string;
  riskId?: number;
  sourceIp?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      checkParams: 'CheckParams',
      lang: 'Lang',
      riskId: 'RiskId',
      sourceIp: 'SourceIp',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkParams: 'string',
      lang: 'string',
      riskId: 'number',
      sourceIp: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FixCheckWarningsResponseBody extends $tea.Model {
  batchId?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      batchId: 'BatchId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FixCheckWarningsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: FixCheckWarningsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: FixCheckWarningsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOnceTaskRequest extends $tea.Model {
  param?: string;
  source?: string;
  taskName?: string;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      param: 'Param',
      source: 'Source',
      taskName: 'TaskName',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      param: 'string',
      source: 'string',
      taskName: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOnceTaskResponseBody extends $tea.Model {
  canCreate?: boolean;
  collectTime?: number;
  finishCount?: number;
  lastTask?: string;
  requestId?: string;
  taskId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      canCreate: 'CanCreate',
      collectTime: 'CollectTime',
      finishCount: 'FinishCount',
      lastTask: 'LastTask',
      requestId: 'RequestId',
      taskId: 'TaskId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canCreate: 'boolean',
      collectTime: 'number',
      finishCount: 'number',
      lastTask: 'string',
      requestId: 'string',
      taskId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GenerateOnceTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GenerateOnceTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GenerateOnceTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAgentlessTaskCountResponseBody extends $tea.Model {
  baselineCheckCount?: number;
  cveVulCount?: number;
  lastTaskTime?: number;
  maliciousFile?: number;
  requestId?: string;
  riskMachine?: number;
  scaVulCount?: number;
  scanMachine?: number;
  sysVulCount?: string;
  vulnerability?: number;
  static names(): { [key: string]: string } {
    return {
      baselineCheckCount: 'BaselineCheckCount',
      cveVulCount: 'CveVulCount',
      lastTaskTime: 'LastTaskTime',
      maliciousFile: 'MaliciousFile',
      requestId: 'RequestId',
      riskMachine: 'RiskMachine',
      scaVulCount: 'ScaVulCount',
      scanMachine: 'ScanMachine',
      sysVulCount: 'SysVulCount',
      vulnerability: 'Vulnerability',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineCheckCount: 'number',
      cveVulCount: 'number',
      lastTaskTime: 'number',
      maliciousFile: 'number',
      requestId: 'string',
      riskMachine: 'number',
      scaVulCount: 'number',
      scanMachine: 'number',
      sysVulCount: 'string',
      vulnerability: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAgentlessTaskCountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetAgentlessTaskCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAgentlessTaskCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlarmMachineCountRequest extends $tea.Model {
  from?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlarmMachineCountResponseBody extends $tea.Model {
  data?: GetAlarmMachineCountResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetAlarmMachineCountResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlarmMachineCountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetAlarmMachineCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAlarmMachineCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppNetworkRequest extends $tea.Model {
  clusterId?: string;
  endTime?: number;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      endTime: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppNetworkResponseBody extends $tea.Model {
  appNetwork?: GetAppNetworkResponseBodyAppNetwork;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      appNetwork: 'AppNetwork',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appNetwork: GetAppNetworkResponseBodyAppNetwork,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppNetworkResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetAppNetworkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAppNetworkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetDetailByUuidRequest extends $tea.Model {
  lang?: string;
  sourceIp?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      sourceIp: 'SourceIp',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      sourceIp: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetDetailByUuidResponseBody extends $tea.Model {
  assetDetail?: GetAssetDetailByUuidResponseBodyAssetDetail;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      assetDetail: 'AssetDetail',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetDetail: GetAssetDetailByUuidResponseBodyAssetDetail,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetDetailByUuidResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetAssetDetailByUuidResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAssetDetailByUuidResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetSelectionConfigRequest extends $tea.Model {
  businessType?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetSelectionConfigResponseBody extends $tea.Model {
  data?: GetAssetSelectionConfigResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetAssetSelectionConfigResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetSelectionConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetAssetSelectionConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAssetSelectionConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetsPropertyDetailRequest extends $tea.Model {
  biz?: string;
  currentPage?: number;
  itemName?: string;
  lang?: string;
  pageSize?: number;
  remark?: string;
  searchCriteriaList?: GetAssetsPropertyDetailRequestSearchCriteriaList[];
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      biz: 'Biz',
      currentPage: 'CurrentPage',
      itemName: 'ItemName',
      lang: 'Lang',
      pageSize: 'PageSize',
      remark: 'Remark',
      searchCriteriaList: 'SearchCriteriaList',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      biz: 'string',
      currentPage: 'number',
      itemName: 'string',
      lang: 'string',
      pageSize: 'number',
      remark: 'string',
      searchCriteriaList: { 'type': 'array', 'itemType': GetAssetsPropertyDetailRequestSearchCriteriaList },
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetsPropertyDetailResponseBody extends $tea.Model {
  pageInfo?: GetAssetsPropertyDetailResponseBodyPageInfo;
  propertys?: GetAssetsPropertyDetailResponseBodyPropertys[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertys: 'Propertys',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: GetAssetsPropertyDetailResponseBodyPageInfo,
      propertys: { 'type': 'array', 'itemType': GetAssetsPropertyDetailResponseBodyPropertys },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetsPropertyDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetAssetsPropertyDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAssetsPropertyDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetsPropertyItemRequest extends $tea.Model {
  biz?: string;
  currentPage?: number;
  forceFlush?: boolean;
  lang?: string;
  pageSize?: number;
  searchInfo?: string;
  searchItem?: string;
  static names(): { [key: string]: string } {
    return {
      biz: 'Biz',
      currentPage: 'CurrentPage',
      forceFlush: 'ForceFlush',
      lang: 'Lang',
      pageSize: 'PageSize',
      searchInfo: 'SearchInfo',
      searchItem: 'SearchItem',
    };
  }

  static types(): { [key: string]: any } {
    return {
      biz: 'string',
      currentPage: 'number',
      forceFlush: 'boolean',
      lang: 'string',
      pageSize: 'number',
      searchInfo: 'string',
      searchItem: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetsPropertyItemResponseBody extends $tea.Model {
  pageInfo?: GetAssetsPropertyItemResponseBodyPageInfo;
  propertyItems?: GetAssetsPropertyItemResponseBodyPropertyItems[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      propertyItems: 'PropertyItems',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: GetAssetsPropertyItemResponseBodyPageInfo,
      propertyItems: { 'type': 'array', 'itemType': GetAssetsPropertyItemResponseBodyPropertyItems },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetsPropertyItemResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetAssetsPropertyItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAssetsPropertyItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthVersionStatisticResponseBody extends $tea.Model {
  requestId?: string;
  statistics?: GetAuthVersionStatisticResponseBodyStatistics[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      statistics: 'Statistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      statistics: { 'type': 'array', 'itemType': GetAuthVersionStatisticResponseBodyStatistics },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthVersionStatisticResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetAuthVersionStatisticResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAuthVersionStatisticResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBackupStorageCountResponseBody extends $tea.Model {
  backupStorageCount?: GetBackupStorageCountResponseBodyBackupStorageCount;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      backupStorageCount: 'BackupStorageCount',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      backupStorageCount: GetBackupStorageCountResponseBodyBackupStorageCount,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBackupStorageCountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetBackupStorageCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetBackupStorageCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckConfigResponseBody extends $tea.Model {
  cycleDays?: number[];
  enableAddCheck?: boolean;
  enableAutoCheck?: boolean;
  endTime?: number;
  requestId?: string;
  selectedChecks?: GetCheckConfigResponseBodySelectedChecks[];
  standards?: GetCheckConfigResponseBodyStandards[];
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      cycleDays: 'CycleDays',
      enableAddCheck: 'EnableAddCheck',
      enableAutoCheck: 'EnableAutoCheck',
      endTime: 'EndTime',
      requestId: 'RequestId',
      selectedChecks: 'SelectedChecks',
      standards: 'Standards',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycleDays: { 'type': 'array', 'itemType': 'number' },
      enableAddCheck: 'boolean',
      enableAutoCheck: 'boolean',
      endTime: 'number',
      requestId: 'string',
      selectedChecks: { 'type': 'array', 'itemType': GetCheckConfigResponseBodySelectedChecks },
      standards: { 'type': 'array', 'itemType': GetCheckConfigResponseBodyStandards },
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetCheckConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCheckConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckDetailRequest extends $tea.Model {
  checkId?: number;
  lang?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      lang: 'Lang',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      lang: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckDetailResponseBody extends $tea.Model {
  assistInfo?: GetCheckDetailResponseBodyAssistInfo;
  customConfigs?: GetCheckDetailResponseBodyCustomConfigs[];
  description?: GetCheckDetailResponseBodyDescription;
  requestId?: string;
  solution?: GetCheckDetailResponseBodySolution;
  static names(): { [key: string]: string } {
    return {
      assistInfo: 'AssistInfo',
      customConfigs: 'CustomConfigs',
      description: 'Description',
      requestId: 'RequestId',
      solution: 'Solution',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assistInfo: GetCheckDetailResponseBodyAssistInfo,
      customConfigs: { 'type': 'array', 'itemType': GetCheckDetailResponseBodyCustomConfigs },
      description: GetCheckDetailResponseBodyDescription,
      requestId: 'string',
      solution: GetCheckDetailResponseBodySolution,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetCheckDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCheckDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckProcessRequest extends $tea.Model {
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckProcessResponseBody extends $tea.Model {
  finishCount?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      finishCount: 'FinishCount',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      finishCount: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckProcessResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetCheckProcessResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCheckProcessResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRiskStatisticsRequest extends $tea.Model {
  currentPage?: number;
  lang?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      lang: 'Lang',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      lang: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRiskStatisticsResponseBody extends $tea.Model {
  count?: number;
  data?: GetCheckRiskStatisticsResponseBodyData[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      data: { 'type': 'array', 'itemType': GetCheckRiskStatisticsResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRiskStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetCheckRiskStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCheckRiskStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckSaleRequest extends $tea.Model {
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckSaleResponseBody extends $tea.Model {
  checkSale?: GetCheckSaleResponseBodyCheckSale;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      checkSale: 'CheckSale',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkSale: GetCheckSaleResponseBodyCheckSale,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckSaleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetCheckSaleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCheckSaleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckSummaryRequest extends $tea.Model {
  lang?: string;
  resourceDirectoryAccountId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      resourceDirectoryAccountId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckSummaryResponseBody extends $tea.Model {
  requestId?: string;
  summarys?: GetCheckSummaryResponseBodySummarys[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      summarys: 'Summarys',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      summarys: { 'type': 'array', 'itemType': GetCheckSummaryResponseBodySummarys },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckSummaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetCheckSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCheckSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientInstallationStatisticRequest extends $tea.Model {
  timeEnd?: number;
  timeStart?: number;
  static names(): { [key: string]: string } {
    return {
      timeEnd: 'TimeEnd',
      timeStart: 'TimeStart',
    };
  }

  static types(): { [key: string]: any } {
    return {
      timeEnd: 'number',
      timeStart: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientInstallationStatisticResponseBody extends $tea.Model {
  clientInstallRatio?: GetClientInstallationStatisticResponseBodyClientInstallRatio;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clientInstallRatio: 'ClientInstallRatio',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientInstallRatio: GetClientInstallationStatisticResponseBodyClientInstallRatio,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientInstallationStatisticResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetClientInstallationStatisticResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClientInstallationStatisticResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientRatioStatisticRequest extends $tea.Model {
  resourceDirectoryAccountId?: number;
  statisticTypes?: string[];
  timeEnd?: number;
  timeStart?: number;
  static names(): { [key: string]: string } {
    return {
      resourceDirectoryAccountId: 'ResourceDirectoryAccountId',
      statisticTypes: 'StatisticTypes',
      timeEnd: 'TimeEnd',
      timeStart: 'TimeStart',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceDirectoryAccountId: 'number',
      statisticTypes: { 'type': 'array', 'itemType': 'string' },
      timeEnd: 'number',
      timeStart: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientRatioStatisticResponseBody extends $tea.Model {
  clientInstallRatio?: GetClientRatioStatisticResponseBodyClientInstallRatio;
  clientOnlineRatio?: GetClientRatioStatisticResponseBodyClientOnlineRatio;
  dates?: number[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clientInstallRatio: 'ClientInstallRatio',
      clientOnlineRatio: 'ClientOnlineRatio',
      dates: 'Dates',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientInstallRatio: GetClientRatioStatisticResponseBodyClientInstallRatio,
      clientOnlineRatio: GetClientRatioStatisticResponseBodyClientOnlineRatio,
      dates: { 'type': 'array', 'itemType': 'number' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientRatioStatisticResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetClientRatioStatisticResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClientRatioStatisticResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientUserDefineRuleRequest extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientUserDefineRuleResponseBody extends $tea.Model {
  requestId?: string;
  userDefineRuleDetail?: GetClientUserDefineRuleResponseBodyUserDefineRuleDetail;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      userDefineRuleDetail: 'UserDefineRuleDetail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      userDefineRuleDetail: GetClientUserDefineRuleResponseBodyUserDefineRuleDetail,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientUserDefineRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetClientUserDefineRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClientUserDefineRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetCriteriaRequest extends $tea.Model {
  cloudAssetTypes?: GetCloudAssetCriteriaRequestCloudAssetTypes[];
  value?: string;
  static names(): { [key: string]: string } {
    return {
      cloudAssetTypes: 'CloudAssetTypes',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cloudAssetTypes: { 'type': 'array', 'itemType': GetCloudAssetCriteriaRequestCloudAssetTypes },
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetCriteriaResponseBody extends $tea.Model {
  criteriaList?: GetCloudAssetCriteriaResponseBodyCriteriaList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      criteriaList: 'CriteriaList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      criteriaList: { 'type': 'array', 'itemType': GetCloudAssetCriteriaResponseBodyCriteriaList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetCriteriaResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetCloudAssetCriteriaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCloudAssetCriteriaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetDetailRequest extends $tea.Model {
  assetSubType?: number;
  assetType?: number;
  cloudAssetInstances?: GetCloudAssetDetailRequestCloudAssetInstances[];
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      assetSubType: 'AssetSubType',
      assetType: 'AssetType',
      cloudAssetInstances: 'CloudAssetInstances',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetSubType: 'number',
      assetType: 'number',
      cloudAssetInstances: { 'type': 'array', 'itemType': GetCloudAssetDetailRequestCloudAssetInstances },
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetDetailResponseBody extends $tea.Model {
  count?: number;
  instances?: GetCloudAssetDetailResponseBodyInstances[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      instances: 'Instances',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      instances: { 'type': 'array', 'itemType': GetCloudAssetDetailResponseBodyInstances },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetCloudAssetDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCloudAssetDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetSummaryResponseBody extends $tea.Model {
  groupedFields?: GetCloudAssetSummaryResponseBodyGroupedFields;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupedFields: 'GroupedFields',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupedFields: GetCloudAssetSummaryResponseBodyGroupedFields,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetSummaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetCloudAssetSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCloudAssetSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterCheckItemWarningStatisticsRequest extends $tea.Model {
  clusterId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterCheckItemWarningStatisticsResponseBody extends $tea.Model {
  data?: GetClusterCheckItemWarningStatisticsResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetClusterCheckItemWarningStatisticsResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterCheckItemWarningStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetClusterCheckItemWarningStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClusterCheckItemWarningStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterRuleSummaryRequest extends $tea.Model {
  clusterId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterRuleSummaryResponseBody extends $tea.Model {
  clusterRuleSummary?: GetClusterRuleSummaryResponseBodyClusterRuleSummary;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterRuleSummary: 'ClusterRuleSummary',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterRuleSummary: GetClusterRuleSummaryResponseBodyClusterRuleSummary,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterRuleSummaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetClusterRuleSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClusterRuleSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterSuspEventStatisticsRequest extends $tea.Model {
  clusterId?: string;
  from?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      from: 'From',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      from: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterSuspEventStatisticsResponseBody extends $tea.Model {
  requestId?: string;
  suspStatistics?: GetClusterSuspEventStatisticsResponseBodySuspStatistics;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      suspStatistics: 'SuspStatistics',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      suspStatistics: GetClusterSuspEventStatisticsResponseBodySuspStatistics,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterSuspEventStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetClusterSuspEventStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetClusterSuspEventStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCommonSwitchConfigRequest extends $tea.Model {
  type?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCommonSwitchConfigResponseBody extends $tea.Model {
  data?: GetCommonSwitchConfigResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetCommonSwitchConfigResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCommonSwitchConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetCommonSwitchConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetCommonSwitchConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetContainerDefenseRuleDetailRequest extends $tea.Model {
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetContainerDefenseRuleDetailResponseBody extends $tea.Model {
  code?: string;
  data?: GetContainerDefenseRuleDetailResponseBodyData;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetContainerDefenseRuleDetailResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetContainerDefenseRuleDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetContainerDefenseRuleDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetContainerDefenseRuleDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDetectApiInvokeInfoResponseBody extends $tea.Model {
  data?: GetFileDetectApiInvokeInfoResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetFileDetectApiInvokeInfoResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDetectApiInvokeInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetFileDetectApiInvokeInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileDetectApiInvokeInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDetectReportRequest extends $tea.Model {
  eventId?: number;
  field?: string;
  fileHash?: string;
  lang?: string;
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      eventId: 'EventId',
      field: 'Field',
      fileHash: 'FileHash',
      lang: 'Lang',
      sourceType: 'SourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventId: 'number',
      field: 'string',
      fileHash: 'string',
      lang: 'string',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDetectReportResponseBody extends $tea.Model {
  code?: string;
  data?: GetFileDetectReportResponseBodyData;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetFileDetectReportResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDetectReportResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetFileDetectReportResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileDetectReportResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDetectResultRequest extends $tea.Model {
  hashKeyList?: string[];
  sourceIp?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      hashKeyList: 'HashKeyList',
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hashKeyList: { 'type': 'array', 'itemType': 'string' },
      sourceIp: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDetectResultResponseBody extends $tea.Model {
  requestId?: string;
  resultList?: GetFileDetectResultResponseBodyResultList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      resultList: 'ResultList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      resultList: { 'type': 'array', 'itemType': GetFileDetectResultResponseBodyResultList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDetectResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetFileDetectResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileDetectResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectDashboardResponseBody extends $tea.Model {
  data?: GetFileProtectDashboardResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetFileProtectDashboardResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectDashboardResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetFileProtectDashboardResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileProtectDashboardResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectEventRequest extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectEventResponseBody extends $tea.Model {
  data?: GetFileProtectEventResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetFileProtectEventResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectEventResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetFileProtectEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileProtectEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectEventCountRequest extends $tea.Model {
  status?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectEventCountResponseBody extends $tea.Model {
  data?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectEventCountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetFileProtectEventCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileProtectEventCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectRuleRequest extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectRuleResponseBody extends $tea.Model {
  data?: GetFileProtectRuleResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetFileProtectRuleResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetFileProtectRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileProtectRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileUploadLimitResponseBody extends $tea.Model {
  data?: GetFileUploadLimitResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetFileUploadLimitResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileUploadLimitResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetFileUploadLimitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetFileUploadLimitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotAttackStatisticsRequest extends $tea.Model {
  currentPage?: number;
  endTimeStamp?: number;
  lang?: string;
  pageSize?: number;
  riskLevelList?: string[];
  srcIp?: string;
  startTimeStamp?: number;
  statisticsType?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTimeStamp: 'EndTimeStamp',
      lang: 'Lang',
      pageSize: 'PageSize',
      riskLevelList: 'RiskLevelList',
      srcIp: 'SrcIp',
      startTimeStamp: 'StartTimeStamp',
      statisticsType: 'StatisticsType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTimeStamp: 'number',
      lang: 'string',
      pageSize: 'number',
      riskLevelList: { 'type': 'array', 'itemType': 'string' },
      srcIp: 'string',
      startTimeStamp: 'number',
      statisticsType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotAttackStatisticsResponseBody extends $tea.Model {
  code?: string;
  data?: GetHoneypotAttackStatisticsResponseBodyData;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetHoneypotAttackStatisticsResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotAttackStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetHoneypotAttackStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetHoneypotAttackStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotEventTrendRequest extends $tea.Model {
  endTimeStamp?: number;
  lang?: string;
  riskLevelList?: string[];
  srcIp?: string;
  startTimeStamp?: number;
  static names(): { [key: string]: string } {
    return {
      endTimeStamp: 'EndTimeStamp',
      lang: 'Lang',
      riskLevelList: 'RiskLevelList',
      srcIp: 'SrcIp',
      startTimeStamp: 'StartTimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTimeStamp: 'number',
      lang: 'string',
      riskLevelList: { 'type': 'array', 'itemType': 'string' },
      srcIp: 'string',
      startTimeStamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotEventTrendResponseBody extends $tea.Model {
  code?: string;
  count?: number;
  data?: GetHoneypotEventTrendResponseBodyData[];
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'number',
      data: { 'type': 'array', 'itemType': GetHoneypotEventTrendResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotEventTrendResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetHoneypotEventTrendResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetHoneypotEventTrendResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotNodeRequest extends $tea.Model {
  lang?: string;
  nodeId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      nodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotNodeResponseBody extends $tea.Model {
  code?: string;
  honeypotNode?: GetHoneypotNodeResponseBodyHoneypotNode;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      honeypotNode: 'HoneypotNode',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      honeypotNode: GetHoneypotNodeResponseBodyHoneypotNode,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotNodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetHoneypotNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetHoneypotNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotNodeMetricListRequest extends $tea.Model {
  endTime?: string;
  express?: string;
  length?: string;
  metricName?: string;
  namespace?: string;
  nodeId?: string;
  period?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      express: 'Express',
      length: 'Length',
      metricName: 'MetricName',
      namespace: 'Namespace',
      nodeId: 'NodeId',
      period: 'Period',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'string',
      express: 'string',
      length: 'string',
      metricName: 'string',
      namespace: 'string',
      nodeId: 'string',
      period: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotNodeMetricListResponseBody extends $tea.Model {
  data?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotNodeMetricListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetHoneypotNodeMetricListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetHoneypotNodeMetricListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotPresetRequest extends $tea.Model {
  honeypotPresetId?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      honeypotPresetId: 'HoneypotPresetId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeypotPresetId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotPresetResponseBody extends $tea.Model {
  code?: string;
  data?: GetHoneypotPresetResponseBodyData;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetHoneypotPresetResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotPresetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetHoneypotPresetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetHoneypotPresetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotProbeRequest extends $tea.Model {
  lang?: string;
  probeId?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      probeId: 'ProbeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      probeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotProbeResponseBody extends $tea.Model {
  code?: string;
  data?: GetHoneypotProbeResponseBodyData;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetHoneypotProbeResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotProbeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetHoneypotProbeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetHoneypotProbeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotStatisticsRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotStatisticsResponseBody extends $tea.Model {
  code?: string;
  data?: GetHoneypotStatisticsResponseBodyData;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetHoneypotStatisticsResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetHoneypotStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetHoneypotStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageEventOperationRequest extends $tea.Model {
  id?: number;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageEventOperationResponseBody extends $tea.Model {
  code?: string;
  data?: GetImageEventOperationResponseBodyData;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetImageEventOperationResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageEventOperationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetImageEventOperationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetImageEventOperationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageScanNumInPeriodRequest extends $tea.Model {
  pastDay?: string;
  static names(): { [key: string]: string } {
    return {
      pastDay: 'PastDay',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pastDay: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageScanNumInPeriodResponseBody extends $tea.Model {
  imageScanData?: GetImageScanNumInPeriodResponseBodyImageScanData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      imageScanData: 'ImageScanData',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageScanData: GetImageScanNumInPeriodResponseBodyImageScanData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageScanNumInPeriodResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetImageScanNumInPeriodResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetImageScanNumInPeriodResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionRuleDetailRequest extends $tea.Model {
  clusterId?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionRuleDetailResponseBody extends $tea.Model {
  interceptionRuleDetail?: GetInterceptionRuleDetailResponseBodyInterceptionRuleDetail;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      interceptionRuleDetail: 'InterceptionRuleDetail',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interceptionRuleDetail: GetInterceptionRuleDetailResponseBodyInterceptionRuleDetail,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionRuleDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetInterceptionRuleDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInterceptionRuleDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionSummaryRequest extends $tea.Model {
  clusterId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionSummaryResponseBody extends $tea.Model {
  interceptionSummary?: GetInterceptionSummaryResponseBodyInterceptionSummary;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      interceptionSummary: 'InterceptionSummary',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interceptionSummary: GetInterceptionSummaryResponseBodyInterceptionSummary,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionSummaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetInterceptionSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInterceptionSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionTargetDetailRequest extends $tea.Model {
  targetId?: number;
  static names(): { [key: string]: string } {
    return {
      targetId: 'TargetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionTargetDetailResponseBody extends $tea.Model {
  requestId?: string;
  ruleTarget?: GetInterceptionTargetDetailResponseBodyRuleTarget;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      ruleTarget: 'RuleTarget',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      ruleTarget: GetInterceptionTargetDetailResponseBodyRuleTarget,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionTargetDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetInterceptionTargetDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetInterceptionTargetDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLastOnceTaskInfoRequest extends $tea.Model {
  source?: string;
  taskName?: string;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      source: 'Source',
      taskName: 'TaskName',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      source: 'string',
      taskName: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLastOnceTaskInfoResponseBody extends $tea.Model {
  collectTime?: number;
  finishCount?: number;
  requestId?: string;
  taskId?: number;
  taskInfo?: GetLastOnceTaskInfoResponseBodyTaskInfo;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      collectTime: 'CollectTime',
      finishCount: 'FinishCount',
      requestId: 'RequestId',
      taskId: 'TaskId',
      taskInfo: 'TaskInfo',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      collectTime: 'number',
      finishCount: 'number',
      requestId: 'string',
      taskId: 'number',
      taskInfo: GetLastOnceTaskInfoResponseBodyTaskInfo,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLastOnceTaskInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetLastOnceTaskInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetLastOnceTaskInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogMetaRequest extends $tea.Model {
  logStore?: string;
  static names(): { [key: string]: string } {
    return {
      logStore: 'LogStore',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logStore: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogMetaResponseBody extends $tea.Model {
  logMeta?: GetLogMetaResponseBodyLogMeta;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      logMeta: 'LogMeta',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logMeta: GetLogMetaResponseBodyLogMeta,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogMetaResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetLogMetaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetLogMetaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetModuleConfigRequest extends $tea.Model {
  currentPage?: string;
  pageSize?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'string',
      pageSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetModuleConfigResponseBody extends $tea.Model {
  httpStatusCode?: number;
  moduleConfigList?: GetModuleConfigResponseBodyModuleConfigList[];
  pageInfo?: GetModuleConfigResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      httpStatusCode: 'HttpStatusCode',
      moduleConfigList: 'ModuleConfigList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      httpStatusCode: 'number',
      moduleConfigList: { 'type': 'array', 'itemType': GetModuleConfigResponseBodyModuleConfigList },
      pageInfo: GetModuleConfigResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetModuleConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetModuleConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetModuleConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetModuleTrialAuthInfoRequest extends $tea.Model {
  lang?: string;
  moduleCode?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      moduleCode: 'ModuleCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      moduleCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetModuleTrialAuthInfoResponseBody extends $tea.Model {
  data?: GetModuleTrialAuthInfoResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetModuleTrialAuthInfoResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetModuleTrialAuthInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetModuleTrialAuthInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetModuleTrialAuthInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetObjectScanEventRequest extends $tea.Model {
  eventId?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      eventId: 'EventId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetObjectScanEventResponseBody extends $tea.Model {
  data?: GetObjectScanEventResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetObjectScanEventResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetObjectScanEventResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetObjectScanEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetObjectScanEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnceTaskResultInfoRequest extends $tea.Model {
  taskId?: string;
  taskName?: string;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
      taskName: 'TaskName',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
      taskName: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnceTaskResultInfoResponseBody extends $tea.Model {
  collectTime?: number;
  finishCount?: number;
  requestId?: string;
  taskId?: number;
  taskInfo?: GetOnceTaskResultInfoResponseBodyTaskInfo;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      collectTime: 'CollectTime',
      finishCount: 'FinishCount',
      requestId: 'RequestId',
      taskId: 'TaskId',
      taskInfo: 'TaskInfo',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      collectTime: 'number',
      finishCount: 'number',
      requestId: 'string',
      taskId: 'number',
      taskInfo: GetOnceTaskResultInfoResponseBodyTaskInfo,
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnceTaskResultInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetOnceTaskResultInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOnceTaskResultInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterBaseLineListResponseBody extends $tea.Model {
  code?: string;
  data?: GetOpaClusterBaseLineListResponseBodyData[];
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': GetOpaClusterBaseLineListResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterBaseLineListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetOpaClusterBaseLineListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOpaClusterBaseLineListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterImageListRequest extends $tea.Model {
  clusterId?: string;
  currentPage?: number;
  imageName?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      currentPage: 'CurrentPage',
      imageName: 'ImageName',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      currentPage: 'number',
      imageName: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterImageListResponseBody extends $tea.Model {
  code?: string;
  count?: number;
  data?: GetOpaClusterImageListResponseBodyData[];
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'number',
      data: { 'type': 'array', 'itemType': GetOpaClusterImageListResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterImageListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetOpaClusterImageListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOpaClusterImageListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterLabelListRequest extends $tea.Model {
  clusterId?: string;
  currentPage?: number;
  pageSize?: number;
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      tagName: 'TagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      currentPage: 'number',
      pageSize: 'number',
      tagName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterLabelListResponseBody extends $tea.Model {
  code?: string;
  count?: number;
  data?: GetOpaClusterLabelListResponseBodyData[];
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'number',
      data: { 'type': 'array', 'itemType': GetOpaClusterLabelListResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterLabelListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetOpaClusterLabelListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOpaClusterLabelListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterNamespaceListRequest extends $tea.Model {
  clusterId?: string;
  currentPage?: number;
  nameSpaceName?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      currentPage: 'CurrentPage',
      nameSpaceName: 'NameSpaceName',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      currentPage: 'number',
      nameSpaceName: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterNamespaceListResponseBody extends $tea.Model {
  code?: string;
  count?: number;
  data?: GetOpaClusterNamespaceListResponseBodyData[];
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'number',
      data: { 'type': 'array', 'itemType': GetOpaClusterNamespaceListResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterNamespaceListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetOpaClusterNamespaceListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOpaClusterNamespaceListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaPluginStatusRequest extends $tea.Model {
  clusterIds?: string[];
  static names(): { [key: string]: string } {
    return {
      clusterIds: 'ClusterIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaPluginStatusResponseBody extends $tea.Model {
  installStatus?: GetOpaPluginStatusResponseBodyInstallStatus[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      installStatus: 'InstallStatus',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      installStatus: { 'type': 'array', 'itemType': GetOpaPluginStatusResponseBodyInstallStatus },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaPluginStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetOpaPluginStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOpaPluginStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaStrategyTemplateSummaryResponseBody extends $tea.Model {
  code?: string;
  data?: GetOpaStrategyTemplateSummaryResponseBodyData[];
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': GetOpaStrategyTemplateSummaryResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaStrategyTemplateSummaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetOpaStrategyTemplateSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOpaStrategyTemplateSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOssBucketScanStatisticRequest extends $tea.Model {
  bucketNameList?: string[];
  static names(): { [key: string]: string } {
    return {
      bucketNameList: 'BucketNameList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketNameList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOssBucketScanStatisticResponseBody extends $tea.Model {
  data?: GetOssBucketScanStatisticResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetOssBucketScanStatisticResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOssBucketScanStatisticResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetOssBucketScanStatisticResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOssBucketScanStatisticResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOssScanConfigResponseBody extends $tea.Model {
  data?: GetOssScanConfigResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetOssScanConfigResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOssScanConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetOssScanConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOssScanConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPropertyScheduleConfigRequest extends $tea.Model {
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPropertyScheduleConfigResponseBody extends $tea.Model {
  propertyScheduleConfig?: GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      propertyScheduleConfig: 'PropertyScheduleConfig',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      propertyScheduleConfig: GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPropertyScheduleConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetPropertyScheduleConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetPropertyScheduleConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRulesCountResponseBody extends $tea.Model {
  requestId?: string;
  totalSystemClientRuleCount?: number;
  totalUserDefineRuleCount?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      totalSystemClientRuleCount: 'TotalSystemClientRuleCount',
      totalUserDefineRuleCount: 'TotalUserDefineRuleCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      totalSystemClientRuleCount: 'number',
      totalUserDefineRuleCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetRulesCountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetRulesCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetRulesCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSecurityScoreRuleRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSecurityScoreRuleResponseBody extends $tea.Model {
  enableStatus?: boolean;
  requestId?: string;
  securityScoreRuleList?: GetSecurityScoreRuleResponseBodySecurityScoreRuleList[];
  static names(): { [key: string]: string } {
    return {
      enableStatus: 'EnableStatus',
      requestId: 'RequestId',
      securityScoreRuleList: 'SecurityScoreRuleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableStatus: 'boolean',
      requestId: 'string',
      securityScoreRuleList: { 'type': 'array', 'itemType': GetSecurityScoreRuleResponseBodySecurityScoreRuleList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSecurityScoreRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetSecurityScoreRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSecurityScoreRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSensitiveDefineRuleConfigRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSensitiveDefineRuleConfigResponseBody extends $tea.Model {
  code?: string;
  data?: GetSensitiveDefineRuleConfigResponseBodyData;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetSensitiveDefineRuleConfigResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSensitiveDefineRuleConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetSensitiveDefineRuleConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSensitiveDefineRuleConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceTrailRequest extends $tea.Model {
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceTrailResponseBody extends $tea.Model {
  requestId?: string;
  serviceTrail?: GetServiceTrailResponseBodyServiceTrail;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      serviceTrail: 'ServiceTrail',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      serviceTrail: GetServiceTrailResponseBodyServiceTrail,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceTrailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetServiceTrailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetServiceTrailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStrategyTemplateDetailRequest extends $tea.Model {
  strategyId?: number;
  static names(): { [key: string]: string } {
    return {
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      strategyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStrategyTemplateDetailResponseBody extends $tea.Model {
  code?: string;
  data?: GetStrategyTemplateDetailResponseBodyData;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: GetStrategyTemplateDetailResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStrategyTemplateDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetStrategyTemplateDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetStrategyTemplateDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSuspiciousStatisticsRequest extends $tea.Model {
  groupIdList?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      groupIdList: 'GroupIdList',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupIdList: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSuspiciousStatisticsResponseBody extends $tea.Model {
  remindCount?: number;
  requestId?: string;
  seriousCount?: number;
  suspiciousCount?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      remindCount: 'RemindCount',
      requestId: 'RequestId',
      seriousCount: 'SeriousCount',
      suspiciousCount: 'SuspiciousCount',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      remindCount: 'number',
      requestId: 'string',
      seriousCount: 'number',
      suspiciousCount: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSuspiciousStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetSuspiciousStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSuspiciousStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSwitchRegionDetailRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSwitchRegionDetailResponseBody extends $tea.Model {
  data?: GetSwitchRegionDetailResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetSwitchRegionDetailResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSwitchRegionDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetSwitchRegionDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetSwitchRegionDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLangResponseBody extends $tea.Model {
  requestId?: string;
  sasUserLang?: GetUserLangResponseBodySasUserLang;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      sasUserLang: 'SasUserLang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      sasUserLang: GetUserLangResponseBodySasUserLang,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLangResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetUserLangResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetUserLangResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVirusScanConfigRequest extends $tea.Model {
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVirusScanConfigResponseBody extends $tea.Model {
  data?: GetVirusScanConfigResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetVirusScanConfigResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVirusScanConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetVirusScanConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetVirusScanConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVirusScanLatestTaskStatisticResponseBody extends $tea.Model {
  data?: GetVirusScanLatestTaskStatisticResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: GetVirusScanLatestTaskStatisticResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVirusScanLatestTaskStatisticResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetVirusScanLatestTaskStatisticResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetVirusScanLatestTaskStatisticResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVulStatisticsRequest extends $tea.Model {
  groupIdList?: string;
  sourceIp?: string;
  typeList?: string;
  static names(): { [key: string]: string } {
    return {
      groupIdList: 'GroupIdList',
      sourceIp: 'SourceIp',
      typeList: 'TypeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupIdList: 'string',
      sourceIp: 'string',
      typeList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVulStatisticsResponseBody extends $tea.Model {
  requestId?: string;
  vulAsapSum?: number;
  vulLaterSum?: number;
  vulNntfSum?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vulAsapSum: 'VulAsapSum',
      vulLaterSum: 'VulLaterSum',
      vulNntfSum: 'VulNntfSum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vulAsapSum: 'number',
      vulLaterSum: 'number',
      vulNntfSum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVulStatisticsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetVulStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetVulStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVulWhitelistRequest extends $tea.Model {
  vulWhitelistId?: number;
  static names(): { [key: string]: string } {
    return {
      vulWhitelistId: 'VulWhitelistId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vulWhitelistId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVulWhitelistResponseBody extends $tea.Model {
  requestId?: string;
  vulWhitelist?: GetVulWhitelistResponseBodyVulWhitelist;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vulWhitelist: 'VulWhitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vulWhitelist: GetVulWhitelistResponseBodyVulWhitelist,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVulWhitelistResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: GetVulWhitelistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetVulWhitelistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HandleSecurityEventsRequest extends $tea.Model {
  markBatch?: string;
  markMissParam?: string;
  operationCode?: string;
  operationParams?: string;
  remark?: string;
  securityEventIds?: string[];
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      markBatch: 'MarkBatch',
      markMissParam: 'MarkMissParam',
      operationCode: 'OperationCode',
      operationParams: 'OperationParams',
      remark: 'Remark',
      securityEventIds: 'SecurityEventIds',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      markBatch: 'string',
      markMissParam: 'string',
      operationCode: 'string',
      operationParams: 'string',
      remark: 'string',
      securityEventIds: { 'type': 'array', 'itemType': 'string' },
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HandleSecurityEventsResponseBody extends $tea.Model {
  handleSecurityEventsResponse?: HandleSecurityEventsResponseBodyHandleSecurityEventsResponse;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      handleSecurityEventsResponse: 'HandleSecurityEventsResponse',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      handleSecurityEventsResponse: HandleSecurityEventsResponseBodyHandleSecurityEventsResponse,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HandleSecurityEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: HandleSecurityEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: HandleSecurityEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HandleSimilarSecurityEventsRequest extends $tea.Model {
  markMissParam?: string;
  operationCode?: string;
  operationParams?: string;
  remark?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      markMissParam: 'MarkMissParam',
      operationCode: 'OperationCode',
      operationParams: 'OperationParams',
      remark: 'Remark',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      markMissParam: 'string',
      operationCode: 'string',
      operationParams: 'string',
      remark: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HandleSimilarSecurityEventsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HandleSimilarSecurityEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: HandleSimilarSecurityEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: HandleSimilarSecurityEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class IgnoreCheckItemsRequest extends $tea.Model {
  checkAndRiskTypeList?: IgnoreCheckItemsRequestCheckAndRiskTypeList[];
  lang?: string;
  reason?: string;
  source?: string;
  type?: number;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      checkAndRiskTypeList: 'CheckAndRiskTypeList',
      lang: 'Lang',
      reason: 'Reason',
      source: 'Source',
      type: 'Type',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkAndRiskTypeList: { 'type': 'array', 'itemType': IgnoreCheckItemsRequestCheckAndRiskTypeList },
      lang: 'string',
      reason: 'string',
      source: 'string',
      type: 'number',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class IgnoreCheckItemsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class IgnoreCheckItemsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: IgnoreCheckItemsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: IgnoreCheckItemsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class IgnoreHcCheckWarningsRequest extends $tea.Model {
  checkIds?: string;
  checkWarningIds?: string;
  reason?: string;
  riskId?: string;
  source?: string;
  sourceIp?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      checkIds: 'CheckIds',
      checkWarningIds: 'CheckWarningIds',
      reason: 'Reason',
      riskId: 'RiskId',
      source: 'Source',
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkIds: 'string',
      checkWarningIds: 'string',
      reason: 'string',
      riskId: 'string',
      source: 'string',
      sourceIp: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class IgnoreHcCheckWarningsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class IgnoreHcCheckWarningsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: IgnoreHcCheckWarningsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: IgnoreHcCheckWarningsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallBackupClientRequest extends $tea.Model {
  policyVersion?: string;
  uuid?: string;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      policyVersion: 'PolicyVersion',
      uuid: 'Uuid',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyVersion: 'string',
      uuid: 'string',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallBackupClientResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallBackupClientResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: InstallBackupClientResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InstallBackupClientResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallCloudMonitorRequest extends $tea.Model {
  agentAccessKey?: string;
  agentSecretKey?: string;
  argusVersion?: string;
  instanceIdList?: string[];
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      agentAccessKey: 'AgentAccessKey',
      agentSecretKey: 'AgentSecretKey',
      argusVersion: 'ArgusVersion',
      instanceIdList: 'InstanceIdList',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agentAccessKey: 'string',
      agentSecretKey: 'string',
      argusVersion: 'string',
      instanceIdList: { 'type': 'array', 'itemType': 'string' },
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallCloudMonitorResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallCloudMonitorResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: InstallCloudMonitorResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InstallCloudMonitorResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallPmAgentRequest extends $tea.Model {
  lang?: string;
  sourceIp?: string;
  type?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      sourceIp: 'SourceIp',
      type: 'Type',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      sourceIp: 'string',
      type: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallPmAgentResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallPmAgentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: InstallPmAgentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InstallPmAgentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallRaspAttachRequest extends $tea.Model {
  applicationId?: string;
  ecsUUIDList?: string[];
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      ecsUUIDList: 'EcsUUIDList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      ecsUUIDList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallRaspAttachResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallRaspAttachResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: InstallRaspAttachResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InstallRaspAttachResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallUniBackupAgentRequest extends $tea.Model {
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallUniBackupAgentResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallUniBackupAgentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: InstallUniBackupAgentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InstallUniBackupAgentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinWebLockProcessWhiteListRequest extends $tea.Model {
  processPaths?: string[];
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      processPaths: 'ProcessPaths',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      processPaths: { 'type': 'array', 'itemType': 'string' },
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinWebLockProcessWhiteListResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinWebLockProcessWhiteListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: JoinWebLockProcessWhiteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: JoinWebLockProcessWhiteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessMaliciousFilesRequest extends $tea.Model {
  currentPage?: number;
  dealed?: string;
  eventId?: number;
  fuzzyMaliciousName?: string;
  lang?: string;
  levels?: string;
  maliciousMd5?: string;
  maliciousType?: string;
  pageSize?: string;
  remark?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      dealed: 'Dealed',
      eventId: 'EventId',
      fuzzyMaliciousName: 'FuzzyMaliciousName',
      lang: 'Lang',
      levels: 'Levels',
      maliciousMd5: 'MaliciousMd5',
      maliciousType: 'MaliciousType',
      pageSize: 'PageSize',
      remark: 'Remark',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      dealed: 'string',
      eventId: 'number',
      fuzzyMaliciousName: 'string',
      lang: 'string',
      levels: 'string',
      maliciousMd5: 'string',
      maliciousType: 'string',
      pageSize: 'string',
      remark: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessMaliciousFilesResponseBody extends $tea.Model {
  list?: ListAgentlessMaliciousFilesResponseBodyList[];
  pageInfo?: ListAgentlessMaliciousFilesResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': ListAgentlessMaliciousFilesResponseBodyList },
      pageInfo: ListAgentlessMaliciousFilesResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessMaliciousFilesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListAgentlessMaliciousFilesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAgentlessMaliciousFilesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessRegionResponseBody extends $tea.Model {
  regionList?: string[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      regionList: 'RegionList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionList: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessRegionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListAgentlessRegionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAgentlessRegionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessRelateMaliciousRequest extends $tea.Model {
  currentPage?: number;
  eventId?: number;
  pageSize?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      eventId: 'EventId',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      eventId: 'number',
      pageSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessRelateMaliciousResponseBody extends $tea.Model {
  list?: ListAgentlessRelateMaliciousResponseBodyList[];
  pageInfo?: ListAgentlessRelateMaliciousResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': ListAgentlessRelateMaliciousResponseBodyList },
      pageInfo: ListAgentlessRelateMaliciousResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessRelateMaliciousResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListAgentlessRelateMaliciousResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAgentlessRelateMaliciousResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessRiskUuidRequest extends $tea.Model {
  currentPage?: number;
  internetIp?: string;
  intranetIp?: string;
  machineName?: string;
  pageSize?: number;
  risk?: boolean;
  targetName?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      machineName: 'MachineName',
      pageSize: 'PageSize',
      risk: 'Risk',
      targetName: 'TargetName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      internetIp: 'string',
      intranetIp: 'string',
      machineName: 'string',
      pageSize: 'number',
      risk: 'boolean',
      targetName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessRiskUuidResponseBody extends $tea.Model {
  list?: ListAgentlessRiskUuidResponseBodyList[];
  pageInfo?: ListAgentlessRiskUuidResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': ListAgentlessRiskUuidResponseBodyList },
      pageInfo: ListAgentlessRiskUuidResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessRiskUuidResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListAgentlessRiskUuidResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAgentlessRiskUuidResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessTaskRequest extends $tea.Model {
  currentPage?: number;
  endTime?: number;
  internetIp?: string;
  intranetIp?: string;
  lang?: string;
  machineName?: string;
  pageSize?: number;
  rootTask?: boolean;
  rootTaskId?: string;
  startTime?: number;
  status?: number;
  targetName?: string;
  targetType?: number;
  taskId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      lang: 'Lang',
      machineName: 'MachineName',
      pageSize: 'PageSize',
      rootTask: 'RootTask',
      rootTaskId: 'RootTaskId',
      startTime: 'StartTime',
      status: 'Status',
      targetName: 'TargetName',
      targetType: 'TargetType',
      taskId: 'TaskId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      internetIp: 'string',
      intranetIp: 'string',
      lang: 'string',
      machineName: 'string',
      pageSize: 'number',
      rootTask: 'boolean',
      rootTaskId: 'string',
      startTime: 'number',
      status: 'number',
      targetName: 'string',
      targetType: 'number',
      taskId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessTaskResponseBody extends $tea.Model {
  list?: ListAgentlessTaskResponseBodyList[];
  pageInfo?: ListAgentlessTaskResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': ListAgentlessTaskResponseBodyList },
      pageInfo: ListAgentlessTaskResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListAgentlessTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAgentlessTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetCleanConfigResponseBody extends $tea.Model {
  count?: number;
  data?: ListAssetCleanConfigResponseBodyData[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      data: { 'type': 'array', 'itemType': ListAssetCleanConfigResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetCleanConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListAssetCleanConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAssetCleanConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetRefreshTaskConfigRequest extends $tea.Model {
  refreshConfigType?: number;
  regionId?: string;
  targetId?: number;
  static names(): { [key: string]: string } {
    return {
      refreshConfigType: 'RefreshConfigType',
      regionId: 'RegionId',
      targetId: 'TargetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      refreshConfigType: 'number',
      regionId: 'string',
      targetId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetRefreshTaskConfigResponseBody extends $tea.Model {
  assetRefreshConfig?: ListAssetRefreshTaskConfigResponseBodyAssetRefreshConfig[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      assetRefreshConfig: 'AssetRefreshConfig',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetRefreshConfig: { 'type': 'array', 'itemType': ListAssetRefreshTaskConfigResponseBodyAssetRefreshConfig },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetRefreshTaskConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListAssetRefreshTaskConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAssetRefreshTaskConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetSelectionSelectedTargetRequest extends $tea.Model {
  selectionKey?: string;
  targetList?: string[];
  static names(): { [key: string]: string } {
    return {
      selectionKey: 'SelectionKey',
      targetList: 'TargetList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      selectionKey: 'string',
      targetList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetSelectionSelectedTargetResponseBody extends $tea.Model {
  data?: ListAssetSelectionSelectedTargetResponseBodyData[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListAssetSelectionSelectedTargetResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetSelectionSelectedTargetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListAssetSelectionSelectedTargetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAssetSelectionSelectedTargetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetSelectionTargetRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  selectionKey?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      selectionKey: 'SelectionKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      selectionKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetSelectionTargetResponseBody extends $tea.Model {
  data?: ListAssetSelectionTargetResponseBodyData[];
  pageInfo?: ListAssetSelectionTargetResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListAssetSelectionTargetResponseBodyData },
      pageInfo: ListAssetSelectionTargetResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetSelectionTargetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListAssetSelectionTargetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAssetSelectionTargetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAvailableHoneypotRequest extends $tea.Model {
  nodeId?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAvailableHoneypotResponseBody extends $tea.Model {
  code?: string;
  count?: number;
  data?: ListAvailableHoneypotResponseBodyData[];
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'number',
      data: { 'type': 'array', 'itemType': ListAvailableHoneypotResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAvailableHoneypotResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListAvailableHoneypotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListAvailableHoneypotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckInstanceResultRequest extends $tea.Model {
  checkId?: number;
  currentPage?: number;
  instanceIdKey?: string;
  instanceIds?: string[];
  instanceNameKey?: string;
  lang?: string;
  pageSize?: number;
  regionIdKey?: string;
  sortTypes?: string[];
  statuses?: string[];
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      currentPage: 'CurrentPage',
      instanceIdKey: 'InstanceIdKey',
      instanceIds: 'InstanceIds',
      instanceNameKey: 'InstanceNameKey',
      lang: 'Lang',
      pageSize: 'PageSize',
      regionIdKey: 'RegionIdKey',
      sortTypes: 'SortTypes',
      statuses: 'Statuses',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      currentPage: 'number',
      instanceIdKey: 'string',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      instanceNameKey: 'string',
      lang: 'string',
      pageSize: 'number',
      regionIdKey: 'string',
      sortTypes: { 'type': 'array', 'itemType': 'string' },
      statuses: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckInstanceResultResponseBody extends $tea.Model {
  basicData?: ListCheckInstanceResultResponseBodyBasicData[];
  checks?: { [key: string]: any }[];
  columns?: ListCheckInstanceResultResponseBodyColumns[];
  pageInfo?: ListCheckInstanceResultResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      basicData: 'BasicData',
      checks: 'Checks',
      columns: 'Columns',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      basicData: { 'type': 'array', 'itemType': ListCheckInstanceResultResponseBodyBasicData },
      checks: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      columns: { 'type': 'array', 'itemType': ListCheckInstanceResultResponseBodyColumns },
      pageInfo: ListCheckInstanceResultResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckInstanceResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListCheckInstanceResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCheckInstanceResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemRequest extends $tea.Model {
  currentPage?: number;
  lang?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      lang: 'Lang',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      lang: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemResponseBody extends $tea.Model {
  checkItems?: ListCheckItemResponseBodyCheckItems[];
  pageInfo?: ListCheckItemResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      checkItems: 'CheckItems',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkItems: { 'type': 'array', 'itemType': ListCheckItemResponseBodyCheckItems },
      pageInfo: ListCheckItemResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListCheckItemResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCheckItemResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemWarningMachineRequest extends $tea.Model {
  checkId?: number;
  containerFieldName?: string;
  containerFieldValue?: string;
  currentPage?: number;
  groupId?: number;
  lang?: string;
  pageSize?: number;
  remark?: string;
  riskType?: string;
  source?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      containerFieldName: 'ContainerFieldName',
      containerFieldValue: 'ContainerFieldValue',
      currentPage: 'CurrentPage',
      groupId: 'GroupId',
      lang: 'Lang',
      pageSize: 'PageSize',
      remark: 'Remark',
      riskType: 'RiskType',
      source: 'Source',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      containerFieldName: 'string',
      containerFieldValue: 'string',
      currentPage: 'number',
      groupId: 'number',
      lang: 'string',
      pageSize: 'number',
      remark: 'string',
      riskType: 'string',
      source: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemWarningMachineResponseBody extends $tea.Model {
  list?: ListCheckItemWarningMachineResponseBodyList[];
  pageInfo?: ListCheckItemWarningMachineResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': ListCheckItemWarningMachineResponseBodyList },
      pageInfo: ListCheckItemWarningMachineResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemWarningMachineResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListCheckItemWarningMachineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCheckItemWarningMachineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemWarningSummaryRequest extends $tea.Model {
  checkItemFuzzy?: string;
  checkLevel?: string;
  checkType?: string;
  checkWarningStatus?: number;
  containerFieldName?: string;
  containerFieldValue?: string;
  currentPage?: number;
  groupId?: number;
  lang?: string;
  pageSize?: number;
  riskType?: string;
  source?: string;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      checkItemFuzzy: 'CheckItemFuzzy',
      checkLevel: 'CheckLevel',
      checkType: 'CheckType',
      checkWarningStatus: 'CheckWarningStatus',
      containerFieldName: 'ContainerFieldName',
      containerFieldValue: 'ContainerFieldValue',
      currentPage: 'CurrentPage',
      groupId: 'GroupId',
      lang: 'Lang',
      pageSize: 'PageSize',
      riskType: 'RiskType',
      source: 'Source',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkItemFuzzy: 'string',
      checkLevel: 'string',
      checkType: 'string',
      checkWarningStatus: 'number',
      containerFieldName: 'string',
      containerFieldValue: 'string',
      currentPage: 'number',
      groupId: 'number',
      lang: 'string',
      pageSize: 'number',
      riskType: 'string',
      source: 'string',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemWarningSummaryResponseBody extends $tea.Model {
  list?: ListCheckItemWarningSummaryResponseBodyList[];
  pageInfo?: ListCheckItemWarningSummaryResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': ListCheckItemWarningSummaryResponseBodyList },
      pageInfo: ListCheckItemWarningSummaryResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemWarningSummaryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListCheckItemWarningSummaryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCheckItemWarningSummaryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckResultRequest extends $tea.Model {
  checkKey?: string;
  currentPage?: number;
  customParam?: boolean;
  instanceIds?: string[];
  instanceTypes?: string[];
  lang?: string;
  pageSize?: number;
  regionId?: string;
  requirementIds?: number[];
  riskLevels?: string[];
  sortTypes?: string[];
  standardIds?: number[];
  statuses?: string[];
  types?: string[];
  vendors?: string[];
  static names(): { [key: string]: string } {
    return {
      checkKey: 'CheckKey',
      currentPage: 'CurrentPage',
      customParam: 'CustomParam',
      instanceIds: 'InstanceIds',
      instanceTypes: 'InstanceTypes',
      lang: 'Lang',
      pageSize: 'PageSize',
      regionId: 'RegionId',
      requirementIds: 'RequirementIds',
      riskLevels: 'RiskLevels',
      sortTypes: 'SortTypes',
      standardIds: 'StandardIds',
      statuses: 'Statuses',
      types: 'Types',
      vendors: 'Vendors',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkKey: 'string',
      currentPage: 'number',
      customParam: 'boolean',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      instanceTypes: { 'type': 'array', 'itemType': 'string' },
      lang: 'string',
      pageSize: 'number',
      regionId: 'string',
      requirementIds: { 'type': 'array', 'itemType': 'number' },
      riskLevels: { 'type': 'array', 'itemType': 'string' },
      sortTypes: { 'type': 'array', 'itemType': 'string' },
      standardIds: { 'type': 'array', 'itemType': 'number' },
      statuses: { 'type': 'array', 'itemType': 'string' },
      types: { 'type': 'array', 'itemType': 'string' },
      vendors: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckResultResponseBody extends $tea.Model {
  checks?: ListCheckResultResponseBodyChecks[];
  pageInfo?: ListCheckResultResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      checks: 'Checks',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checks: { 'type': 'array', 'itemType': ListCheckResultResponseBodyChecks },
      pageInfo: ListCheckResultResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListCheckResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCheckResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckStandardRequest extends $tea.Model {
  instanceIds?: string[];
  instanceSubTypes?: string[];
  instanceTypes?: string[];
  lang?: string;
  vendors?: string[];
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
      instanceSubTypes: 'InstanceSubTypes',
      instanceTypes: 'InstanceTypes',
      lang: 'Lang',
      vendors: 'Vendors',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: { 'type': 'array', 'itemType': 'string' },
      instanceSubTypes: { 'type': 'array', 'itemType': 'string' },
      instanceTypes: { 'type': 'array', 'itemType': 'string' },
      lang: 'string',
      vendors: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckStandardResponseBody extends $tea.Model {
  requestId?: string;
  standards?: ListCheckStandardResponseBodyStandards[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      standards: 'Standards',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      standards: { 'type': 'array', 'itemType': ListCheckStandardResponseBodyStandards },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckStandardResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListCheckStandardResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCheckStandardResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientAlertModeRequest extends $tea.Model {
  mode?: string;
  static names(): { [key: string]: string } {
    return {
      mode: 'Mode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientAlertModeResponseBody extends $tea.Model {
  data?: ListClientAlertModeResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: ListClientAlertModeResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientAlertModeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListClientAlertModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClientAlertModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientUserDefineRuleTypesResponseBody extends $tea.Model {
  requestId?: string;
  userDefineRuleTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      userDefineRuleTypes: 'UserDefineRuleTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      userDefineRuleTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientUserDefineRuleTypesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListClientUserDefineRuleTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClientUserDefineRuleTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientUserDefineRulesRequest extends $tea.Model {
  currentPage?: number;
  name?: string;
  pageSize?: number;
  type?: number[];
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      name: 'Name',
      pageSize: 'PageSize',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      name: 'string',
      pageSize: 'number',
      type: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientUserDefineRulesResponseBody extends $tea.Model {
  pageInfo?: ListClientUserDefineRulesResponseBodyPageInfo;
  requestId?: string;
  userDefineRuleList?: ListClientUserDefineRulesResponseBodyUserDefineRuleList[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      userDefineRuleList: 'UserDefineRuleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: ListClientUserDefineRulesResponseBodyPageInfo,
      requestId: 'string',
      userDefineRuleList: { 'type': 'array', 'itemType': ListClientUserDefineRulesResponseBodyUserDefineRuleList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientUserDefineRulesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListClientUserDefineRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClientUserDefineRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudAssetInstancesRequest extends $tea.Model {
  cloudAssetTypes?: ListCloudAssetInstancesRequestCloudAssetTypes[];
  criteria?: string;
  currentPage?: number;
  logicalExp?: string;
  pageSize?: number;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      cloudAssetTypes: 'CloudAssetTypes',
      criteria: 'Criteria',
      currentPage: 'CurrentPage',
      logicalExp: 'LogicalExp',
      pageSize: 'PageSize',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cloudAssetTypes: { 'type': 'array', 'itemType': ListCloudAssetInstancesRequestCloudAssetTypes },
      criteria: 'string',
      currentPage: 'number',
      logicalExp: 'string',
      pageSize: 'number',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudAssetInstancesResponseBody extends $tea.Model {
  instances?: ListCloudAssetInstancesResponseBodyInstances[];
  pageInfo?: ListCloudAssetInstancesResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      instances: 'Instances',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instances: { 'type': 'array', 'itemType': ListCloudAssetInstancesResponseBodyInstances },
      pageInfo: ListCloudAssetInstancesResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudAssetInstancesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListCloudAssetInstancesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCloudAssetInstancesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudVendorRegionsRequest extends $tea.Model {
  lang?: string;
  vendor?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      vendor: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudVendorRegionsResponseBody extends $tea.Model {
  code?: string;
  count?: number;
  data?: ListCloudVendorRegionsResponseBodyData[];
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'number',
      data: { 'type': 'array', 'itemType': ListCloudVendorRegionsResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudVendorRegionsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListCloudVendorRegionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCloudVendorRegionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterCnnfStatusDetailRequest extends $tea.Model {
  clusterIds?: string[];
  static names(): { [key: string]: string } {
    return {
      clusterIds: 'ClusterIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterCnnfStatusDetailResponseBody extends $tea.Model {
  data?: ListClusterCnnfStatusDetailResponseBodyData[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListClusterCnnfStatusDetailResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterCnnfStatusDetailResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListClusterCnnfStatusDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClusterCnnfStatusDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterInterceptionConfigRequest extends $tea.Model {
  clusterCNNFStatus?: number;
  clusterId?: string;
  clusterName?: string;
  currentPage?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      clusterCNNFStatus: 'ClusterCNNFStatus',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterCNNFStatus: 'number',
      clusterId: 'string',
      clusterName: 'string',
      currentPage: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterInterceptionConfigResponseBody extends $tea.Model {
  clusterConfigList?: ListClusterInterceptionConfigResponseBodyClusterConfigList[];
  pageInfo?: ListClusterInterceptionConfigResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterConfigList: 'ClusterConfigList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterConfigList: { 'type': 'array', 'itemType': ListClusterInterceptionConfigResponseBodyClusterConfigList },
      pageInfo: ListClusterInterceptionConfigResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterInterceptionConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListClusterInterceptionConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListClusterInterceptionConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListContainerDefenseRuleRequest extends $tea.Model {
  conditions?: ListContainerDefenseRuleRequestConditions[];
  currentPage?: number;
  isDefaultRule?: number;
  lang?: string;
  pageSize?: number;
  ruleType?: number;
  static names(): { [key: string]: string } {
    return {
      conditions: 'Conditions',
      currentPage: 'CurrentPage',
      isDefaultRule: 'IsDefaultRule',
      lang: 'Lang',
      pageSize: 'PageSize',
      ruleType: 'RuleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditions: { 'type': 'array', 'itemType': ListContainerDefenseRuleRequestConditions },
      currentPage: 'number',
      isDefaultRule: 'number',
      lang: 'string',
      pageSize: 'number',
      ruleType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListContainerDefenseRuleResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  list?: ListContainerDefenseRuleResponseBodyList[];
  message?: string;
  pageInfo?: ListContainerDefenseRuleResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      list: 'List',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      list: { 'type': 'array', 'itemType': ListContainerDefenseRuleResponseBodyList },
      message: 'string',
      pageInfo: ListContainerDefenseRuleResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListContainerDefenseRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListContainerDefenseRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListContainerDefenseRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCriteriaStrategyRequest extends $tea.Model {
  clusterId?: string;
  imageName?: string;
  label?: string;
  namespace?: string;
  strategyName?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      imageName: 'ImageName',
      label: 'Label',
      namespace: 'Namespace',
      strategyName: 'StrategyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      imageName: 'string',
      label: 'string',
      namespace: 'string',
      strategyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCriteriaStrategyResponseBody extends $tea.Model {
  code?: string;
  data?: ListCriteriaStrategyResponseBodyData[];
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': ListCriteriaStrategyResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCriteriaStrategyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListCriteriaStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListCriteriaStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectEventRequest extends $tea.Model {
  alertLevels?: number[];
  currentPage?: number;
  pageSize?: string;
  ruleName?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      alertLevels: 'AlertLevels',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertLevels: { 'type': 'array', 'itemType': 'number' },
      currentPage: 'number',
      pageSize: 'string',
      ruleName: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectEventResponseBody extends $tea.Model {
  eventList?: ListFileProtectEventResponseBodyEventList[];
  pageInfo?: ListFileProtectEventResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      eventList: 'EventList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventList: { 'type': 'array', 'itemType': ListFileProtectEventResponseBodyEventList },
      pageInfo: ListFileProtectEventResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectEventResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListFileProtectEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListFileProtectEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectPluginStatusRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  switchId?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      switchId: 'SwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      switchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectPluginStatusResponseBody extends $tea.Model {
  data?: ListFileProtectPluginStatusResponseBodyData[];
  pageInfo?: ListFileProtectPluginStatusResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListFileProtectPluginStatusResponseBodyData },
      pageInfo: ListFileProtectPluginStatusResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectPluginStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListFileProtectPluginStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListFileProtectPluginStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectRuleRequest extends $tea.Model {
  alertLevel?: number;
  currentPage?: number;
  pageSize?: number;
  ruleAction?: string;
  ruleName?: string;
  static names(): { [key: string]: string } {
    return {
      alertLevel: 'AlertLevel',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      ruleAction: 'RuleAction',
      ruleName: 'RuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertLevel: 'number',
      currentPage: 'number',
      pageSize: 'number',
      ruleAction: 'string',
      ruleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectRuleResponseBody extends $tea.Model {
  fileProtectList?: ListFileProtectRuleResponseBodyFileProtectList[];
  pageInfo?: ListFileProtectRuleResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      fileProtectList: 'FileProtectList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileProtectList: { 'type': 'array', 'itemType': ListFileProtectRuleResponseBodyFileProtectList },
      pageInfo: ListFileProtectRuleResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListFileProtectRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListFileProtectRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupsRequest extends $tea.Model {
  currentPage?: number;
  lang?: string;
  nextToken?: string;
  pageSize?: number;
  useNextToken?: boolean;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      lang: 'Lang',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      useNextToken: 'UseNextToken',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      lang: 'string',
      nextToken: 'string',
      pageSize: 'number',
      useNextToken: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupsResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  list?: ListGroupsResponseBodyList[];
  message?: string;
  pageInfo?: ListGroupsResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      list: 'List',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      list: { 'type': 'array', 'itemType': ListGroupsResponseBodyList },
      message: 'string',
      pageInfo: ListGroupsResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListGroupsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListGroupsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotRequest extends $tea.Model {
  currentPage?: number;
  honeypotIds?: string[];
  honeypotName?: string;
  nodeId?: string;
  nodeName?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      honeypotIds: 'HoneypotIds',
      honeypotName: 'HoneypotName',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      honeypotIds: { 'type': 'array', 'itemType': 'string' },
      honeypotName: 'string',
      nodeId: 'string',
      nodeName: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  list?: ListHoneypotResponseBodyList[];
  message?: string;
  pageInfo?: ListHoneypotResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      list: 'List',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      list: { 'type': 'array', 'itemType': ListHoneypotResponseBodyList },
      message: 'string',
      pageInfo: ListHoneypotResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListHoneypotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHoneypotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAlarmEventsRequest extends $tea.Model {
  currentPage?: number;
  dealed?: string;
  dstIp?: string;
  pageSize?: number;
  riskLevelList?: string[];
  srcIp?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      dealed: 'Dealed',
      dstIp: 'DstIp',
      pageSize: 'PageSize',
      riskLevelList: 'RiskLevelList',
      srcIp: 'SrcIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      dealed: 'string',
      dstIp: 'string',
      pageSize: 'number',
      riskLevelList: { 'type': 'array', 'itemType': 'string' },
      srcIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAlarmEventsResponseBody extends $tea.Model {
  honeypotAlarmEvents?: ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents[];
  pageInfo?: ListHoneypotAlarmEventsResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      honeypotAlarmEvents: 'HoneypotAlarmEvents',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeypotAlarmEvents: { 'type': 'array', 'itemType': ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents },
      pageInfo: ListHoneypotAlarmEventsResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAlarmEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListHoneypotAlarmEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHoneypotAlarmEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAttackerPortraitRequest extends $tea.Model {
  currentPage?: number;
  endTimeStamp?: number;
  lang?: string;
  pageSize?: number;
  srcIp?: string;
  startTimeStamp?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTimeStamp: 'EndTimeStamp',
      lang: 'Lang',
      pageSize: 'PageSize',
      srcIp: 'SrcIp',
      startTimeStamp: 'StartTimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTimeStamp: 'number',
      lang: 'string',
      pageSize: 'number',
      srcIp: 'string',
      startTimeStamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAttackerPortraitResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  list?: ListHoneypotAttackerPortraitResponseBodyList[];
  message?: string;
  pageInfo?: ListHoneypotAttackerPortraitResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      list: 'List',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      list: { 'type': 'array', 'itemType': ListHoneypotAttackerPortraitResponseBodyList },
      message: 'string',
      pageInfo: ListHoneypotAttackerPortraitResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAttackerPortraitResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListHoneypotAttackerPortraitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHoneypotAttackerPortraitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAttackerSourceRequest extends $tea.Model {
  currentPage?: number;
  endTimeStamp?: number;
  lang?: string;
  pageSize?: number;
  riskLevelList?: string[];
  srcIp?: string;
  startTimeStamp?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTimeStamp: 'EndTimeStamp',
      lang: 'Lang',
      pageSize: 'PageSize',
      riskLevelList: 'RiskLevelList',
      srcIp: 'SrcIp',
      startTimeStamp: 'StartTimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTimeStamp: 'number',
      lang: 'string',
      pageSize: 'number',
      riskLevelList: { 'type': 'array', 'itemType': 'string' },
      srcIp: 'string',
      startTimeStamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAttackerSourceResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  list?: ListHoneypotAttackerSourceResponseBodyList[];
  message?: string;
  pageInfo?: ListHoneypotAttackerSourceResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      list: 'List',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      list: { 'type': 'array', 'itemType': ListHoneypotAttackerSourceResponseBodyList },
      message: 'string',
      pageInfo: ListHoneypotAttackerSourceResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAttackerSourceResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListHoneypotAttackerSourceResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHoneypotAttackerSourceResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotEventsRequest extends $tea.Model {
  agentIdList?: string[];
  alarmEventId?: number;
  currentPage?: number;
  dealed?: string;
  honeypotIdList?: string[];
  lang?: string;
  pageSize?: number;
  portraitId?: string;
  requestId?: string;
  riskLevelList?: string[];
  srcIp?: string;
  static names(): { [key: string]: string } {
    return {
      agentIdList: 'AgentIdList',
      alarmEventId: 'AlarmEventId',
      currentPage: 'CurrentPage',
      dealed: 'Dealed',
      honeypotIdList: 'HoneypotIdList',
      lang: 'Lang',
      pageSize: 'PageSize',
      portraitId: 'PortraitId',
      requestId: 'RequestId',
      riskLevelList: 'RiskLevelList',
      srcIp: 'SrcIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agentIdList: { 'type': 'array', 'itemType': 'string' },
      alarmEventId: 'number',
      currentPage: 'number',
      dealed: 'string',
      honeypotIdList: { 'type': 'array', 'itemType': 'string' },
      lang: 'string',
      pageSize: 'number',
      portraitId: 'string',
      requestId: 'string',
      riskLevelList: { 'type': 'array', 'itemType': 'string' },
      srcIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotEventsResponseBody extends $tea.Model {
  honeypotEvents?: ListHoneypotEventsResponseBodyHoneypotEvents[];
  pageInfo?: ListHoneypotEventsResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      honeypotEvents: 'HoneypotEvents',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeypotEvents: { 'type': 'array', 'itemType': ListHoneypotEventsResponseBodyHoneypotEvents },
      pageInfo: ListHoneypotEventsResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListHoneypotEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHoneypotEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotNodeRequest extends $tea.Model {
  currentPage?: number;
  nodeId?: string;
  nodeName?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      nodeId: 'string',
      nodeName: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotNodeResponseBody extends $tea.Model {
  code?: string;
  honeypotNodeList?: ListHoneypotNodeResponseBodyHoneypotNodeList[];
  httpStatusCode?: number;
  message?: string;
  pageInfo?: ListHoneypotNodeResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      honeypotNodeList: 'HoneypotNodeList',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      honeypotNodeList: { 'type': 'array', 'itemType': ListHoneypotNodeResponseBodyHoneypotNodeList },
      httpStatusCode: 'number',
      message: 'string',
      pageInfo: ListHoneypotNodeResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotNodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListHoneypotNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHoneypotNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotPresetRequest extends $tea.Model {
  currentPage?: number;
  honeypotImageName?: string;
  lang?: string;
  nodeId?: string;
  nodeName?: string;
  pageSize?: number;
  presetName?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      honeypotImageName: 'HoneypotImageName',
      lang: 'Lang',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      pageSize: 'PageSize',
      presetName: 'PresetName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      honeypotImageName: 'string',
      lang: 'string',
      nodeId: 'string',
      nodeName: 'string',
      pageSize: 'number',
      presetName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotPresetResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  list?: ListHoneypotPresetResponseBodyList[];
  message?: string;
  pageInfo?: ListHoneypotPresetResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      list: 'List',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      list: { 'type': 'array', 'itemType': ListHoneypotPresetResponseBodyList },
      message: 'string',
      pageInfo: ListHoneypotPresetResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotPresetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListHoneypotPresetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHoneypotPresetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotProbeRequest extends $tea.Model {
  currentPage?: number;
  displayName?: string;
  lang?: string;
  pageSize?: number;
  probeStatus?: string;
  probeType?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      displayName: 'DisplayName',
      lang: 'Lang',
      pageSize: 'PageSize',
      probeStatus: 'ProbeStatus',
      probeType: 'ProbeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      displayName: 'string',
      lang: 'string',
      pageSize: 'number',
      probeStatus: 'string',
      probeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotProbeResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  list?: ListHoneypotProbeResponseBodyList[];
  message?: string;
  pageInfo?: ListHoneypotProbeResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      list: 'List',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      list: { 'type': 'array', 'itemType': ListHoneypotProbeResponseBodyList },
      message: 'string',
      pageInfo: ListHoneypotProbeResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotProbeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListHoneypotProbeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHoneypotProbeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotProbeUuidRequest extends $tea.Model {
  controlNodeId?: string;
  lang?: string;
  probeType?: string;
  static names(): { [key: string]: string } {
    return {
      controlNodeId: 'ControlNodeId',
      lang: 'Lang',
      probeType: 'ProbeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      controlNodeId: 'string',
      lang: 'string',
      probeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotProbeUuidResponseBody extends $tea.Model {
  code?: string;
  count?: number;
  data?: string[];
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'number',
      data: { 'type': 'array', 'itemType': 'string' },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotProbeUuidResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListHoneypotProbeUuidResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListHoneypotProbeUuidResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListImageRegistryRegionResponseBody extends $tea.Model {
  regions?: ListImageRegistryRegionResponseBodyRegions[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      regions: 'Regions',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regions: { 'type': 'array', 'itemType': ListImageRegistryRegionResponseBodyRegions },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListImageRegistryRegionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListImageRegistryRegionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListImageRegistryRegionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListImageRiskRequest extends $tea.Model {
  appName?: string;
  clusterId?: string;
  currentPage?: number;
  imageName?: string;
  namespace?: string;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      clusterId: 'ClusterId',
      currentPage: 'CurrentPage',
      imageName: 'ImageName',
      namespace: 'Namespace',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      clusterId: 'string',
      currentPage: 'number',
      imageName: 'string',
      namespace: 'string',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListImageRiskResponseBody extends $tea.Model {
  imageRiskList?: ListImageRiskResponseBodyImageRiskList[];
  pageInfo?: ListImageRiskResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      imageRiskList: 'ImageRiskList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageRiskList: { 'type': 'array', 'itemType': ListImageRiskResponseBodyImageRiskList },
      pageInfo: ListImageRiskResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListImageRiskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListImageRiskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListImageRiskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceCatalogRequest extends $tea.Model {
  lang?: string;
  regionId?: string;
  requirementIds?: number[];
  standardIds?: number[];
  types?: string[];
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      regionId: 'RegionId',
      requirementIds: 'RequirementIds',
      standardIds: 'StandardIds',
      types: 'Types',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      regionId: 'string',
      requirementIds: { 'type': 'array', 'itemType': 'number' },
      standardIds: { 'type': 'array', 'itemType': 'number' },
      types: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceCatalogResponseBody extends $tea.Model {
  requestId?: string;
  vendors?: ListInstanceCatalogResponseBodyVendors[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vendors: 'Vendors',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vendors: { 'type': 'array', 'itemType': ListInstanceCatalogResponseBodyVendors },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceCatalogResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListInstanceCatalogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceCatalogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceRiskLevelsRequest extends $tea.Model {
  instanceList?: ListInstanceRiskLevelsRequestInstanceList[];
  static names(): { [key: string]: string } {
    return {
      instanceList: 'InstanceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceList: { 'type': 'array', 'itemType': ListInstanceRiskLevelsRequestInstanceList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceRiskLevelsResponseBody extends $tea.Model {
  instanceRiskLevels?: ListInstanceRiskLevelsResponseBodyInstanceRiskLevels[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceRiskLevels: 'InstanceRiskLevels',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceRiskLevels: { 'type': 'array', 'itemType': ListInstanceRiskLevelsResponseBodyInstanceRiskLevels },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceRiskLevelsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListInstanceRiskLevelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceRiskLevelsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceRiskNumRequest extends $tea.Model {
  instanceList?: ListInstanceRiskNumRequestInstanceList[];
  static names(): { [key: string]: string } {
    return {
      instanceList: 'InstanceList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceList: { 'type': 'array', 'itemType': ListInstanceRiskNumRequestInstanceList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceRiskNumResponseBody extends $tea.Model {
  instanceRiskNum?: ListInstanceRiskNumResponseBodyInstanceRiskNum[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceRiskNum: 'InstanceRiskNum',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceRiskNum: { 'type': 'array', 'itemType': ListInstanceRiskNumResponseBodyInstanceRiskNum },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceRiskNumResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListInstanceRiskNumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInstanceRiskNumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionHistoryRequest extends $tea.Model {
  clusterId?: string;
  currentPage?: number;
  endTime?: number;
  historyName?: string;
  interceptionTypes?: number[];
  lang?: string;
  pageSize?: number;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      historyName: 'HistoryName',
      interceptionTypes: 'InterceptionTypes',
      lang: 'Lang',
      pageSize: 'PageSize',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      currentPage: 'number',
      endTime: 'number',
      historyName: 'string',
      interceptionTypes: { 'type': 'array', 'itemType': 'number' },
      lang: 'string',
      pageSize: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionHistoryResponseBody extends $tea.Model {
  interceptionHistoryList?: ListInterceptionHistoryResponseBodyInterceptionHistoryList[];
  pageInfo?: ListInterceptionHistoryResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      interceptionHistoryList: 'InterceptionHistoryList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interceptionHistoryList: { 'type': 'array', 'itemType': ListInterceptionHistoryResponseBodyInterceptionHistoryList },
      pageInfo: ListInterceptionHistoryResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionHistoryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListInterceptionHistoryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInterceptionHistoryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionRulePageRequest extends $tea.Model {
  clusterId?: string;
  criteria?: string;
  criteriaType?: string;
  currentPage?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      criteria: 'Criteria',
      criteriaType: 'CriteriaType',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      criteria: 'string',
      criteriaType: 'string',
      currentPage: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionRulePageResponseBody extends $tea.Model {
  interceptionRuleList?: ListInterceptionRulePageResponseBodyInterceptionRuleList[];
  pageInfo?: ListInterceptionRulePageResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      interceptionRuleList: 'InterceptionRuleList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      interceptionRuleList: { 'type': 'array', 'itemType': ListInterceptionRulePageResponseBodyInterceptionRuleList },
      pageInfo: ListInterceptionRulePageResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionRulePageResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListInterceptionRulePageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInterceptionRulePageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionTargetPageRequest extends $tea.Model {
  appName?: string;
  currentPage?: number;
  imageList?: string[];
  namespace?: string;
  pageSize?: number;
  tagList?: string[];
  targetName?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      currentPage: 'CurrentPage',
      imageList: 'ImageList',
      namespace: 'Namespace',
      pageSize: 'PageSize',
      tagList: 'TagList',
      targetName: 'TargetName',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      currentPage: 'number',
      imageList: { 'type': 'array', 'itemType': 'string' },
      namespace: 'string',
      pageSize: 'number',
      tagList: { 'type': 'array', 'itemType': 'string' },
      targetName: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionTargetPageResponseBody extends $tea.Model {
  pageInfo?: ListInterceptionTargetPageResponseBodyPageInfo;
  requestId?: string;
  ruleTargetList?: ListInterceptionTargetPageResponseBodyRuleTargetList[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      ruleTargetList: 'RuleTargetList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: ListInterceptionTargetPageResponseBodyPageInfo,
      requestId: 'string',
      ruleTargetList: { 'type': 'array', 'itemType': ListInterceptionTargetPageResponseBodyRuleTargetList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionTargetPageResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListInterceptionTargetPageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListInterceptionTargetPageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListObjectScanEventRequest extends $tea.Model {
  bucketName?: string;
  currentPage?: number;
  eventName?: string;
  lang?: string;
  md5?: string;
  ossKey?: string;
  pageSize?: number;
  riskLevel?: string;
  source?: string;
  timeEnd?: number;
  timeStart?: number;
  static names(): { [key: string]: string } {
    return {
      bucketName: 'BucketName',
      currentPage: 'CurrentPage',
      eventName: 'EventName',
      lang: 'Lang',
      md5: 'Md5',
      ossKey: 'OssKey',
      pageSize: 'PageSize',
      riskLevel: 'RiskLevel',
      source: 'Source',
      timeEnd: 'TimeEnd',
      timeStart: 'TimeStart',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketName: 'string',
      currentPage: 'number',
      eventName: 'string',
      lang: 'string',
      md5: 'string',
      ossKey: 'string',
      pageSize: 'number',
      riskLevel: 'string',
      source: 'string',
      timeEnd: 'number',
      timeStart: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListObjectScanEventResponseBody extends $tea.Model {
  data?: ListObjectScanEventResponseBodyData[];
  pageInfo?: ListObjectScanEventResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListObjectScanEventResponseBodyData },
      pageInfo: ListObjectScanEventResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListObjectScanEventResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListObjectScanEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListObjectScanEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOssBucketRequest extends $tea.Model {
  bucketName?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      bucketName: 'BucketName',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketName: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOssBucketResponseBody extends $tea.Model {
  data?: ListOssBucketResponseBodyData[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListOssBucketResponseBodyData },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOssBucketResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListOssBucketResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOssBucketResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOssBucketScanInfoRequest extends $tea.Model {
  bucketName?: string;
  currentPage?: number;
  fuzzBucketName?: string;
  hasRisk?: number;
  lang?: string;
  pageSize?: number;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      bucketName: 'BucketName',
      currentPage: 'CurrentPage',
      fuzzBucketName: 'FuzzBucketName',
      hasRisk: 'HasRisk',
      lang: 'Lang',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketName: 'string',
      currentPage: 'number',
      fuzzBucketName: 'string',
      hasRisk: 'number',
      lang: 'string',
      pageSize: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOssBucketScanInfoResponseBody extends $tea.Model {
  data?: ListOssBucketScanInfoResponseBodyData[];
  pageInfo?: ListOssBucketScanInfoResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListOssBucketScanInfoResponseBodyData },
      pageInfo: ListOssBucketScanInfoResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOssBucketScanInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListOssBucketScanInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListOssBucketScanInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPluginForUuidRequest extends $tea.Model {
  types?: string[];
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      types: 'Types',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      types: { 'type': 'array', 'itemType': 'string' },
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPluginForUuidShrinkRequest extends $tea.Model {
  typesShrink?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      typesShrink: 'Types',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      typesShrink: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPluginForUuidResponseBody extends $tea.Model {
  aegisUuidTargetPluginConfigList?: ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList[];
  code?: number;
  message?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      aegisUuidTargetPluginConfigList: 'AegisUuidTargetPluginConfigList',
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aegisUuidTargetPluginConfigList: { 'type': 'array', 'itemType': ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList },
      code: 'number',
      message: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPluginForUuidResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListPluginForUuidResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPluginForUuidResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPodRiskRequest extends $tea.Model {
  appName?: string;
  clusterId?: string;
  currentPage?: number;
  namespace?: string;
  pageSize?: number;
  podName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      clusterId: 'ClusterId',
      currentPage: 'CurrentPage',
      namespace: 'Namespace',
      pageSize: 'PageSize',
      podName: 'PodName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      clusterId: 'string',
      currentPage: 'number',
      namespace: 'string',
      pageSize: 'number',
      podName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPodRiskResponseBody extends $tea.Model {
  pageInfo?: ListPodRiskResponseBodyPageInfo;
  podRiskList?: ListPodRiskResponseBodyPodRiskList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      podRiskList: 'PodRiskList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: ListPodRiskResponseBodyPageInfo,
      podRiskList: { 'type': 'array', 'itemType': ListPodRiskResponseBodyPodRiskList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPodRiskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListPodRiskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPodRiskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrivateRegistryListRequest extends $tea.Model {
  registryType?: string;
  static names(): { [key: string]: string } {
    return {
      registryType: 'RegistryType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      registryType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrivateRegistryListResponseBody extends $tea.Model {
  imageRegistryInfos?: ListPrivateRegistryListResponseBodyImageRegistryInfos[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      imageRegistryInfos: 'ImageRegistryInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageRegistryInfos: { 'type': 'array', 'itemType': ListPrivateRegistryListResponseBodyImageRegistryInfos },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrivateRegistryListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListPrivateRegistryListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPrivateRegistryListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrivateRegistryTypeRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrivateRegistryTypeResponseBody extends $tea.Model {
  registryTypeInfos?: ListPrivateRegistryTypeResponseBodyRegistryTypeInfos[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      registryTypeInfos: 'RegistryTypeInfos',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      registryTypeInfos: { 'type': 'array', 'itemType': ListPrivateRegistryTypeResponseBodyRegistryTypeInfos },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrivateRegistryTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListPrivateRegistryTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListPrivateRegistryTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQueryRaspAppInfoRequest extends $tea.Model {
  lang?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQueryRaspAppInfoResponseBody extends $tea.Model {
  code?: string;
  data?: ListQueryRaspAppInfoResponseBodyData[];
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: { 'type': 'array', 'itemType': ListQueryRaspAppInfoResponseBodyData },
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQueryRaspAppInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListQueryRaspAppInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListQueryRaspAppInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleTargetAllRequest extends $tea.Model {
  clusterId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleTargetAllResponseBody extends $tea.Model {
  requestId?: string;
  ruleTargetList?: ListRuleTargetAllResponseBodyRuleTargetList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      ruleTargetList: 'RuleTargetList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      ruleTargetList: { 'type': 'array', 'itemType': ListRuleTargetAllResponseBodyRuleTargetList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleTargetAllResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListRuleTargetAllResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListRuleTargetAllResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSupportObjectSuffixResponseBody extends $tea.Model {
  data?: string[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': 'string' },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSupportObjectSuffixResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListSupportObjectSuffixResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSupportObjectSuffixResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemAggregationRulesRequest extends $tea.Model {
  aggregationIds?: number[];
  currentPage?: number;
  lang?: string;
  pageSize?: number;
  ruleName?: string;
  ruleTypes?: number[];
  systemType?: number;
  static names(): { [key: string]: string } {
    return {
      aggregationIds: 'AggregationIds',
      currentPage: 'CurrentPage',
      lang: 'Lang',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      ruleTypes: 'RuleTypes',
      systemType: 'SystemType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregationIds: { 'type': 'array', 'itemType': 'number' },
      currentPage: 'number',
      lang: 'string',
      pageSize: 'number',
      ruleName: 'string',
      ruleTypes: { 'type': 'array', 'itemType': 'number' },
      systemType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemAggregationRulesResponseBody extends $tea.Model {
  aggregationList?: ListSystemAggregationRulesResponseBodyAggregationList[];
  pageInfo?: ListSystemAggregationRulesResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      aggregationList: 'AggregationList',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregationList: { 'type': 'array', 'itemType': ListSystemAggregationRulesResponseBodyAggregationList },
      pageInfo: ListSystemAggregationRulesResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemAggregationRulesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListSystemAggregationRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSystemAggregationRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemClientRuleTypesResponseBody extends $tea.Model {
  requestId?: string;
  ruleTypes?: string[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      ruleTypes: 'RuleTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      ruleTypes: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemClientRuleTypesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListSystemClientRuleTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSystemClientRuleTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemClientRulesRequest extends $tea.Model {
  aggregationIds?: number[];
  currentPage?: number;
  isContainer?: number;
  lang?: string;
  pageSize?: number;
  ruleName?: string;
  ruleTypes?: number[];
  systemType?: number;
  static names(): { [key: string]: string } {
    return {
      aggregationIds: 'AggregationIds',
      currentPage: 'CurrentPage',
      isContainer: 'IsContainer',
      lang: 'Lang',
      pageSize: 'PageSize',
      ruleName: 'RuleName',
      ruleTypes: 'RuleTypes',
      systemType: 'SystemType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregationIds: { 'type': 'array', 'itemType': 'number' },
      currentPage: 'number',
      isContainer: 'number',
      lang: 'string',
      pageSize: 'number',
      ruleName: 'string',
      ruleTypes: { 'type': 'array', 'itemType': 'number' },
      systemType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemClientRulesResponseBody extends $tea.Model {
  pageInfo?: ListSystemClientRulesResponseBodyPageInfo;
  requestId?: string;
  ruleList?: ListSystemClientRulesResponseBodyRuleList[];
  static names(): { [key: string]: string } {
    return {
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      ruleList: 'RuleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageInfo: ListSystemClientRulesResponseBodyPageInfo,
      requestId: 'string',
      ruleList: { 'type': 'array', 'itemType': ListSystemClientRulesResponseBodyRuleList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemClientRulesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListSystemClientRulesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSystemClientRulesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemRuleAggregationTypesRequest extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemRuleAggregationTypesResponseBody extends $tea.Model {
  aggregationTypeList?: ListSystemRuleAggregationTypesResponseBodyAggregationTypeList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      aggregationTypeList: 'AggregationTypeList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregationTypeList: { 'type': 'array', 'itemType': ListSystemRuleAggregationTypesResponseBodyAggregationTypeList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemRuleAggregationTypesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListSystemRuleAggregationTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListSystemRuleAggregationTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUninstallAegisMachinesRequest extends $tea.Model {
  currentPage?: number;
  os?: string;
  pageSize?: number;
  regionIdStr?: string;
  regionNo?: string;
  remark?: string;
  sourceIp?: string;
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      os: 'Os',
      pageSize: 'PageSize',
      regionIdStr: 'RegionIdStr',
      regionNo: 'RegionNo',
      remark: 'Remark',
      sourceIp: 'SourceIp',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      os: 'string',
      pageSize: 'number',
      regionIdStr: 'string',
      regionNo: 'string',
      remark: 'string',
      sourceIp: 'string',
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUninstallAegisMachinesResponseBody extends $tea.Model {
  currentPage?: number;
  machineList?: ListUninstallAegisMachinesResponseBodyMachineList[];
  pageSize?: number;
  requestId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      machineList: 'MachineList',
      pageSize: 'PageSize',
      requestId: 'RequestId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      machineList: { 'type': 'array', 'itemType': ListUninstallAegisMachinesResponseBodyMachineList },
      pageSize: 'number',
      requestId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUninstallAegisMachinesResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListUninstallAegisMachinesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUninstallAegisMachinesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUuidsByWebPathRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  type?: string;
  webPath?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      type: 'Type',
      webPath: 'WebPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      type: 'string',
      webPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUuidsByWebPathResponseBody extends $tea.Model {
  list?: ListUuidsByWebPathResponseBodyList[];
  pageInfo?: ListUuidsByWebPathResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': ListUuidsByWebPathResponseBodyList },
      pageInfo: ListUuidsByWebPathResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUuidsByWebPathResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListUuidsByWebPathResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListUuidsByWebPathResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanMachineRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  remark?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      remark: 'Remark',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      remark: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanMachineResponseBody extends $tea.Model {
  data?: ListVirusScanMachineResponseBodyData[];
  pageInfo?: ListVirusScanMachineResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListVirusScanMachineResponseBodyData },
      pageInfo: ListVirusScanMachineResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanMachineResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListVirusScanMachineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListVirusScanMachineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanMachineEventRequest extends $tea.Model {
  currentPage?: number;
  operateTaskId?: string;
  pageSize?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      operateTaskId: 'OperateTaskId',
      pageSize: 'PageSize',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      operateTaskId: 'string',
      pageSize: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanMachineEventResponseBody extends $tea.Model {
  data?: ListVirusScanMachineEventResponseBodyData[];
  pageInfo?: ListVirusScanMachineEventResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: { 'type': 'array', 'itemType': ListVirusScanMachineEventResponseBodyData },
      pageInfo: ListVirusScanMachineEventResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanMachineEventResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListVirusScanMachineEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListVirusScanMachineEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanTaskRequest extends $tea.Model {
  currentPage?: number;
  endTime?: number;
  internetIp?: string;
  intranetIp?: string;
  lang?: string;
  machineName?: string;
  pageSize?: number;
  rootTask?: boolean;
  rootTaskId?: string;
  scanType?: string;
  startTime?: number;
  status?: number;
  statusList?: number[];
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      endTime: 'EndTime',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      lang: 'Lang',
      machineName: 'MachineName',
      pageSize: 'PageSize',
      rootTask: 'RootTask',
      rootTaskId: 'RootTaskId',
      scanType: 'ScanType',
      startTime: 'StartTime',
      status: 'Status',
      statusList: 'StatusList',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      endTime: 'number',
      internetIp: 'string',
      intranetIp: 'string',
      lang: 'string',
      machineName: 'string',
      pageSize: 'number',
      rootTask: 'boolean',
      rootTaskId: 'string',
      scanType: 'string',
      startTime: 'number',
      status: 'number',
      statusList: { 'type': 'array', 'itemType': 'number' },
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanTaskResponseBody extends $tea.Model {
  list?: ListVirusScanTaskResponseBodyList[];
  pageInfo?: ListVirusScanTaskResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': ListVirusScanTaskResponseBodyList },
      pageInfo: ListVirusScanTaskResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListVirusScanTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListVirusScanTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVulAutoRepairConfigRequest extends $tea.Model {
  aliasName?: string;
  currentPage?: number;
  pageSize?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      currentPage: 'number',
      pageSize: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVulAutoRepairConfigResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  pageInfo?: ListVulAutoRepairConfigResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  vulAutoRepairConfigList?: ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
      vulAutoRepairConfigList: 'VulAutoRepairConfigList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      pageInfo: ListVulAutoRepairConfigResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
      vulAutoRepairConfigList: { 'type': 'array', 'itemType': ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVulAutoRepairConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListVulAutoRepairConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListVulAutoRepairConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVulGlobalConfigRequest extends $tea.Model {
  configKey?: string;
  static names(): { [key: string]: string } {
    return {
      configKey: 'ConfigKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVulGlobalConfigResponseBody extends $tea.Model {
  requestId?: string;
  vulGlobalConfigList?: ListVulGlobalConfigResponseBodyVulGlobalConfigList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vulGlobalConfigList: 'VulGlobalConfigList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vulGlobalConfigList: { 'type': 'array', 'itemType': ListVulGlobalConfigResponseBodyVulGlobalConfigList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVulGlobalConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ListVulGlobalConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListVulGlobalConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAccessKeyLeakDealRequest extends $tea.Model {
  id?: number;
  idList?: number[];
  remark?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      idList: 'IdList',
      remark: 'Remark',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      idList: { 'type': 'array', 'itemType': 'number' },
      remark: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAccessKeyLeakDealResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAccessKeyLeakDealResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyAccessKeyLeakDealResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyAccessKeyLeakDealResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAntiBruteForceRuleRequest extends $tea.Model {
  defaultRule?: boolean;
  failCount?: number;
  forbiddenTime?: number;
  id?: number;
  name?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  span?: number;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      defaultRule: 'DefaultRule',
      failCount: 'FailCount',
      forbiddenTime: 'ForbiddenTime',
      id: 'Id',
      name: 'Name',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
      span: 'Span',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultRule: 'boolean',
      failCount: 'number',
      forbiddenTime: 'number',
      id: 'number',
      name: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
      span: 'number',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAntiBruteForceRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAntiBruteForceRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyAntiBruteForceRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyAntiBruteForceRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAppVulScanCycleRequest extends $tea.Model {
  cycle?: string;
  static names(): { [key: string]: string } {
    return {
      cycle: 'Cycle',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cycle: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAppVulScanCycleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAppVulScanCycleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyAppVulScanCycleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyAppVulScanCycleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAssetCleanConfigRequest extends $tea.Model {
  assetCleanConfigs?: ModifyAssetCleanConfigRequestAssetCleanConfigs[];
  static names(): { [key: string]: string } {
    return {
      assetCleanConfigs: 'AssetCleanConfigs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetCleanConfigs: { 'type': 'array', 'itemType': ModifyAssetCleanConfigRequestAssetCleanConfigs },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAssetCleanConfigResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAssetCleanConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyAssetCleanConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyAssetCleanConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAssetGroupRequest extends $tea.Model {
  groupId?: number;
  sourceIp?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      sourceIp: 'SourceIp',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      sourceIp: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAssetGroupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAssetGroupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyAssetGroupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyAssetGroupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAssetImportantRequest extends $tea.Model {
  importantCode?: number;
  uuidList?: string;
  static names(): { [key: string]: string } {
    return {
      importantCode: 'ImportantCode',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      importantCode: 'number',
      uuidList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAssetImportantResponseBody extends $tea.Model {
  errCode?: string;
  errMessage?: string;
  httpStatusCode?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errCode: 'ErrCode',
      errMessage: 'ErrMessage',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errCode: 'string',
      errMessage: 'string',
      httpStatusCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAssetImportantResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyAssetImportantResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyAssetImportantResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAutoDelConfigRequest extends $tea.Model {
  days?: number;
  static names(): { [key: string]: string } {
    return {
      days: 'Days',
    };
  }

  static types(): { [key: string]: any } {
    return {
      days: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAutoDelConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAutoDelConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyAutoDelConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyAutoDelConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBackupPolicyRequest extends $tea.Model {
  id?: number;
  name?: string;
  policy?: { [key: string]: any };
  policyRegionId?: string;
  policyVersion?: string;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      policy: 'Policy',
      policyRegionId: 'PolicyRegionId',
      policyVersion: 'PolicyVersion',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      policy: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      policyRegionId: 'string',
      policyVersion: 'string',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBackupPolicyShrinkRequest extends $tea.Model {
  id?: number;
  name?: string;
  policyShrink?: string;
  policyRegionId?: string;
  policyVersion?: string;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      policyShrink: 'Policy',
      policyRegionId: 'PolicyRegionId',
      policyVersion: 'PolicyVersion',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      policyShrink: 'string',
      policyRegionId: 'string',
      policyVersion: 'string',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBackupPolicyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBackupPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyBackupPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyBackupPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBackupPolicyStatusRequest extends $tea.Model {
  id?: number;
  policyVersion?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      policyVersion: 'PolicyVersion',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      policyVersion: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBackupPolicyStatusResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyBackupPolicyStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyBackupPolicyStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyBackupPolicyStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClearLogstoreStorageRequest extends $tea.Model {
  from?: string;
  lang?: string;
  userLogStore?: string;
  userProject?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      lang: 'Lang',
      userLogStore: 'UserLogStore',
      userProject: 'UserProject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      lang: 'string',
      userLogStore: 'string',
      userProject: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClearLogstoreStorageResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClearLogstoreStorageResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyClearLogstoreStorageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyClearLogstoreStorageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClientConfSetupRequest extends $tea.Model {
  strategyConfig?: string;
  strategyTag?: string;
  strategyTagValue?: string;
  static names(): { [key: string]: string } {
    return {
      strategyConfig: 'StrategyConfig',
      strategyTag: 'StrategyTag',
      strategyTagValue: 'StrategyTagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      strategyConfig: 'string',
      strategyTag: 'string',
      strategyTagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClientConfSetupResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClientConfSetupResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyClientConfSetupResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyClientConfSetupResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClientConfStrategyRequest extends $tea.Model {
  tag?: string;
  tagExt?: string;
  tagValue?: string;
  uuid?: string;
  uuids?: string[];
  static names(): { [key: string]: string } {
    return {
      tag: 'Tag',
      tagExt: 'TagExt',
      tagValue: 'TagValue',
      uuid: 'Uuid',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tag: 'string',
      tagExt: 'string',
      tagValue: 'string',
      uuid: 'string',
      uuids: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClientConfStrategyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClientConfStrategyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyClientConfStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyClientConfStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClientUserDefineRuleRequest extends $tea.Model {
  actionType?: number;
  cmdline?: string;
  filePath?: string;
  IP?: string;
  id?: number;
  md5List?: string;
  name?: string;
  newFilePath?: string;
  parentCmdline?: string;
  parentProcPath?: string;
  platform?: string;
  port?: number;
  portStr?: string;
  procPath?: string;
  registryContent?: string;
  registryKey?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      actionType: 'ActionType',
      cmdline: 'Cmdline',
      filePath: 'FilePath',
      IP: 'IP',
      id: 'Id',
      md5List: 'Md5List',
      name: 'Name',
      newFilePath: 'NewFilePath',
      parentCmdline: 'ParentCmdline',
      parentProcPath: 'ParentProcPath',
      platform: 'Platform',
      port: 'Port',
      portStr: 'PortStr',
      procPath: 'ProcPath',
      registryContent: 'RegistryContent',
      registryKey: 'RegistryKey',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionType: 'number',
      cmdline: 'string',
      filePath: 'string',
      IP: 'string',
      id: 'number',
      md5List: 'string',
      name: 'string',
      newFilePath: 'string',
      parentCmdline: 'string',
      parentProcPath: 'string',
      platform: 'string',
      port: 'number',
      portStr: 'string',
      procPath: 'string',
      registryContent: 'string',
      registryKey: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClientUserDefineRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClientUserDefineRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyClientUserDefineRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyClientUserDefineRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterCnnfStatusUserConfirmRequest extends $tea.Model {
  clusterIds?: string[];
  userConfirm?: boolean;
  static names(): { [key: string]: string } {
    return {
      clusterIds: 'ClusterIds',
      userConfirm: 'UserConfirm',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterIds: { 'type': 'array', 'itemType': 'string' },
      userConfirm: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterCnnfStatusUserConfirmResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyClusterCnnfStatusUserConfirmResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyClusterCnnfStatusUserConfirmResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyClusterCnnfStatusUserConfirmResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyConcernNecessityRequest extends $tea.Model {
  concernNecessity?: string;
  static names(): { [key: string]: string } {
    return {
      concernNecessity: 'ConcernNecessity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      concernNecessity: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyConcernNecessityResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyConcernNecessityResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyConcernNecessityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyConcernNecessityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyContainerScanConfigRequest extends $tea.Model {
  appNames?: string;
  clusterId?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      appNames: 'AppNames',
      clusterId: 'ClusterId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appNames: 'string',
      clusterId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyContainerScanConfigResponseBody extends $tea.Model {
  data?: boolean;
  httpStatusCode?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      httpStatusCode: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyContainerScanConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyContainerScanConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyContainerScanConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCreateVulWhitelistRequest extends $tea.Model {
  reason?: string;
  targetInfo?: string;
  whitelist?: string;
  static names(): { [key: string]: string } {
    return {
      reason: 'Reason',
      targetInfo: 'TargetInfo',
      whitelist: 'Whitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      reason: 'string',
      targetInfo: 'string',
      whitelist: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCreateVulWhitelistResponseBody extends $tea.Model {
  requestId?: string;
  vulWhitelistList?: ModifyCreateVulWhitelistResponseBodyVulWhitelistList[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      vulWhitelistList: 'VulWhitelistList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      vulWhitelistList: { 'type': 'array', 'itemType': ModifyCreateVulWhitelistResponseBodyVulWhitelistList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCreateVulWhitelistResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyCreateVulWhitelistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyCreateVulWhitelistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCustomBlockRecordRequest extends $tea.Model {
  blockIp?: string;
  bound?: string;
  expireTime?: number;
  resourceOwnerId?: number;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      blockIp: 'BlockIp',
      bound: 'Bound',
      expireTime: 'ExpireTime',
      resourceOwnerId: 'ResourceOwnerId',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockIp: 'string',
      bound: 'string',
      expireTime: 'number',
      resourceOwnerId: 'number',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCustomBlockRecordResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCustomBlockRecordResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyCustomBlockRecordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyCustomBlockRecordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCycleTaskRequest extends $tea.Model {
  configId?: string;
  enable?: number;
  firstDateStr?: number;
  intervalPeriod?: number;
  param?: string;
  periodUnit?: string;
  targetEndTime?: number;
  targetStartTime?: number;
  taskName?: string;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      firstDateStr: 'FirstDateStr',
      intervalPeriod: 'IntervalPeriod',
      param: 'Param',
      periodUnit: 'PeriodUnit',
      targetEndTime: 'TargetEndTime',
      targetStartTime: 'TargetStartTime',
      taskName: 'TaskName',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      enable: 'number',
      firstDateStr: 'number',
      intervalPeriod: 'number',
      param: 'string',
      periodUnit: 'string',
      targetEndTime: 'number',
      targetStartTime: 'number',
      taskName: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCycleTaskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCycleTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyCycleTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyCycleTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyEmgVulSubmitRequest extends $tea.Model {
  lang?: string;
  name?: string;
  userAgreement?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      name: 'Name',
      userAgreement: 'UserAgreement',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      name: 'string',
      userAgreement: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyEmgVulSubmitResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyEmgVulSubmitResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyEmgVulSubmitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyEmgVulSubmitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyGroupPropertyRequest extends $tea.Model {
  data?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyGroupPropertyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyGroupPropertyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyGroupPropertyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyGroupPropertyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageFixCycleConfigRequest extends $tea.Model {
  imageFixCycle?: number;
  imageFixSwitch?: string;
  imageFixTarget?: string;
  imageTimeRange?: number;
  static names(): { [key: string]: string } {
    return {
      imageFixCycle: 'ImageFixCycle',
      imageFixSwitch: 'ImageFixSwitch',
      imageFixTarget: 'ImageFixTarget',
      imageTimeRange: 'ImageTimeRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageFixCycle: 'number',
      imageFixSwitch: 'string',
      imageFixTarget: 'string',
      imageTimeRange: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageFixCycleConfigResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyImageFixCycleConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyImageFixCycleConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyImageFixCycleConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAntiBruteForceRuleRequest extends $tea.Model {
  newRuleId?: number;
  resourceOwnerId?: number;
  sourceIp?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      newRuleId: 'NewRuleId',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      newRuleId: 'number',
      resourceOwnerId: 'number',
      sourceIp: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAntiBruteForceRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInstanceAntiBruteForceRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyInstanceAntiBruteForceRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInstanceAntiBruteForceRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInterceptionRuleRequest extends $tea.Model {
  clusterId?: string;
  dstTarget?: { [key: string]: any };
  interceptType?: number;
  orderIndex?: number;
  ruleId?: number;
  ruleName?: string;
  ruleSwitch?: number;
  srcTarget?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dstTarget: 'DstTarget',
      interceptType: 'InterceptType',
      orderIndex: 'OrderIndex',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleSwitch: 'RuleSwitch',
      srcTarget: 'SrcTarget',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dstTarget: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      interceptType: 'number',
      orderIndex: 'number',
      ruleId: 'number',
      ruleName: 'string',
      ruleSwitch: 'number',
      srcTarget: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInterceptionRuleShrinkRequest extends $tea.Model {
  clusterId?: string;
  dstTargetShrink?: string;
  interceptType?: number;
  orderIndex?: number;
  ruleId?: number;
  ruleName?: string;
  ruleSwitch?: number;
  srcTargetShrink?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      dstTargetShrink: 'DstTarget',
      interceptType: 'InterceptType',
      orderIndex: 'OrderIndex',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleSwitch: 'RuleSwitch',
      srcTargetShrink: 'SrcTarget',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      dstTargetShrink: 'string',
      interceptType: 'number',
      orderIndex: 'number',
      ruleId: 'number',
      ruleName: 'string',
      ruleSwitch: 'number',
      srcTargetShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInterceptionRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInterceptionRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyInterceptionRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInterceptionRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInterceptionRuleSwitchRequest extends $tea.Model {
  clusterId?: string;
  ruleIds?: string;
  ruleSwitch?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      ruleIds: 'RuleIds',
      ruleSwitch: 'RuleSwitch',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      ruleIds: 'string',
      ruleSwitch: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInterceptionRuleSwitchResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInterceptionRuleSwitchResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyInterceptionRuleSwitchResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInterceptionRuleSwitchResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInterceptionTargetRequest extends $tea.Model {
  appName?: string;
  imageList?: string[];
  namespace?: string;
  tagList?: string[];
  targetId?: number;
  targetName?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      imageList: 'ImageList',
      namespace: 'Namespace',
      tagList: 'TagList',
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      imageList: { 'type': 'array', 'itemType': 'string' },
      namespace: 'string',
      tagList: { 'type': 'array', 'itemType': 'string' },
      targetId: 'number',
      targetName: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInterceptionTargetResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyInterceptionTargetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyInterceptionTargetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyInterceptionTargetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLogMetaStatusRequest extends $tea.Model {
  from?: string;
  logStore?: string;
  project?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      logStore: 'LogStore',
      project: 'Project',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      logStore: 'string',
      project: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLogMetaStatusResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLogMetaStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyLogMetaStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyLogMetaStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLoginBaseConfigRequest extends $tea.Model {
  config?: string;
  target?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      target: 'Target',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      target: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLoginBaseConfigResponseBody extends $tea.Model {
  code?: string;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLoginBaseConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyLoginBaseConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyLoginBaseConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLoginSwitchConfigRequest extends $tea.Model {
  item?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLoginSwitchConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyLoginSwitchConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyLoginSwitchConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyLoginSwitchConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyNoticeConfigRequest extends $tea.Model {
  project?: string;
  route?: number;
  sourceIp?: string;
  timeLimit?: number;
  static names(): { [key: string]: string } {
    return {
      project: 'Project',
      route: 'Route',
      sourceIp: 'SourceIp',
      timeLimit: 'TimeLimit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      project: 'string',
      route: 'number',
      sourceIp: 'string',
      timeLimit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyNoticeConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyNoticeConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyNoticeConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyNoticeConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyOpenLogShipperRequest extends $tea.Model {
  from?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyOpenLogShipperResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyOpenLogShipperResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyOpenLogShipperResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyOpenLogShipperResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyOperateVulRequest extends $tea.Model {
  from?: string;
  info?: string;
  operateType?: string;
  reason?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      info: 'Info',
      operateType: 'OperateType',
      reason: 'Reason',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      info: 'string',
      operateType: 'string',
      reason: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyOperateVulResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyOperateVulResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyOperateVulResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyOperateVulResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPropertyScheduleConfigRequest extends $tea.Model {
  scheduleTime?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      scheduleTime: 'ScheduleTime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scheduleTime: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPropertyScheduleConfigResponseBody extends $tea.Model {
  modifyResult?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      modifyResult: 'ModifyResult',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      modifyResult: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPropertyScheduleConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyPropertyScheduleConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyPropertyScheduleConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPushAllTaskRequest extends $tea.Model {
  sourceIp?: string;
  tasks?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      sourceIp: 'SourceIp',
      tasks: 'Tasks',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceIp: 'string',
      tasks: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPushAllTaskResponseBody extends $tea.Model {
  pushTaskRsp?: ModifyPushAllTaskResponseBodyPushTaskRsp;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      pushTaskRsp: 'PushTaskRsp',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pushTaskRsp: ModifyPushAllTaskResponseBodyPushTaskRsp,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPushAllTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyPushAllTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyPushAllTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRefreshProcessInfoRequest extends $tea.Model {
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRefreshProcessInfoResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRefreshProcessInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyRefreshProcessInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyRefreshProcessInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRiskCheckStatusRequest extends $tea.Model {
  itemId?: number;
  lang?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  status?: string;
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      itemId: 'ItemId',
      lang: 'Lang',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemId: 'number',
      lang: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
      status: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRiskCheckStatusResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRiskCheckStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyRiskCheckStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyRiskCheckStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRiskSingleResultStatusRequest extends $tea.Model {
  ids?: string[];
  lang?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  status?: string;
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      ids: 'Ids',
      lang: 'Lang',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ids: { 'type': 'array', 'itemType': 'string' },
      lang: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
      status: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRiskSingleResultStatusResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyRiskSingleResultStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyRiskSingleResultStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyRiskSingleResultStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityCheckScheduleConfigRequest extends $tea.Model {
  daysOfWeek?: string;
  endTime?: number;
  lang?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      daysOfWeek: 'DaysOfWeek',
      endTime: 'EndTime',
      lang: 'Lang',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      daysOfWeek: 'string',
      endTime: 'number',
      lang: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityCheckScheduleConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityCheckScheduleConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifySecurityCheckScheduleConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifySecurityCheckScheduleConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityEventMarkMissIndividuallyRequest extends $tea.Model {
  deleteMarkMissParam?: string;
  from?: string;
  insertMarkMissParam?: string;
  lang?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      deleteMarkMissParam: 'DeleteMarkMissParam',
      from: 'From',
      insertMarkMissParam: 'InsertMarkMissParam',
      lang: 'Lang',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deleteMarkMissParam: 'string',
      from: 'string',
      insertMarkMissParam: 'string',
      lang: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityEventMarkMissIndividuallyResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  timeCost?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      timeCost: 'TimeCost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      timeCost: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifySecurityEventMarkMissIndividuallyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifySecurityEventMarkMissIndividuallyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifySecurityEventMarkMissIndividuallyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStartVulScanRequest extends $tea.Model {
  types?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      types: 'Types',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      types: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStartVulScanResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStartVulScanResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyStartVulScanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyStartVulScanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStrategyRequest extends $tea.Model {
  customType?: string;
  cycleDays?: string;
  cycleStartTime?: string;
  endTime?: string;
  id?: string;
  name?: string;
  riskCustomParams?: string;
  riskSubTypeName?: string;
  sourceIp?: string;
  startTime?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      customType: 'CustomType',
      cycleDays: 'CycleDays',
      cycleStartTime: 'CycleStartTime',
      endTime: 'EndTime',
      id: 'Id',
      name: 'Name',
      riskCustomParams: 'RiskCustomParams',
      riskSubTypeName: 'RiskSubTypeName',
      sourceIp: 'SourceIp',
      startTime: 'StartTime',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customType: 'string',
      cycleDays: 'string',
      cycleStartTime: 'string',
      endTime: 'string',
      id: 'string',
      name: 'string',
      riskCustomParams: 'string',
      riskSubTypeName: 'string',
      sourceIp: 'string',
      startTime: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStrategyResponseBody extends $tea.Model {
  httpStatusCode?: number;
  requestId?: string;
  result?: ModifyStrategyResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      httpStatusCode: 'number',
      requestId: 'string',
      result: ModifyStrategyResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStrategyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStrategyTargetRequest extends $tea.Model {
  config?: string;
  sourceIp?: string;
  target?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      sourceIp: 'SourceIp',
      target: 'Target',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      sourceIp: 'string',
      target: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStrategyTargetResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStrategyTargetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyStrategyTargetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyStrategyTargetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagWithUuidRequest extends $tea.Model {
  machineTypes?: string;
  tagId?: string;
  tagList?: string;
  uuidList?: string;
  static names(): { [key: string]: string } {
    return {
      machineTypes: 'MachineTypes',
      tagId: 'TagId',
      tagList: 'TagList',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      machineTypes: 'string',
      tagId: 'string',
      tagList: 'string',
      uuidList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagWithUuidResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTagWithUuidResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyTagWithUuidResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTagWithUuidResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyUniBackupPolicyRequest extends $tea.Model {
  accountName?: string;
  accountPassword?: string;
  fullPlan?: { [key: string]: any };
  incPlan?: { [key: string]: any };
  policyId?: number;
  policyName?: string;
  policyStatus?: string;
  retention?: number;
  speedLimiter?: number;
  static names(): { [key: string]: string } {
    return {
      accountName: 'AccountName',
      accountPassword: 'AccountPassword',
      fullPlan: 'FullPlan',
      incPlan: 'IncPlan',
      policyId: 'PolicyId',
      policyName: 'PolicyName',
      policyStatus: 'PolicyStatus',
      retention: 'Retention',
      speedLimiter: 'SpeedLimiter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountName: 'string',
      accountPassword: 'string',
      fullPlan: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      incPlan: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      policyId: 'number',
      policyName: 'string',
      policyStatus: 'string',
      retention: 'number',
      speedLimiter: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyUniBackupPolicyShrinkRequest extends $tea.Model {
  accountName?: string;
  accountPassword?: string;
  fullPlanShrink?: string;
  incPlanShrink?: string;
  policyId?: number;
  policyName?: string;
  policyStatus?: string;
  retention?: number;
  speedLimiter?: number;
  static names(): { [key: string]: string } {
    return {
      accountName: 'AccountName',
      accountPassword: 'AccountPassword',
      fullPlanShrink: 'FullPlan',
      incPlanShrink: 'IncPlan',
      policyId: 'PolicyId',
      policyName: 'PolicyName',
      policyStatus: 'PolicyStatus',
      retention: 'Retention',
      speedLimiter: 'SpeedLimiter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountName: 'string',
      accountPassword: 'string',
      fullPlanShrink: 'string',
      incPlanShrink: 'string',
      policyId: 'number',
      policyName: 'string',
      policyStatus: 'string',
      retention: 'number',
      speedLimiter: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyUniBackupPolicyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyUniBackupPolicyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyUniBackupPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyUniBackupPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVpcHoneyPotRequest extends $tea.Model {
  honeyPotAction?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      honeyPotAction: 'HoneyPotAction',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeyPotAction: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVpcHoneyPotResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVpcHoneyPotResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyVpcHoneyPotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyVpcHoneyPotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVulConfigRequest extends $tea.Model {
  config?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVulConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVulConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyVulConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyVulConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVulTargetRequest extends $tea.Model {
  config?: string;
  target?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVulTargetResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVulTargetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyVulTargetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyVulTargetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVulTargetConfigRequest extends $tea.Model {
  config?: string;
  sourceIp?: string;
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      sourceIp: 'SourceIp',
      type: 'Type',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      sourceIp: 'string',
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVulTargetConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVulTargetConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyVulTargetConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyVulTargetConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVulWhitelistTargetRequest extends $tea.Model {
  id?: number;
  reason?: string;
  sourceIp?: string;
  targetInfo?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      reason: 'Reason',
      sourceIp: 'SourceIp',
      targetInfo: 'TargetInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      reason: 'string',
      sourceIp: 'string',
      targetInfo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVulWhitelistTargetResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyVulWhitelistTargetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyVulWhitelistTargetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyVulWhitelistTargetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockCreateConfigRequest extends $tea.Model {
  defenceMode?: string;
  dir?: string;
  exclusiveDir?: string;
  exclusiveFile?: string;
  exclusiveFileType?: string;
  inclusiveFile?: string;
  inclusiveFileType?: string;
  lang?: string;
  localBackupDir?: string;
  mode?: string;
  sourceIp?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      defenceMode: 'DefenceMode',
      dir: 'Dir',
      exclusiveDir: 'ExclusiveDir',
      exclusiveFile: 'ExclusiveFile',
      exclusiveFileType: 'ExclusiveFileType',
      inclusiveFile: 'InclusiveFile',
      inclusiveFileType: 'InclusiveFileType',
      lang: 'Lang',
      localBackupDir: 'LocalBackupDir',
      mode: 'Mode',
      sourceIp: 'SourceIp',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenceMode: 'string',
      dir: 'string',
      exclusiveDir: 'string',
      exclusiveFile: 'string',
      exclusiveFileType: 'string',
      inclusiveFile: 'string',
      inclusiveFileType: 'string',
      lang: 'string',
      localBackupDir: 'string',
      mode: 'string',
      sourceIp: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockCreateConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockCreateConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyWebLockCreateConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebLockCreateConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockDeleteConfigRequest extends $tea.Model {
  id?: number;
  lang?: string;
  sourceIp?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      lang: 'Lang',
      sourceIp: 'SourceIp',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      lang: 'string',
      sourceIp: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockDeleteConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockDeleteConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyWebLockDeleteConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebLockDeleteConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockProcessStatusRequest extends $tea.Model {
  dealAll?: number;
  operateInfo?: string;
  processPath?: string[];
  status?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      dealAll: 'DealAll',
      operateInfo: 'OperateInfo',
      processPath: 'ProcessPath',
      status: 'Status',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dealAll: 'number',
      operateInfo: 'string',
      processPath: { 'type': 'array', 'itemType': 'string' },
      status: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockProcessStatusResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockProcessStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyWebLockProcessStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebLockProcessStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockStartRequest extends $tea.Model {
  defenceMode?: string;
  dir?: string;
  exclusiveDir?: string;
  exclusiveFile?: string;
  exclusiveFileType?: string;
  inclusiveFileType?: string;
  localBackupDir?: string;
  mode?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      defenceMode: 'DefenceMode',
      dir: 'Dir',
      exclusiveDir: 'ExclusiveDir',
      exclusiveFile: 'ExclusiveFile',
      exclusiveFileType: 'ExclusiveFileType',
      inclusiveFileType: 'InclusiveFileType',
      localBackupDir: 'LocalBackupDir',
      mode: 'Mode',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenceMode: 'string',
      dir: 'string',
      exclusiveDir: 'string',
      exclusiveFile: 'string',
      exclusiveFileType: 'string',
      inclusiveFileType: 'string',
      localBackupDir: 'string',
      mode: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockStartResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockStartResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyWebLockStartResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebLockStartResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockStatusRequest extends $tea.Model {
  lang?: string;
  sourceIp?: string;
  status?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      sourceIp: 'SourceIp',
      status: 'Status',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      sourceIp: 'string',
      status: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockStatusResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyWebLockStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebLockStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockUnbindRequest extends $tea.Model {
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockUnbindResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockUnbindResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyWebLockUnbindResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebLockUnbindResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockUpdateConfigRequest extends $tea.Model {
  defenceMode?: string;
  dir?: string;
  exclusiveDir?: string;
  exclusiveFile?: string;
  exclusiveFileType?: string;
  id?: number;
  inclusiveFile?: string;
  inclusiveFileType?: string;
  lang?: string;
  localBackupDir?: string;
  mode?: string;
  sourceIp?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      defenceMode: 'DefenceMode',
      dir: 'Dir',
      exclusiveDir: 'ExclusiveDir',
      exclusiveFile: 'ExclusiveFile',
      exclusiveFileType: 'ExclusiveFileType',
      id: 'Id',
      inclusiveFile: 'InclusiveFile',
      inclusiveFileType: 'InclusiveFileType',
      lang: 'Lang',
      localBackupDir: 'LocalBackupDir',
      mode: 'Mode',
      sourceIp: 'SourceIp',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenceMode: 'string',
      dir: 'string',
      exclusiveDir: 'string',
      exclusiveFile: 'string',
      exclusiveFileType: 'string',
      id: 'number',
      inclusiveFile: 'string',
      inclusiveFileType: 'string',
      lang: 'string',
      localBackupDir: 'string',
      mode: 'string',
      sourceIp: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockUpdateConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebLockUpdateConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyWebLockUpdateConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebLockUpdateConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebPathRequest extends $tea.Model {
  config?: string;
  target?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      target: 'Target',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      target: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebPathResponseBody extends $tea.Model {
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyWebPathResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ModifyWebPathResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyWebPathResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenSensitiveFileScanRequest extends $tea.Model {
  switchOn?: string;
  static names(): { [key: string]: string } {
    return {
      switchOn: 'SwitchOn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      switchOn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenSensitiveFileScanResponseBody extends $tea.Model {
  code?: string;
  data?: OpenSensitiveFileScanResponseBodyData;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: OpenSensitiveFileScanResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenSensitiveFileScanResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OpenSensitiveFileScanResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OpenSensitiveFileScanResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateAgentClientInstallRequest extends $tea.Model {
  instanceIds?: string;
  lang?: string;
  os?: string;
  region?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      instanceIds: 'InstanceIds',
      lang: 'Lang',
      os: 'Os',
      region: 'Region',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceIds: 'string',
      lang: 'string',
      os: 'string',
      region: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateAgentClientInstallResponseBody extends $tea.Model {
  aegisCelintInstallResposeList?: OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList[];
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      aegisCelintInstallResposeList: 'AegisCelintInstallResposeList',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aegisCelintInstallResposeList: { 'type': 'array', 'itemType': OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList },
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateAgentClientInstallResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OperateAgentClientInstallResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperateAgentClientInstallResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateBucketScanTaskRequest extends $tea.Model {
  bucketName?: string;
  operateCode?: number;
  static names(): { [key: string]: string } {
    return {
      bucketName: 'BucketName',
      operateCode: 'OperateCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketName: 'string',
      operateCode: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateBucketScanTaskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateBucketScanTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OperateBucketScanTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperateBucketScanTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateCommonOverallConfigRequest extends $tea.Model {
  config?: string;
  sourceIp?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      sourceIp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateCommonOverallConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateCommonOverallConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OperateCommonOverallConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperateCommonOverallConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateCommonTargetConfigRequest extends $tea.Model {
  fieldName?: string;
  fieldValue?: string;
  sourceIp?: string;
  targetOperations?: string;
  targetType?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      fieldName: 'FieldName',
      fieldValue: 'FieldValue',
      sourceIp: 'SourceIp',
      targetOperations: 'TargetOperations',
      targetType: 'TargetType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldName: 'string',
      fieldValue: 'string',
      sourceIp: 'string',
      targetOperations: 'string',
      targetType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateCommonTargetConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateCommonTargetConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OperateCommonTargetConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperateCommonTargetConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateImageBaselineWhitelistRequest extends $tea.Model {
  baselineItemKeyList?: string;
  imageUuid?: string;
  lang?: string;
  operation?: string;
  scanRange?: string[];
  static names(): { [key: string]: string } {
    return {
      baselineItemKeyList: 'BaselineItemKeyList',
      imageUuid: 'ImageUuid',
      lang: 'Lang',
      operation: 'Operation',
      scanRange: 'ScanRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineItemKeyList: 'string',
      imageUuid: 'string',
      lang: 'string',
      operation: 'string',
      scanRange: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateImageBaselineWhitelistResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateImageBaselineWhitelistResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OperateImageBaselineWhitelistResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperateImageBaselineWhitelistResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateImageVulRequest extends $tea.Model {
  info?: string;
  operateType?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      info: 'Info',
      operateType: 'OperateType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      info: 'string',
      operateType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateImageVulResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateImageVulResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OperateImageVulResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperateImageVulResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateSuspiciousOverallConfigRequest extends $tea.Model {
  config?: string;
  lang?: string;
  noTargetAsOn?: boolean;
  sourceIp?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      lang: 'Lang',
      noTargetAsOn: 'NoTargetAsOn',
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      lang: 'string',
      noTargetAsOn: 'boolean',
      sourceIp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateSuspiciousOverallConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateSuspiciousOverallConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OperateSuspiciousOverallConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperateSuspiciousOverallConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateSuspiciousTargetConfigRequest extends $tea.Model {
  lang?: string;
  sourceIp?: string;
  targetOperations?: string;
  targetType?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
      sourceIp: 'SourceIp',
      targetOperations: 'TargetOperations',
      targetType: 'TargetType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
      sourceIp: 'string',
      targetOperations: 'string',
      targetType: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateSuspiciousTargetConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateSuspiciousTargetConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OperateSuspiciousTargetConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperateSuspiciousTargetConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateVirusEventsRequest extends $tea.Model {
  operationAll?: number;
  operationCode?: string;
  operationRange?: string;
  static names(): { [key: string]: string } {
    return {
      operationAll: 'OperationAll',
      operationCode: 'OperationCode',
      operationRange: 'OperationRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operationAll: 'number',
      operationCode: 'string',
      operationRange: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateVirusEventsResponseBody extends $tea.Model {
  requestId?: string;
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateVirusEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OperateVirusEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperateVirusEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateVulsRequest extends $tea.Model {
  operateType?: string;
  type?: string;
  uuids?: string[];
  vulNames?: string[];
  static names(): { [key: string]: string } {
    return {
      operateType: 'OperateType',
      type: 'Type',
      uuids: 'Uuids',
      vulNames: 'VulNames',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operateType: 'string',
      type: 'string',
      uuids: { 'type': 'array', 'itemType': 'string' },
      vulNames: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateVulsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateVulsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OperateVulsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperateVulsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateWebLockFileEventsRequest extends $tea.Model {
  dealAll?: number;
  eventIds?: number[];
  operationCode?: string;
  static names(): { [key: string]: string } {
    return {
      dealAll: 'DealAll',
      eventIds: 'EventIds',
      operationCode: 'OperationCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dealAll: 'number',
      eventIds: { 'type': 'array', 'itemType': 'number' },
      operationCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateWebLockFileEventsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateWebLockFileEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OperateWebLockFileEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperateWebLockFileEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperationCancelIgnoreSuspEventRequest extends $tea.Model {
  remark?: string;
  securityEventIds?: number[];
  static names(): { [key: string]: string } {
    return {
      remark: 'Remark',
      securityEventIds: 'SecurityEventIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      remark: 'string',
      securityEventIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperationCancelIgnoreSuspEventResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  timeCost?: number;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
      timeCost: 'TimeCost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
      timeCost: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperationCancelIgnoreSuspEventResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OperationCancelIgnoreSuspEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperationCancelIgnoreSuspEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperationSuspEventsRequest extends $tea.Model {
  from?: string;
  operation?: string;
  sourceIp?: string;
  subOperation?: string;
  suspiciousEventIds?: string;
  warnType?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      operation: 'Operation',
      sourceIp: 'SourceIp',
      subOperation: 'SubOperation',
      suspiciousEventIds: 'SuspiciousEventIds',
      warnType: 'WarnType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      operation: 'string',
      sourceIp: 'string',
      subOperation: 'string',
      suspiciousEventIds: 'string',
      warnType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperationSuspEventsResponseBody extends $tea.Model {
  accessCode?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      accessCode: 'AccessCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessCode: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperationSuspEventsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: OperationSuspEventsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperationSuspEventsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageImageRegistryRequest extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  registryNameLike?: string;
  registryTypeInList?: string[];
  registryTypeNotInList?: string[];
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      registryNameLike: 'RegistryNameLike',
      registryTypeInList: 'RegistryTypeInList',
      registryTypeNotInList: 'RegistryTypeNotInList',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      registryNameLike: 'string',
      registryTypeInList: { 'type': 'array', 'itemType': 'string' },
      registryTypeNotInList: { 'type': 'array', 'itemType': 'string' },
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageImageRegistryResponseBody extends $tea.Model {
  list?: PageImageRegistryResponseBodyList[];
  pageInfo?: PageImageRegistryResponseBodyPageInfo;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': PageImageRegistryResponseBodyList },
      pageInfo: PageImageRegistryResponseBodyPageInfo,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageImageRegistryResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PageImageRegistryResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PageImageRegistryResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PauseClientRequest extends $tea.Model {
  uuids?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      uuids: 'Uuids',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      uuids: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PauseClientResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PauseClientResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PauseClientResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PauseClientResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublicCreateImageScanTaskRequest extends $tea.Model {
  digests?: string;
  instanceIds?: string;
  regionIds?: string;
  registryTypes?: string;
  repoIds?: string;
  repoNames?: string;
  repoNamespaces?: string;
  sourceIp?: string;
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      digests: 'Digests',
      instanceIds: 'InstanceIds',
      regionIds: 'RegionIds',
      registryTypes: 'RegistryTypes',
      repoIds: 'RepoIds',
      repoNames: 'RepoNames',
      repoNamespaces: 'RepoNamespaces',
      sourceIp: 'SourceIp',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      digests: 'string',
      instanceIds: 'string',
      regionIds: 'string',
      registryTypes: 'string',
      repoIds: 'string',
      repoNames: 'string',
      repoNamespaces: 'string',
      sourceIp: 'string',
      tags: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublicCreateImageScanTaskResponseBody extends $tea.Model {
  data?: PublicCreateImageScanTaskResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: PublicCreateImageScanTaskResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublicCreateImageScanTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PublicCreateImageScanTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublicCreateImageScanTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublicPreCheckImageScanTaskRequest extends $tea.Model {
  digests?: string;
  instanceIds?: string;
  regionIds?: string;
  registryTypes?: string;
  repoIds?: string;
  repoNames?: string;
  repoNamespaces?: string;
  sourceIp?: string;
  tags?: string;
  static names(): { [key: string]: string } {
    return {
      digests: 'Digests',
      instanceIds: 'InstanceIds',
      regionIds: 'RegionIds',
      registryTypes: 'RegistryTypes',
      repoIds: 'RepoIds',
      repoNames: 'RepoNames',
      repoNamespaces: 'RepoNamespaces',
      sourceIp: 'SourceIp',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      digests: 'string',
      instanceIds: 'string',
      regionIds: 'string',
      registryTypes: 'string',
      repoIds: 'string',
      repoNames: 'string',
      repoNamespaces: 'string',
      sourceIp: 'string',
      tags: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublicPreCheckImageScanTaskResponseBody extends $tea.Model {
  data?: PublicPreCheckImageScanTaskResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: PublicPreCheckImageScanTaskResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublicPreCheckImageScanTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PublicPreCheckImageScanTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublicPreCheckImageScanTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublicSyncAndCreateImageScanTaskRequest extends $tea.Model {
  images?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      images: 'Images',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      images: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublicSyncAndCreateImageScanTaskResponseBody extends $tea.Model {
  data?: PublicSyncAndCreateImageScanTaskResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: PublicSyncAndCreateImageScanTaskResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublicSyncAndCreateImageScanTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: PublicSyncAndCreateImageScanTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: PublicSyncAndCreateImageScanTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAttackCountRequest extends $tea.Model {
  from?: string;
  lang?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      lang: 'Lang',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      lang: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAttackCountResponseBody extends $tea.Model {
  code?: string;
  count?: number;
  data?: QueryAttackCountResponseBodyData[];
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      count: 'Count',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      count: 'number',
      data: { 'type': 'array', 'itemType': QueryAttackCountResponseBodyData },
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAttackCountResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryAttackCountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryAttackCountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDiscoverDatabaseRequest extends $tea.Model {
  createMark?: string;
  static names(): { [key: string]: string } {
    return {
      createMark: 'CreateMark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createMark: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDiscoverDatabaseResponseBody extends $tea.Model {
  requestId?: string;
  taskProgress?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      taskProgress: 'TaskProgress',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      taskProgress: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryDiscoverDatabaseResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryDiscoverDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryDiscoverDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGroupIdByGroupNameRequest extends $tea.Model {
  groupName?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      groupName: 'GroupName',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupName: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGroupIdByGroupNameResponseBody extends $tea.Model {
  groupId?: number;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGroupIdByGroupNameResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryGroupIdByGroupNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryGroupIdByGroupNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGroupedSecurityEventMarkMissListRequest extends $tea.Model {
  currentPage?: number;
  disposalWay?: string;
  eventName?: string;
  from?: string;
  lang?: string;
  pageSize?: number;
  remark?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      disposalWay: 'DisposalWay',
      eventName: 'EventName',
      from: 'From',
      lang: 'Lang',
      pageSize: 'PageSize',
      remark: 'Remark',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      disposalWay: 'string',
      eventName: 'string',
      from: 'string',
      lang: 'string',
      pageSize: 'number',
      remark: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGroupedSecurityEventMarkMissListResponseBody extends $tea.Model {
  code?: string;
  list?: QueryGroupedSecurityEventMarkMissListResponseBodyList[];
  message?: string;
  pageInfo?: QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      list: 'List',
      message: 'Message',
      pageInfo: 'PageInfo',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      list: { 'type': 'array', 'itemType': QueryGroupedSecurityEventMarkMissListResponseBodyList },
      message: 'string',
      pageInfo: QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo,
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGroupedSecurityEventMarkMissListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryGroupedSecurityEventMarkMissListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryGroupedSecurityEventMarkMissListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJenkinsImageRegistryPersistenceDayRequest extends $tea.Model {
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJenkinsImageRegistryPersistenceDayResponseBody extends $tea.Model {
  data?: number;
  httpStatusCode?: number;
  requestId?: string;
  timeCost?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      timeCost: 'TimeCost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'number',
      httpStatusCode: 'number',
      requestId: 'string',
      timeCost: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryJenkinsImageRegistryPersistenceDayResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryJenkinsImageRegistryPersistenceDayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryJenkinsImageRegistryPersistenceDayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPreCheckDatabaseRequest extends $tea.Model {
  instanceUuid?: string;
  taskId?: string;
  uniRegionId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceUuid: 'InstanceUuid',
      taskId: 'TaskId',
      uniRegionId: 'UniRegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceUuid: 'string',
      taskId: 'string',
      uniRegionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPreCheckDatabaseResponseBody extends $tea.Model {
  completedTime?: number;
  createdTime?: number;
  description?: string;
  progress?: number;
  requestId?: string;
  result?: string;
  updatedTime?: number;
  static names(): { [key: string]: string } {
    return {
      completedTime: 'CompletedTime',
      createdTime: 'CreatedTime',
      description: 'Description',
      progress: 'Progress',
      requestId: 'RequestId',
      result: 'Result',
      updatedTime: 'UpdatedTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      completedTime: 'number',
      createdTime: 'number',
      description: 'string',
      progress: 'number',
      requestId: 'string',
      result: 'string',
      updatedTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryPreCheckDatabaseResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: QueryPreCheckDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryPreCheckDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebootMachineRequest extends $tea.Model {
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebootMachineResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RebootMachineResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RebootMachineResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RebootMachineResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshAssetsRequest extends $tea.Model {
  assetType?: string;
  cloudAssetSubType?: number;
  cloudAssetType?: number;
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      assetType: 'AssetType',
      cloudAssetSubType: 'CloudAssetSubType',
      cloudAssetType: 'CloudAssetType',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetType: 'string',
      cloudAssetSubType: 'number',
      cloudAssetType: 'number',
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshAssetsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshAssetsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RefreshAssetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RefreshAssetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshContainerAssetsRequest extends $tea.Model {
  assetType?: string;
  static names(): { [key: string]: string } {
    return {
      assetType: 'AssetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshContainerAssetsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshContainerAssetsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RefreshContainerAssetsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RefreshContainerAssetsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshOssBucketScanInfoResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RefreshOssBucketScanInfoResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RefreshOssBucketScanInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RefreshOssBucketScanInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveCheckInstanceResultWhiteListRequest extends $tea.Model {
  checkId?: number;
  instanceIds?: string[];
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveCheckInstanceResultWhiteListResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveCheckInstanceResultWhiteListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RemoveCheckInstanceResultWhiteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveCheckInstanceResultWhiteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveCheckResultWhiteListRequest extends $tea.Model {
  checkGroupId?: string;
  checkIds?: number[];
  type?: string;
  static names(): { [key: string]: string } {
    return {
      checkGroupId: 'CheckGroupId',
      checkIds: 'CheckIds',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkGroupId: 'string',
      checkIds: { 'type': 'array', 'itemType': 'number' },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveCheckResultWhiteListResponseBody extends $tea.Model {
  code?: string;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RemoveCheckResultWhiteListResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RemoveCheckResultWhiteListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RemoveCheckResultWhiteListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryAgentlessTaskRequest extends $tea.Model {
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryAgentlessTaskResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryAgentlessTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RetryAgentlessTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RetryAgentlessTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryInstallProbeRequest extends $tea.Model {
  probeId?: string;
  static names(): { [key: string]: string } {
    return {
      probeId: 'ProbeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      probeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryInstallProbeResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RetryInstallProbeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RetryInstallProbeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RetryInstallProbeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackSuspEventQuaraFileRequest extends $tea.Model {
  from?: string;
  quaraFileId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      quaraFileId: 'QuaraFileId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      quaraFileId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackSuspEventQuaraFileResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RollbackSuspEventQuaraFileResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: RollbackSuspEventQuaraFileResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RollbackSuspEventQuaraFileResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SasInstallCodeRequest extends $tea.Model {
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SasInstallCodeResponseBody extends $tea.Model {
  requestId?: string;
  data?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      data: 'data',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      data: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SasInstallCodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SasInstallCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SasInstallCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveImageBaselineStrategyRequest extends $tea.Model {
  baselineItemList?: string;
  lang?: string;
  source?: string;
  strategyId?: number;
  strategyName?: string;
  static names(): { [key: string]: string } {
    return {
      baselineItemList: 'BaselineItemList',
      lang: 'Lang',
      source: 'Source',
      strategyId: 'StrategyId',
      strategyName: 'StrategyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineItemList: 'string',
      lang: 'string',
      source: 'string',
      strategyId: 'number',
      strategyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveImageBaselineStrategyResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveImageBaselineStrategyResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SaveImageBaselineStrategyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SaveImageBaselineStrategyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveSuspEventUserSettingRequest extends $tea.Model {
  from?: string;
  levelsOn?: string;
  static names(): { [key: string]: string } {
    return {
      from: 'From',
      levelsOn: 'LevelsOn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      from: 'string',
      levelsOn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveSuspEventUserSettingResponseBody extends $tea.Model {
  code?: string;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SaveSuspEventUserSettingResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SaveSuspEventUserSettingResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SaveSuspEventUserSettingResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetClusterInterceptionConfigRequest extends $tea.Model {
  clusterIds?: string;
  switchOn?: number;
  switchType?: number;
  static names(): { [key: string]: string } {
    return {
      clusterIds: 'ClusterIds',
      switchOn: 'SwitchOn',
      switchType: 'SwitchType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterIds: 'string',
      switchOn: 'number',
      switchType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetClusterInterceptionConfigResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetClusterInterceptionConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetClusterInterceptionConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetClusterInterceptionConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetImageSensitiveFileStatusRequest extends $tea.Model {
  imageUuids?: string;
  sensitiveFileKey?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      imageUuids: 'ImageUuids',
      sensitiveFileKey: 'SensitiveFileKey',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageUuids: 'string',
      sensitiveFileKey: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetImageSensitiveFileStatusResponseBody extends $tea.Model {
  code?: string;
  data?: SetImageSensitiveFileStatusResponseBodyData;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: SetImageSensitiveFileStatusResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetImageSensitiveFileStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetImageSensitiveFileStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetImageSensitiveFileStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRegistryScanDayNumRequest extends $tea.Model {
  scanDayNum?: number;
  static names(): { [key: string]: string } {
    return {
      scanDayNum: 'ScanDayNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scanDayNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRegistryScanDayNumResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetRegistryScanDayNumResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetRegistryScanDayNumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetRegistryScanDayNumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetSensitiveDefineRuleConfigRequest extends $tea.Model {
  config?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetSensitiveDefineRuleConfigResponseBody extends $tea.Model {
  code?: string;
  data?: SetSensitiveDefineRuleConfigResponseBodyData;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: SetSensitiveDefineRuleConfigResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetSensitiveDefineRuleConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SetSensitiveDefineRuleConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SetSensitiveDefineRuleConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartBaselineSecurityCheckRequest extends $tea.Model {
  itemIds?: number[];
  lang?: string;
  resourceOwnerId?: number;
  sourceIp?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      itemIds: 'ItemIds',
      lang: 'Lang',
      resourceOwnerId: 'ResourceOwnerId',
      sourceIp: 'SourceIp',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      itemIds: { 'type': 'array', 'itemType': 'number' },
      lang: 'string',
      resourceOwnerId: 'number',
      sourceIp: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartBaselineSecurityCheckResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartBaselineSecurityCheckResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StartBaselineSecurityCheckResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartBaselineSecurityCheckResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDiscoverDatabaseTaskResponseBody extends $tea.Model {
  createMark?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      createMark: 'CreateMark',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createMark: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartDiscoverDatabaseTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StartDiscoverDatabaseTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartDiscoverDatabaseTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPreCheckDatabaseRequest extends $tea.Model {
  databaseType?: string;
  instanceUuid?: string;
  uniRegionId?: string;
  static names(): { [key: string]: string } {
    return {
      databaseType: 'DatabaseType',
      instanceUuid: 'InstanceUuid',
      uniRegionId: 'UniRegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      databaseType: 'string',
      instanceUuid: 'string',
      uniRegionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPreCheckDatabaseResponseBody extends $tea.Model {
  createMark?: string;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      createMark: 'CreateMark',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createMark: 'string',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartPreCheckDatabaseResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StartPreCheckDatabaseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartPreCheckDatabaseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartVirusScanTaskRequest extends $tea.Model {
  targetInfo?: string;
  static names(): { [key: string]: string } {
    return {
      targetInfo: 'TargetInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetInfo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartVirusScanTaskResponseBody extends $tea.Model {
  requestId?: string;
  scanTaskId?: number;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      scanTaskId: 'ScanTaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      scanTaskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartVirusScanTaskResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StartVirusScanTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartVirusScanTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopHoneypotRequest extends $tea.Model {
  honeypotId?: string;
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      honeypotId: 'HoneypotId',
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeypotId: 'string',
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopHoneypotResponseBody extends $tea.Model {
  code?: string;
  data?: StopHoneypotResponseBodyData;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: StopHoneypotResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopHoneypotResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: StopHoneypotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StopHoneypotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitCheckRequest extends $tea.Model {
  scanRange?: string;
  static names(): { [key: string]: string } {
    return {
      scanRange: 'ScanRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      scanRange: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitCheckResponseBody extends $tea.Model {
  data?: SubmitCheckResponseBodyData;
  requestId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: SubmitCheckResponseBodyData,
      requestId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitCheckResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: SubmitCheckResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SubmitCheckResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindAegisRequest extends $tea.Model {
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindAegisResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnbindAegisResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UnbindAegisResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UnbindAegisResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallBackupClientRequest extends $tea.Model {
  policyVersion?: string;
  uuid?: string;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      policyVersion: 'PolicyVersion',
      uuid: 'Uuid',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyVersion: 'string',
      uuid: 'string',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallBackupClientResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallBackupClientResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UninstallBackupClientResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UninstallBackupClientResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallRaspAttachRequest extends $tea.Model {
  applicationId?: string;
  ecsUUIDList?: string[];
  static names(): { [key: string]: string } {
    return {
      applicationId: 'ApplicationId',
      ecsUUIDList: 'EcsUUIDList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applicationId: 'string',
      ecsUUIDList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallRaspAttachResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallRaspAttachResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UninstallRaspAttachResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UninstallRaspAttachResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallUniBackupAgentRequest extends $tea.Model {
  policyId?: number;
  static names(): { [key: string]: string } {
    return {
      policyId: 'PolicyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallUniBackupAgentResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UninstallUniBackupAgentResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UninstallUniBackupAgentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UninstallUniBackupAgentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAlarmEventRequest extends $tea.Model {
  alarmEventIdList?: number[];
  lang?: string;
  operationCode?: string;
  static names(): { [key: string]: string } {
    return {
      alarmEventIdList: 'AlarmEventIdList',
      lang: 'Lang',
      operationCode: 'OperationCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmEventIdList: { 'type': 'array', 'itemType': 'number' },
      lang: 'string',
      operationCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAlarmEventResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAlarmEventResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateAlarmEventResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAlarmEventResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateClientAlertModeRequest extends $tea.Model {
  mode?: string;
  uuids?: string[];
  static names(): { [key: string]: string } {
    return {
      mode: 'Mode',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      mode: 'string',
      uuids: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateClientAlertModeResponseBody extends $tea.Model {
  data?: boolean;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateClientAlertModeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateClientAlertModeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateClientAlertModeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCommonSwitchConfigRequest extends $tea.Model {
  targetDefault?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      targetDefault: 'TargetDefault',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetDefault: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCommonSwitchConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateCommonSwitchConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateCommonSwitchConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateCommonSwitchConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileProtectEventStatusRequest extends $tea.Model {
  id?: number[];
  status?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: { 'type': 'array', 'itemType': 'number' },
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileProtectEventStatusResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileProtectEventStatusResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateFileProtectEventStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFileProtectEventStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileProtectRemarkRequest extends $tea.Model {
  id?: number;
  remark?: string[];
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      remark: 'Remark',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      remark: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileProtectRemarkResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileProtectRemarkResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateFileProtectRemarkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFileProtectRemarkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileProtectRuleRequest extends $tea.Model {
  alertLevel?: number;
  fileOps?: string[];
  filePaths?: string[];
  id?: number;
  procPaths?: string[];
  ruleAction?: string;
  ruleName?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      alertLevel: 'AlertLevel',
      fileOps: 'FileOps',
      filePaths: 'FilePaths',
      id: 'Id',
      procPaths: 'ProcPaths',
      ruleAction: 'RuleAction',
      ruleName: 'RuleName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertLevel: 'number',
      fileOps: { 'type': 'array', 'itemType': 'string' },
      filePaths: { 'type': 'array', 'itemType': 'string' },
      id: 'number',
      procPaths: { 'type': 'array', 'itemType': 'string' },
      ruleAction: 'string',
      ruleName: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileProtectRuleResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileProtectRuleResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateFileProtectRuleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFileProtectRuleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileUploadLimitRequest extends $tea.Model {
  limit?: number;
  static names(): { [key: string]: string } {
    return {
      limit: 'Limit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      limit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileUploadLimitResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateFileUploadLimitResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateFileUploadLimitResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateFileUploadLimitResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotRequest extends $tea.Model {
  honeypotId?: string;
  honeypotName?: string;
  lang?: string;
  meta?: string;
  static names(): { [key: string]: string } {
    return {
      honeypotId: 'HoneypotId',
      honeypotName: 'HoneypotName',
      lang: 'Lang',
      meta: 'Meta',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeypotId: 'string',
      honeypotName: 'string',
      lang: 'string',
      meta: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotResponseBody extends $tea.Model {
  code?: string;
  data?: UpdateHoneypotResponseBodyData;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: UpdateHoneypotResponseBodyData,
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateHoneypotResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateHoneypotResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotNodeRequest extends $tea.Model {
  availableProbeNum?: number;
  nodeId?: string;
  nodeName?: string;
  securityGroupProbeIpList?: string[];
  static names(): { [key: string]: string } {
    return {
      availableProbeNum: 'AvailableProbeNum',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
      securityGroupProbeIpList: 'SecurityGroupProbeIpList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      availableProbeNum: 'number',
      nodeId: 'string',
      nodeName: 'string',
      securityGroupProbeIpList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotNodeResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotNodeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateHoneypotNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateHoneypotNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotPresetRequest extends $tea.Model {
  honeypotImageName?: string;
  honeypotPresetId?: string;
  lang?: string;
  meta?: string;
  presetName?: string;
  static names(): { [key: string]: string } {
    return {
      honeypotImageName: 'HoneypotImageName',
      honeypotPresetId: 'HoneypotPresetId',
      lang: 'Lang',
      meta: 'Meta',
      presetName: 'PresetName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeypotImageName: 'string',
      honeypotPresetId: 'string',
      lang: 'string',
      meta: 'string',
      presetName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotPresetResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotPresetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateHoneypotPresetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateHoneypotPresetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotProbeRequest extends $tea.Model {
  arp?: boolean;
  displayName?: string;
  lang?: string;
  ping?: boolean;
  probeId?: string;
  serviceIpList?: string[];
  static names(): { [key: string]: string } {
    return {
      arp: 'Arp',
      displayName: 'DisplayName',
      lang: 'Lang',
      ping: 'Ping',
      probeId: 'ProbeId',
      serviceIpList: 'ServiceIpList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arp: 'boolean',
      displayName: 'string',
      lang: 'string',
      ping: 'boolean',
      probeId: 'string',
      serviceIpList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotProbeResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotProbeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateHoneypotProbeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateHoneypotProbeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotProbeBindRequest extends $tea.Model {
  bindId?: string;
  bindPortList?: UpdateHoneypotProbeBindRequestBindPortList[];
  bindType?: string;
  currentPage?: number;
  honeypotId?: string;
  id?: number;
  lang?: string;
  pageSize?: number;
  ports?: string;
  probeId?: string;
  serviceIpList?: string[];
  setStatus?: number;
  static names(): { [key: string]: string } {
    return {
      bindId: 'BindId',
      bindPortList: 'BindPortList',
      bindType: 'BindType',
      currentPage: 'CurrentPage',
      honeypotId: 'HoneypotId',
      id: 'Id',
      lang: 'Lang',
      pageSize: 'PageSize',
      ports: 'Ports',
      probeId: 'ProbeId',
      serviceIpList: 'ServiceIpList',
      setStatus: 'SetStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindId: 'string',
      bindPortList: { 'type': 'array', 'itemType': UpdateHoneypotProbeBindRequestBindPortList },
      bindType: 'string',
      currentPage: 'number',
      honeypotId: 'string',
      id: 'number',
      lang: 'string',
      pageSize: 'number',
      ports: 'string',
      probeId: 'string',
      serviceIpList: { 'type': 'array', 'itemType': 'string' },
      setStatus: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotProbeBindResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotProbeBindResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateHoneypotProbeBindResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateHoneypotProbeBindResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateImageEventOperationRequest extends $tea.Model {
  id?: number;
  scenarios?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      scenarios: 'Scenarios',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      scenarios: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateImageEventOperationResponseBody extends $tea.Model {
  code?: string;
  data?: UpdateImageEventOperationResponseBodyData;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: UpdateImageEventOperationResponseBodyData,
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateImageEventOperationResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateImageEventOperationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateImageEventOperationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateImageVulWhitelistTargetRequest extends $tea.Model {
  id?: number;
  lang?: string;
  reason?: string;
  source?: string;
  target?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      lang: 'Lang',
      reason: 'Reason',
      source: 'Source',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      lang: 'string',
      reason: 'string',
      source: 'string',
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateImageVulWhitelistTargetResponseBody extends $tea.Model {
  code?: string;
  data?: boolean;
  httpStatusCode?: number;
  message?: string;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      data: 'boolean',
      httpStatusCode: 'number',
      message: 'string',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateImageVulWhitelistTargetResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateImageVulWhitelistTargetResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateImageVulWhitelistTargetResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJenkinsImageRegistryNameRequest extends $tea.Model {
  registryId?: number;
  registryName?: string;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      registryId: 'RegistryId',
      registryName: 'RegistryName',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      registryId: 'number',
      registryName: 'string',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJenkinsImageRegistryNameResponseBody extends $tea.Model {
  data?: boolean;
  httpStatusCode?: number;
  requestId?: string;
  timeCost?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      timeCost: 'TimeCost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      httpStatusCode: 'number',
      requestId: 'string',
      timeCost: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJenkinsImageRegistryNameResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateJenkinsImageRegistryNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateJenkinsImageRegistryNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJenkinsImageRegistryPersistenceDayRequest extends $tea.Model {
  persistenceDay?: number;
  registryId?: number;
  sourceIp?: string;
  static names(): { [key: string]: string } {
    return {
      persistenceDay: 'PersistenceDay',
      registryId: 'RegistryId',
      sourceIp: 'SourceIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      persistenceDay: 'number',
      registryId: 'number',
      sourceIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJenkinsImageRegistryPersistenceDayResponseBody extends $tea.Model {
  data?: boolean;
  httpStatusCode?: number;
  requestId?: string;
  timeCost?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      httpStatusCode: 'HttpStatusCode',
      requestId: 'RequestId',
      timeCost: 'TimeCost',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'boolean',
      httpStatusCode: 'number',
      requestId: 'string',
      timeCost: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateJenkinsImageRegistryPersistenceDayResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateJenkinsImageRegistryPersistenceDayResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateJenkinsImageRegistryPersistenceDayResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOssScanConfigRequest extends $tea.Model {
  bucketNameList?: string[];
  enable?: number;
  endTime?: string;
  keySuffixList?: string[];
  scanDayList?: number[];
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      bucketNameList: 'BucketNameList',
      enable: 'Enable',
      endTime: 'EndTime',
      keySuffixList: 'KeySuffixList',
      scanDayList: 'ScanDayList',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketNameList: { 'type': 'array', 'itemType': 'string' },
      enable: 'number',
      endTime: 'string',
      keySuffixList: { 'type': 'array', 'itemType': 'string' },
      scanDayList: { 'type': 'array', 'itemType': 'number' },
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOssScanConfigResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateOssScanConfigResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateOssScanConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateOssScanConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSelectionKeyByTypeRequest extends $tea.Model {
  businessType?: string;
  selectionKey?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      selectionKey: 'SelectionKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      selectionKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSelectionKeyByTypeResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSelectionKeyByTypeResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpdateSelectionKeyByTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSelectionKeyByTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeBackupPolicyVersionRequest extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeBackupPolicyVersionResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeBackupPolicyVersionResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: UpgradeBackupPolicyVersionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpgradeBackupPolicyVersionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ValidateHcWarningsRequest extends $tea.Model {
  checkIds?: string;
  riskIds?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      checkIds: 'CheckIds',
      riskIds: 'RiskIds',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkIds: 'string',
      riskIds: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ValidateHcWarningsResponseBody extends $tea.Model {
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ValidateHcWarningsResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: ValidateHcWarningsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ValidateHcWarningsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyCheckInstanceResultRequest extends $tea.Model {
  checkId?: number;
  instanceIds?: string[];
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      instanceIds: 'InstanceIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      instanceIds: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyCheckInstanceResultResponseBody extends $tea.Model {
  data?: VerifyCheckInstanceResultResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: VerifyCheckInstanceResultResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyCheckInstanceResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: VerifyCheckInstanceResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: VerifyCheckInstanceResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyCheckResultRequest extends $tea.Model {
  checkIds?: number[];
  static names(): { [key: string]: string } {
    return {
      checkIds: 'CheckIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyCheckResultResponseBody extends $tea.Model {
  data?: VerifyCheckResultResponseBodyData;
  requestId?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      requestId: 'RequestId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: VerifyCheckResultResponseBodyData,
      requestId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyCheckResultResponse extends $tea.Model {
  headers: { [key: string]: string };
  statusCode: number;
  body: VerifyCheckResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: VerifyCheckResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAssetSelectionCriteriaRequestTargetOperationList extends $tea.Model {
  operation?: string;
  target?: string;
  static names(): { [key: string]: string } {
    return {
      operation: 'Operation',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operation: 'string',
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddClientUserDefineRuleResponseBodyUserDefineRuleAddResult extends $tea.Model {
  id?: number;
  platform?: string;
  switchId?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      platform: 'Platform',
      switchId: 'SwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      platform: 'string',
      switchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddContainerDefenseRuleRequestScope extends $tea.Model {
  allNamespace?: number;
  clusterId?: string;
  namespaces?: string[];
  static names(): { [key: string]: string } {
    return {
      allNamespace: 'AllNamespace',
      clusterId: 'ClusterId',
      namespaces: 'Namespaces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allNamespace: 'number',
      clusterId: 'string',
      namespaces: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddContainerDefenseRuleRequestWhitelist extends $tea.Model {
  hash?: string[];
  image?: string[];
  path?: string[];
  static names(): { [key: string]: string } {
    return {
      hash: 'Hash',
      image: 'Image',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hash: { 'type': 'array', 'itemType': 'string' },
      image: { 'type': 'array', 'itemType': 'string' },
      path: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddContainerDefenseRuleShrinkRequestScope extends $tea.Model {
  allNamespace?: number;
  clusterId?: string;
  namespaces?: string[];
  static names(): { [key: string]: string } {
    return {
      allNamespace: 'AllNamespace',
      clusterId: 'ClusterId',
      namespaces: 'Namespaces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allNamespace: 'number',
      clusterId: 'string',
      namespaces: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddImageEventOperationResponseBodyData extends $tea.Model {
  conditions?: string;
  eventKey?: string;
  eventName?: string;
  eventType?: string;
  id?: number;
  operationCode?: string;
  scenarios?: string;
  static names(): { [key: string]: string } {
    return {
      conditions: 'Conditions',
      eventKey: 'EventKey',
      eventName: 'EventName',
      eventType: 'EventType',
      id: 'Id',
      operationCode: 'OperationCode',
      scenarios: 'Scenarios',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditions: 'string',
      eventKey: 'string',
      eventName: 'string',
      eventType: 'string',
      id: 'number',
      operationCode: 'string',
      scenarios: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddPrivateRegistryResponseBodyData extends $tea.Model {
  aliUid?: number;
  domainName?: string;
  id?: number;
  netType?: number;
  password?: string;
  protocolType?: number;
  regionId?: string;
  registryHostIp?: string;
  registryType?: string;
  registryVersion?: string;
  token?: string;
  transPerHour?: number;
  userName?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      domainName: 'DomainName',
      id: 'Id',
      netType: 'NetType',
      password: 'Password',
      protocolType: 'ProtocolType',
      regionId: 'RegionId',
      registryHostIp: 'RegistryHostIp',
      registryType: 'RegistryType',
      registryVersion: 'RegistryVersion',
      token: 'Token',
      transPerHour: 'TransPerHour',
      userName: 'UserName',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'number',
      domainName: 'string',
      id: 'number',
      netType: 'number',
      password: 'string',
      protocolType: 'number',
      regionId: 'string',
      registryHostIp: 'string',
      registryType: 'string',
      registryVersion: 'string',
      token: 'string',
      transPerHour: 'number',
      userName: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSasModuleTrialResponseBodyDataTrialRecordList extends $tea.Model {
  authLimit?: number;
  gmtEnd?: number;
  gmtStart?: number;
  moduleCode?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      authLimit: 'AuthLimit',
      gmtEnd: 'GmtEnd',
      gmtStart: 'GmtStart',
      moduleCode: 'ModuleCode',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authLimit: 'number',
      gmtEnd: 'number',
      gmtStart: 'number',
      moduleCode: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddSasModuleTrialResponseBodyData extends $tea.Model {
  trialRecordList?: AddSasModuleTrialResponseBodyDataTrialRecordList[];
  static names(): { [key: string]: string } {
    return {
      trialRecordList: 'TrialRecordList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      trialRecordList: { 'type': 'array', 'itemType': AddSasModuleTrialResponseBodyDataTrialRecordList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField extends $tea.Model {
  filedAliasName?: string;
  filedName?: string;
  markMisType?: string;
  markMisValue?: string;
  supportedMisType?: string[];
  static names(): { [key: string]: string } {
    return {
      filedAliasName: 'FiledAliasName',
      filedName: 'FiledName',
      markMisType: 'MarkMisType',
      markMisValue: 'MarkMisValue',
      supportedMisType: 'SupportedMisType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filedAliasName: 'string',
      filedName: 'string',
      markMisType: 'string',
      markMisValue: 'string',
      supportedMisType: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource extends $tea.Model {
  filedAliasName?: string;
  filedName?: string;
  markMisValue?: string;
  supportedMisType?: string[];
  static names(): { [key: string]: string } {
    return {
      filedAliasName: 'FiledAliasName',
      filedName: 'FiledName',
      markMisValue: 'MarkMisValue',
      supportedMisType: 'SupportedMisType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filedAliasName: 'string',
      filedName: 'string',
      markMisValue: 'string',
      supportedMisType: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponse extends $tea.Model {
  markField?: AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField[];
  markFieldsSource?: AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource[];
  operationCode?: string;
  operationParams?: string;
  userCanOperate?: boolean;
  static names(): { [key: string]: string } {
    return {
      markField: 'MarkField',
      markFieldsSource: 'MarkFieldsSource',
      operationCode: 'OperationCode',
      operationParams: 'OperationParams',
      userCanOperate: 'UserCanOperate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      markField: { 'type': 'array', 'itemType': AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField },
      markFieldsSource: { 'type': 'array', 'itemType': AdvanceSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource },
      operationCode: 'string',
      operationParams: 'string',
      userCanOperate: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeAssetRefreshTaskConfigRequestAssetRefreshConfigs extends $tea.Model {
  refreshConfigType?: number;
  schedulePeriod?: number;
  status?: number;
  targetId?: number;
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      refreshConfigType: 'RefreshConfigType',
      schedulePeriod: 'SchedulePeriod',
      status: 'Status',
      targetId: 'TargetId',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      refreshConfigType: 'number',
      schedulePeriod: 'number',
      status: 'number',
      targetId: 'number',
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckConfigRequestAddedCheck extends $tea.Model {
  checkId?: number;
  sectionId?: number;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      sectionId: 'SectionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      sectionId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckConfigRequestConfigRequirementIds extends $tea.Model {
  addIds?: number[];
  removeIds?: number[];
  static names(): { [key: string]: string } {
    return {
      addIds: 'AddIds',
      removeIds: 'RemoveIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addIds: { 'type': 'array', 'itemType': 'number' },
      removeIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckConfigRequestConfigStandardIds extends $tea.Model {
  addIds?: number[];
  removeIds?: number[];
  static names(): { [key: string]: string } {
    return {
      addIds: 'AddIds',
      removeIds: 'RemoveIds',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addIds: { 'type': 'array', 'itemType': 'number' },
      removeIds: { 'type': 'array', 'itemType': 'number' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckConfigRequestRemovedCheck extends $tea.Model {
  checkId?: number;
  sectionId?: number;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      sectionId: 'SectionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      sectionId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckConfigShrinkRequestAddedCheck extends $tea.Model {
  checkId?: number;
  sectionId?: number;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      sectionId: 'SectionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      sectionId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckConfigShrinkRequestRemovedCheck extends $tea.Model {
  checkId?: number;
  sectionId?: number;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      sectionId: 'SectionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      sectionId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckCustomConfigRequestCustomConfigs extends $tea.Model {
  name?: string;
  operation?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      operation: 'Operation',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      operation: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeCheckCustomConfigResponseBodyIllegalCustomConfigs extends $tea.Model {
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeSecurityScoreRuleRequestSecurityScoreRuleListSecurityScoreItemList extends $tea.Model {
  score?: number;
  scoreThreshold?: number;
  subRuleType?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      scoreThreshold: 'ScoreThreshold',
      subRuleType: 'SubRuleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'number',
      scoreThreshold: 'number',
      subRuleType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChangeSecurityScoreRuleRequestSecurityScoreRuleList extends $tea.Model {
  ruleType?: string;
  score?: number;
  securityScoreItemList?: ChangeSecurityScoreRuleRequestSecurityScoreRuleListSecurityScoreItemList[];
  static names(): { [key: string]: string } {
    return {
      ruleType: 'RuleType',
      score: 'Score',
      securityScoreItemList: 'SecurityScoreItemList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleType: 'string',
      score: 'number',
      securityScoreItemList: { 'type': 'array', 'itemType': ChangeSecurityScoreRuleRequestSecurityScoreRuleListSecurityScoreItemList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntiBruteForceRuleResponseBodyCreateAntiBruteForceRule extends $tea.Model {
  ruleId?: number;
  static names(): { [key: string]: string } {
    return {
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAssetSelectionConfigResponseBodyData extends $tea.Model {
  businessType?: string;
  selectionKey?: number;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      businessType: 'BusinessType',
      selectionKey: 'SelectionKey',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      businessType: 'string',
      selectionKey: 'number',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBackupPolicyResponseBodyBackupPolicy extends $tea.Model {
  id?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateContainerScanTaskResponseBodyData extends $tea.Model {
  canCreate?: boolean;
  collectTime?: number;
  execTime?: number;
  finishCount?: number;
  progress?: number;
  result?: string;
  status?: string;
  taskId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      canCreate: 'CanCreate',
      collectTime: 'CollectTime',
      execTime: 'ExecTime',
      finishCount: 'FinishCount',
      progress: 'Progress',
      result: 'Result',
      status: 'Status',
      taskId: 'TaskId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canCreate: 'boolean',
      collectTime: 'number',
      execTime: 'number',
      finishCount: 'number',
      progress: 'number',
      result: 'string',
      status: 'string',
      taskId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateContainerScanTaskByAppNameResponseBodyData extends $tea.Model {
  canCreate?: boolean;
  collectTime?: number;
  execTime?: number;
  finishCount?: number;
  progress?: number;
  result?: string;
  status?: string;
  taskId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      canCreate: 'CanCreate',
      collectTime: 'CollectTime',
      execTime: 'ExecTime',
      finishCount: 'FinishCount',
      progress: 'Progress',
      result: 'Result',
      status: 'Status',
      taskId: 'TaskId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canCreate: 'boolean',
      collectTime: 'number',
      execTime: 'number',
      finishCount: 'number',
      progress: 'number',
      result: 'string',
      status: 'string',
      taskId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileDetectUploadUrlRequestHashKeyContextList extends $tea.Model {
  fileSize?: number;
  hashKey?: string;
  static names(): { [key: string]: string } {
    return {
      fileSize: 'FileSize',
      hashKey: 'HashKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileSize: 'number',
      hashKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileDetectUploadUrlResponseBodyUploadUrlListContext extends $tea.Model {
  accessId?: string;
  ossKey?: string;
  policy?: string;
  signature?: string;
  static names(): { [key: string]: string } {
    return {
      accessId: 'AccessId',
      ossKey: 'OssKey',
      policy: 'Policy',
      signature: 'Signature',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessId: 'string',
      ossKey: 'string',
      policy: 'string',
      signature: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFileDetectUploadUrlResponseBodyUploadUrlList extends $tea.Model {
  code?: string;
  context?: CreateFileDetectUploadUrlResponseBodyUploadUrlListContext;
  expire?: string;
  fileExist?: boolean;
  hashKey?: string;
  internalUrl?: string;
  message?: string;
  publicUrl?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      context: 'Context',
      expire: 'Expire',
      fileExist: 'FileExist',
      hashKey: 'HashKey',
      internalUrl: 'InternalUrl',
      message: 'Message',
      publicUrl: 'PublicUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      context: CreateFileDetectUploadUrlResponseBodyUploadUrlListContext,
      expire: 'string',
      fileExist: 'boolean',
      hashKey: 'string',
      internalUrl: 'string',
      message: 'string',
      publicUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotResponseBodyData extends $tea.Model {
  controlNodeName?: string;
  honeypotId?: string;
  honeypotImageDisplayName?: string;
  honeypotImageName?: string;
  honeypotName?: string;
  nodeId?: string;
  presetId?: string;
  state?: string[];
  static names(): { [key: string]: string } {
    return {
      controlNodeName: 'ControlNodeName',
      honeypotId: 'HoneypotId',
      honeypotImageDisplayName: 'HoneypotImageDisplayName',
      honeypotImageName: 'HoneypotImageName',
      honeypotName: 'HoneypotName',
      nodeId: 'NodeId',
      presetId: 'PresetId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      controlNodeName: 'string',
      honeypotId: 'string',
      honeypotImageDisplayName: 'string',
      honeypotImageName: 'string',
      honeypotName: 'string',
      nodeId: 'string',
      presetId: 'string',
      state: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotNodeResponseBodyHoneypotNode extends $tea.Model {
  nodeId?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotPresetResponseBodyHoneypotPreset extends $tea.Model {
  honeypotPresetId?: string;
  static names(): { [key: string]: string } {
    return {
      honeypotPresetId: 'HoneypotPresetId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeypotPresetId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotProbeRequestHoneypotBindListBindPortList extends $tea.Model {
  bindPort?: boolean;
  endPort?: number;
  fixed?: boolean;
  startPort?: number;
  targetPort?: number;
  static names(): { [key: string]: string } {
    return {
      bindPort: 'BindPort',
      endPort: 'EndPort',
      fixed: 'Fixed',
      startPort: 'StartPort',
      targetPort: 'TargetPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindPort: 'boolean',
      endPort: 'number',
      fixed: 'boolean',
      startPort: 'number',
      targetPort: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotProbeRequestHoneypotBindList extends $tea.Model {
  bindPortList?: CreateHoneypotProbeRequestHoneypotBindListBindPortList[];
  honeypotId?: string;
  static names(): { [key: string]: string } {
    return {
      bindPortList: 'BindPortList',
      honeypotId: 'HoneypotId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindPortList: { 'type': 'array', 'itemType': CreateHoneypotProbeRequestHoneypotBindListBindPortList },
      honeypotId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotProbeResponseBodyHoneypotProbe extends $tea.Model {
  probeId?: string;
  static names(): { [key: string]: string } {
    return {
      probeId: 'ProbeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      probeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateHoneypotProbeBindRequestBindPortList extends $tea.Model {
  bindPort?: boolean;
  endPort?: number;
  fixed?: boolean;
  proto?: string;
  startPort?: number;
  targetPort?: number;
  static names(): { [key: string]: string } {
    return {
      bindPort: 'BindPort',
      endPort: 'EndPort',
      fixed: 'Fixed',
      proto: 'Proto',
      startPort: 'StartPort',
      targetPort: 'TargetPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindPort: 'boolean',
      endPort: 'number',
      fixed: 'boolean',
      proto: 'string',
      startPort: 'number',
      targetPort: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateJenkinsImageRegistryResponseBodyData extends $tea.Model {
  blackList?: string;
  domainName?: string;
  gmtCreate?: string;
  gmtModified?: string;
  id?: number;
  netType?: number;
  password?: string;
  persistenceDay?: number;
  protocolType?: number;
  regionId?: string;
  registryHostIp?: string;
  registryName?: string;
  registryType?: string;
  token?: string;
  transPerHour?: number;
  userName?: string;
  vpcId?: string;
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      blackList: 'BlackList',
      domainName: 'DomainName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      netType: 'NetType',
      password: 'Password',
      persistenceDay: 'PersistenceDay',
      protocolType: 'ProtocolType',
      regionId: 'RegionId',
      registryHostIp: 'RegistryHostIp',
      registryName: 'RegistryName',
      registryType: 'RegistryType',
      token: 'Token',
      transPerHour: 'TransPerHour',
      userName: 'UserName',
      vpcId: 'VpcId',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blackList: 'string',
      domainName: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      netType: 'number',
      password: 'string',
      persistenceDay: 'number',
      protocolType: 'number',
      regionId: 'string',
      registryHostIp: 'string',
      registryName: 'string',
      registryType: 'string',
      token: 'string',
      transPerHour: 'number',
      userName: 'string',
      vpcId: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOpaClusterPluginResponseBodyInstallStatus extends $tea.Model {
  clusterId?: string;
  installStatus?: boolean;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      installStatus: 'InstallStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      installStatus: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSimilarSecurityEventsQueryTaskResponseBodyCreateSimilarSecurityEventsQueryTaskResponse extends $tea.Model {
  status?: string;
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateVulAutoRepairConfigRequestVulAutoRepairConfigList extends $tea.Model {
  aliasName?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteImageEventOperationResponseBodyData extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAccesskeyLeakListResponseBodyAccessKeyLeakList extends $tea.Model {
  accesskeyId?: string;
  aliUserName?: string;
  asset?: string;
  dealTime?: string;
  dealType?: string;
  gmtModified?: number;
  id?: number;
  status?: string;
  type?: string;
  url?: string;
  userType?: string;
  static names(): { [key: string]: string } {
    return {
      accesskeyId: 'AccesskeyId',
      aliUserName: 'AliUserName',
      asset: 'Asset',
      dealTime: 'DealTime',
      dealType: 'DealType',
      gmtModified: 'GmtModified',
      id: 'Id',
      status: 'Status',
      type: 'Type',
      url: 'Url',
      userType: 'UserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accesskeyId: 'string',
      aliUserName: 'string',
      asset: 'string',
      dealTime: 'string',
      dealType: 'string',
      gmtModified: 'number',
      id: 'number',
      status: 'string',
      type: 'string',
      url: 'string',
      userType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAffectedAssetsResponseBodyAssetList extends $tea.Model {
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  riskNum?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      riskNum: 'RiskNum',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      riskNum: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAffectedAssetsResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAffectedMaliciousFileImagesResponseBodyAffectedMaliciousFileImagesResponse extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  containerId?: string;
  digest?: string;
  downloadUrl?: string;
  filePath?: string;
  firstScanTimestamp?: number;
  highLight?: string;
  image?: string;
  imageUuid?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  latestScanTimestamp?: number;
  latestVerifyTimestamp?: number;
  layer?: string;
  level?: string;
  maliciousMd5?: string;
  namespace?: string;
  pod?: string;
  repoId?: string;
  repoInstanceId?: string;
  repoName?: string;
  repoRegionId?: string;
  status?: number;
  tag?: string;
  targetId?: string;
  targetName?: string;
  targetType?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      containerId: 'ContainerId',
      digest: 'Digest',
      downloadUrl: 'DownloadUrl',
      filePath: 'FilePath',
      firstScanTimestamp: 'FirstScanTimestamp',
      highLight: 'HighLight',
      image: 'Image',
      imageUuid: 'ImageUuid',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      latestScanTimestamp: 'LatestScanTimestamp',
      latestVerifyTimestamp: 'LatestVerifyTimestamp',
      layer: 'Layer',
      level: 'Level',
      maliciousMd5: 'MaliciousMd5',
      namespace: 'Namespace',
      pod: 'Pod',
      repoId: 'RepoId',
      repoInstanceId: 'RepoInstanceId',
      repoName: 'RepoName',
      repoRegionId: 'RepoRegionId',
      status: 'Status',
      tag: 'Tag',
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      containerId: 'string',
      digest: 'string',
      downloadUrl: 'string',
      filePath: 'string',
      firstScanTimestamp: 'number',
      highLight: 'string',
      image: 'string',
      imageUuid: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      latestScanTimestamp: 'number',
      latestVerifyTimestamp: 'number',
      layer: 'string',
      level: 'string',
      maliciousMd5: 'string',
      namespace: 'string',
      pod: 'string',
      repoId: 'string',
      repoInstanceId: 'string',
      repoName: 'string',
      repoRegionId: 'string',
      status: 'number',
      tag: 'string',
      targetId: 'string',
      targetName: 'string',
      targetType: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAffectedMaliciousFileImagesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAgentInstallStatusResponseBodyAegisClientInvokeStatusResponseList extends $tea.Model {
  message?: string;
  resuleCode?: string;
  result?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      message: 'Message',
      resuleCode: 'ResuleCode',
      result: 'Result',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      message: 'string',
      resuleCode: 'string',
      result: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue extends $tea.Model {
  name?: string;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlarmEventDetailResponseBodyDataCauseDetails extends $tea.Model {
  key?: string;
  value?: DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue[];
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: { 'type': 'array', 'itemType': DescribeAlarmEventDetailResponseBodyDataCauseDetailsValue },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAlarmEventDetailResponseBodyData extends $tea.Model {
  alarmEventAliasName?: string;
  alarmEventDesc?: string;
  alarmUniqueInfo?: string;
  appName?: string;
  canBeDealOnLine?: boolean;
  canCancelFault?: boolean;
  causeDetails?: DescribeAlarmEventDetailResponseBodyDataCauseDetails[];
  containHwMode?: boolean;
  containerId?: string;
  containerImageId?: string;
  containerImageName?: string;
  dataSource?: string;
  endTime?: number;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  k8sClusterId?: string;
  k8sClusterName?: string;
  k8sNamespace?: string;
  k8sNodeId?: string;
  k8sNodeName?: string;
  k8sPodName?: string;
  level?: string;
  solution?: string;
  startTime?: number;
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      alarmEventAliasName: 'AlarmEventAliasName',
      alarmEventDesc: 'AlarmEventDesc',
      alarmUniqueInfo: 'AlarmUniqueInfo',
      appName: 'AppName',
      canBeDealOnLine: 'CanBeDealOnLine',
      canCancelFault: 'CanCancelFault',
      causeDetails: 'CauseDetails',
      containHwMode: 'ContainHwMode',
      containerId: 'ContainerId',
      containerImageId: 'ContainerImageId',
      containerImageName: 'ContainerImageName',
      dataSource: 'DataSource',
      endTime: 'EndTime',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      k8sClusterId: 'K8sClusterId',
      k8sClusterName: 'K8sClusterName',
      k8sNamespace: 'K8sNamespace',
      k8sNodeId: 'K8sNodeId',
      k8sNodeName: 'K8sNodeName',
      k8sPodName: 'K8sPodName',
      level: 'Level',
      solution: 'Solution',
      startTime: 'StartTime',
      type: 'Type',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmEventAliasName: 'string',
      alarmEventDesc: 'string',
      alarmUniqueInfo: 'string',
      appName: 'string',
      canBeDealOnLine: 'boolean',
      canCancelFault: 'boolean',
      causeDetails: { 'type': 'array', 'itemType': DescribeAlarmEventDetailResponseBodyDataCauseDetails },
      containHwMode: 'boolean',
      containerId: 'string',
      containerImageId: 'string',
      containerImageName: 'string',
      dataSource: 'string',
      endTime: 'number',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      k8sClusterId: 'string',
      k8sClusterName: 'string',
      k8sNamespace: 'string',
      k8sNodeId: 'string',
      k8sNodeName: 'string',
      k8sPodName: 'string',
      level: 'string',
      solution: 'string',
      startTime: 'number',
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllEntityResponseBodyEntityList extends $tea.Model {
  groupId?: number;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  ip?: string;
  os?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      ip: 'Ip',
      os: 'Os',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      ip: 'string',
      os: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllGroupsResponseBodyGroups extends $tea.Model {
  groupFlag?: number;
  groupId?: number;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      groupFlag: 'GroupFlag',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupFlag: 'number',
      groupId: 'number',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList extends $tea.Model {
  alias?: string;
  classKey?: string;
  itemKey?: string;
  nameKey?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      classKey: 'ClassKey',
      itemKey: 'ItemKey',
      nameKey: 'NameKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      classKey: 'string',
      itemKey: 'string',
      nameKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList extends $tea.Model {
  alias?: string;
  baselineItemList?: DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList[];
  classKey?: string;
  nameKey?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      baselineItemList: 'BaselineItemList',
      classKey: 'ClassKey',
      nameKey: 'NameKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      baselineItemList: { 'type': 'array', 'itemType': DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameListBaselineItemList },
      classKey: 'string',
      nameKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList extends $tea.Model {
  alias?: string;
  baselineNameList?: DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList[];
  classKey?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      baselineNameList: 'BaselineNameList',
      classKey: 'ClassKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      baselineNameList: { 'type': 'array', 'itemType': DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassListBaselineNameList },
      classKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAllImageBaselineResponseBodyImageBaselines extends $tea.Model {
  baselineClassList?: DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList[];
  static names(): { [key: string]: string } {
    return {
      baselineClassList: 'BaselineClassList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineClassList: { 'type': 'array', 'itemType': DescribeAllImageBaselineResponseBodyImageBaselinesBaselineClassList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntiBruteForceRulesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntiBruteForceRulesResponseBodyRules extends $tea.Model {
  createTimestamp?: number;
  defaultRule?: boolean;
  enableSmartRule?: boolean;
  failCount?: number;
  forbiddenTime?: number;
  id?: number;
  machineCount?: number;
  name?: string;
  span?: number;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      createTimestamp: 'CreateTimestamp',
      defaultRule: 'DefaultRule',
      enableSmartRule: 'EnableSmartRule',
      failCount: 'FailCount',
      forbiddenTime: 'ForbiddenTime',
      id: 'Id',
      machineCount: 'MachineCount',
      name: 'Name',
      span: 'Span',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTimestamp: 'number',
      defaultRule: 'boolean',
      enableSmartRule: 'boolean',
      failCount: 'number',
      forbiddenTime: 'number',
      id: 'number',
      machineCount: 'number',
      name: 'string',
      span: 'number',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetDetailByUuidResponseBodyAssetDetail extends $tea.Model {
  assetType?: string;
  authModifyTime?: number;
  authVersion?: number;
  bind?: boolean;
  clientStatus?: string;
  clientVersion?: string;
  cpu?: number;
  cpuInfo?: string;
  createTime?: number;
  diskInfoList?: string[];
  flag?: number;
  groupTrace?: string;
  hostName?: string;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  ip?: string;
  ipList?: string[];
  kernel?: string;
  macList?: string[];
  mem?: number;
  memory?: number;
  os?: string;
  osDetail?: string;
  osName?: string;
  region?: string;
  regionId?: string;
  regionName?: string;
  sysInfo?: string;
  tag?: string;
  uuid?: string;
  vpcInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      assetType: 'AssetType',
      authModifyTime: 'AuthModifyTime',
      authVersion: 'AuthVersion',
      bind: 'Bind',
      clientStatus: 'ClientStatus',
      clientVersion: 'ClientVersion',
      cpu: 'Cpu',
      cpuInfo: 'CpuInfo',
      createTime: 'CreateTime',
      diskInfoList: 'DiskInfoList',
      flag: 'Flag',
      groupTrace: 'GroupTrace',
      hostName: 'HostName',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      ip: 'Ip',
      ipList: 'IpList',
      kernel: 'Kernel',
      macList: 'MacList',
      mem: 'Mem',
      memory: 'Memory',
      os: 'Os',
      osDetail: 'OsDetail',
      osName: 'OsName',
      region: 'Region',
      regionId: 'RegionId',
      regionName: 'RegionName',
      sysInfo: 'SysInfo',
      tag: 'Tag',
      uuid: 'Uuid',
      vpcInstanceId: 'VpcInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetType: 'string',
      authModifyTime: 'number',
      authVersion: 'number',
      bind: 'boolean',
      clientStatus: 'string',
      clientVersion: 'string',
      cpu: 'number',
      cpuInfo: 'string',
      createTime: 'number',
      diskInfoList: { 'type': 'array', 'itemType': 'string' },
      flag: 'number',
      groupTrace: 'string',
      hostName: 'string',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      ip: 'string',
      ipList: { 'type': 'array', 'itemType': 'string' },
      kernel: 'string',
      macList: { 'type': 'array', 'itemType': 'string' },
      mem: 'number',
      memory: 'number',
      os: 'string',
      osDetail: 'string',
      osName: 'string',
      region: 'string',
      regionId: 'string',
      regionName: 'string',
      sysInfo: 'string',
      tag: 'string',
      uuid: 'string',
      vpcInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetDetailByUuidsResponseBodyAssetList extends $tea.Model {
  assetType?: string;
  clientStatus?: string;
  flag?: number;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  ip?: string;
  os?: string;
  osName?: string;
  region?: string;
  regionId?: string;
  regionName?: string;
  uuid?: string;
  vpcInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      assetType: 'AssetType',
      clientStatus: 'ClientStatus',
      flag: 'Flag',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      ip: 'Ip',
      os: 'Os',
      osName: 'OsName',
      region: 'Region',
      regionId: 'RegionId',
      regionName: 'RegionName',
      uuid: 'Uuid',
      vpcInstanceId: 'VpcInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetType: 'string',
      clientStatus: 'string',
      flag: 'number',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      ip: 'string',
      os: 'string',
      osName: 'string',
      region: 'string',
      regionId: 'string',
      regionName: 'string',
      uuid: 'string',
      vpcInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetSummaryResponseBodyAssetsSummary extends $tea.Model {
  totalAssetAllRegion?: number;
  totalCoreAllRegion?: number;
  totalCoreNum?: number;
  static names(): { [key: string]: string } {
    return {
      totalAssetAllRegion: 'TotalAssetAllRegion',
      totalCoreAllRegion: 'TotalCoreAllRegion',
      totalCoreNum: 'TotalCoreNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalAssetAllRegion: 'number',
      totalCoreAllRegion: 'number',
      totalCoreNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAssetsSecurityEventSummaryResponseBodyAssets extends $tea.Model {
  assetType?: string;
  riskCount?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      assetType: 'AssetType',
      riskCount: 'RiskCount',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetType: 'string',
      riskCount: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAttachRecordsResponseBodyAccessList extends $tea.Model {
  attachState?: number;
  attachSwitch?: string;
  ecsUUID?: string;
  installMsg?: string;
  installState?: number;
  static names(): { [key: string]: string } {
    return {
      attachState: 'AttachState',
      attachSwitch: 'AttachSwitch',
      ecsUUID: 'EcsUUID',
      installMsg: 'InstallMsg',
      installState: 'InstallState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attachState: 'number',
      attachSwitch: 'string',
      ecsUUID: 'string',
      installMsg: 'string',
      installState: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackUpExportInfoResponseBodyData extends $tea.Model {
  currentCount?: number;
  fileName?: string;
  gmtCreate?: number;
  id?: number;
  link?: string;
  message?: string;
  progress?: number;
  status?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentCount: 'CurrentCount',
      fileName: 'FileName',
      gmtCreate: 'GmtCreate',
      id: 'Id',
      link: 'Link',
      message: 'Message',
      progress: 'Progress',
      status: 'Status',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentCount: 'number',
      fileName: 'string',
      gmtCreate: 'number',
      id: 'number',
      link: 'string',
      message: 'string',
      progress: 'number',
      status: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackUpExportInfoResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupClientsResponseBodyClients extends $tea.Model {
  clientId?: string;
  clientStatus?: string;
  clientVersion?: string;
  instanceId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      clientId: 'ClientId',
      clientStatus: 'ClientStatus',
      clientVersion: 'ClientVersion',
      instanceId: 'InstanceId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientId: 'string',
      clientStatus: 'string',
      clientVersion: 'string',
      instanceId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupFilesResponseBodyBackupFiles extends $tea.Model {
  name?: string;
  size?: number;
  subtree?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      size: 'Size',
      subtree: 'Subtree',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      size: 'number',
      subtree: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupFilesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList extends $tea.Model {
  errorCode?: string;
  errorStatus?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorStatus: 'ErrorStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      errorStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupMachineStatusResponseBodyBackupMachineStatus extends $tea.Model {
  clientId?: string;
  clientStatus?: string;
  clientVersion?: string;
  errorCode?: string;
  errorList?: DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList[];
  instanceId?: string;
  regionId?: string;
  savedBackupCount?: number;
  status?: string;
  uuid?: string;
  vaultId?: string;
  static names(): { [key: string]: string } {
    return {
      clientId: 'ClientId',
      clientStatus: 'ClientStatus',
      clientVersion: 'ClientVersion',
      errorCode: 'ErrorCode',
      errorList: 'ErrorList',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      savedBackupCount: 'SavedBackupCount',
      status: 'Status',
      uuid: 'Uuid',
      vaultId: 'VaultId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientId: 'string',
      clientStatus: 'string',
      clientVersion: 'string',
      errorCode: 'string',
      errorList: { 'type': 'array', 'itemType': DescribeBackupMachineStatusResponseBodyBackupMachineStatusErrorList },
      instanceId: 'string',
      regionId: 'string',
      savedBackupCount: 'number',
      status: 'string',
      uuid: 'string',
      vaultId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupPoliciesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupPoliciesResponseBodyPolicies extends $tea.Model {
  clientErrorCount?: number;
  clientErrorUuidList?: string[];
  clientStatus?: string;
  healthClientCount?: number;
  healthClientUuidList?: string[];
  id?: number;
  name?: string;
  policy?: string;
  policyRegionId?: string;
  policyVersion?: string;
  remarkedUuidList?: string[];
  serverType?: string;
  serviceErrorCount?: number;
  serviceErrorUuidList?: string[];
  status?: string;
  upgradeStatus?: string;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      clientErrorCount: 'ClientErrorCount',
      clientErrorUuidList: 'ClientErrorUuidList',
      clientStatus: 'ClientStatus',
      healthClientCount: 'HealthClientCount',
      healthClientUuidList: 'HealthClientUuidList',
      id: 'Id',
      name: 'Name',
      policy: 'Policy',
      policyRegionId: 'PolicyRegionId',
      policyVersion: 'PolicyVersion',
      remarkedUuidList: 'RemarkedUuidList',
      serverType: 'ServerType',
      serviceErrorCount: 'ServiceErrorCount',
      serviceErrorUuidList: 'ServiceErrorUuidList',
      status: 'Status',
      upgradeStatus: 'UpgradeStatus',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientErrorCount: 'number',
      clientErrorUuidList: { 'type': 'array', 'itemType': 'string' },
      clientStatus: 'string',
      healthClientCount: 'number',
      healthClientUuidList: { 'type': 'array', 'itemType': 'string' },
      id: 'number',
      name: 'string',
      policy: 'string',
      policyRegionId: 'string',
      policyVersion: 'string',
      remarkedUuidList: { 'type': 'array', 'itemType': 'string' },
      serverType: 'string',
      serviceErrorCount: 'number',
      serviceErrorUuidList: { 'type': 'array', 'itemType': 'string' },
      status: 'string',
      upgradeStatus: 'string',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupPolicyResponseBodyBackupPolicyDetail extends $tea.Model {
  clientStatus?: string;
  id?: number;
  name?: string;
  policy?: string;
  policyVersion?: string;
  regionId?: string;
  status?: string;
  uuidList?: string[];
  static names(): { [key: string]: string } {
    return {
      clientStatus: 'ClientStatus',
      id: 'Id',
      name: 'Name',
      policy: 'Policy',
      policyVersion: 'PolicyVersion',
      regionId: 'RegionId',
      status: 'Status',
      uuidList: 'UuidList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientStatus: 'string',
      id: 'number',
      name: 'string',
      policy: 'string',
      policyVersion: 'string',
      regionId: 'string',
      status: 'string',
      uuidList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBackupRestoreCountResponseBodyBackupRestoreCount extends $tea.Model {
  recovering?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      recovering: 'Recovering',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recovering: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBruteForceRecordsResponseBodyMachineList extends $tea.Model {
  aliNetOnline?: boolean;
  blockExpireDate?: number;
  blockIp?: string;
  blockType?: string;
  errorCode?: string;
  id?: number;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  port?: string;
  ruleName?: string;
  source?: string;
  status?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      aliNetOnline: 'AliNetOnline',
      blockExpireDate: 'BlockExpireDate',
      blockIp: 'BlockIp',
      blockType: 'BlockType',
      errorCode: 'ErrorCode',
      id: 'Id',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      port: 'Port',
      ruleName: 'RuleName',
      source: 'Source',
      status: 'Status',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliNetOnline: 'boolean',
      blockExpireDate: 'number',
      blockIp: 'string',
      blockType: 'string',
      errorCode: 'string',
      id: 'number',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      port: 'string',
      ruleName: 'string',
      source: 'string',
      status: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBruteForceRecordsResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBruteForceSummaryResponseBodyBruteForceSummary extends $tea.Model {
  allStrategyCount?: number;
  antiBruteForceRuleCount?: string;
  customEffectiveCount?: string;
  customRecordCount?: string;
  effectiveCount?: number;
  systemEffectiveCount?: string;
  systemRecordCount?: string;
  static names(): { [key: string]: string } {
    return {
      allStrategyCount: 'AllStrategyCount',
      antiBruteForceRuleCount: 'AntiBruteForceRuleCount',
      customEffectiveCount: 'CustomEffectiveCount',
      customRecordCount: 'CustomRecordCount',
      effectiveCount: 'EffectiveCount',
      systemEffectiveCount: 'SystemEffectiveCount',
      systemRecordCount: 'SystemRecordCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allStrategyCount: 'number',
      antiBruteForceRuleCount: 'string',
      customEffectiveCount: 'string',
      customRecordCount: 'string',
      effectiveCount: 'number',
      systemEffectiveCount: 'string',
      systemRecordCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCanFixVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList extends $tea.Model {
  fullVersion?: string;
  layer?: string;
  matchDetail?: string;
  matchList?: string[];
  name?: string;
  path?: string;
  updateCmd?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      fullVersion: 'FullVersion',
      layer: 'Layer',
      matchDetail: 'MatchDetail',
      matchList: 'MatchList',
      name: 'Name',
      path: 'Path',
      updateCmd: 'UpdateCmd',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fullVersion: 'string',
      layer: 'string',
      matchDetail: 'string',
      matchList: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
      path: 'string',
      updateCmd: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCanFixVulListResponseBodyVulRecordsExtendContentJson extends $tea.Model {
  os?: string;
  osRelease?: string;
  rpmEntityList?: DescribeCanFixVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList[];
  static names(): { [key: string]: string } {
    return {
      os: 'Os',
      osRelease: 'OsRelease',
      rpmEntityList: 'RpmEntityList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      os: 'string',
      osRelease: 'string',
      rpmEntityList: { 'type': 'array', 'itemType': DescribeCanFixVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCanFixVulListResponseBodyVulRecords extends $tea.Model {
  aliasName?: string;
  canFix?: string;
  canUpdate?: boolean;
  clusterId?: string;
  clusterName?: string;
  containerId?: string;
  extendContentJson?: DescribeCanFixVulListResponseBodyVulRecordsExtendContentJson;
  firstTs?: number;
  image?: string;
  imageDigest?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  lastTs?: number;
  layers?: string[];
  maliciousSource?: string;
  modifyTs?: number;
  name?: string;
  namespace?: string;
  necessity?: string;
  pod?: string;
  primaryId?: number;
  related?: string;
  repoName?: string;
  repoNamespace?: string;
  scanTime?: number;
  status?: number;
  tag?: string;
  targetId?: string;
  targetName?: string;
  targetType?: string;
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      canFix: 'CanFix',
      canUpdate: 'CanUpdate',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      containerId: 'ContainerId',
      extendContentJson: 'ExtendContentJson',
      firstTs: 'FirstTs',
      image: 'Image',
      imageDigest: 'ImageDigest',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      lastTs: 'LastTs',
      layers: 'Layers',
      maliciousSource: 'MaliciousSource',
      modifyTs: 'ModifyTs',
      name: 'Name',
      namespace: 'Namespace',
      necessity: 'Necessity',
      pod: 'Pod',
      primaryId: 'PrimaryId',
      related: 'Related',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      scanTime: 'ScanTime',
      status: 'Status',
      tag: 'Tag',
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
      type: 'Type',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      canFix: 'string',
      canUpdate: 'boolean',
      clusterId: 'string',
      clusterName: 'string',
      containerId: 'string',
      extendContentJson: DescribeCanFixVulListResponseBodyVulRecordsExtendContentJson,
      firstTs: 'number',
      image: 'string',
      imageDigest: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      lastTs: 'number',
      layers: { 'type': 'array', 'itemType': 'string' },
      maliciousSource: 'string',
      modifyTs: 'number',
      name: 'string',
      namespace: 'string',
      necessity: 'string',
      pod: 'string',
      primaryId: 'number',
      related: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      scanTime: 'number',
      status: 'number',
      tag: 'string',
      targetId: 'string',
      targetName: 'string',
      targetType: 'string',
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList extends $tea.Model {
  enumValue?: string;
  maxValue?: number;
  minValue?: number;
  paramDefaultValue?: string;
  paramDesc?: string;
  paramName?: string;
  paramType?: number;
  ruleId?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      enumValue: 'EnumValue',
      maxValue: 'MaxValue',
      minValue: 'MinValue',
      paramDefaultValue: 'ParamDefaultValue',
      paramDesc: 'ParamDesc',
      paramName: 'ParamName',
      paramType: 'ParamType',
      ruleId: 'RuleId',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enumValue: 'string',
      maxValue: 'number',
      minValue: 'number',
      paramDefaultValue: 'string',
      paramDesc: 'string',
      paramName: 'string',
      paramType: 'number',
      ruleId: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules extends $tea.Model {
  checkId?: number;
  defaultValue?: number;
  optional?: number;
  paramList?: DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList[];
  ruleDesc?: string;
  ruleId?: string;
  value?: number;
  varName?: string;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      defaultValue: 'DefaultValue',
      optional: 'Optional',
      paramList: 'ParamList',
      ruleDesc: 'RuleDesc',
      ruleId: 'RuleId',
      value: 'Value',
      varName: 'VarName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      defaultValue: 'number',
      optional: 'number',
      paramList: { 'type': 'array', 'itemType': DescribeCheckFixDetailsResponseBodyCheckFixDetailsRulesParamList },
      ruleDesc: 'string',
      ruleId: 'string',
      value: 'number',
      varName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckFixDetailsResponseBodyCheckFixDetails extends $tea.Model {
  checkDesc?: string;
  checkId?: number;
  checkItem?: string;
  rules?: DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules[];
  static names(): { [key: string]: string } {
    return {
      checkDesc: 'CheckDesc',
      checkId: 'CheckId',
      checkItem: 'CheckItem',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkDesc: 'string',
      checkId: 'number',
      checkItem: 'string',
      rules: { 'type': 'array', 'itemType': DescribeCheckFixDetailsResponseBodyCheckFixDetailsRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningDetailResponseBodyCheckDetailColumnsGrids extends $tea.Model {
  key?: string;
  showName?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      showName: 'ShowName',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      showName: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningDetailResponseBodyCheckDetailColumns extends $tea.Model {
  grids?: DescribeCheckWarningDetailResponseBodyCheckDetailColumnsGrids[];
  key?: string;
  showName?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      grids: 'Grids',
      key: 'Key',
      showName: 'ShowName',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      grids: { 'type': 'array', 'itemType': DescribeCheckWarningDetailResponseBodyCheckDetailColumnsGrids },
      key: 'string',
      showName: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningMachinesResponseBodyMachines extends $tea.Model {
  bind?: boolean;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  regionId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      bind: 'Bind',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      regionId: 'RegionId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bind: 'boolean',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      regionId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningSummaryResponseBodyWarningSummarys extends $tea.Model {
  checkCount?: number;
  checkExploit?: boolean;
  containerRisk?: boolean;
  databaseRisk?: boolean;
  highWarningCount?: number;
  lastFoundTime?: string;
  level?: string;
  lowWarningCount?: number;
  mediumWarningCount?: number;
  riskId?: number;
  riskName?: string;
  subTypeAlias?: string;
  typeAlias?: string;
  warningMachineCount?: number;
  static names(): { [key: string]: string } {
    return {
      checkCount: 'CheckCount',
      checkExploit: 'CheckExploit',
      containerRisk: 'ContainerRisk',
      databaseRisk: 'DatabaseRisk',
      highWarningCount: 'HighWarningCount',
      lastFoundTime: 'LastFoundTime',
      level: 'Level',
      lowWarningCount: 'LowWarningCount',
      mediumWarningCount: 'MediumWarningCount',
      riskId: 'RiskId',
      riskName: 'RiskName',
      subTypeAlias: 'SubTypeAlias',
      typeAlias: 'TypeAlias',
      warningMachineCount: 'WarningMachineCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkCount: 'number',
      checkExploit: 'boolean',
      containerRisk: 'boolean',
      databaseRisk: 'boolean',
      highWarningCount: 'number',
      lastFoundTime: 'string',
      level: 'string',
      lowWarningCount: 'number',
      mediumWarningCount: 'number',
      riskId: 'number',
      riskName: 'string',
      subTypeAlias: 'string',
      typeAlias: 'string',
      warningMachineCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCheckWarningsResponseBodyCheckWarnings extends $tea.Model {
  checkId?: number;
  checkWarningId?: number;
  execErrorMessage?: string;
  fixStatus?: number;
  item?: string;
  level?: string;
  reason?: string;
  status?: number;
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      checkWarningId: 'CheckWarningId',
      execErrorMessage: 'ExecErrorMessage',
      fixStatus: 'FixStatus',
      item: 'Item',
      level: 'Level',
      reason: 'Reason',
      status: 'Status',
      type: 'Type',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      checkWarningId: 'number',
      execErrorMessage: 'string',
      fixStatus: 'number',
      item: 'string',
      level: 'string',
      reason: 'string',
      status: 'number',
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClientConfSetupResponseBodyClientConf extends $tea.Model {
  config?: string;
  strategyTag?: string;
  strategyTagValue?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      strategyTag: 'StrategyTag',
      strategyTagValue: 'StrategyTagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      strategyTag: 'string',
      strategyTagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClientConfStrategyResponseBodyTargetList extends $tea.Model {
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudCenterInstancesResponseBodyInstances extends $tea.Model {
  alarmStatus?: string;
  assetType?: string;
  authModifyTime?: number;
  authVersion?: number;
  authVersionName?: string;
  bind?: boolean;
  clientStatus?: string;
  clusterId?: string;
  clusterName?: string;
  cores?: number;
  cpuInfo?: string;
  createdTime?: number;
  exposedStatus?: number;
  flag?: number;
  groupId?: number;
  groupTrace?: string;
  hcStatus?: string;
  healthCheckCount?: number;
  importance?: number;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  ip?: string;
  ipListString?: string;
  kernel?: string;
  lastLoginTimestamp?: number;
  macListString?: string;
  mem?: number;
  os?: string;
  osName?: string;
  podCount?: number;
  region?: string;
  regionId?: string;
  regionName?: string;
  riskCount?: string;
  riskStatus?: string;
  safeEventCount?: number;
  status?: string;
  tag?: string;
  tagId?: string;
  uuid?: string;
  vendor?: number;
  vendorName?: string;
  vpcInstanceId?: string;
  vulCount?: number;
  vulStatus?: string;
  static names(): { [key: string]: string } {
    return {
      alarmStatus: 'AlarmStatus',
      assetType: 'AssetType',
      authModifyTime: 'AuthModifyTime',
      authVersion: 'AuthVersion',
      authVersionName: 'AuthVersionName',
      bind: 'Bind',
      clientStatus: 'ClientStatus',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      cores: 'Cores',
      cpuInfo: 'CpuInfo',
      createdTime: 'CreatedTime',
      exposedStatus: 'ExposedStatus',
      flag: 'Flag',
      groupId: 'GroupId',
      groupTrace: 'GroupTrace',
      hcStatus: 'HcStatus',
      healthCheckCount: 'HealthCheckCount',
      importance: 'Importance',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      ip: 'Ip',
      ipListString: 'IpListString',
      kernel: 'Kernel',
      lastLoginTimestamp: 'LastLoginTimestamp',
      macListString: 'MacListString',
      mem: 'Mem',
      os: 'Os',
      osName: 'OsName',
      podCount: 'PodCount',
      region: 'Region',
      regionId: 'RegionId',
      regionName: 'RegionName',
      riskCount: 'RiskCount',
      riskStatus: 'RiskStatus',
      safeEventCount: 'SafeEventCount',
      status: 'Status',
      tag: 'Tag',
      tagId: 'TagId',
      uuid: 'Uuid',
      vendor: 'Vendor',
      vendorName: 'VendorName',
      vpcInstanceId: 'VpcInstanceId',
      vulCount: 'VulCount',
      vulStatus: 'VulStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmStatus: 'string',
      assetType: 'string',
      authModifyTime: 'number',
      authVersion: 'number',
      authVersionName: 'string',
      bind: 'boolean',
      clientStatus: 'string',
      clusterId: 'string',
      clusterName: 'string',
      cores: 'number',
      cpuInfo: 'string',
      createdTime: 'number',
      exposedStatus: 'number',
      flag: 'number',
      groupId: 'number',
      groupTrace: 'string',
      hcStatus: 'string',
      healthCheckCount: 'number',
      importance: 'number',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      ip: 'string',
      ipListString: 'string',
      kernel: 'string',
      lastLoginTimestamp: 'number',
      macListString: 'string',
      mem: 'number',
      os: 'string',
      osName: 'string',
      podCount: 'number',
      region: 'string',
      regionId: 'string',
      regionName: 'string',
      riskCount: 'string',
      riskStatus: 'string',
      safeEventCount: 'number',
      status: 'string',
      tag: 'string',
      tagId: 'string',
      uuid: 'string',
      vendor: 'number',
      vendorName: 'string',
      vpcInstanceId: 'string',
      vulCount: 'number',
      vulStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudCenterInstancesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  nextToken?: string;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      nextToken: 'string',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudProductFieldStatisticsResponseBodyGroupedFields extends $tea.Model {
  categoryCount?: string;
  instanceCount?: number;
  riskInstanceCount?: number;
  static names(): { [key: string]: string } {
    return {
      categoryCount: 'CategoryCount',
      instanceCount: 'InstanceCount',
      riskInstanceCount: 'RiskInstanceCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      categoryCount: 'string',
      instanceCount: 'number',
      riskInstanceCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterBasicInfoResponseBodyClusterInfo extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  clusterType?: string;
  createTime?: number;
  currentVersion?: string;
  instanceCount?: number;
  regionId?: string;
  state?: string;
  targetResult?: boolean;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      createTime: 'CreateTime',
      currentVersion: 'CurrentVersion',
      instanceCount: 'InstanceCount',
      regionId: 'RegionId',
      state: 'State',
      targetResult: 'TargetResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      createTime: 'number',
      currentVersion: 'string',
      instanceCount: 'number',
      regionId: 'string',
      state: 'string',
      targetResult: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterInfoListResponseBodyClusterList extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  clusterType?: string;
  regionId?: string;
  state?: string;
  targetResult?: boolean;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      regionId: 'RegionId',
      state: 'State',
      targetResult: 'TargetResult',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      regionId: 'string',
      state: 'string',
      targetResult: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterNetworkResponseBodyClusterNetworkEdge extends $tea.Model {
  dstNodeId?: string;
  dstNodeType?: string;
  id?: string;
  port?: string;
  srcNodeId?: string;
  srcNodeType?: string;
  static names(): { [key: string]: string } {
    return {
      dstNodeId: 'DstNodeId',
      dstNodeType: 'DstNodeType',
      id: 'Id',
      port: 'Port',
      srcNodeId: 'SrcNodeId',
      srcNodeType: 'SrcNodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dstNodeId: 'string',
      dstNodeType: 'string',
      id: 'string',
      port: 'string',
      srcNodeId: 'string',
      srcNodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterNetworkResponseBodyClusterNetworkNode extends $tea.Model {
  cnnfSwitch?: number;
  id?: string;
  interceptionType?: number;
  name?: string;
  netTopoSwitch?: string;
  riskLevel?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      cnnfSwitch: 'CnnfSwitch',
      id: 'Id',
      interceptionType: 'InterceptionType',
      name: 'Name',
      netTopoSwitch: 'NetTopoSwitch',
      riskLevel: 'RiskLevel',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cnnfSwitch: 'number',
      id: 'string',
      interceptionType: 'number',
      name: 'string',
      netTopoSwitch: 'string',
      riskLevel: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterNetworkResponseBodyClusterNetwork extends $tea.Model {
  edge?: DescribeClusterNetworkResponseBodyClusterNetworkEdge[];
  node?: DescribeClusterNetworkResponseBodyClusterNetworkNode[];
  static names(): { [key: string]: string } {
    return {
      edge: 'Edge',
      node: 'Node',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edge: { 'type': 'array', 'itemType': DescribeClusterNetworkResponseBodyClusterNetworkEdge },
      node: { 'type': 'array', 'itemType': DescribeClusterNetworkResponseBodyClusterNetworkNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeClusterVulStatisticsResponseBodyVulStat extends $tea.Model {
  asapCount?: string;
  laterCount?: string;
  nntfCount?: string;
  static names(): { [key: string]: string } {
    return {
      asapCount: 'AsapCount',
      laterCount: 'LaterCount',
      nntfCount: 'NntfCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asapCount: 'string',
      laterCount: 'string',
      nntfCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonOverallConfigResponseBodyOverallConfig extends $tea.Model {
  config?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonOverallConfigListResponseBodyOverallList extends $tea.Model {
  config?: string;
  totalCount?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      totalCount: 'TotalCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      totalCount: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonTargetConfigResponseBodyTargetList extends $tea.Model {
  flag?: string;
  target?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      flag: 'Flag',
      target: 'Target',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flag: 'string',
      target: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCommonTargetResultListResponseBodyTargetConfig extends $tea.Model {
  flag?: string;
  targetDefault?: string;
  targetList?: string[];
  targetType?: string;
  totalCount?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      flag: 'Flag',
      targetDefault: 'TargetDefault',
      targetList: 'TargetList',
      targetType: 'TargetType',
      totalCount: 'TotalCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flag: 'string',
      targetDefault: 'string',
      targetList: { 'type': 'array', 'itemType': 'string' },
      targetType: 'string',
      totalCount: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerCriteriaResponseBodyCriteriaList extends $tea.Model {
  name?: string;
  type?: string;
  values?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      type: 'string',
      values: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerInstancesResponseBodyContainerInstanceList extends $tea.Model {
  alarmCount?: number;
  alarmStatus?: string;
  appName?: string;
  clusterId?: string;
  clusterName?: string;
  containerId?: string;
  createTimestamp?: number;
  exposed?: number;
  exposedDetail?: string;
  hcCount?: number;
  hcStatus?: string;
  hostIp?: string;
  image?: string;
  imageDigest?: string;
  imageId?: string;
  imageRepoName?: string;
  imageRepoNamespace?: string;
  imageRepoTag?: string;
  imageUuid?: string;
  instanceId?: string;
  namespace?: string;
  nodeInfo?: string;
  nodeName?: string;
  pod?: string;
  podIp?: string;
  regionId?: string;
  riskCount?: string;
  riskStatus?: string;
  updateMark?: string;
  vulCount?: number;
  vulStatus?: string;
  static names(): { [key: string]: string } {
    return {
      alarmCount: 'AlarmCount',
      alarmStatus: 'AlarmStatus',
      appName: 'AppName',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      containerId: 'ContainerId',
      createTimestamp: 'CreateTimestamp',
      exposed: 'Exposed',
      exposedDetail: 'ExposedDetail',
      hcCount: 'HcCount',
      hcStatus: 'HcStatus',
      hostIp: 'HostIp',
      image: 'Image',
      imageDigest: 'ImageDigest',
      imageId: 'ImageId',
      imageRepoName: 'ImageRepoName',
      imageRepoNamespace: 'ImageRepoNamespace',
      imageRepoTag: 'ImageRepoTag',
      imageUuid: 'ImageUuid',
      instanceId: 'InstanceId',
      namespace: 'Namespace',
      nodeInfo: 'NodeInfo',
      nodeName: 'NodeName',
      pod: 'Pod',
      podIp: 'PodIp',
      regionId: 'RegionId',
      riskCount: 'RiskCount',
      riskStatus: 'RiskStatus',
      updateMark: 'UpdateMark',
      vulCount: 'VulCount',
      vulStatus: 'VulStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmCount: 'number',
      alarmStatus: 'string',
      appName: 'string',
      clusterId: 'string',
      clusterName: 'string',
      containerId: 'string',
      createTimestamp: 'number',
      exposed: 'number',
      exposedDetail: 'string',
      hcCount: 'number',
      hcStatus: 'string',
      hostIp: 'string',
      image: 'string',
      imageDigest: 'string',
      imageId: 'string',
      imageRepoName: 'string',
      imageRepoNamespace: 'string',
      imageRepoTag: 'string',
      imageUuid: 'string',
      instanceId: 'string',
      namespace: 'string',
      nodeInfo: 'string',
      nodeName: 'string',
      pod: 'string',
      podIp: 'string',
      regionId: 'string',
      riskCount: 'string',
      riskStatus: 'string',
      updateMark: 'string',
      vulCount: 'number',
      vulStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerInstancesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerScanConfigResponseBodyData extends $tea.Model {
  allCount?: number;
  appNames?: string;
  chooseCount?: number;
  clusterId?: string;
  clusterName?: string;
  static names(): { [key: string]: string } {
    return {
      allCount: 'AllCount',
      appNames: 'AppNames',
      chooseCount: 'ChooseCount',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allCount: 'number',
      appNames: 'string',
      chooseCount: 'number',
      clusterId: 'string',
      clusterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeContainerStatisticsResponseBodyData extends $tea.Model {
  remindAlarmCount?: number;
  seriousAlarmCount?: number;
  suspiciousAlarmCount?: number;
  totalAlarmCount?: number;
  totalNode?: number;
  hasRiskNode?: number;
  static names(): { [key: string]: string } {
    return {
      remindAlarmCount: 'RemindAlarmCount',
      seriousAlarmCount: 'SeriousAlarmCount',
      suspiciousAlarmCount: 'SuspiciousAlarmCount',
      totalAlarmCount: 'TotalAlarmCount',
      totalNode: 'TotalNode',
      hasRiskNode: 'hasRiskNode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      remindAlarmCount: 'number',
      seriousAlarmCount: 'number',
      suspiciousAlarmCount: 'number',
      totalAlarmCount: 'number',
      totalNode: 'number',
      hasRiskNode: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCriteriaResponseBodyCriteriaList extends $tea.Model {
  multiValues?: string;
  name?: string;
  type?: string;
  values?: string;
  static names(): { [key: string]: string } {
    return {
      multiValues: 'MultiValues',
      name: 'Name',
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      multiValues: 'string',
      name: 'string',
      type: 'string',
      values: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomBlockRecordsResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomBlockRecordsResponseBodyRecordListTargetList extends $tea.Model {
  target?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      target: 'Target',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      target: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCustomBlockRecordsResponseBodyRecordList extends $tea.Model {
  blockExpireDate?: number;
  blockIp?: string;
  bound?: string;
  enableCount?: number;
  id?: number;
  serverCount?: number;
  source?: string;
  status?: number;
  targetList?: DescribeCustomBlockRecordsResponseBodyRecordListTargetList[];
  static names(): { [key: string]: string } {
    return {
      blockExpireDate: 'BlockExpireDate',
      blockIp: 'BlockIp',
      bound: 'Bound',
      enableCount: 'EnableCount',
      id: 'Id',
      serverCount: 'ServerCount',
      source: 'Source',
      status: 'Status',
      targetList: 'TargetList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockExpireDate: 'number',
      blockIp: 'string',
      bound: 'string',
      enableCount: 'number',
      id: 'number',
      serverCount: 'number',
      source: 'string',
      status: 'number',
      targetList: { 'type': 'array', 'itemType': DescribeCustomBlockRecordsResponseBodyRecordListTargetList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCycleTaskListResponseBodyCycleScheduleResponseList extends $tea.Model {
  configId?: string;
  enable?: number;
  firstDateStr?: number;
  intervalPeriod?: number;
  lastTaskId?: string;
  nextStartTimeStr?: number;
  param?: string;
  periodUnit?: string;
  targetEndTime?: number;
  targetStartTime?: number;
  taskName?: string;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      firstDateStr: 'FirstDateStr',
      intervalPeriod: 'IntervalPeriod',
      lastTaskId: 'LastTaskId',
      nextStartTimeStr: 'NextStartTimeStr',
      param: 'Param',
      periodUnit: 'PeriodUnit',
      targetEndTime: 'TargetEndTime',
      targetStartTime: 'TargetStartTime',
      taskName: 'TaskName',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      enable: 'number',
      firstDateStr: 'number',
      intervalPeriod: 'number',
      lastTaskId: 'string',
      nextStartTimeStr: 'number',
      param: 'string',
      periodUnit: 'string',
      targetEndTime: 'number',
      targetStartTime: 'number',
      taskName: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCycleTaskListResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDingTalkResponseBodyActionList extends $tea.Model {
  actionName?: string;
  aliUid?: number;
  configList?: string;
  dingTalkLang?: string;
  gmtCreate?: number;
  gmtModified?: number;
  groupIdList?: string;
  id?: number;
  intervalTime?: number;
  status?: number;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      actionName: 'ActionName',
      aliUid: 'AliUid',
      configList: 'ConfigList',
      dingTalkLang: 'DingTalkLang',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      groupIdList: 'GroupIdList',
      id: 'Id',
      intervalTime: 'IntervalTime',
      status: 'Status',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionName: 'string',
      aliUid: 'number',
      configList: 'string',
      dingTalkLang: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      groupIdList: 'string',
      id: 'number',
      intervalTime: 'number',
      status: 'number',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDingTalkResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainDetailResponseBodyDomainDetailItems extends $tea.Model {
  assetType?: string;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      assetType: 'AssetType',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetType: 'string',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainListResponseBodyDomainListResponseList extends $tea.Model {
  domain?: string;
  ipList?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      ipList: 'IpList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      ipList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDomainListResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEmgVulItemResponseBodyGroupedVulItems extends $tea.Model {
  aliasName?: string;
  checkType?: number;
  gmtLastCheck?: number;
  gmtPublish?: number;
  name?: string;
  pendingCount?: number;
  progress?: number;
  raspDefend?: number;
  status?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      checkType: 'CheckType',
      gmtLastCheck: 'GmtLastCheck',
      gmtPublish: 'GmtPublish',
      name: 'Name',
      pendingCount: 'PendingCount',
      progress: 'Progress',
      raspDefend: 'RaspDefend',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      checkType: 'number',
      gmtLastCheck: 'number',
      gmtPublish: 'number',
      name: 'string',
      pendingCount: 'number',
      progress: 'number',
      raspDefend: 'number',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventLevelCountResponseBodyEventLevels extends $tea.Model {
  remind?: number;
  serious?: number;
  suspicious?: number;
  static names(): { [key: string]: string } {
    return {
      remind: 'Remind',
      serious: 'Serious',
      suspicious: 'Suspicious',
    };
  }

  static types(): { [key: string]: any } {
    return {
      remind: 'number',
      serious: 'number',
      suspicious: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEventOnStageResponseBodySecurityEventStageResponse extends $tea.Model {
  securityEventOnStag?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      securityEventOnStag: 'SecurityEventOnStag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityEventOnStag: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExcludeSystemPathResponseBodyExcludePaths extends $tea.Model {
  os?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      os: 'Os',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      os: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExcludeSystemPathResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedCheckWarningResponseBodyWarningList extends $tea.Model {
  riskId?: number;
  riskName?: string;
  subTypeAlias?: string;
  typeAlias?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      riskId: 'RiskId',
      riskName: 'RiskName',
      subTypeAlias: 'SubTypeAlias',
      typeAlias: 'TypeAlias',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      riskId: 'number',
      riskName: 'string',
      subTypeAlias: 'string',
      typeAlias: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceCriteriaResponseBodyCriteriaList extends $tea.Model {
  name?: string;
  type?: string;
  values?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      type: 'string',
      values: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList extends $tea.Model {
  aliasName?: string;
  name?: string;
  necessity?: string;
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      name: 'Name',
      necessity: 'Necessity',
      type: 'Type',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      name: 'string',
      necessity: 'string',
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList extends $tea.Model {
  aliasName?: string;
  name?: string;
  necessity?: string;
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      name: 'Name',
      necessity: 'Necessity',
      type: 'Type',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      name: 'string',
      necessity: 'string',
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceDetailResponseBodyExposedChains extends $tea.Model {
  allVulList?: DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList[];
  exposureComponent?: string;
  exposureIp?: string;
  exposurePort?: string;
  exposureType?: string;
  exposureTypeId?: string;
  groupNo?: string;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  realVulList?: DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList[];
  regionId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      allVulList: 'AllVulList',
      exposureComponent: 'ExposureComponent',
      exposureIp: 'ExposureIp',
      exposurePort: 'ExposurePort',
      exposureType: 'ExposureType',
      exposureTypeId: 'ExposureTypeId',
      groupNo: 'GroupNo',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      realVulList: 'RealVulList',
      regionId: 'RegionId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allVulList: { 'type': 'array', 'itemType': DescribeExposedInstanceDetailResponseBodyExposedChainsAllVulList },
      exposureComponent: 'string',
      exposureIp: 'string',
      exposurePort: 'string',
      exposureType: 'string',
      exposureTypeId: 'string',
      groupNo: 'string',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      realVulList: { 'type': 'array', 'itemType': DescribeExposedInstanceDetailResponseBodyExposedChainsRealVulList },
      regionId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceListResponseBodyExposedInstances extends $tea.Model {
  asapVulCount?: number;
  exploitHealthCount?: number;
  exposureComponent?: string;
  exposureIp?: string;
  exposurePort?: string;
  exposureType?: string;
  exposureTypeId?: string;
  groupId?: number;
  groupName?: string;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  laterVulCount?: number;
  nntfVulCount?: number;
  regionId?: string;
  totalVulCount?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      asapVulCount: 'AsapVulCount',
      exploitHealthCount: 'ExploitHealthCount',
      exposureComponent: 'ExposureComponent',
      exposureIp: 'ExposureIp',
      exposurePort: 'ExposurePort',
      exposureType: 'ExposureType',
      exposureTypeId: 'ExposureTypeId',
      groupId: 'GroupId',
      groupName: 'GroupName',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      laterVulCount: 'LaterVulCount',
      nntfVulCount: 'NntfVulCount',
      regionId: 'RegionId',
      totalVulCount: 'TotalVulCount',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asapVulCount: 'number',
      exploitHealthCount: 'number',
      exposureComponent: 'string',
      exposureIp: 'string',
      exposurePort: 'string',
      exposureType: 'string',
      exposureTypeId: 'string',
      groupId: 'number',
      groupName: 'string',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      laterVulCount: 'number',
      nntfVulCount: 'number',
      regionId: 'string',
      totalVulCount: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedInstanceListResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedStatisticsDetailResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExposedStatisticsDetailResponseBodyStatisticsDetails extends $tea.Model {
  exposedCount?: number;
  exposureComponent?: string;
  exposureIp?: string;
  exposurePort?: string;
  exposureType?: string;
  exposureTypeId?: string;
  exposureTypeInstanceName?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      exposedCount: 'ExposedCount',
      exposureComponent: 'ExposureComponent',
      exposureIp: 'ExposureIp',
      exposurePort: 'ExposurePort',
      exposureType: 'ExposureType',
      exposureTypeId: 'ExposureTypeId',
      exposureTypeInstanceName: 'ExposureTypeInstanceName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exposedCount: 'number',
      exposureComponent: 'string',
      exposureIp: 'string',
      exposurePort: 'string',
      exposureType: 'string',
      exposureTypeId: 'string',
      exposureTypeInstanceName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFieldStatisticsResponseBodyGroupedFields extends $tea.Model {
  aliYunInstanceCount?: number;
  awsInstanceCount?: number;
  azureInstanceCount?: number;
  exposedInstanceCount?: number;
  generalAssetCount?: number;
  groupCount?: number;
  huaweiInstanceCount?: number;
  idcInstanceCount?: number;
  importantAssetCount?: number;
  instanceCount?: number;
  instanceSyncTaskCount?: number;
  newInstanceCount?: number;
  noRiskInstanceCount?: number;
  notRunningStatusCount?: number;
  offlineInstanceCount?: number;
  outMachineInstanceCount?: number;
  pauseInstanceCount?: number;
  regionCount?: number;
  riskInstanceCount?: number;
  tencentInstanceCount?: number;
  testAssetCount?: number;
  tripartiteInstanceCount?: number;
  unKnowStatusInstanceCount?: number;
  unprotectedInstanceCount?: number;
  vpcCount?: number;
  static names(): { [key: string]: string } {
    return {
      aliYunInstanceCount: 'AliYunInstanceCount',
      awsInstanceCount: 'AwsInstanceCount',
      azureInstanceCount: 'AzureInstanceCount',
      exposedInstanceCount: 'ExposedInstanceCount',
      generalAssetCount: 'GeneralAssetCount',
      groupCount: 'GroupCount',
      huaweiInstanceCount: 'HuaweiInstanceCount',
      idcInstanceCount: 'IdcInstanceCount',
      importantAssetCount: 'ImportantAssetCount',
      instanceCount: 'InstanceCount',
      instanceSyncTaskCount: 'InstanceSyncTaskCount',
      newInstanceCount: 'NewInstanceCount',
      noRiskInstanceCount: 'NoRiskInstanceCount',
      notRunningStatusCount: 'NotRunningStatusCount',
      offlineInstanceCount: 'OfflineInstanceCount',
      outMachineInstanceCount: 'OutMachineInstanceCount',
      pauseInstanceCount: 'PauseInstanceCount',
      regionCount: 'RegionCount',
      riskInstanceCount: 'RiskInstanceCount',
      tencentInstanceCount: 'TencentInstanceCount',
      testAssetCount: 'TestAssetCount',
      tripartiteInstanceCount: 'TripartiteInstanceCount',
      unKnowStatusInstanceCount: 'UnKnowStatusInstanceCount',
      unprotectedInstanceCount: 'UnprotectedInstanceCount',
      vpcCount: 'VpcCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliYunInstanceCount: 'number',
      awsInstanceCount: 'number',
      azureInstanceCount: 'number',
      exposedInstanceCount: 'number',
      generalAssetCount: 'number',
      groupCount: 'number',
      huaweiInstanceCount: 'number',
      idcInstanceCount: 'number',
      importantAssetCount: 'number',
      instanceCount: 'number',
      instanceSyncTaskCount: 'number',
      newInstanceCount: 'number',
      noRiskInstanceCount: 'number',
      notRunningStatusCount: 'number',
      offlineInstanceCount: 'number',
      outMachineInstanceCount: 'number',
      pauseInstanceCount: 'number',
      regionCount: 'number',
      riskInstanceCount: 'number',
      tencentInstanceCount: 'number',
      testAssetCount: 'number',
      tripartiteInstanceCount: 'number',
      unKnowStatusInstanceCount: 'number',
      unprotectedInstanceCount: 'number',
      vpcCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList extends $tea.Model {
  aliasName?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFrontVulPatchListResponseBodyFrontPatchList extends $tea.Model {
  patchList?: DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList[];
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      patchList: 'PatchList',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      patchList: { 'type': 'array', 'itemType': DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList },
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedContainerInstancesResponseBodyGroupedContainerInstanceList extends $tea.Model {
  alarmCount?: number;
  appName?: string;
  clusterId?: string;
  clusterName?: string;
  clusterType?: string;
  createTime?: number;
  custerState?: string;
  hcCount?: number;
  hostIp?: string;
  image?: string;
  imageDigest?: string;
  imageRepoName?: string;
  imageRepoNamespace?: string;
  imageRepoTag?: string;
  imageUuid?: string;
  instanceCount?: number;
  instanceId?: string;
  namespace?: string;
  pod?: string;
  podIp?: string;
  regionId?: string;
  riskInstanceCount?: number;
  riskLevel?: string;
  riskStatus?: string;
  vulCount?: number;
  static names(): { [key: string]: string } {
    return {
      alarmCount: 'AlarmCount',
      appName: 'AppName',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      createTime: 'CreateTime',
      custerState: 'CusterState',
      hcCount: 'HcCount',
      hostIp: 'HostIp',
      image: 'Image',
      imageDigest: 'ImageDigest',
      imageRepoName: 'ImageRepoName',
      imageRepoNamespace: 'ImageRepoNamespace',
      imageRepoTag: 'ImageRepoTag',
      imageUuid: 'ImageUuid',
      instanceCount: 'InstanceCount',
      instanceId: 'InstanceId',
      namespace: 'Namespace',
      pod: 'Pod',
      podIp: 'PodIp',
      regionId: 'RegionId',
      riskInstanceCount: 'RiskInstanceCount',
      riskLevel: 'RiskLevel',
      riskStatus: 'RiskStatus',
      vulCount: 'VulCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmCount: 'number',
      appName: 'string',
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      createTime: 'number',
      custerState: 'string',
      hcCount: 'number',
      hostIp: 'string',
      image: 'string',
      imageDigest: 'string',
      imageRepoName: 'string',
      imageRepoNamespace: 'string',
      imageRepoTag: 'string',
      imageUuid: 'string',
      instanceCount: 'number',
      instanceId: 'string',
      namespace: 'string',
      pod: 'string',
      podIp: 'string',
      regionId: 'string',
      riskInstanceCount: 'number',
      riskLevel: 'string',
      riskStatus: 'string',
      vulCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedContainerInstancesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedInstancesResponseBodyInstances extends $tea.Model {
  asapVulInstanceCount?: number;
  authVersionCheckCount?: number;
  fieldAliasName?: string;
  groupFlag?: number;
  instanceCount?: string;
  os?: string;
  riskInstanceCount?: string;
  unProtectedInstanceCount?: string;
  static names(): { [key: string]: string } {
    return {
      asapVulInstanceCount: 'AsapVulInstanceCount',
      authVersionCheckCount: 'AuthVersionCheckCount',
      fieldAliasName: 'FieldAliasName',
      groupFlag: 'GroupFlag',
      instanceCount: 'InstanceCount',
      os: 'Os',
      riskInstanceCount: 'RiskInstanceCount',
      unProtectedInstanceCount: 'UnProtectedInstanceCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asapVulInstanceCount: 'number',
      authVersionCheckCount: 'number',
      fieldAliasName: 'string',
      groupFlag: 'number',
      instanceCount: 'string',
      os: 'string',
      riskInstanceCount: 'string',
      unProtectedInstanceCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedInstancesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedMaliciousFilesResponseBodyGroupedMaliciousFileResponse extends $tea.Model {
  firstScanTimestamp?: number;
  imageCount?: number;
  latestScanTimestamp?: number;
  level?: string;
  maliciousKey?: string;
  maliciousMd5?: string;
  maliciousName?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      firstScanTimestamp: 'FirstScanTimestamp',
      imageCount: 'ImageCount',
      latestScanTimestamp: 'LatestScanTimestamp',
      level: 'Level',
      maliciousKey: 'MaliciousKey',
      maliciousMd5: 'MaliciousMd5',
      maliciousName: 'MaliciousName',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firstScanTimestamp: 'number',
      imageCount: 'number',
      latestScanTimestamp: 'number',
      level: 'string',
      maliciousKey: 'string',
      maliciousMd5: 'string',
      maliciousName: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedMaliciousFilesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedTagsResponseBodyGroupedFileds extends $tea.Model {
  count?: string;
  name?: string;
  tagId?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      name: 'Name',
      tagId: 'TagId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'string',
      name: 'string',
      tagId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGroupedVulResponseBodyGroupedVulItems extends $tea.Model {
  aliasName?: string;
  asapCount?: number;
  gmtLast?: number;
  handledCount?: number;
  laterCount?: number;
  name?: string;
  nntfCount?: number;
  raspDefend?: number;
  related?: string;
  tags?: string;
  totalFixCount?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      asapCount: 'AsapCount',
      gmtLast: 'GmtLast',
      handledCount: 'HandledCount',
      laterCount: 'LaterCount',
      name: 'Name',
      nntfCount: 'NntfCount',
      raspDefend: 'RaspDefend',
      related: 'Related',
      tags: 'Tags',
      totalFixCount: 'TotalFixCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      asapCount: 'number',
      gmtLast: 'number',
      handledCount: 'number',
      laterCount: 'number',
      name: 'string',
      nntfCount: 'number',
      raspDefend: 'number',
      related: 'string',
      tags: 'string',
      totalFixCount: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeHoneyPotSuspStatisticsResponseBodySuspHoneyPotStatisticsResponse extends $tea.Model {
  count?: number;
  instanceId?: string;
  instanceName?: string;
  type?: string;
  vpcId?: string;
  vpcName?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      type: 'Type',
      vpcId: 'VpcId',
      vpcName: 'VpcName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      instanceId: 'string',
      instanceName: 'string',
      type: 'string',
      vpcId: 'string',
      vpcName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageResponseBodyData extends $tea.Model {
  digest?: string;
  static names(): { [key: string]: string } {
    return {
      digest: 'Digest',
    };
  }

  static types(): { [key: string]: any } {
    return {
      digest: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineCheckResultResponseBodyBaselineResult extends $tea.Model {
  baselineClassAlias?: string;
  baselineItemCount?: number;
  baselineNameAlias?: string;
  baselineNameKey?: string;
  baselineNameLevel?: string;
  firstScanTime?: number;
  highRiskItemCount?: number;
  lastScanTime?: number;
  lowRiskItemCount?: number;
  middleRiskItemCount?: number;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      baselineClassAlias: 'BaselineClassAlias',
      baselineItemCount: 'BaselineItemCount',
      baselineNameAlias: 'BaselineNameAlias',
      baselineNameKey: 'BaselineNameKey',
      baselineNameLevel: 'BaselineNameLevel',
      firstScanTime: 'FirstScanTime',
      highRiskItemCount: 'HighRiskItemCount',
      lastScanTime: 'LastScanTime',
      lowRiskItemCount: 'LowRiskItemCount',
      middleRiskItemCount: 'MiddleRiskItemCount',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineClassAlias: 'string',
      baselineItemCount: 'number',
      baselineNameAlias: 'string',
      baselineNameKey: 'string',
      baselineNameLevel: 'string',
      firstScanTime: 'number',
      highRiskItemCount: 'number',
      lastScanTime: 'number',
      lowRiskItemCount: 'number',
      middleRiskItemCount: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineCheckResultResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineCheckSummaryResponseBodyBaselineResultSummary extends $tea.Model {
  baselineClassAlias?: string;
  baselineClassKey?: string;
  baselineNameAlias?: string;
  baselineNameKey?: string;
  baselineNameLevel?: string;
  firstScanTime?: number;
  highRiskImage?: number;
  lastScanTime?: number;
  lowRiskImage?: number;
  middleRiskImage?: number;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      baselineClassAlias: 'BaselineClassAlias',
      baselineClassKey: 'BaselineClassKey',
      baselineNameAlias: 'BaselineNameAlias',
      baselineNameKey: 'BaselineNameKey',
      baselineNameLevel: 'BaselineNameLevel',
      firstScanTime: 'FirstScanTime',
      highRiskImage: 'HighRiskImage',
      lastScanTime: 'LastScanTime',
      lowRiskImage: 'LowRiskImage',
      middleRiskImage: 'MiddleRiskImage',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineClassAlias: 'string',
      baselineClassKey: 'string',
      baselineNameAlias: 'string',
      baselineNameKey: 'string',
      baselineNameLevel: 'string',
      firstScanTime: 'number',
      highRiskImage: 'number',
      lastScanTime: 'number',
      lowRiskImage: 'number',
      middleRiskImage: 'number',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineCheckSummaryResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineDetailResponseBodyBaselineDetail extends $tea.Model {
  advice?: string;
  baselineClassAlias?: string;
  baselineItemAlias?: string;
  baselineItemKey?: string;
  baselineNameAlias?: string;
  description?: string;
  level?: string;
  prompt?: string;
  resultId?: string;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      baselineClassAlias: 'BaselineClassAlias',
      baselineItemAlias: 'BaselineItemAlias',
      baselineItemKey: 'BaselineItemKey',
      baselineNameAlias: 'BaselineNameAlias',
      description: 'Description',
      level: 'Level',
      prompt: 'Prompt',
      resultId: 'ResultId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      baselineClassAlias: 'string',
      baselineItemAlias: 'string',
      baselineItemKey: 'string',
      baselineNameAlias: 'string',
      description: 'string',
      level: 'string',
      prompt: 'string',
      resultId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineItemListResponseBodyBaselineItemInfos extends $tea.Model {
  baselineClassAlias?: string;
  baselineClassKey?: string;
  baselineItemAlias?: string;
  baselineItemKey?: string;
  baselineNameAlias?: string;
  baselineNameKey?: string;
  status?: number;
  whiteList?: number;
  static names(): { [key: string]: string } {
    return {
      baselineClassAlias: 'BaselineClassAlias',
      baselineClassKey: 'BaselineClassKey',
      baselineItemAlias: 'BaselineItemAlias',
      baselineItemKey: 'BaselineItemKey',
      baselineNameAlias: 'BaselineNameAlias',
      baselineNameKey: 'BaselineNameKey',
      status: 'Status',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineClassAlias: 'string',
      baselineClassKey: 'string',
      baselineItemAlias: 'string',
      baselineItemKey: 'string',
      baselineNameAlias: 'string',
      baselineNameKey: 'string',
      status: 'number',
      whiteList: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineItemListResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList extends $tea.Model {
  classKey?: string;
  itemKey?: string;
  nameKey?: string;
  static names(): { [key: string]: string } {
    return {
      classKey: 'ClassKey',
      itemKey: 'ItemKey',
      nameKey: 'NameKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classKey: 'string',
      itemKey: 'string',
      nameKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageBaselineStrategyResponseBodyStrategy extends $tea.Model {
  baselineItem?: string;
  baselineItemList?: DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList[];
  selectedItemCount?: number;
  strategyId?: number;
  strategyName?: string;
  totalItemCount?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      baselineItem: 'BaselineItem',
      baselineItemList: 'BaselineItemList',
      selectedItemCount: 'SelectedItemCount',
      strategyId: 'StrategyId',
      strategyName: 'StrategyName',
      totalItemCount: 'TotalItemCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineItem: 'string',
      baselineItemList: { 'type': 'array', 'itemType': DescribeImageBaselineStrategyResponseBodyStrategyBaselineItemList },
      selectedItemCount: 'number',
      strategyId: 'number',
      strategyName: 'string',
      totalItemCount: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageCriteriaResponseBodyCriteriaList extends $tea.Model {
  name?: string;
  type?: string;
  values?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      type: 'string',
      values: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageEventOperationConditionResponseBodyDataOperationsConditions extends $tea.Model {
  conditionKey?: string;
  conditionName?: string;
  supportedMisType?: string[];
  static names(): { [key: string]: string } {
    return {
      conditionKey: 'ConditionKey',
      conditionName: 'ConditionName',
      supportedMisType: 'SupportedMisType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditionKey: 'string',
      conditionName: 'string',
      supportedMisType: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageEventOperationConditionResponseBodyDataOperations extends $tea.Model {
  conditions?: DescribeImageEventOperationConditionResponseBodyDataOperationsConditions[];
  operationCode?: string;
  operationName?: string;
  static names(): { [key: string]: string } {
    return {
      conditions: 'Conditions',
      operationCode: 'OperationCode',
      operationName: 'OperationName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditions: { 'type': 'array', 'itemType': DescribeImageEventOperationConditionResponseBodyDataOperationsConditions },
      operationCode: 'string',
      operationName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageEventOperationConditionResponseBodyData extends $tea.Model {
  eventType?: string;
  operations?: DescribeImageEventOperationConditionResponseBodyDataOperations[];
  scenarios?: string[];
  static names(): { [key: string]: string } {
    return {
      eventType: 'EventType',
      operations: 'Operations',
      scenarios: 'Scenarios',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventType: 'string',
      operations: { 'type': 'array', 'itemType': DescribeImageEventOperationConditionResponseBodyDataOperations },
      scenarios: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageEventOperationPageResponseBodyDataList extends $tea.Model {
  conditions?: string;
  eventKey?: string;
  eventName?: string;
  eventType?: string;
  id?: number;
  operationCode?: string;
  scenarios?: string;
  static names(): { [key: string]: string } {
    return {
      conditions: 'Conditions',
      eventKey: 'EventKey',
      eventName: 'EventName',
      eventType: 'EventType',
      id: 'Id',
      operationCode: 'OperationCode',
      scenarios: 'Scenarios',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditions: 'string',
      eventKey: 'string',
      eventName: 'string',
      eventType: 'string',
      id: 'number',
      operationCode: 'string',
      scenarios: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageEventOperationPageResponseBodyDataPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageEventOperationPageResponseBodyData extends $tea.Model {
  list?: DescribeImageEventOperationPageResponseBodyDataList[];
  pageInfo?: DescribeImageEventOperationPageResponseBodyDataPageInfo;
  static names(): { [key: string]: string } {
    return {
      list: 'List',
      pageInfo: 'PageInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      list: { 'type': 'array', 'itemType': DescribeImageEventOperationPageResponseBodyDataList },
      pageInfo: DescribeImageEventOperationPageResponseBodyDataPageInfo,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFixCycleConfigResponseBodyData extends $tea.Model {
  imageFixCycle?: number;
  imageFixSwitch?: string;
  imageFixTarget?: string;
  imageTimeRange?: number;
  static names(): { [key: string]: string } {
    return {
      imageFixCycle: 'ImageFixCycle',
      imageFixSwitch: 'ImageFixSwitch',
      imageFixTarget: 'ImageFixTarget',
      imageTimeRange: 'ImageTimeRange',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageFixCycle: 'number',
      imageFixSwitch: 'string',
      imageFixTarget: 'string',
      imageTimeRange: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFixTaskResponseBodyBuildTasks extends $tea.Model {
  buildTaskId?: string;
  finishTime?: string;
  fixTime?: string;
  newTag?: string;
  newUuid?: string;
  oldTag?: string;
  oldUuid?: string;
  regionId?: string;
  repoName?: string;
  repoNamespace?: string;
  status?: number;
  taskType?: string;
  vulAlias?: string;
  static names(): { [key: string]: string } {
    return {
      buildTaskId: 'BuildTaskId',
      finishTime: 'FinishTime',
      fixTime: 'FixTime',
      newTag: 'NewTag',
      newUuid: 'NewUuid',
      oldTag: 'OldTag',
      oldUuid: 'OldUuid',
      regionId: 'RegionId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      status: 'Status',
      taskType: 'TaskType',
      vulAlias: 'VulAlias',
    };
  }

  static types(): { [key: string]: any } {
    return {
      buildTaskId: 'string',
      finishTime: 'string',
      fixTime: 'string',
      newTag: 'string',
      newUuid: 'string',
      oldTag: 'string',
      oldUuid: 'string',
      regionId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      status: 'number',
      taskType: 'string',
      vulAlias: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageFixTaskResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageGroupedVulListResponseBodyGroupedVulItems extends $tea.Model {
  aliasName?: string;
  asapCount?: number;
  canFix?: string;
  gmtLast?: number;
  lastScanTime?: number;
  laterCount?: number;
  name?: string;
  nntfCount?: number;
  status?: number;
  tags?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      asapCount: 'AsapCount',
      canFix: 'CanFix',
      gmtLast: 'GmtLast',
      lastScanTime: 'LastScanTime',
      laterCount: 'LaterCount',
      name: 'Name',
      nntfCount: 'NntfCount',
      status: 'Status',
      tags: 'Tags',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      asapCount: 'number',
      canFix: 'string',
      gmtLast: 'number',
      lastScanTime: 'number',
      laterCount: 'number',
      name: 'string',
      nntfCount: 'number',
      status: 'number',
      tags: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageInfoListResponseBodyImageInfos extends $tea.Model {
  alarmCount?: number;
  alarmStatus?: string;
  digest?: string;
  endpoints?: string;
  imageCreate?: number;
  imageId?: string;
  imageSize?: number;
  imageUpdate?: number;
  instanceId?: string;
  regionId?: string;
  registryType?: string;
  repoId?: string;
  repoName?: string;
  repoNamespace?: string;
  repoType?: string;
  riskStatus?: string;
  status?: string;
  tag?: string;
  tagImmutable?: number;
  uuid?: string;
  vulCount?: number;
  vulStatus?: string;
  static names(): { [key: string]: string } {
    return {
      alarmCount: 'AlarmCount',
      alarmStatus: 'AlarmStatus',
      digest: 'Digest',
      endpoints: 'Endpoints',
      imageCreate: 'ImageCreate',
      imageId: 'ImageId',
      imageSize: 'ImageSize',
      imageUpdate: 'ImageUpdate',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      registryType: 'RegistryType',
      repoId: 'RepoId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      repoType: 'RepoType',
      riskStatus: 'RiskStatus',
      status: 'Status',
      tag: 'Tag',
      tagImmutable: 'TagImmutable',
      uuid: 'Uuid',
      vulCount: 'VulCount',
      vulStatus: 'VulStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmCount: 'number',
      alarmStatus: 'string',
      digest: 'string',
      endpoints: 'string',
      imageCreate: 'number',
      imageId: 'string',
      imageSize: 'number',
      imageUpdate: 'number',
      instanceId: 'string',
      regionId: 'string',
      registryType: 'string',
      repoId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      repoType: 'string',
      riskStatus: 'string',
      status: 'string',
      tag: 'string',
      tagImmutable: 'number',
      uuid: 'string',
      vulCount: 'number',
      vulStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageInstancesResponseBodyImageInstanceList extends $tea.Model {
  alarmCount?: number;
  alarmStatus?: string;
  deployed?: number;
  digest?: string;
  endpoints?: string;
  hcCount?: number;
  hcStatus?: string;
  imageCreate?: string;
  imageId?: string;
  imageSize?: string;
  imageUpdate?: string;
  instanceId?: string;
  regionId?: string;
  registryType?: string;
  repoId?: string;
  repoName?: string;
  repoNamespace?: string;
  repoType?: string;
  riskStatus?: string;
  scaProgress?: number;
  scaResult?: string;
  scaStatus?: string;
  status?: string;
  tag?: string;
  uuid?: string;
  vulCount?: number;
  vulStatus?: string;
  static names(): { [key: string]: string } {
    return {
      alarmCount: 'AlarmCount',
      alarmStatus: 'AlarmStatus',
      deployed: 'Deployed',
      digest: 'Digest',
      endpoints: 'Endpoints',
      hcCount: 'HcCount',
      hcStatus: 'HcStatus',
      imageCreate: 'ImageCreate',
      imageId: 'ImageId',
      imageSize: 'ImageSize',
      imageUpdate: 'ImageUpdate',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      registryType: 'RegistryType',
      repoId: 'RepoId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      repoType: 'RepoType',
      riskStatus: 'RiskStatus',
      scaProgress: 'ScaProgress',
      scaResult: 'ScaResult',
      scaStatus: 'ScaStatus',
      status: 'Status',
      tag: 'Tag',
      uuid: 'Uuid',
      vulCount: 'VulCount',
      vulStatus: 'VulStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmCount: 'number',
      alarmStatus: 'string',
      deployed: 'number',
      digest: 'string',
      endpoints: 'string',
      hcCount: 'number',
      hcStatus: 'string',
      imageCreate: 'string',
      imageId: 'string',
      imageSize: 'string',
      imageUpdate: 'string',
      instanceId: 'string',
      regionId: 'string',
      registryType: 'string',
      repoId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      repoType: 'string',
      riskStatus: 'string',
      scaProgress: 'number',
      scaResult: 'string',
      scaStatus: 'string',
      status: 'string',
      tag: 'string',
      uuid: 'string',
      vulCount: 'number',
      vulStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageInstancesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageLatestScanTaskResponseBodyTask extends $tea.Model {
  create?: string;
  finish?: number;
  finishTime?: number;
  id?: number;
  modified?: string;
  name?: string;
  source?: string;
  startTime?: number;
  status?: string;
  target?: string;
  targetType?: string;
  taskId?: string;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      create: 'Create',
      finish: 'Finish',
      finishTime: 'FinishTime',
      id: 'Id',
      modified: 'Modified',
      name: 'Name',
      source: 'Source',
      startTime: 'StartTime',
      status: 'Status',
      target: 'Target',
      targetType: 'TargetType',
      taskId: 'TaskId',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      create: 'string',
      finish: 'number',
      finishTime: 'number',
      id: 'number',
      modified: 'string',
      name: 'string',
      source: 'string',
      startTime: 'number',
      status: 'string',
      target: 'string',
      targetType: 'string',
      taskId: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageListBySensitiveFileResponseBodyImageInfos extends $tea.Model {
  digest?: string;
  firstScanTime?: number;
  instanceId?: string;
  lastScanTime?: number;
  regionId?: string;
  repoName?: string;
  repoNamespace?: string;
  riskLevel?: string;
  status?: string;
  tag?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      digest: 'Digest',
      firstScanTime: 'FirstScanTime',
      instanceId: 'InstanceId',
      lastScanTime: 'LastScanTime',
      regionId: 'RegionId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      riskLevel: 'RiskLevel',
      status: 'Status',
      tag: 'Tag',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      digest: 'string',
      firstScanTime: 'number',
      instanceId: 'string',
      lastScanTime: 'number',
      regionId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      riskLevel: 'string',
      status: 'string',
      tag: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageListBySensitiveFileResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  lastRowKey?: string;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      lastRowKey: 'LastRowKey',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      lastRowKey: 'string',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageListWithBaselineNameResponseBodyImageInfos extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  containerId?: string;
  digest?: string;
  highRiskImage?: number;
  image?: string;
  imageCreate?: number;
  imageId?: string;
  imageSize?: number;
  imageUpdate?: number;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  lastScanTime?: number;
  lowRiskImage?: number;
  middleRiskImage?: number;
  namespace?: string;
  noRiskImage?: number;
  pod?: string;
  regionId?: string;
  repoId?: string;
  repoName?: string;
  repoNamespace?: string;
  repoType?: string;
  riskStatus?: string;
  tag?: string;
  targetId?: string;
  targetName?: string;
  targetType?: string;
  totalItemCount?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      containerId: 'ContainerId',
      digest: 'Digest',
      highRiskImage: 'HighRiskImage',
      image: 'Image',
      imageCreate: 'ImageCreate',
      imageId: 'ImageId',
      imageSize: 'ImageSize',
      imageUpdate: 'ImageUpdate',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      lastScanTime: 'LastScanTime',
      lowRiskImage: 'LowRiskImage',
      middleRiskImage: 'MiddleRiskImage',
      namespace: 'Namespace',
      noRiskImage: 'NoRiskImage',
      pod: 'Pod',
      regionId: 'RegionId',
      repoId: 'RepoId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      repoType: 'RepoType',
      riskStatus: 'RiskStatus',
      tag: 'Tag',
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
      totalItemCount: 'TotalItemCount',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      containerId: 'string',
      digest: 'string',
      highRiskImage: 'number',
      image: 'string',
      imageCreate: 'number',
      imageId: 'string',
      imageSize: 'number',
      imageUpdate: 'number',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      lastScanTime: 'number',
      lowRiskImage: 'number',
      middleRiskImage: 'number',
      namespace: 'string',
      noRiskImage: 'number',
      pod: 'string',
      regionId: 'string',
      repoId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      repoType: 'string',
      riskStatus: 'string',
      tag: 'string',
      targetId: 'string',
      targetName: 'string',
      targetType: 'string',
      totalItemCount: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageListWithBaselineNameResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoCriteriaResponseBodyCriteriaList extends $tea.Model {
  name?: string;
  type?: string;
  values?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      type: 'string',
      values: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoDetailListResponseBodyImageRepoResponses extends $tea.Model {
  alarmCount?: number;
  alarmStatus?: string;
  endpoints?: string;
  hcCount?: number;
  hcStatus?: string;
  imageCount?: number;
  instanceId?: string;
  regionId?: string;
  registryType?: string;
  repoId?: string;
  repoName?: string;
  repoNamespace?: string;
  riskStatus?: string;
  vulCount?: number;
  vulStatus?: string;
  static names(): { [key: string]: string } {
    return {
      alarmCount: 'AlarmCount',
      alarmStatus: 'AlarmStatus',
      endpoints: 'Endpoints',
      hcCount: 'HcCount',
      hcStatus: 'HcStatus',
      imageCount: 'ImageCount',
      instanceId: 'InstanceId',
      regionId: 'RegionId',
      registryType: 'RegistryType',
      repoId: 'RepoId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      riskStatus: 'RiskStatus',
      vulCount: 'VulCount',
      vulStatus: 'VulStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmCount: 'number',
      alarmStatus: 'string',
      endpoints: 'string',
      hcCount: 'number',
      hcStatus: 'string',
      imageCount: 'number',
      instanceId: 'string',
      regionId: 'string',
      registryType: 'string',
      repoId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      riskStatus: 'string',
      vulCount: 'number',
      vulStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoDetailListResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoListResponseBodyImageRepoList extends $tea.Model {
  flag?: string;
  repoName?: string;
  repoNamespace?: string;
  static names(): { [key: string]: string } {
    return {
      flag: 'Flag',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flag: 'string',
      repoName: 'string',
      repoNamespace: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageRepoListResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageScanAuthCountResponseBodyImageScan extends $tea.Model {
  imageScanCapacity?: number;
  instanceId?: string;
  scanCount?: number;
  static names(): { [key: string]: string } {
    return {
      imageScanCapacity: 'ImageScanCapacity',
      instanceId: 'InstanceId',
      scanCount: 'ScanCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageScanCapacity: 'number',
      instanceId: 'string',
      scanCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageScanAuthorizationResponseBodyAuthStatus extends $tea.Model {
  status?: boolean;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSensitiveFileByKeyResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  lastRowKey?: string;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      lastRowKey: 'LastRowKey',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      lastRowKey: 'string',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSensitiveFileByKeyResponseBodySensitiveFileList extends $tea.Model {
  advice?: string;
  description?: string;
  filePath?: string;
  firstScanTime?: number;
  lastScanTime?: number;
  layerDigest?: string;
  md5?: string;
  promt?: string;
  riskLevel?: string;
  sensitiveFileKey?: string;
  sensitiveFileName?: string;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      description: 'Description',
      filePath: 'FilePath',
      firstScanTime: 'FirstScanTime',
      lastScanTime: 'LastScanTime',
      layerDigest: 'LayerDigest',
      md5: 'Md5',
      promt: 'Promt',
      riskLevel: 'RiskLevel',
      sensitiveFileKey: 'SensitiveFileKey',
      sensitiveFileName: 'SensitiveFileName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      description: 'string',
      filePath: 'string',
      firstScanTime: 'number',
      lastScanTime: 'number',
      layerDigest: 'string',
      md5: 'string',
      promt: 'string',
      riskLevel: 'string',
      sensitiveFileKey: 'string',
      sensitiveFileName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSensitiveFileListResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  lastRowKey?: string;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      lastRowKey: 'LastRowKey',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      lastRowKey: 'string',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageSensitiveFileListResponseBodySensitiveFileList extends $tea.Model {
  classKey?: string;
  className?: string;
  count?: number;
  firstScanTime?: number;
  lastScanTime?: number;
  riskLevel?: string;
  sensitiveFileKey?: string;
  sensitiveFileName?: string;
  static names(): { [key: string]: string } {
    return {
      classKey: 'ClassKey',
      className: 'ClassName',
      count: 'Count',
      firstScanTime: 'FirstScanTime',
      lastScanTime: 'LastScanTime',
      riskLevel: 'RiskLevel',
      sensitiveFileKey: 'SensitiveFileKey',
      sensitiveFileName: 'SensitiveFileName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classKey: 'string',
      className: 'string',
      count: 'number',
      firstScanTime: 'number',
      lastScanTime: 'number',
      riskLevel: 'string',
      sensitiveFileKey: 'string',
      sensitiveFileName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList extends $tea.Model {
  fullVersion?: string;
  layer?: string;
  matchDetail?: string;
  matchList?: string[];
  name?: string;
  path?: string;
  updateCmd?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      fullVersion: 'FullVersion',
      layer: 'Layer',
      matchDetail: 'MatchDetail',
      matchList: 'MatchList',
      name: 'Name',
      path: 'Path',
      updateCmd: 'UpdateCmd',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fullVersion: 'string',
      layer: 'string',
      matchDetail: 'string',
      matchList: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
      path: 'string',
      updateCmd: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageVulListResponseBodyVulRecordsExtendContentJson extends $tea.Model {
  os?: string;
  osRelease?: string;
  rpmEntityList?: DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList[];
  static names(): { [key: string]: string } {
    return {
      os: 'Os',
      osRelease: 'OsRelease',
      rpmEntityList: 'RpmEntityList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      os: 'string',
      osRelease: 'string',
      rpmEntityList: { 'type': 'array', 'itemType': DescribeImageVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageVulListResponseBodyVulRecords extends $tea.Model {
  aliasName?: string;
  canFix?: string;
  canUpdate?: boolean;
  clusterId?: string;
  clusterName?: string;
  containerId?: string;
  extendContentJson?: DescribeImageVulListResponseBodyVulRecordsExtendContentJson;
  firstTs?: number;
  image?: string;
  imageDigest?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  lastTs?: number;
  layers?: string[];
  maliciousSource?: string;
  modifyTs?: number;
  name?: string;
  namespace?: string;
  necessity?: string;
  pod?: string;
  primaryId?: number;
  related?: string;
  repoName?: string;
  repoNamespace?: string;
  scanTime?: number;
  status?: number;
  tag?: string;
  targetId?: string;
  targetName?: string;
  targetType?: string;
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      canFix: 'CanFix',
      canUpdate: 'CanUpdate',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      containerId: 'ContainerId',
      extendContentJson: 'ExtendContentJson',
      firstTs: 'FirstTs',
      image: 'Image',
      imageDigest: 'ImageDigest',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      lastTs: 'LastTs',
      layers: 'Layers',
      maliciousSource: 'MaliciousSource',
      modifyTs: 'ModifyTs',
      name: 'Name',
      namespace: 'Namespace',
      necessity: 'Necessity',
      pod: 'Pod',
      primaryId: 'PrimaryId',
      related: 'Related',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      scanTime: 'ScanTime',
      status: 'Status',
      tag: 'Tag',
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
      type: 'Type',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      canFix: 'string',
      canUpdate: 'boolean',
      clusterId: 'string',
      clusterName: 'string',
      containerId: 'string',
      extendContentJson: DescribeImageVulListResponseBodyVulRecordsExtendContentJson,
      firstTs: 'number',
      image: 'string',
      imageDigest: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      lastTs: 'number',
      layers: { 'type': 'array', 'itemType': 'string' },
      maliciousSource: 'string',
      modifyTs: 'number',
      name: 'string',
      namespace: 'string',
      necessity: 'string',
      pod: 'string',
      primaryId: 'number',
      related: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      scanTime: 'number',
      status: 'number',
      tag: 'string',
      targetId: 'string',
      targetName: 'string',
      targetType: 'string',
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageVulWhiteListResponseBodyImageVulWhitelist extends $tea.Model {
  aliasName?: string;
  id?: number;
  name?: string;
  reason?: string;
  target?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      id: 'Id',
      name: 'Name',
      reason: 'Reason',
      target: 'Target',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      id: 'number',
      name: 'string',
      reason: 'string',
      target: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeImageVulWhiteListResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstallCodesResponseBodyInstallCodes extends $tea.Model {
  captchaCode?: string;
  expiredDate?: number;
  groupId?: number;
  groupName?: string;
  onlyImage?: boolean;
  os?: string;
  proxyCluster?: string;
  vendorName?: string;
  static names(): { [key: string]: string } {
    return {
      captchaCode: 'CaptchaCode',
      expiredDate: 'ExpiredDate',
      groupId: 'GroupId',
      groupName: 'GroupName',
      onlyImage: 'OnlyImage',
      os: 'Os',
      proxyCluster: 'ProxyCluster',
      vendorName: 'VendorName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      captchaCode: 'string',
      expiredDate: 'number',
      groupId: 'number',
      groupName: 'string',
      onlyImage: 'boolean',
      os: 'string',
      proxyCluster: 'string',
      vendorName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAntiBruteForceRulesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceAntiBruteForceRulesResponseBodyRules extends $tea.Model {
  id?: number;
  name?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceRebootStatusResponseBodyRebootStatuses extends $tea.Model {
  code?: string;
  msg?: string;
  rebootStatus?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      msg: 'Msg',
      rebootStatus: 'RebootStatus',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      msg: 'string',
      rebootStatus: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInstanceStatisticsResponseBodyData extends $tea.Model {
  account?: number;
  agentlessAll?: number;
  agentlessBaseline?: number;
  agentlessMalicious?: number;
  agentlessVulCve?: number;
  agentlessVulSca?: number;
  agentlessVulSys?: number;
  appNum?: number;
  cmsNum?: number;
  cspmNum?: number;
  cveNum?: number;
  emgNum?: number;
  health?: number;
  scaNum?: number;
  suspicious?: number;
  sysNum?: number;
  trojan?: number;
  uuid?: string;
  vul?: number;
  weakPWNum?: number;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      agentlessAll: 'AgentlessAll',
      agentlessBaseline: 'AgentlessBaseline',
      agentlessMalicious: 'AgentlessMalicious',
      agentlessVulCve: 'AgentlessVulCve',
      agentlessVulSca: 'AgentlessVulSca',
      agentlessVulSys: 'AgentlessVulSys',
      appNum: 'AppNum',
      cmsNum: 'CmsNum',
      cspmNum: 'CspmNum',
      cveNum: 'CveNum',
      emgNum: 'EmgNum',
      health: 'Health',
      scaNum: 'ScaNum',
      suspicious: 'Suspicious',
      sysNum: 'SysNum',
      trojan: 'Trojan',
      uuid: 'Uuid',
      vul: 'Vul',
      weakPWNum: 'WeakPWNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'number',
      agentlessAll: 'number',
      agentlessBaseline: 'number',
      agentlessMalicious: 'number',
      agentlessVulCve: 'number',
      agentlessVulSca: 'number',
      agentlessVulSys: 'number',
      appNum: 'number',
      cmsNum: 'number',
      cspmNum: 'number',
      cveNum: 'number',
      emgNum: 'number',
      health: 'number',
      scaNum: 'number',
      suspicious: 'number',
      sysNum: 'number',
      trojan: 'number',
      uuid: 'string',
      vul: 'number',
      weakPWNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogMetaResponseBodyLogMetaList extends $tea.Model {
  category?: string;
  hotTtl?: number;
  logDesc?: string;
  logStore?: string;
  project?: string;
  status?: string;
  topic?: string;
  ttl?: number;
  userLogStore?: string;
  userProject?: string;
  userRegion?: string;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      hotTtl: 'HotTtl',
      logDesc: 'LogDesc',
      logStore: 'LogStore',
      project: 'Project',
      status: 'Status',
      topic: 'Topic',
      ttl: 'Ttl',
      userLogStore: 'UserLogStore',
      userProject: 'UserProject',
      userRegion: 'UserRegion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      hotTtl: 'number',
      logDesc: 'string',
      logStore: 'string',
      project: 'string',
      status: 'string',
      topic: 'string',
      ttl: 'number',
      userLogStore: 'string',
      userProject: 'string',
      userRegion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLogShipperStatusResponseBodyLogShipperStatus extends $tea.Model {
  authStatus?: string;
  buyStatus?: string;
  openStatus?: string;
  postPaidOpenStatus?: string;
  postPaidSupportStatus?: string;
  slsProjectStatus?: string;
  slsServiceStatus?: string;
  static names(): { [key: string]: string } {
    return {
      authStatus: 'AuthStatus',
      buyStatus: 'BuyStatus',
      openStatus: 'OpenStatus',
      postPaidOpenStatus: 'PostPaidOpenStatus',
      postPaidSupportStatus: 'PostPaidSupportStatus',
      slsProjectStatus: 'SlsProjectStatus',
      slsServiceStatus: 'SlsServiceStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authStatus: 'string',
      buyStatus: 'string',
      openStatus: 'string',
      postPaidOpenStatus: 'string',
      postPaidSupportStatus: 'string',
      slsProjectStatus: 'string',
      slsServiceStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList extends $tea.Model {
  target?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      target: 'Target',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      target: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLoginBaseConfigsResponseBodyBaseConfigs extends $tea.Model {
  account?: string;
  endTime?: string;
  ip?: string;
  location?: string;
  remark?: string;
  startTime?: string;
  targetList?: DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList[];
  totalCount?: number;
  uuidCount?: number;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      endTime: 'EndTime',
      ip: 'Ip',
      location: 'Location',
      remark: 'Remark',
      startTime: 'StartTime',
      targetList: 'TargetList',
      totalCount: 'TotalCount',
      uuidCount: 'UuidCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      endTime: 'string',
      ip: 'string',
      location: 'string',
      remark: 'string',
      startTime: 'string',
      targetList: { 'type': 'array', 'itemType': DescribeLoginBaseConfigsResponseBodyBaseConfigsTargetList },
      totalCount: 'number',
      uuidCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLoginSwitchConfigsResponseBodyConfigList extends $tea.Model {
  item?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeModuleConfigResponseBodyModuleConfigListItems extends $tea.Model {
  groupId?: number;
  instanceId?: string;
  instanceName?: string;
  ip?: string;
  region?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      ip: 'Ip',
      region: 'Region',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      instanceId: 'string',
      instanceName: 'string',
      ip: 'string',
      region: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeModuleConfigResponseBodyModuleConfigList extends $tea.Model {
  configName?: string;
  items?: DescribeModuleConfigResponseBodyModuleConfigListItems[];
  moduleName?: string;
  static names(): { [key: string]: string } {
    return {
      configName: 'ConfigName',
      items: 'Items',
      moduleName: 'ModuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configName: 'string',
      items: { 'type': 'array', 'itemType': DescribeModuleConfigResponseBodyModuleConfigListItems },
      moduleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNoticeConfigResponseBodyNoticeConfigList extends $tea.Model {
  aliUid?: number;
  currentPage?: number;
  project?: string;
  route?: number;
  timeLimit?: number;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      currentPage: 'CurrentPage',
      project: 'Project',
      route: 'Route',
      timeLimit: 'TimeLimit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'number',
      currentPage: 'number',
      project: 'string',
      route: 'number',
      timeLimit: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNsasSuspEventTypeResponseBodyEventTypes extends $tea.Model {
  name?: string;
  suspEventCount?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      suspEventCount: 'SuspEventCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      suspEventCount: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOfflineMachinesResponseBodyMachineList extends $tea.Model {
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  machineRegion?: string;
  os?: string;
  regionId?: string;
  uuid?: string;
  vendor?: number;
  vendorName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      machineRegion: 'MachineRegion',
      os: 'Os',
      regionId: 'RegionId',
      uuid: 'Uuid',
      vendor: 'Vendor',
      vendorName: 'VendorName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      machineRegion: 'string',
      os: 'string',
      regionId: 'string',
      uuid: 'string',
      vendor: 'number',
      vendorName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOnceTaskResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOnceTaskResponseBodyTaskManageResponseList extends $tea.Model {
  detailData?: string;
  failCount?: number;
  progress?: string;
  resultInfo?: string;
  successCount?: number;
  taskEndTime?: number;
  taskId?: string;
  taskName?: string;
  taskStartTime?: number;
  taskStatus?: number;
  taskStatusText?: string;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      detailData: 'DetailData',
      failCount: 'FailCount',
      progress: 'Progress',
      resultInfo: 'ResultInfo',
      successCount: 'SuccessCount',
      taskEndTime: 'TaskEndTime',
      taskId: 'TaskId',
      taskName: 'TaskName',
      taskStartTime: 'TaskStartTime',
      taskStatus: 'TaskStatus',
      taskStatusText: 'TaskStatusText',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      detailData: 'string',
      failCount: 'number',
      progress: 'string',
      resultInfo: 'string',
      successCount: 'number',
      taskEndTime: 'number',
      taskId: 'string',
      taskName: 'string',
      taskStartTime: 'number',
      taskStatus: 'number',
      taskStatusText: 'string',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo extends $tea.Model {
  appName?: string;
  clusterId?: string;
  clusterName?: string;
  costTimeInfo?: string;
  digest?: string;
  image?: string;
  nodeInstanceId?: string;
  nodeIp?: string;
  nodeName?: string;
  pod?: string;
  regionId?: string;
  repoId?: string;
  repoName?: string;
  repoNamespace?: string;
  repoRegionId?: string;
  tag?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      costTimeInfo: 'CostTimeInfo',
      digest: 'Digest',
      image: 'Image',
      nodeInstanceId: 'NodeInstanceId',
      nodeIp: 'NodeIp',
      nodeName: 'NodeName',
      pod: 'Pod',
      regionId: 'RegionId',
      repoId: 'RepoId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      repoRegionId: 'RepoRegionId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      clusterId: 'string',
      clusterName: 'string',
      costTimeInfo: 'string',
      digest: 'string',
      image: 'string',
      nodeInstanceId: 'string',
      nodeIp: 'string',
      nodeName: 'string',
      pod: 'string',
      regionId: 'string',
      repoId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      repoRegionId: 'string',
      tag: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOnceTaskLeafRecordPageResponseBodyOnceTasks extends $tea.Model {
  endTime?: number;
  finish?: number;
  finishCount?: string;
  progress?: number;
  realRunTime?: number;
  resultInfo?: string;
  startTime?: number;
  status?: string;
  statusText?: string;
  target?: string;
  targetType?: string;
  taskId?: string;
  taskImageInfo?: DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo;
  taskName?: string;
  taskType?: string;
  totalCount?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      finish: 'Finish',
      finishCount: 'FinishCount',
      progress: 'Progress',
      realRunTime: 'RealRunTime',
      resultInfo: 'ResultInfo',
      startTime: 'StartTime',
      status: 'Status',
      statusText: 'StatusText',
      target: 'Target',
      targetType: 'TargetType',
      taskId: 'TaskId',
      taskImageInfo: 'TaskImageInfo',
      taskName: 'TaskName',
      taskType: 'TaskType',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      finish: 'number',
      finishCount: 'string',
      progress: 'number',
      realRunTime: 'number',
      resultInfo: 'string',
      startTime: 'number',
      status: 'string',
      statusText: 'string',
      target: 'string',
      targetType: 'string',
      taskId: 'string',
      taskImageInfo: DescribeOnceTaskLeafRecordPageResponseBodyOnceTasksTaskImageInfo,
      taskName: 'string',
      taskType: 'string',
      totalCount: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOnceTaskLeafRecordPageResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyCronDetailResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyCronDetailResponseBodyPropertys extends $tea.Model {
  cmd?: string;
  createTimestamp?: number;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  ip?: string;
  md5?: string;
  period?: string;
  source?: string;
  user?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      cmd: 'Cmd',
      createTimestamp: 'CreateTimestamp',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      ip: 'Ip',
      md5: 'Md5',
      period: 'Period',
      source: 'Source',
      user: 'User',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cmd: 'string',
      createTimestamp: 'number',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      ip: 'string',
      md5: 'string',
      period: 'string',
      source: 'string',
      user: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyCronItemResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyCronItemResponseBodyPropertyItems extends $tea.Model {
  count?: number;
  source?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyPortDetailResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyPortDetailResponseBodyPropertys extends $tea.Model {
  bindIp?: string;
  createTimestamp?: number;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  ip?: string;
  pid?: string;
  port?: string;
  procName?: string;
  proto?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      bindIp: 'BindIp',
      createTimestamp: 'CreateTimestamp',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      ip: 'Ip',
      pid: 'Pid',
      port: 'Port',
      procName: 'ProcName',
      proto: 'Proto',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindIp: 'string',
      createTimestamp: 'number',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      ip: 'string',
      pid: 'string',
      port: 'string',
      procName: 'string',
      proto: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyPortItemResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyPortItemResponseBodyPropertyItems extends $tea.Model {
  count?: number;
  port?: string;
  proto?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      port: 'Port',
      proto: 'Proto',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      port: 'string',
      proto: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyProcDetailResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyProcDetailResponseBodyPropertys extends $tea.Model {
  cmdline?: string;
  createTimestamp?: number;
  euidName?: string;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  isPackage?: number;
  md5?: string;
  name?: string;
  path?: string;
  pid?: string;
  pname?: string;
  startTime?: string;
  startTimeDt?: number;
  state?: string;
  user?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      cmdline: 'Cmdline',
      createTimestamp: 'CreateTimestamp',
      euidName: 'EuidName',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      isPackage: 'IsPackage',
      md5: 'Md5',
      name: 'Name',
      path: 'Path',
      pid: 'Pid',
      pname: 'Pname',
      startTime: 'StartTime',
      startTimeDt: 'StartTimeDt',
      state: 'State',
      user: 'User',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cmdline: 'string',
      createTimestamp: 'number',
      euidName: 'string',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      isPackage: 'number',
      md5: 'string',
      name: 'string',
      path: 'string',
      pid: 'string',
      pname: 'string',
      startTime: 'string',
      startTimeDt: 'number',
      state: 'string',
      user: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyProcItemResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyProcItemResponseBodyPropertyItems extends $tea.Model {
  count?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyScaDetailResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyScaDetailResponseBodyPropertys extends $tea.Model {
  bizType?: string;
  bizTypeDispaly?: string;
  cmdline?: string;
  configPath?: string;
  containerName?: string;
  createTimestamp?: number;
  imageName?: string;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  ip?: string;
  listenIp?: string;
  listenProtocol?: string;
  listenStatus?: string;
  name?: string;
  path?: string;
  pid?: string;
  podName?: string;
  port?: string;
  ppid?: string;
  processStarted?: number;
  processUser?: string;
  proof?: string;
  runtimeEnvVersion?: string;
  type?: string;
  uuid?: string;
  version?: string;
  webPath?: string;
  static names(): { [key: string]: string } {
    return {
      bizType: 'BizType',
      bizTypeDispaly: 'BizTypeDispaly',
      cmdline: 'Cmdline',
      configPath: 'ConfigPath',
      containerName: 'ContainerName',
      createTimestamp: 'CreateTimestamp',
      imageName: 'ImageName',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      ip: 'Ip',
      listenIp: 'ListenIp',
      listenProtocol: 'ListenProtocol',
      listenStatus: 'ListenStatus',
      name: 'Name',
      path: 'Path',
      pid: 'Pid',
      podName: 'PodName',
      port: 'Port',
      ppid: 'Ppid',
      processStarted: 'ProcessStarted',
      processUser: 'ProcessUser',
      proof: 'Proof',
      runtimeEnvVersion: 'RuntimeEnvVersion',
      type: 'Type',
      uuid: 'Uuid',
      version: 'Version',
      webPath: 'WebPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizType: 'string',
      bizTypeDispaly: 'string',
      cmdline: 'string',
      configPath: 'string',
      containerName: 'string',
      createTimestamp: 'number',
      imageName: 'string',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      ip: 'string',
      listenIp: 'string',
      listenProtocol: 'string',
      listenStatus: 'string',
      name: 'string',
      path: 'string',
      pid: 'string',
      podName: 'string',
      port: 'string',
      ppid: 'string',
      processStarted: 'number',
      processUser: 'string',
      proof: 'string',
      runtimeEnvVersion: 'string',
      type: 'string',
      uuid: 'string',
      version: 'string',
      webPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyScaItemResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyScaItemResponseBodyPropertyItems extends $tea.Model {
  bizType?: string;
  count?: number;
  name?: string;
  typeDisplay?: string;
  static names(): { [key: string]: string } {
    return {
      bizType: 'BizType',
      count: 'Count',
      name: 'Name',
      typeDisplay: 'TypeDisplay',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizType: 'string',
      count: 'number',
      name: 'string',
      typeDisplay: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertySoftwareDetailResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertySoftwareDetailResponseBodyPropertys extends $tea.Model {
  createTimestamp?: number;
  installTime?: string;
  installTimeDt?: number;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  ip?: string;
  name?: string;
  path?: string;
  uuid?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      createTimestamp: 'CreateTimestamp',
      installTime: 'InstallTime',
      installTimeDt: 'InstallTimeDt',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      ip: 'Ip',
      name: 'Name',
      path: 'Path',
      uuid: 'Uuid',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTimestamp: 'number',
      installTime: 'string',
      installTimeDt: 'number',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      ip: 'string',
      name: 'string',
      path: 'string',
      uuid: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertySoftwareItemResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertySoftwareItemResponseBodyPropertyItems extends $tea.Model {
  count?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyTypeScaItemResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyTypeScaItemResponseBodyPropertyTypeItems extends $tea.Model {
  name?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUsageNewestResponseBodyNewestStatisticItems extends $tea.Model {
  create?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      create: 'Create',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      create: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUserDetailResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUserDetailResponseBodyPropertys extends $tea.Model {
  accountsExpirationDate?: string;
  createTimestamp?: number;
  groupNames?: string[];
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  ip?: string;
  isCouldLogin?: number;
  isPasswdExpired?: number;
  isPasswdLocked?: number;
  isRoot?: string;
  isSudoer?: number;
  isUserExpired?: number;
  lastLoginIp?: string;
  lastLoginTime?: string;
  lastLoginTimeDt?: number;
  lastLoginTimestamp?: number;
  passwordExpirationDate?: string;
  status?: string;
  user?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      accountsExpirationDate: 'AccountsExpirationDate',
      createTimestamp: 'CreateTimestamp',
      groupNames: 'GroupNames',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      ip: 'Ip',
      isCouldLogin: 'IsCouldLogin',
      isPasswdExpired: 'IsPasswdExpired',
      isPasswdLocked: 'IsPasswdLocked',
      isRoot: 'IsRoot',
      isSudoer: 'IsSudoer',
      isUserExpired: 'IsUserExpired',
      lastLoginIp: 'LastLoginIp',
      lastLoginTime: 'LastLoginTime',
      lastLoginTimeDt: 'LastLoginTimeDt',
      lastLoginTimestamp: 'LastLoginTimestamp',
      passwordExpirationDate: 'PasswordExpirationDate',
      status: 'Status',
      user: 'User',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountsExpirationDate: 'string',
      createTimestamp: 'number',
      groupNames: { 'type': 'array', 'itemType': 'string' },
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      ip: 'string',
      isCouldLogin: 'number',
      isPasswdExpired: 'number',
      isPasswdLocked: 'number',
      isRoot: 'string',
      isSudoer: 'number',
      isUserExpired: 'number',
      lastLoginIp: 'string',
      lastLoginTime: 'string',
      lastLoginTimeDt: 'number',
      lastLoginTimestamp: 'number',
      passwordExpirationDate: 'string',
      status: 'string',
      user: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUserItemResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePropertyUserItemResponseBodyPropertyItems extends $tea.Model {
  count?: number;
  user?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      user: 'User',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      user: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestoreJobsResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestoreJobsResponseBodyRestoreJobs extends $tea.Model {
  actualBytes?: number;
  bytesDone?: number;
  bytesTotal?: number;
  clientId?: string;
  completeTime?: number;
  createdTime?: number;
  duration?: number;
  errorCount?: number;
  errorFile?: string;
  errorFileUrl?: string;
  errorType?: string;
  eta?: number;
  excludes?: string;
  exitCode?: string;
  gmtCreate?: string;
  gmtModified?: string;
  includes?: string;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  itemsDone?: number;
  itemsTotal?: number;
  message?: string;
  percentage?: number;
  requestId?: string;
  restoreId?: string;
  restoreName?: string;
  restoreType?: string;
  snapshotHash?: string;
  snapshotId?: string;
  snapshotVersion?: string;
  source?: string;
  sourceClientId?: string;
  speed?: number;
  status?: string;
  target?: string;
  updatedTime?: number;
  uuid?: string;
  vaultId?: string;
  static names(): { [key: string]: string } {
    return {
      actualBytes: 'ActualBytes',
      bytesDone: 'BytesDone',
      bytesTotal: 'BytesTotal',
      clientId: 'ClientId',
      completeTime: 'CompleteTime',
      createdTime: 'CreatedTime',
      duration: 'Duration',
      errorCount: 'ErrorCount',
      errorFile: 'ErrorFile',
      errorFileUrl: 'ErrorFileUrl',
      errorType: 'ErrorType',
      eta: 'Eta',
      excludes: 'Excludes',
      exitCode: 'ExitCode',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      includes: 'Includes',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      itemsDone: 'ItemsDone',
      itemsTotal: 'ItemsTotal',
      message: 'Message',
      percentage: 'Percentage',
      requestId: 'RequestId',
      restoreId: 'RestoreId',
      restoreName: 'RestoreName',
      restoreType: 'RestoreType',
      snapshotHash: 'SnapshotHash',
      snapshotId: 'SnapshotId',
      snapshotVersion: 'SnapshotVersion',
      source: 'Source',
      sourceClientId: 'SourceClientId',
      speed: 'Speed',
      status: 'Status',
      target: 'Target',
      updatedTime: 'UpdatedTime',
      uuid: 'Uuid',
      vaultId: 'VaultId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualBytes: 'number',
      bytesDone: 'number',
      bytesTotal: 'number',
      clientId: 'string',
      completeTime: 'number',
      createdTime: 'number',
      duration: 'number',
      errorCount: 'number',
      errorFile: 'string',
      errorFileUrl: 'string',
      errorType: 'string',
      eta: 'number',
      excludes: 'string',
      exitCode: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      includes: 'string',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      itemsDone: 'number',
      itemsTotal: 'number',
      message: 'string',
      percentage: 'number',
      requestId: 'string',
      restoreId: 'string',
      restoreName: 'string',
      restoreType: 'string',
      snapshotHash: 'string',
      snapshotId: 'string',
      snapshotVersion: 'string',
      source: 'string',
      sourceClientId: 'string',
      speed: 'number',
      status: 'string',
      target: 'string',
      updatedTime: 'number',
      uuid: 'string',
      vaultId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestorePlansResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRestorePlansResponseBodyRestorePlans extends $tea.Model {
  createdTime?: number;
  databaseName?: string;
  instanceName?: string;
  policyId?: number;
  policyName?: string;
  restorePoint?: number;
  status?: string;
  targetDatabaseName?: string;
  targetInstanceId?: string;
  targetInstanceName?: string;
  updatedTime?: number;
  static names(): { [key: string]: string } {
    return {
      createdTime: 'CreatedTime',
      databaseName: 'DatabaseName',
      instanceName: 'InstanceName',
      policyId: 'PolicyId',
      policyName: 'PolicyName',
      restorePoint: 'RestorePoint',
      status: 'Status',
      targetDatabaseName: 'TargetDatabaseName',
      targetInstanceId: 'TargetInstanceId',
      targetInstanceName: 'TargetInstanceName',
      updatedTime: 'UpdatedTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createdTime: 'number',
      databaseName: 'string',
      instanceName: 'string',
      policyId: 'number',
      policyName: 'string',
      restorePoint: 'number',
      status: 'string',
      targetDatabaseName: 'string',
      targetInstanceId: 'string',
      targetInstanceName: 'string',
      updatedTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckItemResultResponseBodyPageContentResource extends $tea.Model {
  contentResource?: { [key: string]: any };
  count?: number;
  currentPage?: number;
  pageCount?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      contentResource: 'ContentResource',
      count: 'Count',
      currentPage: 'CurrentPage',
      pageCount: 'PageCount',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentResource: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      count: 'number',
      currentPage: 'number',
      pageCount: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckResultResponseBodyListRiskItemResources extends $tea.Model {
  contentResource?: { [key: string]: any };
  resourceName?: string;
  static names(): { [key: string]: string } {
    return {
      contentResource: 'ContentResource',
      resourceName: 'ResourceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentResource: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
      resourceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckResultResponseBodyList extends $tea.Model {
  affectedCount?: number;
  checkTime?: number;
  itemId?: number;
  remainingTime?: number;
  repairStatus?: string;
  riskAssertType?: string;
  riskItemResources?: DescribeRiskCheckResultResponseBodyListRiskItemResources[];
  riskLevel?: string;
  sort?: number;
  startStatus?: string;
  status?: string;
  taskId?: number;
  title?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      affectedCount: 'AffectedCount',
      checkTime: 'CheckTime',
      itemId: 'ItemId',
      remainingTime: 'RemainingTime',
      repairStatus: 'RepairStatus',
      riskAssertType: 'RiskAssertType',
      riskItemResources: 'RiskItemResources',
      riskLevel: 'RiskLevel',
      sort: 'Sort',
      startStatus: 'StartStatus',
      status: 'Status',
      taskId: 'TaskId',
      title: 'Title',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectedCount: 'number',
      checkTime: 'number',
      itemId: 'number',
      remainingTime: 'number',
      repairStatus: 'string',
      riskAssertType: 'string',
      riskItemResources: { 'type': 'array', 'itemType': DescribeRiskCheckResultResponseBodyListRiskItemResources },
      riskLevel: 'string',
      sort: 'number',
      startStatus: 'string',
      status: 'string',
      taskId: 'number',
      title: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus extends $tea.Model {
  count?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups extends $tea.Model {
  countByStatus?: DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus[];
  id?: number;
  remainingTime?: number;
  sort?: number;
  status?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      countByStatus: 'CountByStatus',
      id: 'Id',
      remainingTime: 'RemainingTime',
      sort: 'Sort',
      status: 'Status',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      countByStatus: { 'type': 'array', 'itemType': DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroupsCountByStatus },
      id: 'number',
      remainingTime: 'number',
      sort: 'number',
      status: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount extends $tea.Model {
  count?: number;
  key?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      key: 'Key',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      key: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskCheckSummaryResponseBodyRiskCheckSummary extends $tea.Model {
  affectedAssetCount?: number;
  disabledRiskCount?: number;
  enabledRiskCount?: number;
  groups?: DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups[];
  itemCount?: number;
  previousCount?: number;
  previousTime?: number;
  riskCount?: number;
  riskLevelCount?: DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount[];
  riskRate?: number;
  static names(): { [key: string]: string } {
    return {
      affectedAssetCount: 'AffectedAssetCount',
      disabledRiskCount: 'DisabledRiskCount',
      enabledRiskCount: 'EnabledRiskCount',
      groups: 'Groups',
      itemCount: 'ItemCount',
      previousCount: 'PreviousCount',
      previousTime: 'PreviousTime',
      riskCount: 'RiskCount',
      riskLevelCount: 'RiskLevelCount',
      riskRate: 'RiskRate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      affectedAssetCount: 'number',
      disabledRiskCount: 'number',
      enabledRiskCount: 'number',
      groups: { 'type': 'array', 'itemType': DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryGroups },
      itemCount: 'number',
      previousCount: 'number',
      previousTime: 'number',
      riskCount: 'number',
      riskLevelCount: { 'type': 'array', 'itemType': DescribeRiskCheckSummaryResponseBodyRiskCheckSummaryRiskLevelCount },
      riskRate: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskItemTypeResponseBodyList extends $tea.Model {
  id?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskListCheckResultResponseBodyList extends $tea.Model {
  instanceId?: string;
  riskCount?: number;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      riskCount: 'riskCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      riskCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList extends $tea.Model {
  enumValue?: string;
  maxValue?: number;
  minValue?: number;
  paramDefaultValue?: string;
  paramDesc?: string;
  paramName?: string;
  paramType?: number;
  static names(): { [key: string]: string } {
    return {
      enumValue: 'EnumValue',
      maxValue: 'MaxValue',
      minValue: 'MinValue',
      paramDefaultValue: 'ParamDefaultValue',
      paramDesc: 'ParamDesc',
      paramName: 'ParamName',
      paramType: 'ParamType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enumValue: 'string',
      maxValue: 'number',
      minValue: 'number',
      paramDefaultValue: 'string',
      paramDesc: 'string',
      paramName: 'string',
      paramType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules extends $tea.Model {
  optional?: number;
  paramList?: DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList[];
  ruleDesc?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      optional: 'Optional',
      paramList: 'ParamList',
      ruleDesc: 'RuleDesc',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      optional: 'number',
      paramList: { 'type': 'array', 'itemType': DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRulesParamList },
      ruleDesc: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails extends $tea.Model {
  checkDesc?: string;
  checkId?: number;
  checkItem?: string;
  rules?: DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules[];
  static names(): { [key: string]: string } {
    return {
      checkDesc: 'CheckDesc',
      checkId: 'CheckId',
      checkItem: 'CheckItem',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkDesc: 'string',
      checkId: 'number',
      checkItem: 'string',
      rules: { 'type': 'array', 'itemType': DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetailsRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskTypeResponseBodyRiskTypesSubTypes extends $tea.Model {
  alias?: string;
  checkDetails?: DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails[];
  typeName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      checkDetails: 'CheckDetails',
      typeName: 'TypeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      checkDetails: { 'type': 'array', 'itemType': DescribeRiskTypeResponseBodyRiskTypesSubTypesCheckDetails },
      typeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRiskTypeResponseBodyRiskTypes extends $tea.Model {
  alias?: string;
  subTypes?: DescribeRiskTypeResponseBodyRiskTypesSubTypes[];
  typeName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      subTypes: 'SubTypes',
      typeName: 'TypeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      subTypes: { 'type': 'array', 'itemType': DescribeRiskTypeResponseBodyRiskTypesSubTypes },
      typeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRisksResponseBodyRisks extends $tea.Model {
  riskDetail?: string;
  riskId?: number;
  riskName?: string;
  riskType?: string;
  subRiskType?: string;
  subTypeAlias?: string;
  typeAlias?: string;
  static names(): { [key: string]: string } {
    return {
      riskDetail: 'RiskDetail',
      riskId: 'RiskId',
      riskName: 'RiskName',
      riskType: 'RiskType',
      subRiskType: 'SubRiskType',
      subTypeAlias: 'SubTypeAlias',
      typeAlias: 'TypeAlias',
    };
  }

  static types(): { [key: string]: any } {
    return {
      riskDetail: 'string',
      riskId: 'number',
      riskName: 'string',
      riskType: 'string',
      subRiskType: 'string',
      subTypeAlias: 'string',
      typeAlias: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSasPmAgentListResponseBodySasPmAgentList extends $tea.Model {
  aliyunAssistId?: string;
  aliyunMonitorId?: string;
  assistInstallResult?: number;
  assistInstallStatus?: number;
  monitorInstallResult?: number;
  monitorInstallStatus?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      aliyunAssistId: 'AliyunAssistId',
      aliyunMonitorId: 'AliyunMonitorId',
      assistInstallResult: 'AssistInstallResult',
      assistInstallStatus: 'AssistInstallStatus',
      monitorInstallResult: 'MonitorInstallResult',
      monitorInstallStatus: 'MonitorInstallStatus',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliyunAssistId: 'string',
      aliyunMonitorId: 'string',
      assistInstallResult: 'number',
      assistInstallStatus: 'number',
      monitorInstallResult: 'number',
      monitorInstallStatus: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSearchConditionResponseBodyConditionList extends $tea.Model {
  conditionType?: string;
  filterConditions?: string;
  name?: string;
  nameKey?: string;
  static names(): { [key: string]: string } {
    return {
      conditionType: 'ConditionType',
      filterConditions: 'FilterConditions',
      name: 'Name',
      nameKey: 'NameKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditionType: 'string',
      filterConditions: 'string',
      name: 'string',
      nameKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecureSuggestionResponseBodySuggestionsDetail extends $tea.Model {
  description?: string;
  subType?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      subType: 'SubType',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      subType: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecureSuggestionResponseBodySuggestions extends $tea.Model {
  detail?: DescribeSecureSuggestionResponseBodySuggestionsDetail[];
  points?: number;
  suggestType?: string;
  static names(): { [key: string]: string } {
    return {
      detail: 'Detail',
      points: 'Points',
      suggestType: 'SuggestType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      detail: { 'type': 'array', 'itemType': DescribeSecureSuggestionResponseBodySuggestionsDetail },
      points: 'number',
      suggestType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityCheckScheduleConfigResponseBodyRiskCheckJobConfig extends $tea.Model {
  daysOfWeek?: string;
  endTime?: number;
  startTime?: number;
  static names(): { [key: string]: string } {
    return {
      daysOfWeek: 'DaysOfWeek',
      endTime: 'EndTime',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      daysOfWeek: 'string',
      endTime: 'number',
      startTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventMarkMissListResponseBodyList extends $tea.Model {
  aliUid?: number;
  eventName?: string;
  eventNameOriginal?: string;
  eventType?: string;
  eventTypeOriginal?: string;
  field?: string;
  fieldValue?: string;
  filedAliasName?: string;
  id?: number;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  operate?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      eventName: 'EventName',
      eventNameOriginal: 'EventNameOriginal',
      eventType: 'EventType',
      eventTypeOriginal: 'EventTypeOriginal',
      field: 'Field',
      fieldValue: 'FieldValue',
      filedAliasName: 'FiledAliasName',
      id: 'Id',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      operate: 'Operate',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'number',
      eventName: 'string',
      eventNameOriginal: 'string',
      eventType: 'string',
      eventTypeOriginal: 'string',
      field: 'string',
      fieldValue: 'string',
      filedAliasName: 'string',
      id: 'number',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      operate: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventMarkMissListResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses extends $tea.Model {
  errorCode?: string;
  securityEventId?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      securityEventId: 'SecurityEventId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'string',
      securityEventId: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponse extends $tea.Model {
  securityEventOperationStatuses?: DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses[];
  taskStatus?: string;
  static names(): { [key: string]: string } {
    return {
      securityEventOperationStatuses: 'SecurityEventOperationStatuses',
      taskStatus: 'TaskStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      securityEventOperationStatuses: { 'type': 'array', 'itemType': DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatusResponseSecurityEventOperationStatuses },
      taskStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField extends $tea.Model {
  filedAliasName?: string;
  filedName?: string;
  markMisType?: string;
  markMisValue?: string;
  supportedMisType?: string[];
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      filedAliasName: 'FiledAliasName',
      filedName: 'FiledName',
      markMisType: 'MarkMisType',
      markMisValue: 'MarkMisValue',
      supportedMisType: 'SupportedMisType',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filedAliasName: 'string',
      filedName: 'string',
      markMisType: 'string',
      markMisValue: 'string',
      supportedMisType: { 'type': 'array', 'itemType': 'string' },
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource extends $tea.Model {
  filedAliasName?: string;
  filedName?: string;
  markMisValue?: string;
  supportedMisType?: string[];
  static names(): { [key: string]: string } {
    return {
      filedAliasName: 'FiledAliasName',
      filedName: 'FiledName',
      markMisValue: 'MarkMisValue',
      supportedMisType: 'SupportedMisType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filedAliasName: 'string',
      filedName: 'string',
      markMisValue: 'string',
      supportedMisType: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponse extends $tea.Model {
  markField?: DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField[];
  markFieldsSource?: DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource[];
  operationCode?: string;
  operationParams?: string;
  userCanOperate?: boolean;
  static names(): { [key: string]: string } {
    return {
      markField: 'MarkField',
      markFieldsSource: 'MarkFieldsSource',
      operationCode: 'OperationCode',
      operationParams: 'OperationParams',
      userCanOperate: 'UserCanOperate',
    };
  }

  static types(): { [key: string]: any } {
    return {
      markField: { 'type': 'array', 'itemType': DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkField },
      markFieldsSource: { 'type': 'array', 'itemType': DescribeSecurityEventOperationsResponseBodySecurityEventOperationsResponseMarkFieldsSource },
      operationCode: 'string',
      operationParams: 'string',
      userCanOperate: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityStatInfoResponseBodyAttackEvent extends $tea.Model {
  dateArray?: string[];
  totalCount?: number;
  valueArray?: string[];
  static names(): { [key: string]: string } {
    return {
      dateArray: 'DateArray',
      totalCount: 'TotalCount',
      valueArray: 'ValueArray',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dateArray: { 'type': 'array', 'itemType': 'string' },
      totalCount: 'number',
      valueArray: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityStatInfoResponseBodyHealthCheck extends $tea.Model {
  dateArray?: string[];
  highCount?: number;
  highList?: string[];
  levelsOn?: string[];
  lowCount?: number;
  lowList?: string[];
  mediumCount?: number;
  mediumList?: string[];
  timeArray?: string[];
  totalCount?: number;
  valueArray?: string[];
  static names(): { [key: string]: string } {
    return {
      dateArray: 'DateArray',
      highCount: 'HighCount',
      highList: 'HighList',
      levelsOn: 'LevelsOn',
      lowCount: 'LowCount',
      lowList: 'LowList',
      mediumCount: 'MediumCount',
      mediumList: 'MediumList',
      timeArray: 'TimeArray',
      totalCount: 'TotalCount',
      valueArray: 'ValueArray',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dateArray: { 'type': 'array', 'itemType': 'string' },
      highCount: 'number',
      highList: { 'type': 'array', 'itemType': 'string' },
      levelsOn: { 'type': 'array', 'itemType': 'string' },
      lowCount: 'number',
      lowList: { 'type': 'array', 'itemType': 'string' },
      mediumCount: 'number',
      mediumList: { 'type': 'array', 'itemType': 'string' },
      timeArray: { 'type': 'array', 'itemType': 'string' },
      totalCount: 'number',
      valueArray: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityStatInfoResponseBodySecurityEvent extends $tea.Model {
  dateArray?: string[];
  levelsOn?: string[];
  remindCount?: number;
  remindList?: string[];
  seriousCount?: number;
  seriousList?: string[];
  suspiciousCount?: number;
  suspiciousList?: string[];
  timeArray?: string[];
  totalCount?: number;
  valueArray?: string[];
  static names(): { [key: string]: string } {
    return {
      dateArray: 'DateArray',
      levelsOn: 'LevelsOn',
      remindCount: 'RemindCount',
      remindList: 'RemindList',
      seriousCount: 'SeriousCount',
      seriousList: 'SeriousList',
      suspiciousCount: 'SuspiciousCount',
      suspiciousList: 'SuspiciousList',
      timeArray: 'TimeArray',
      totalCount: 'TotalCount',
      valueArray: 'ValueArray',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dateArray: { 'type': 'array', 'itemType': 'string' },
      levelsOn: { 'type': 'array', 'itemType': 'string' },
      remindCount: 'number',
      remindList: { 'type': 'array', 'itemType': 'string' },
      seriousCount: 'number',
      seriousList: { 'type': 'array', 'itemType': 'string' },
      suspiciousCount: 'number',
      suspiciousList: { 'type': 'array', 'itemType': 'string' },
      timeArray: { 'type': 'array', 'itemType': 'string' },
      totalCount: 'number',
      valueArray: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSecurityStatInfoResponseBodyVulnerability extends $tea.Model {
  asapCount?: number;
  asapList?: string[];
  dateArray?: string[];
  laterCount?: number;
  laterList?: string[];
  levelsOn?: string[];
  nntfCount?: number;
  nntfList?: string[];
  timeArray?: string[];
  totalCount?: number;
  valueArray?: string[];
  static names(): { [key: string]: string } {
    return {
      asapCount: 'AsapCount',
      asapList: 'AsapList',
      dateArray: 'DateArray',
      laterCount: 'LaterCount',
      laterList: 'LaterList',
      levelsOn: 'LevelsOn',
      nntfCount: 'NntfCount',
      nntfList: 'NntfList',
      timeArray: 'TimeArray',
      totalCount: 'TotalCount',
      valueArray: 'ValueArray',
    };
  }

  static types(): { [key: string]: any } {
    return {
      asapCount: 'number',
      asapList: { 'type': 'array', 'itemType': 'string' },
      dateArray: { 'type': 'array', 'itemType': 'string' },
      laterCount: 'number',
      laterList: { 'type': 'array', 'itemType': 'string' },
      levelsOn: { 'type': 'array', 'itemType': 'string' },
      nntfCount: 'number',
      nntfList: { 'type': 'array', 'itemType': 'string' },
      timeArray: { 'type': 'array', 'itemType': 'string' },
      totalCount: 'number',
      valueArray: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeServiceLinkedRoleStatusResponseBodyRoleStatus extends $tea.Model {
  status?: boolean;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSimilarEventScenariosResponseBodyScenarios extends $tea.Model {
  code?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSimilarSecurityEventsResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSimilarSecurityEventsResponseBodySecurityEventsResponse extends $tea.Model {
  eventName?: string;
  eventType?: string;
  lastTime?: number;
  occurrenceTime?: number;
  securityEventId?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      eventName: 'EventName',
      eventType: 'EventType',
      lastTime: 'LastTime',
      occurrenceTime: 'OccurrenceTime',
      securityEventId: 'SecurityEventId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventName: 'string',
      eventType: 'string',
      lastTime: 'number',
      occurrenceTime: 'number',
      securityEventId: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  nextToken?: string;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      nextToken: 'string',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSnapshotsResponseBodySnapshots extends $tea.Model {
  actualBytes?: number;
  actualItems?: number;
  bytesDone?: number;
  bytesTotal?: number;
  clientId?: string;
  clientVersion?: string;
  createdTime?: number;
  errorFile?: string;
  instanceId?: string;
  itemsDone?: number;
  itemsTotal?: number;
  jobId?: string;
  parentSnapshotHash?: string;
  path?: string;
  paths?: string[];
  planId?: string;
  regionId?: string;
  retention?: number;
  snapshotHash?: string;
  snapshotId?: string;
  sourceType?: string;
  status?: string;
  uuid?: string;
  vaultId?: string;
  static names(): { [key: string]: string } {
    return {
      actualBytes: 'ActualBytes',
      actualItems: 'ActualItems',
      bytesDone: 'BytesDone',
      bytesTotal: 'BytesTotal',
      clientId: 'ClientId',
      clientVersion: 'ClientVersion',
      createdTime: 'CreatedTime',
      errorFile: 'ErrorFile',
      instanceId: 'InstanceId',
      itemsDone: 'ItemsDone',
      itemsTotal: 'ItemsTotal',
      jobId: 'JobId',
      parentSnapshotHash: 'ParentSnapshotHash',
      path: 'Path',
      paths: 'Paths',
      planId: 'PlanId',
      regionId: 'RegionId',
      retention: 'Retention',
      snapshotHash: 'SnapshotHash',
      snapshotId: 'SnapshotId',
      sourceType: 'SourceType',
      status: 'Status',
      uuid: 'Uuid',
      vaultId: 'VaultId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actualBytes: 'number',
      actualItems: 'number',
      bytesDone: 'number',
      bytesTotal: 'number',
      clientId: 'string',
      clientVersion: 'string',
      createdTime: 'number',
      errorFile: 'string',
      instanceId: 'string',
      itemsDone: 'number',
      itemsTotal: 'number',
      jobId: 'string',
      parentSnapshotHash: 'string',
      path: 'string',
      paths: { 'type': 'array', 'itemType': 'string' },
      planId: 'string',
      regionId: 'string',
      retention: 'number',
      snapshotHash: 'string',
      snapshotId: 'string',
      sourceType: 'string',
      status: 'string',
      uuid: 'string',
      vaultId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyResponseBodyStrategiesConfigTargets extends $tea.Model {
  flag?: string;
  target?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      flag: 'Flag',
      target: 'Target',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flag: 'string',
      target: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyResponseBodyStrategies extends $tea.Model {
  configTargets?: DescribeStrategyResponseBodyStrategiesConfigTargets[];
  customType?: string;
  cycleDays?: number;
  cycleStartTime?: number;
  ecsCount?: number;
  endTime?: string;
  execStatus?: number;
  id?: number;
  name?: string;
  passRate?: number;
  processRate?: number;
  riskCount?: number;
  startTime?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      configTargets: 'ConfigTargets',
      customType: 'CustomType',
      cycleDays: 'CycleDays',
      cycleStartTime: 'CycleStartTime',
      ecsCount: 'EcsCount',
      endTime: 'EndTime',
      execStatus: 'ExecStatus',
      id: 'Id',
      name: 'Name',
      passRate: 'PassRate',
      processRate: 'ProcessRate',
      riskCount: 'RiskCount',
      startTime: 'StartTime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configTargets: { 'type': 'array', 'itemType': DescribeStrategyResponseBodyStrategiesConfigTargets },
      customType: 'string',
      cycleDays: 'number',
      cycleStartTime: 'number',
      ecsCount: 'number',
      endTime: 'string',
      execStatus: 'number',
      id: 'number',
      name: 'string',
      passRate: 'number',
      processRate: 'number',
      riskCount: 'number',
      startTime: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList extends $tea.Model {
  enumValue?: string;
  maxValue?: number;
  minValue?: number;
  paramDefaultValue?: string;
  paramDesc?: string;
  paramName?: string;
  paramType?: number;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      enumValue: 'EnumValue',
      maxValue: 'MaxValue',
      minValue: 'MinValue',
      paramDefaultValue: 'ParamDefaultValue',
      paramDesc: 'ParamDesc',
      paramName: 'ParamName',
      paramType: 'ParamType',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enumValue: 'string',
      maxValue: 'number',
      minValue: 'number',
      paramDefaultValue: 'string',
      paramDesc: 'string',
      paramName: 'string',
      paramType: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules extends $tea.Model {
  defaultValue?: number;
  optional?: number;
  paramList?: DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList[];
  ruleDesc?: string;
  ruleId?: string;
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      optional: 'Optional',
      paramList: 'ParamList',
      ruleDesc: 'RuleDesc',
      ruleId: 'RuleId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'number',
      optional: 'number',
      paramList: { 'type': 'array', 'itemType': DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRulesParamList },
      ruleDesc: 'string',
      ruleId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails extends $tea.Model {
  checkDesc?: string;
  checkId?: number;
  checkItem?: string;
  rules?: DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules[];
  static names(): { [key: string]: string } {
    return {
      checkDesc: 'CheckDesc',
      checkId: 'CheckId',
      checkItem: 'CheckItem',
      rules: 'Rules',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkDesc: 'string',
      checkId: 'number',
      checkItem: 'string',
      rules: { 'type': 'array', 'itemType': DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetailsRules },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes extends $tea.Model {
  alias?: string;
  checkDetails?: DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails[];
  on?: boolean;
  typeName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      checkDetails: 'CheckDetails',
      on: 'On',
      typeName: 'TypeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      checkDetails: { 'type': 'array', 'itemType': DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypesCheckDetails },
      on: 'boolean',
      typeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList extends $tea.Model {
  alias?: string;
  on?: boolean;
  subTypes?: DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes[];
  typeName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      on: 'On',
      subTypes: 'SubTypes',
      typeName: 'TypeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      on: 'boolean',
      subTypes: { 'type': 'array', 'itemType': DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultListSubTypes },
      typeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyDetailResponseBodyStrategy extends $tea.Model {
  customType?: string;
  cycleDays?: number;
  cycleStartTime?: number;
  endTime?: string;
  id?: number;
  name?: string;
  riskSubTypeName?: string;
  riskTypeWhiteListQueryResultList?: DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList[];
  startTime?: string;
  targetType?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      customType: 'CustomType',
      cycleDays: 'CycleDays',
      cycleStartTime: 'CycleStartTime',
      endTime: 'EndTime',
      id: 'Id',
      name: 'Name',
      riskSubTypeName: 'RiskSubTypeName',
      riskTypeWhiteListQueryResultList: 'RiskTypeWhiteListQueryResultList',
      startTime: 'StartTime',
      targetType: 'TargetType',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      customType: 'string',
      cycleDays: 'number',
      cycleStartTime: 'number',
      endTime: 'string',
      id: 'number',
      name: 'string',
      riskSubTypeName: 'string',
      riskTypeWhiteListQueryResultList: { 'type': 'array', 'itemType': DescribeStrategyDetailResponseBodyStrategyRiskTypeWhiteListQueryResultList },
      startTime: 'string',
      targetType: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyExecDetailResponseBodyFailedEcsList extends $tea.Model {
  IP?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  reason?: string;
  static names(): { [key: string]: string } {
    return {
      IP: 'IP',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      reason: 'Reason',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IP: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      reason: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeStrategyTargetResponseBodyStrategyTargets extends $tea.Model {
  bindUuidCount?: number;
  flag?: string;
  target?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      bindUuidCount: 'BindUuidCount',
      flag: 'Flag',
      target: 'Target',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindUuidCount: 'number',
      flag: 'string',
      target: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventDetailResponseBodyDetails extends $tea.Model {
  nameDisplay?: string;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      nameDisplay: 'NameDisplay',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameDisplay: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventQuaraFilesResponseBodyQuaraFiles extends $tea.Model {
  eventName?: string;
  eventType?: string;
  id?: number;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  ip?: string;
  link?: string;
  md5?: string;
  modifyTime?: string;
  path?: string;
  status?: string;
  tag?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      eventName: 'EventName',
      eventType: 'EventType',
      id: 'Id',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      ip: 'Ip',
      link: 'Link',
      md5: 'Md5',
      modifyTime: 'ModifyTime',
      path: 'Path',
      status: 'Status',
      tag: 'Tag',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventName: 'string',
      eventType: 'string',
      id: 'number',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      ip: 'string',
      link: 'string',
      md5: 'string',
      modifyTime: 'string',
      path: 'string',
      status: 'string',
      tag: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventsResponseBodySuspEventsDetails extends $tea.Model {
  nameDisplay?: string;
  type?: string;
  value?: string;
  valueDisplay?: string;
  static names(): { [key: string]: string } {
    return {
      nameDisplay: 'NameDisplay',
      type: 'Type',
      value: 'Value',
      valueDisplay: 'ValueDisplay',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameDisplay: 'string',
      type: 'string',
      value: 'string',
      valueDisplay: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventsResponseBodySuspEventsEventNotes extends $tea.Model {
  note?: string;
  noteId?: number;
  noteTime?: string;
  static names(): { [key: string]: string } {
    return {
      note: 'Note',
      noteId: 'NoteId',
      noteTime: 'NoteTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      note: 'string',
      noteId: 'number',
      noteTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventsResponseBodySuspEventsTacticItems extends $tea.Model {
  tacticDisplayName?: string;
  tacticId?: string;
  static names(): { [key: string]: string } {
    return {
      tacticDisplayName: 'TacticDisplayName',
      tacticId: 'TacticId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tacticDisplayName: 'string',
      tacticId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspEventsResponseBodySuspEvents extends $tea.Model {
  advanced?: boolean;
  alarmEventName?: string;
  alarmEventNameDisplay?: string;
  alarmEventType?: string;
  alarmEventTypeDisplay?: string;
  alarmUniqueInfo?: string;
  appName?: string;
  autoBreaking?: boolean;
  canBeDealOnLine?: boolean;
  canCancelFault?: boolean;
  containHwMode?: boolean;
  containerId?: string;
  containerImageId?: string;
  containerImageName?: string;
  dataSource?: string;
  desc?: string;
  details?: DescribeSuspEventsResponseBodySuspEventsDetails[];
  displaySandboxResult?: boolean;
  eventNotes?: DescribeSuspEventsResponseBodySuspEventsEventNotes[];
  eventStatus?: number;
  eventSubType?: string;
  hasTraceInfo?: boolean;
  id?: number;
  imageUuid?: string;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  k8sClusterId?: string;
  k8sClusterName?: string;
  k8sNamespace?: string;
  k8sNodeId?: string;
  k8sNodeName?: string;
  k8sPodName?: string;
  largeModel?: boolean;
  lastTime?: string;
  lastTimeStamp?: number;
  level?: string;
  maliciousRuleStatus?: string;
  markMisRules?: string;
  name?: string;
  occurrenceTime?: string;
  occurrenceTimeStamp?: number;
  operateErrorCode?: string;
  operateMsg?: string;
  operateTime?: number;
  saleVersion?: string;
  securityEventIds?: string;
  stages?: string;
  tacticItems?: DescribeSuspEventsResponseBodySuspEventsTacticItems[];
  uniqueInfo?: string;
  uuid?: string;
  clusterId?: string;
  static names(): { [key: string]: string } {
    return {
      advanced: 'Advanced',
      alarmEventName: 'AlarmEventName',
      alarmEventNameDisplay: 'AlarmEventNameDisplay',
      alarmEventType: 'AlarmEventType',
      alarmEventTypeDisplay: 'AlarmEventTypeDisplay',
      alarmUniqueInfo: 'AlarmUniqueInfo',
      appName: 'AppName',
      autoBreaking: 'AutoBreaking',
      canBeDealOnLine: 'CanBeDealOnLine',
      canCancelFault: 'CanCancelFault',
      containHwMode: 'ContainHwMode',
      containerId: 'ContainerId',
      containerImageId: 'ContainerImageId',
      containerImageName: 'ContainerImageName',
      dataSource: 'DataSource',
      desc: 'Desc',
      details: 'Details',
      displaySandboxResult: 'DisplaySandboxResult',
      eventNotes: 'EventNotes',
      eventStatus: 'EventStatus',
      eventSubType: 'EventSubType',
      hasTraceInfo: 'HasTraceInfo',
      id: 'Id',
      imageUuid: 'ImageUuid',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      k8sClusterId: 'K8sClusterId',
      k8sClusterName: 'K8sClusterName',
      k8sNamespace: 'K8sNamespace',
      k8sNodeId: 'K8sNodeId',
      k8sNodeName: 'K8sNodeName',
      k8sPodName: 'K8sPodName',
      largeModel: 'LargeModel',
      lastTime: 'LastTime',
      lastTimeStamp: 'LastTimeStamp',
      level: 'Level',
      maliciousRuleStatus: 'MaliciousRuleStatus',
      markMisRules: 'MarkMisRules',
      name: 'Name',
      occurrenceTime: 'OccurrenceTime',
      occurrenceTimeStamp: 'OccurrenceTimeStamp',
      operateErrorCode: 'OperateErrorCode',
      operateMsg: 'OperateMsg',
      operateTime: 'OperateTime',
      saleVersion: 'SaleVersion',
      securityEventIds: 'SecurityEventIds',
      stages: 'Stages',
      tacticItems: 'TacticItems',
      uniqueInfo: 'UniqueInfo',
      uuid: 'Uuid',
      clusterId: 'clusterId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advanced: 'boolean',
      alarmEventName: 'string',
      alarmEventNameDisplay: 'string',
      alarmEventType: 'string',
      alarmEventTypeDisplay: 'string',
      alarmUniqueInfo: 'string',
      appName: 'string',
      autoBreaking: 'boolean',
      canBeDealOnLine: 'boolean',
      canCancelFault: 'boolean',
      containHwMode: 'boolean',
      containerId: 'string',
      containerImageId: 'string',
      containerImageName: 'string',
      dataSource: 'string',
      desc: 'string',
      details: { 'type': 'array', 'itemType': DescribeSuspEventsResponseBodySuspEventsDetails },
      displaySandboxResult: 'boolean',
      eventNotes: { 'type': 'array', 'itemType': DescribeSuspEventsResponseBodySuspEventsEventNotes },
      eventStatus: 'number',
      eventSubType: 'string',
      hasTraceInfo: 'boolean',
      id: 'number',
      imageUuid: 'string',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      k8sClusterId: 'string',
      k8sClusterName: 'string',
      k8sNamespace: 'string',
      k8sNodeId: 'string',
      k8sNodeName: 'string',
      k8sPodName: 'string',
      largeModel: 'boolean',
      lastTime: 'string',
      lastTimeStamp: 'number',
      level: 'string',
      maliciousRuleStatus: 'string',
      markMisRules: 'string',
      name: 'string',
      occurrenceTime: 'string',
      occurrenceTimeStamp: 'number',
      operateErrorCode: 'string',
      operateMsg: 'string',
      operateTime: 'number',
      saleVersion: 'string',
      securityEventIds: 'string',
      stages: 'string',
      tacticItems: { 'type': 'array', 'itemType': DescribeSuspEventsResponseBodySuspEventsTacticItems },
      uniqueInfo: 'string',
      uuid: 'string',
      clusterId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSuspiciousOverallConfigResponseBodyOverallConfig extends $tea.Model {
  config?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTargetResponseBodyTargets extends $tea.Model {
  flag?: string;
  target?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      flag: 'Flag',
      target: 'Target',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flag: 'string',
      target: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTaskErrorLogResponseBodyLogs extends $tea.Model {
  text?: string;
  static names(): { [key: string]: string } {
    return {
      text: 'Text',
    };
  }

  static types(): { [key: string]: any } {
    return {
      text: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList extends $tea.Model {
  count?: number;
  endId?: string;
  startId?: string;
  time?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      endId: 'EndId',
      startId: 'StartId',
      time: 'Time',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      endId: 'string',
      startId: 'string',
      time: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList extends $tea.Model {
  dbId?: number;
  displayColor?: string;
  displayIcon?: string;
  displayTemplate?: string;
  gmtCreate?: number;
  gmtModified?: number;
  id?: string;
  limit?: number;
  name?: string;
  namespace?: string;
  offset?: number;
  static names(): { [key: string]: string } {
    return {
      dbId: 'DbId',
      displayColor: 'DisplayColor',
      displayIcon: 'DisplayIcon',
      displayTemplate: 'DisplayTemplate',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      limit: 'Limit',
      name: 'Name',
      namespace: 'Namespace',
      offset: 'Offset',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dbId: 'number',
      displayColor: 'string',
      displayIcon: 'string',
      displayTemplate: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'string',
      limit: 'number',
      name: 'string',
      namespace: 'string',
      offset: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList extends $tea.Model {
  directed?: number;
  displayColor?: string;
  name?: string;
  relationTypeId?: string;
  showType?: string;
  static names(): { [key: string]: string } {
    return {
      directed: 'Directed',
      displayColor: 'DisplayColor',
      name: 'Name',
      relationTypeId: 'RelationTypeId',
      showType: 'ShowType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      directed: 'number',
      displayColor: 'string',
      name: 'string',
      relationTypeId: 'string',
      showType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList extends $tea.Model {
  count?: number;
  hasMore?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      hasMore: 'HasMore',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      hasMore: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList extends $tea.Model {
  count?: number;
  id?: string;
  name?: string;
  neighborList?: DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList[];
  time?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      id: 'Id',
      name: 'Name',
      neighborList: 'NeighborList',
      time: 'Time',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      id: 'string',
      name: 'string',
      neighborList: { 'type': 'array', 'itemType': DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexListNeighborList },
      time: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoDetailResponseBodyTraceInfoDetail extends $tea.Model {
  edgeList?: DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList[];
  entityTypeList?: DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList[];
  relationTypeList?: DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList[];
  vertexList?: DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList[];
  static names(): { [key: string]: string } {
    return {
      edgeList: 'EdgeList',
      entityTypeList: 'EntityTypeList',
      relationTypeList: 'RelationTypeList',
      vertexList: 'VertexList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edgeList: { 'type': 'array', 'itemType': DescribeTraceInfoDetailResponseBodyTraceInfoDetailEdgeList },
      entityTypeList: { 'type': 'array', 'itemType': DescribeTraceInfoDetailResponseBodyTraceInfoDetailEntityTypeList },
      relationTypeList: { 'type': 'array', 'itemType': DescribeTraceInfoDetailResponseBodyTraceInfoDetailRelationTypeList },
      vertexList: { 'type': 'array', 'itemType': DescribeTraceInfoDetailResponseBodyTraceInfoDetailVertexList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoNodeResponseBodyNodePropertyList extends $tea.Model {
  name?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTraceInfoNodeResponseBodyNode extends $tea.Model {
  name?: string;
  propertyList?: DescribeTraceInfoNodeResponseBodyNodePropertyList[];
  type?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      propertyList: 'PropertyList',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      propertyList: { 'type': 'array', 'itemType': DescribeTraceInfoNodeResponseBodyNodePropertyList },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupDatabaseResponseBodyDatabaseList extends $tea.Model {
  agentStatus?: string;
  createdByProduct?: string;
  databaseName?: string;
  databaseType?: string;
  databaseVersion?: string;
  instanceId?: string;
  instanceName?: string;
  instanceUuid?: string;
  policyId?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      agentStatus: 'AgentStatus',
      createdByProduct: 'CreatedByProduct',
      databaseName: 'DatabaseName',
      databaseType: 'DatabaseType',
      databaseVersion: 'DatabaseVersion',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      instanceUuid: 'InstanceUuid',
      policyId: 'PolicyId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agentStatus: 'string',
      createdByProduct: 'string',
      databaseName: 'string',
      databaseType: 'string',
      databaseVersion: 'string',
      instanceId: 'string',
      instanceName: 'string',
      instanceUuid: 'string',
      policyId: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupDatabaseResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupPoliciesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupPoliciesResponseBodyUniBackupPolicies extends $tea.Model {
  agentErrorMessage?: string;
  agentStatus?: string;
  databaseName?: string;
  databaseType?: string;
  errorCode?: string;
  errorMessage?: string;
  instanceId?: string;
  instanceName?: string;
  instanceStatus?: string;
  instanceUuid?: string;
  latestBackResult?: string;
  latestBackupTime?: string;
  planStatus?: string;
  policyId?: number;
  policyName?: string;
  policyStatus?: string;
  uniRegionId?: string;
  static names(): { [key: string]: string } {
    return {
      agentErrorMessage: 'AgentErrorMessage',
      agentStatus: 'AgentStatus',
      databaseName: 'DatabaseName',
      databaseType: 'DatabaseType',
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      instanceStatus: 'InstanceStatus',
      instanceUuid: 'InstanceUuid',
      latestBackResult: 'LatestBackResult',
      latestBackupTime: 'LatestBackupTime',
      planStatus: 'PlanStatus',
      policyId: 'PolicyId',
      policyName: 'PolicyName',
      policyStatus: 'PolicyStatus',
      uniRegionId: 'UniRegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agentErrorMessage: 'string',
      agentStatus: 'string',
      databaseName: 'string',
      databaseType: 'string',
      errorCode: 'string',
      errorMessage: 'string',
      instanceId: 'string',
      instanceName: 'string',
      instanceStatus: 'string',
      instanceUuid: 'string',
      latestBackResult: 'string',
      latestBackupTime: 'string',
      planStatus: 'string',
      policyId: 'number',
      policyName: 'string',
      policyStatus: 'string',
      uniRegionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan extends $tea.Model {
  days?: string[];
  interval?: number;
  planType?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      days: 'Days',
      interval: 'Interval',
      planType: 'PlanType',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      days: { 'type': 'array', 'itemType': 'string' },
      interval: 'number',
      planType: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan extends $tea.Model {
  days?: string[];
  interval?: number;
  planType?: string;
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      days: 'Days',
      interval: 'Interval',
      planType: 'PlanType',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      days: { 'type': 'array', 'itemType': 'string' },
      interval: 'number',
      planType: 'string',
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTO extends $tea.Model {
  accountName?: string;
  agentStatus?: string;
  databaseType?: string;
  fullPlan?: DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan;
  incPlan?: DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan;
  instanceId?: string;
  instanceName?: string;
  policyId?: number;
  policyName?: string;
  policyStatus?: string;
  retention?: number;
  speedLimiter?: number;
  static names(): { [key: string]: string } {
    return {
      accountName: 'AccountName',
      agentStatus: 'AgentStatus',
      databaseType: 'DatabaseType',
      fullPlan: 'FullPlan',
      incPlan: 'IncPlan',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      policyId: 'PolicyId',
      policyName: 'PolicyName',
      policyStatus: 'PolicyStatus',
      retention: 'Retention',
      speedLimiter: 'SpeedLimiter',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountName: 'string',
      agentStatus: 'string',
      databaseType: 'string',
      fullPlan: DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOFullPlan,
      incPlan: DescribeUniBackupPolicyDetailResponseBodyUniBackupPolicyDTOIncPlan,
      instanceId: 'string',
      instanceName: 'string',
      policyId: 'number',
      policyName: 'string',
      policyStatus: 'string',
      retention: 'number',
      speedLimiter: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUniRecoverableListResponseBodyRecoverableInfoList extends $tea.Model {
  firstTime?: number;
  lastTime?: number;
  resetScn?: string;
  resetTime?: number;
  restoreInfo?: string;
  static names(): { [key: string]: string } {
    return {
      firstTime: 'FirstTime',
      lastTime: 'LastTime',
      resetScn: 'ResetScn',
      resetTime: 'ResetTime',
      restoreInfo: 'RestoreInfo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      firstTime: 'number',
      lastTime: 'number',
      resetScn: 'string',
      resetTime: 'number',
      restoreInfo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserBackupMachinesResponseBodyMachines extends $tea.Model {
  id?: number;
  policyName?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      policyName: 'PolicyName',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      policyName: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUserBaselineAuthorizationResponseBodyUserBaselineAuthorization extends $tea.Model {
  status?: number;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeUuidsByVulNamesResponseBodyMachineInfoStatistics extends $tea.Model {
  machineInstanceId?: string;
  machineIp?: string;
  machineName?: string;
  os?: string;
  regionId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      machineInstanceId: 'MachineInstanceId',
      machineIp: 'MachineIp',
      machineName: 'MachineName',
      os: 'Os',
      regionId: 'RegionId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      machineInstanceId: 'string',
      machineIp: 'string',
      machineName: 'string',
      os: 'string',
      regionId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHoneyPotCriteriaResponseBodyCriteriaList extends $tea.Model {
  name?: string;
  type?: string;
  values?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      type: 'string',
      values: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHoneyPotListResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList extends $tea.Model {
  vpcSwitchId?: string;
  vpcSwitchName?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      vpcSwitchId: 'VpcSwitchId',
      vpcSwitchName: 'VpcSwitchName',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      vpcSwitchId: 'string',
      vpcSwitchName: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOList extends $tea.Model {
  cidrBlock?: string;
  createTime?: number;
  honeyPotEcsInstanceStatus?: string;
  honeyPotEniInstanceId?: string;
  honeyPotExistence?: boolean;
  honeyPotInstanceStatus?: string;
  honeyPotVpcSwitchId?: string;
  vpcId?: string;
  vpcName?: string;
  vpcRegionId?: string;
  vpcStatus?: string;
  vpcSwitchIdList?: DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList[];
  static names(): { [key: string]: string } {
    return {
      cidrBlock: 'CidrBlock',
      createTime: 'CreateTime',
      honeyPotEcsInstanceStatus: 'HoneyPotEcsInstanceStatus',
      honeyPotEniInstanceId: 'HoneyPotEniInstanceId',
      honeyPotExistence: 'HoneyPotExistence',
      honeyPotInstanceStatus: 'HoneyPotInstanceStatus',
      honeyPotVpcSwitchId: 'HoneyPotVpcSwitchId',
      vpcId: 'VpcId',
      vpcName: 'VpcName',
      vpcRegionId: 'VpcRegionId',
      vpcStatus: 'VpcStatus',
      vpcSwitchIdList: 'VpcSwitchIdList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cidrBlock: 'string',
      createTime: 'number',
      honeyPotEcsInstanceStatus: 'string',
      honeyPotEniInstanceId: 'string',
      honeyPotExistence: 'boolean',
      honeyPotInstanceStatus: 'string',
      honeyPotVpcSwitchId: 'string',
      vpcId: 'string',
      vpcName: 'string',
      vpcRegionId: 'string',
      vpcStatus: 'string',
      vpcSwitchIdList: { 'type': 'array', 'itemType': DescribeVpcHoneyPotListResponseBodyVpcHoneyPotDTOListVpcSwitchIdList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVpcListResponseBodyVpcList extends $tea.Model {
  ecsCount?: number;
  instanceDesc?: string;
  instanceId?: string;
  instanceName?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      ecsCount: 'EcsCount',
      instanceDesc: 'InstanceDesc',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ecsCount: 'number',
      instanceDesc: 'string',
      instanceId: 'string',
      instanceName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList extends $tea.Model {
  code?: string;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulCheckTaskStatusDetailResponseBodyTaskStatuses extends $tea.Model {
  taskId?: string;
  taskStatusList?: DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList[];
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
      taskStatusList: 'TaskStatusList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'string',
      taskStatusList: { 'type': 'array', 'itemType': DescribeVulCheckTaskStatusDetailResponseBodyTaskStatusesTaskStatusList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulConfigResponseBodyTargetConfigs extends $tea.Model {
  config?: string;
  overAllConfig?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      overAllConfig: 'OverAllConfig',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      overAllConfig: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulDetailsResponseBodyCvesClassifys extends $tea.Model {
  classify?: string;
  demoVideoUrl?: string;
  description?: string;
  static names(): { [key: string]: string } {
    return {
      classify: 'Classify',
      demoVideoUrl: 'DemoVideoUrl',
      description: 'Description',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classify: 'string',
      demoVideoUrl: 'string',
      description: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulDetailsResponseBodyCves extends $tea.Model {
  classify?: string;
  classifys?: DescribeVulDetailsResponseBodyCvesClassifys[];
  cnvdId?: string;
  complexity?: string;
  content?: string;
  cveId?: string;
  cveLink?: string;
  cvssScore?: string;
  cvssVector?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  otherId?: string;
  poc?: string;
  pocCreateTime?: number;
  pocDisclosureTime?: number;
  product?: string;
  reference?: string;
  releaseTime?: number;
  solution?: string;
  summary?: string;
  targetId?: string;
  targetName?: string;
  title?: string;
  vendor?: string;
  vulLevel?: string;
  static names(): { [key: string]: string } {
    return {
      classify: 'Classify',
      classifys: 'Classifys',
      cnvdId: 'CnvdId',
      complexity: 'Complexity',
      content: 'Content',
      cveId: 'CveId',
      cveLink: 'CveLink',
      cvssScore: 'CvssScore',
      cvssVector: 'CvssVector',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      otherId: 'OtherId',
      poc: 'Poc',
      pocCreateTime: 'PocCreateTime',
      pocDisclosureTime: 'PocDisclosureTime',
      product: 'Product',
      reference: 'Reference',
      releaseTime: 'ReleaseTime',
      solution: 'Solution',
      summary: 'Summary',
      targetId: 'TargetId',
      targetName: 'TargetName',
      title: 'Title',
      vendor: 'Vendor',
      vulLevel: 'VulLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classify: 'string',
      classifys: { 'type': 'array', 'itemType': DescribeVulDetailsResponseBodyCvesClassifys },
      cnvdId: 'string',
      complexity: 'string',
      content: 'string',
      cveId: 'string',
      cveLink: 'string',
      cvssScore: 'string',
      cvssVector: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      otherId: 'string',
      poc: 'string',
      pocCreateTime: 'number',
      pocDisclosureTime: 'number',
      product: 'string',
      reference: 'string',
      releaseTime: 'number',
      solution: 'string',
      summary: 'string',
      targetId: 'string',
      targetName: 'string',
      title: 'string',
      vendor: 'string',
      vulLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulFixStatisticsResponseBodyFixStat extends $tea.Model {
  fixedTodayNum?: number;
  fixedTotalNum?: number;
  fixingNum?: number;
  needFixNum?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      fixedTodayNum: 'FixedTodayNum',
      fixedTotalNum: 'FixedTotalNum',
      fixingNum: 'FixingNum',
      needFixNum: 'NeedFixNum',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fixedTodayNum: 'number',
      fixedTotalNum: 'number',
      fixingNum: 'number',
      needFixNum: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulFixStatisticsResponseBodyFixTotal extends $tea.Model {
  fixedTodayNum?: number;
  fixedTotalNum?: number;
  fixingNum?: number;
  needFixNum?: number;
  static names(): { [key: string]: string } {
    return {
      fixedTodayNum: 'FixedTodayNum',
      fixedTotalNum: 'FixedTotalNum',
      fixingNum: 'FixingNum',
      needFixNum: 'NeedFixNum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fixedTodayNum: 'number',
      fixedTotalNum: 'number',
      fixingNum: 'number',
      needFixNum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity extends $tea.Model {
  assetsFactor?: string;
  cvssFactor?: string;
  enviromentFactor?: string;
  isCalc?: string;
  status?: string;
  timeFactor?: string;
  totalScore?: string;
  static names(): { [key: string]: string } {
    return {
      assetsFactor: 'Assets_factor',
      cvssFactor: 'Cvss_factor',
      enviromentFactor: 'Enviroment_factor',
      isCalc: 'Is_calc',
      status: 'Status',
      timeFactor: 'Time_factor',
      totalScore: 'Total_score',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetsFactor: 'string',
      cvssFactor: 'string',
      enviromentFactor: 'string',
      isCalc: 'string',
      status: 'string',
      timeFactor: 'string',
      totalScore: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList extends $tea.Model {
  containerName?: string;
  fullVersion?: string;
  imageName?: string;
  matchDetail?: string;
  matchList?: string[];
  name?: string;
  path?: string;
  pid?: string;
  updateCmd?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      containerName: 'ContainerName',
      fullVersion: 'FullVersion',
      imageName: 'ImageName',
      matchDetail: 'MatchDetail',
      matchList: 'MatchList',
      name: 'Name',
      path: 'Path',
      pid: 'Pid',
      updateCmd: 'UpdateCmd',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      containerName: 'string',
      fullVersion: 'string',
      imageName: 'string',
      matchDetail: 'string',
      matchList: { 'type': 'array', 'itemType': 'string' },
      name: 'string',
      path: 'string',
      pid: 'string',
      updateCmd: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulListResponseBodyVulRecordsExtendContentJson extends $tea.Model {
  absolutePath?: string;
  aliasName?: string;
  description?: string;
  emgProof?: string;
  ip?: string;
  lastTs?: number;
  necessity?: DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity;
  os?: string;
  osRelease?: string;
  primaryId?: number;
  rpmEntityList?: DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList[];
  status?: string;
  tag?: string;
  target?: string;
  cveList?: string[];
  static names(): { [key: string]: string } {
    return {
      absolutePath: 'AbsolutePath',
      aliasName: 'AliasName',
      description: 'Description',
      emgProof: 'EmgProof',
      ip: 'Ip',
      lastTs: 'LastTs',
      necessity: 'Necessity',
      os: 'Os',
      osRelease: 'OsRelease',
      primaryId: 'PrimaryId',
      rpmEntityList: 'RpmEntityList',
      status: 'Status',
      tag: 'Tag',
      target: 'Target',
      cveList: 'cveList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      absolutePath: 'string',
      aliasName: 'string',
      description: 'string',
      emgProof: 'string',
      ip: 'string',
      lastTs: 'number',
      necessity: DescribeVulListResponseBodyVulRecordsExtendContentJsonNecessity,
      os: 'string',
      osRelease: 'string',
      primaryId: 'number',
      rpmEntityList: { 'type': 'array', 'itemType': DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList },
      status: 'string',
      tag: 'string',
      target: 'string',
      cveList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulListResponseBodyVulRecords extends $tea.Model {
  aliasName?: string;
  authVersion?: string;
  bind?: boolean;
  extendContentJson?: DescribeVulListResponseBodyVulRecordsExtendContentJson;
  firstTs?: number;
  groupId?: number;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  lastTs?: number;
  modifyTs?: number;
  name?: string;
  necessity?: string;
  online?: boolean;
  osName?: string;
  osVersion?: string;
  primaryId?: number;
  raspDefend?: number;
  raspStatus?: number;
  regionId?: string;
  related?: string;
  repairTs?: number;
  resultCode?: string;
  resultMessage?: string;
  status?: number;
  tag?: string;
  type?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      authVersion: 'AuthVersion',
      bind: 'Bind',
      extendContentJson: 'ExtendContentJson',
      firstTs: 'FirstTs',
      groupId: 'GroupId',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      lastTs: 'LastTs',
      modifyTs: 'ModifyTs',
      name: 'Name',
      necessity: 'Necessity',
      online: 'Online',
      osName: 'OsName',
      osVersion: 'OsVersion',
      primaryId: 'PrimaryId',
      raspDefend: 'RaspDefend',
      raspStatus: 'RaspStatus',
      regionId: 'RegionId',
      related: 'Related',
      repairTs: 'RepairTs',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      status: 'Status',
      tag: 'Tag',
      type: 'Type',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      authVersion: 'string',
      bind: 'boolean',
      extendContentJson: DescribeVulListResponseBodyVulRecordsExtendContentJson,
      firstTs: 'number',
      groupId: 'number',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      lastTs: 'number',
      modifyTs: 'number',
      name: 'string',
      necessity: 'string',
      online: 'boolean',
      osName: 'string',
      osVersion: 'string',
      primaryId: 'number',
      raspDefend: 'number',
      raspStatus: 'number',
      regionId: 'string',
      related: 'string',
      repairTs: 'number',
      resultCode: 'string',
      resultMessage: 'string',
      status: 'number',
      tag: 'string',
      type: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulListPageResponseBodyData extends $tea.Model {
  cveId?: string;
  extAegis?: string;
  id?: number;
  isAegis?: number;
  isSas?: number;
  otherId?: string;
  releaseTime?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      cveId: 'CveId',
      extAegis: 'ExtAegis',
      id: 'Id',
      isAegis: 'IsAegis',
      isSas: 'IsSas',
      otherId: 'OtherId',
      releaseTime: 'ReleaseTime',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cveId: 'string',
      extAegis: 'string',
      id: 'number',
      isAegis: 'number',
      isSas: 'number',
      otherId: 'string',
      releaseTime: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulTargetConfigResponseBodyTargetConfigs extends $tea.Model {
  config?: string;
  overAllConfig?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      overAllConfig: 'OverAllConfig',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      overAllConfig: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulTargetStatisticsResponseBodyTargetStatsTargets extends $tea.Model {
  flag?: string;
  target?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      flag: 'Flag',
      target: 'Target',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      flag: 'string',
      target: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulTargetStatisticsResponseBodyTargetStats extends $tea.Model {
  targets?: DescribeVulTargetStatisticsResponseBodyTargetStatsTargets[];
  totalCount?: number;
  uuidCount?: number;
  vulType?: string;
  static names(): { [key: string]: string } {
    return {
      targets: 'Targets',
      totalCount: 'TotalCount',
      uuidCount: 'UuidCount',
      vulType: 'VulType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targets: { 'type': 'array', 'itemType': DescribeVulTargetStatisticsResponseBodyTargetStatsTargets },
      totalCount: 'number',
      uuidCount: 'number',
      vulType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeVulWhitelistResponseBodyVulWhitelists extends $tea.Model {
  aliasName?: string;
  id?: string;
  name?: string;
  reason?: string;
  targetInfo?: string;
  type?: string;
  whitelist?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      id: 'Id',
      name: 'Name',
      reason: 'Reason',
      targetInfo: 'TargetInfo',
      type: 'Type',
      whitelist: 'Whitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      id: 'string',
      name: 'string',
      reason: 'string',
      targetInfo: 'string',
      type: 'string',
      whitelist: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWarningMachinesResponseBodyWarningMachines extends $tea.Model {
  authVersion?: number;
  bind?: boolean;
  containerId?: string;
  containerName?: string;
  highWarningCount?: number;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  lowWarningCount?: number;
  mediumWarningCount?: number;
  passCount?: number;
  portOpen?: boolean;
  regionId?: string;
  status?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      authVersion: 'AuthVersion',
      bind: 'Bind',
      containerId: 'ContainerId',
      containerName: 'ContainerName',
      highWarningCount: 'HighWarningCount',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      lowWarningCount: 'LowWarningCount',
      mediumWarningCount: 'MediumWarningCount',
      passCount: 'PassCount',
      portOpen: 'PortOpen',
      regionId: 'RegionId',
      status: 'Status',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authVersion: 'number',
      bind: 'boolean',
      containerId: 'string',
      containerName: 'string',
      highWarningCount: 'number',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      lowWarningCount: 'number',
      mediumWarningCount: 'number',
      passCount: 'number',
      portOpen: 'boolean',
      regionId: 'string',
      status: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockBindListResponseBodyBindList extends $tea.Model {
  auditCount?: string;
  blockCount?: string;
  dirCount?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  os?: string;
  percent?: number;
  serviceCode?: string;
  serviceDetail?: string;
  serviceStatus?: string;
  status?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      auditCount: 'AuditCount',
      blockCount: 'BlockCount',
      dirCount: 'DirCount',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      os: 'Os',
      percent: 'Percent',
      serviceCode: 'ServiceCode',
      serviceDetail: 'ServiceDetail',
      serviceStatus: 'ServiceStatus',
      status: 'Status',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      auditCount: 'string',
      blockCount: 'string',
      dirCount: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      os: 'string',
      percent: 'number',
      serviceCode: 'string',
      serviceDetail: 'string',
      serviceStatus: 'string',
      status: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockConfigListResponseBodyConfigList extends $tea.Model {
  defenceMode?: string;
  dir?: string;
  exclusiveDir?: string;
  exclusiveFile?: string;
  exclusiveFileType?: string;
  id?: string;
  inclusiveFile?: string;
  inclusiveFileType?: string;
  localBackupDir?: string;
  mode?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      defenceMode: 'DefenceMode',
      dir: 'Dir',
      exclusiveDir: 'ExclusiveDir',
      exclusiveFile: 'ExclusiveFile',
      exclusiveFileType: 'ExclusiveFileType',
      id: 'Id',
      inclusiveFile: 'InclusiveFile',
      inclusiveFileType: 'InclusiveFileType',
      localBackupDir: 'LocalBackupDir',
      mode: 'Mode',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defenceMode: 'string',
      dir: 'string',
      exclusiveDir: 'string',
      exclusiveFile: 'string',
      exclusiveFileType: 'string',
      id: 'string',
      inclusiveFile: 'string',
      inclusiveFileType: 'string',
      localBackupDir: 'string',
      mode: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockFileChangeStatisticsResponseBodyList extends $tea.Model {
  count?: number;
  file?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      file: 'File',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      file: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockFileEventsResponseBodyList extends $tea.Model {
  count?: number;
  ds?: number;
  eventName?: string;
  eventStatus?: string;
  eventType?: string;
  gmtEvent?: number;
  id?: number;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  ip?: string;
  level?: string;
  path?: string;
  processName?: string;
  processPath?: string;
  status?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      ds: 'Ds',
      eventName: 'EventName',
      eventStatus: 'EventStatus',
      eventType: 'EventType',
      gmtEvent: 'GmtEvent',
      id: 'Id',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      ip: 'Ip',
      level: 'Level',
      path: 'Path',
      processName: 'ProcessName',
      processPath: 'ProcessPath',
      status: 'Status',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      ds: 'number',
      eventName: 'string',
      eventStatus: 'string',
      eventType: 'string',
      gmtEvent: 'number',
      id: 'number',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      ip: 'string',
      level: 'string',
      path: 'string',
      processName: 'string',
      processPath: 'string',
      status: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockFileTypeSummaryResponseBodyList extends $tea.Model {
  count?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockProcessBlockStatisticsResponseBodyList extends $tea.Model {
  count?: number;
  process?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      process: 'Process',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      process: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebLockProcessListResponseBodyList extends $tea.Model {
  count?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  processName?: string;
  processPath?: string;
  status?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      processName: 'ProcessName',
      processPath: 'ProcessPath',
      status: 'Status',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      processName: 'string',
      processPath: 'string',
      status: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebPathResponseBodyConfigListTargetList extends $tea.Model {
  target?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      target: 'Target',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      target: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeWebPathResponseBodyConfigList extends $tea.Model {
  targetList?: DescribeWebPathResponseBodyConfigListTargetList[];
  webPath?: string;
  webPathType?: string;
  static names(): { [key: string]: string } {
    return {
      targetList: 'TargetList',
      webPath: 'WebPath',
      webPathType: 'WebPathType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetList: { 'type': 'array', 'itemType': DescribeWebPathResponseBodyConfigListTargetList },
      webPath: 'string',
      webPathType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FindContainerNetworkConnectRequestDstNode extends $tea.Model {
  appName?: string;
  clusterId?: string;
  namespace?: string;
  nodeIds?: string[];
  nodeType?: string;
  podName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      clusterId: 'ClusterId',
      namespace: 'Namespace',
      nodeIds: 'NodeIds',
      nodeType: 'NodeType',
      podName: 'PodName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      clusterId: 'string',
      namespace: 'string',
      nodeIds: { 'type': 'array', 'itemType': 'string' },
      nodeType: 'string',
      podName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FindContainerNetworkConnectRequestSrcNode extends $tea.Model {
  appName?: string;
  clusterId?: string;
  namespace?: string;
  nodeIds?: string[];
  nodeType?: string;
  podName?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      clusterId: 'ClusterId',
      namespace: 'Namespace',
      nodeIds: 'NodeIds',
      nodeType: 'NodeType',
      podName: 'PodName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      clusterId: 'string',
      namespace: 'string',
      nodeIds: { 'type': 'array', 'itemType': 'string' },
      nodeType: 'string',
      podName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FindContainerNetworkConnectResponseBodyConnectsDstContainer extends $tea.Model {
  containerId?: string;
  static names(): { [key: string]: string } {
    return {
      containerId: 'ContainerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      containerId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FindContainerNetworkConnectResponseBodyConnectsSrcContainer extends $tea.Model {
  containerId?: string;
  static names(): { [key: string]: string } {
    return {
      containerId: 'ContainerId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      containerId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FindContainerNetworkConnectResponseBodyConnects extends $tea.Model {
  dstContainer?: FindContainerNetworkConnectResponseBodyConnectsDstContainer;
  dstIp?: string;
  dstPort?: string;
  firstTime?: number;
  id?: number;
  lastTime?: number;
  srcContainer?: FindContainerNetworkConnectResponseBodyConnectsSrcContainer;
  srcIp?: string;
  srcPort?: string;
  static names(): { [key: string]: string } {
    return {
      dstContainer: 'DstContainer',
      dstIp: 'DstIp',
      dstPort: 'DstPort',
      firstTime: 'FirstTime',
      id: 'Id',
      lastTime: 'LastTime',
      srcContainer: 'SrcContainer',
      srcIp: 'SrcIp',
      srcPort: 'SrcPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dstContainer: FindContainerNetworkConnectResponseBodyConnectsDstContainer,
      dstIp: 'string',
      dstPort: 'string',
      firstTime: 'number',
      id: 'number',
      lastTime: 'number',
      srcContainer: FindContainerNetworkConnectResponseBodyConnectsSrcContainer,
      srcIp: 'string',
      srcPort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FindContainerNetworkConnectResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAlarmMachineCountResponseBodyData extends $tea.Model {
  machineCount?: number;
  static names(): { [key: string]: string } {
    return {
      machineCount: 'MachineCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      machineCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppNetworkResponseBodyAppNetworkEdge extends $tea.Model {
  dstNodeId?: string;
  dstNodeType?: string;
  id?: string;
  port?: string;
  srcNodeId?: string;
  srcNodeType?: string;
  static names(): { [key: string]: string } {
    return {
      dstNodeId: 'DstNodeId',
      dstNodeType: 'DstNodeType',
      id: 'Id',
      port: 'Port',
      srcNodeId: 'SrcNodeId',
      srcNodeType: 'SrcNodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dstNodeId: 'string',
      dstNodeType: 'string',
      id: 'string',
      port: 'string',
      srcNodeId: 'string',
      srcNodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppNetworkResponseBodyAppNetworkNamespace extends $tea.Model {
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppNetworkResponseBodyAppNetworkNode extends $tea.Model {
  containerIds?: string[];
  id?: string;
  name?: string;
  namespaceId?: string;
  riskLevel?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      containerIds: 'ContainerIds',
      id: 'Id',
      name: 'Name',
      namespaceId: 'NamespaceId',
      riskLevel: 'RiskLevel',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      containerIds: { 'type': 'array', 'itemType': 'string' },
      id: 'string',
      name: 'string',
      namespaceId: 'string',
      riskLevel: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppNetworkResponseBodyAppNetwork extends $tea.Model {
  edge?: GetAppNetworkResponseBodyAppNetworkEdge[];
  namespace?: GetAppNetworkResponseBodyAppNetworkNamespace[];
  node?: GetAppNetworkResponseBodyAppNetworkNode[];
  static names(): { [key: string]: string } {
    return {
      edge: 'Edge',
      namespace: 'Namespace',
      node: 'Node',
    };
  }

  static types(): { [key: string]: any } {
    return {
      edge: { 'type': 'array', 'itemType': GetAppNetworkResponseBodyAppNetworkEdge },
      namespace: { 'type': 'array', 'itemType': GetAppNetworkResponseBodyAppNetworkNamespace },
      node: { 'type': 'array', 'itemType': GetAppNetworkResponseBodyAppNetworkNode },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetDetailByUuidResponseBodyAssetDetailDiskInfoList extends $tea.Model {
  diskName?: string;
  totalSize?: number;
  totalSizeByte?: number;
  useSize?: number;
  useSizeByte?: number;
  static names(): { [key: string]: string } {
    return {
      diskName: 'DiskName',
      totalSize: 'TotalSize',
      totalSizeByte: 'TotalSizeByte',
      useSize: 'UseSize',
      useSizeByte: 'UseSizeByte',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskName: 'string',
      totalSize: 'number',
      totalSizeByte: 'number',
      useSize: 'number',
      useSizeByte: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetDetailByUuidResponseBodyAssetDetail extends $tea.Model {
  assetType?: string;
  authModifyTime?: number;
  authVersion?: number;
  bind?: boolean;
  clientStatus?: string;
  clientVersion?: string;
  cpu?: number;
  cpuInfo?: string;
  createTime?: number;
  diskInfoList?: GetAssetDetailByUuidResponseBodyAssetDetailDiskInfoList[];
  flag?: number;
  groupTrace?: string;
  hostName?: string;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  ip?: string;
  ipList?: string[];
  kernel?: string;
  macList?: string[];
  mem?: number;
  memory?: number;
  os?: string;
  osDetail?: string;
  osName?: string;
  region?: string;
  regionId?: string;
  regionName?: string;
  sysInfo?: string;
  tag?: string;
  uuid?: string;
  vpcInstanceId?: string;
  static names(): { [key: string]: string } {
    return {
      assetType: 'AssetType',
      authModifyTime: 'AuthModifyTime',
      authVersion: 'AuthVersion',
      bind: 'Bind',
      clientStatus: 'ClientStatus',
      clientVersion: 'ClientVersion',
      cpu: 'Cpu',
      cpuInfo: 'CpuInfo',
      createTime: 'CreateTime',
      diskInfoList: 'DiskInfoList',
      flag: 'Flag',
      groupTrace: 'GroupTrace',
      hostName: 'HostName',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      ip: 'Ip',
      ipList: 'IpList',
      kernel: 'Kernel',
      macList: 'MacList',
      mem: 'Mem',
      memory: 'Memory',
      os: 'Os',
      osDetail: 'OsDetail',
      osName: 'OsName',
      region: 'Region',
      regionId: 'RegionId',
      regionName: 'RegionName',
      sysInfo: 'SysInfo',
      tag: 'Tag',
      uuid: 'Uuid',
      vpcInstanceId: 'VpcInstanceId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetType: 'string',
      authModifyTime: 'number',
      authVersion: 'number',
      bind: 'boolean',
      clientStatus: 'string',
      clientVersion: 'string',
      cpu: 'number',
      cpuInfo: 'string',
      createTime: 'number',
      diskInfoList: { 'type': 'array', 'itemType': GetAssetDetailByUuidResponseBodyAssetDetailDiskInfoList },
      flag: 'number',
      groupTrace: 'string',
      hostName: 'string',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      ip: 'string',
      ipList: { 'type': 'array', 'itemType': 'string' },
      kernel: 'string',
      macList: { 'type': 'array', 'itemType': 'string' },
      mem: 'number',
      memory: 'number',
      os: 'string',
      osDetail: 'string',
      osName: 'string',
      region: 'string',
      regionId: 'string',
      regionName: 'string',
      sysInfo: 'string',
      tag: 'string',
      uuid: 'string',
      vpcInstanceId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetSelectionConfigResponseBodyData extends $tea.Model {
  selectionKey?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      selectionKey: 'SelectionKey',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      selectionKey: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetsPropertyDetailRequestSearchCriteriaList extends $tea.Model {
  name?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetsPropertyDetailResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetsPropertyDetailResponseBodyPropertys extends $tea.Model {
  containerName?: string;
  createTimestamp?: number;
  domain?: string;
  filepath?: string;
  imageName?: string;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  ip?: string;
  listenProtocol?: string;
  moduleName?: string;
  path?: string;
  pathMode?: string;
  pid?: string;
  port?: string;
  processStarted?: number;
  regionId?: string;
  serverType?: string;
  size?: number;
  usedByCount?: number;
  user?: string;
  uuid?: string;
  webPath?: string;
  static names(): { [key: string]: string } {
    return {
      containerName: 'ContainerName',
      createTimestamp: 'CreateTimestamp',
      domain: 'Domain',
      filepath: 'Filepath',
      imageName: 'ImageName',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      ip: 'Ip',
      listenProtocol: 'ListenProtocol',
      moduleName: 'ModuleName',
      path: 'Path',
      pathMode: 'PathMode',
      pid: 'Pid',
      port: 'Port',
      processStarted: 'ProcessStarted',
      regionId: 'RegionId',
      serverType: 'ServerType',
      size: 'Size',
      usedByCount: 'UsedByCount',
      user: 'User',
      uuid: 'Uuid',
      webPath: 'WebPath',
    };
  }

  static types(): { [key: string]: any } {
    return {
      containerName: 'string',
      createTimestamp: 'number',
      domain: 'string',
      filepath: 'string',
      imageName: 'string',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      ip: 'string',
      listenProtocol: 'string',
      moduleName: 'string',
      path: 'string',
      pathMode: 'string',
      pid: 'string',
      port: 'string',
      processStarted: 'number',
      regionId: 'string',
      serverType: 'string',
      size: 'number',
      usedByCount: 'number',
      user: 'string',
      uuid: 'string',
      webPath: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetsPropertyItemResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAssetsPropertyItemResponseBodyPropertyItems extends $tea.Model {
  count?: number;
  domain?: string;
  moduleName?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      domain: 'Domain',
      moduleName: 'ModuleName',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      domain: 'string',
      moduleName: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAuthVersionStatisticResponseBodyStatistics extends $tea.Model {
  authVersion?: number;
  count?: number;
  static names(): { [key: string]: string } {
    return {
      authVersion: 'AuthVersion',
      count: 'Count',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authVersion: 'number',
      count: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBackupStorageCountResponseBodyBackupStorageCount extends $tea.Model {
  buyStorageByte?: number;
  ecsUsageStorageByte?: number;
  overflow?: number;
  uniUsageStorageByte?: number;
  usageStorageByte?: number;
  static names(): { [key: string]: string } {
    return {
      buyStorageByte: 'BuyStorageByte',
      ecsUsageStorageByte: 'EcsUsageStorageByte',
      overflow: 'Overflow',
      uniUsageStorageByte: 'UniUsageStorageByte',
      usageStorageByte: 'UsageStorageByte',
    };
  }

  static types(): { [key: string]: any } {
    return {
      buyStorageByte: 'number',
      ecsUsageStorageByte: 'number',
      overflow: 'number',
      uniUsageStorageByte: 'number',
      usageStorageByte: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckConfigResponseBodySelectedChecks extends $tea.Model {
  checkId?: number;
  sectionId?: number;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      sectionId: 'SectionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      sectionId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckConfigResponseBodyStandards extends $tea.Model {
  id?: number;
  showName?: string;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      showName: 'ShowName',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      showName: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckDetailResponseBodyAssistInfo extends $tea.Model {
  link?: string;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      link: 'Link',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      link: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckDetailResponseBodyCustomConfigs extends $tea.Model {
  defaultValue?: string;
  name?: string;
  showName?: string;
  typeDefine?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      name: 'Name',
      showName: 'ShowName',
      typeDefine: 'TypeDefine',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'string',
      name: 'string',
      showName: 'string',
      typeDefine: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckDetailResponseBodyDescription extends $tea.Model {
  link?: string;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      link: 'Link',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      link: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckDetailResponseBodySolution extends $tea.Model {
  link?: string;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      link: 'Link',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      link: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRiskStatisticsResponseBodyDataSubStatistics extends $tea.Model {
  alias?: string;
  highWarningCount?: number;
  lowWarningCount?: number;
  mediumWarningCount?: number;
  passCount?: number;
  totalCount?: number;
  typeName?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      highWarningCount: 'HighWarningCount',
      lowWarningCount: 'LowWarningCount',
      mediumWarningCount: 'MediumWarningCount',
      passCount: 'PassCount',
      totalCount: 'TotalCount',
      typeName: 'TypeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      highWarningCount: 'number',
      lowWarningCount: 'number',
      mediumWarningCount: 'number',
      passCount: 'number',
      totalCount: 'number',
      typeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckRiskStatisticsResponseBodyData extends $tea.Model {
  highWarningCount?: number;
  lowWarningCount?: number;
  mediumWarningCount?: number;
  passCount?: number;
  sceneName?: string;
  subStatistics?: GetCheckRiskStatisticsResponseBodyDataSubStatistics[];
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      highWarningCount: 'HighWarningCount',
      lowWarningCount: 'LowWarningCount',
      mediumWarningCount: 'MediumWarningCount',
      passCount: 'PassCount',
      sceneName: 'SceneName',
      subStatistics: 'SubStatistics',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      highWarningCount: 'number',
      lowWarningCount: 'number',
      mediumWarningCount: 'number',
      passCount: 'number',
      sceneName: 'string',
      subStatistics: { 'type': 'array', 'itemType': GetCheckRiskStatisticsResponseBodyDataSubStatistics },
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckSaleResponseBodyCheckSale extends $tea.Model {
  consumeCount?: number;
  loyalUser?: boolean;
  purchaseCount?: number;
  saleUserType?: number;
  static names(): { [key: string]: string } {
    return {
      consumeCount: 'ConsumeCount',
      loyalUser: 'LoyalUser',
      purchaseCount: 'PurchaseCount',
      saleUserType: 'SaleUserType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consumeCount: 'number',
      loyalUser: 'boolean',
      purchaseCount: 'number',
      saleUserType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckSummaryResponseBodySummarysStandards extends $tea.Model {
  failCount?: number;
  id?: number;
  passCount?: number;
  riskLevelHighCount?: number;
  riskLevelLowCount?: number;
  riskLevelMediumCount?: number;
  showName?: string;
  static names(): { [key: string]: string } {
    return {
      failCount: 'FailCount',
      id: 'Id',
      passCount: 'PassCount',
      riskLevelHighCount: 'RiskLevelHighCount',
      riskLevelLowCount: 'RiskLevelLowCount',
      riskLevelMediumCount: 'RiskLevelMediumCount',
      showName: 'ShowName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failCount: 'number',
      id: 'number',
      passCount: 'number',
      riskLevelHighCount: 'number',
      riskLevelLowCount: 'number',
      riskLevelMediumCount: 'number',
      showName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCheckSummaryResponseBodySummarys extends $tea.Model {
  failCount?: number;
  passCount?: number;
  standards?: GetCheckSummaryResponseBodySummarysStandards[];
  type?: string;
  static names(): { [key: string]: string } {
    return {
      failCount: 'FailCount',
      passCount: 'PassCount',
      standards: 'Standards',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failCount: 'number',
      passCount: 'number',
      standards: { 'type': 'array', 'itemType': GetCheckSummaryResponseBodySummarysStandards },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientInstallationStatisticResponseBodyClientInstallRatioCurrentItemsItems extends $tea.Model {
  assetTotalCount?: number;
  calculateTime?: number;
  installRatio?: number;
  installedAssetCount?: number;
  static names(): { [key: string]: string } {
    return {
      assetTotalCount: 'AssetTotalCount',
      calculateTime: 'CalculateTime',
      installRatio: 'InstallRatio',
      installedAssetCount: 'InstalledAssetCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetTotalCount: 'number',
      calculateTime: 'number',
      installRatio: 'number',
      installedAssetCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientInstallationStatisticResponseBodyClientInstallRatioCurrentItems extends $tea.Model {
  items?: GetClientInstallationStatisticResponseBodyClientInstallRatioCurrentItemsItems[];
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': GetClientInstallationStatisticResponseBodyClientInstallRatioCurrentItemsItems },
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientInstallationStatisticResponseBodyClientInstallRatioHistoryItemsItems extends $tea.Model {
  assetTotalCount?: number;
  calculateTime?: number;
  installRatio?: number;
  installedAssetCount?: number;
  static names(): { [key: string]: string } {
    return {
      assetTotalCount: 'AssetTotalCount',
      calculateTime: 'CalculateTime',
      installRatio: 'InstallRatio',
      installedAssetCount: 'InstalledAssetCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetTotalCount: 'number',
      calculateTime: 'number',
      installRatio: 'number',
      installedAssetCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientInstallationStatisticResponseBodyClientInstallRatioHistoryItems extends $tea.Model {
  items?: GetClientInstallationStatisticResponseBodyClientInstallRatioHistoryItemsItems[];
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': GetClientInstallationStatisticResponseBodyClientInstallRatioHistoryItemsItems },
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientInstallationStatisticResponseBodyClientInstallRatio extends $tea.Model {
  currentItems?: GetClientInstallationStatisticResponseBodyClientInstallRatioCurrentItems[];
  dates?: number[];
  historyItems?: GetClientInstallationStatisticResponseBodyClientInstallRatioHistoryItems[];
  static names(): { [key: string]: string } {
    return {
      currentItems: 'CurrentItems',
      dates: 'Dates',
      historyItems: 'HistoryItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentItems: { 'type': 'array', 'itemType': GetClientInstallationStatisticResponseBodyClientInstallRatioCurrentItems },
      dates: { 'type': 'array', 'itemType': 'number' },
      historyItems: { 'type': 'array', 'itemType': GetClientInstallationStatisticResponseBodyClientInstallRatioHistoryItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientRatioStatisticResponseBodyClientInstallRatioCurrentItemsItems extends $tea.Model {
  assetTotalCount?: number;
  calculateTime?: number;
  installRatio?: number;
  installedAssetCount?: number;
  static names(): { [key: string]: string } {
    return {
      assetTotalCount: 'AssetTotalCount',
      calculateTime: 'CalculateTime',
      installRatio: 'InstallRatio',
      installedAssetCount: 'InstalledAssetCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetTotalCount: 'number',
      calculateTime: 'number',
      installRatio: 'number',
      installedAssetCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientRatioStatisticResponseBodyClientInstallRatioCurrentItems extends $tea.Model {
  items?: GetClientRatioStatisticResponseBodyClientInstallRatioCurrentItemsItems[];
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': GetClientRatioStatisticResponseBodyClientInstallRatioCurrentItemsItems },
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientRatioStatisticResponseBodyClientInstallRatioHistoryItemsItems extends $tea.Model {
  assetTotalCount?: number;
  calculateTime?: number;
  installRatio?: number;
  installedAssetCount?: number;
  static names(): { [key: string]: string } {
    return {
      assetTotalCount: 'AssetTotalCount',
      calculateTime: 'CalculateTime',
      installRatio: 'InstallRatio',
      installedAssetCount: 'InstalledAssetCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetTotalCount: 'number',
      calculateTime: 'number',
      installRatio: 'number',
      installedAssetCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientRatioStatisticResponseBodyClientInstallRatioHistoryItems extends $tea.Model {
  items?: GetClientRatioStatisticResponseBodyClientInstallRatioHistoryItemsItems[];
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': GetClientRatioStatisticResponseBodyClientInstallRatioHistoryItemsItems },
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientRatioStatisticResponseBodyClientInstallRatio extends $tea.Model {
  currentItems?: GetClientRatioStatisticResponseBodyClientInstallRatioCurrentItems[];
  historyItems?: GetClientRatioStatisticResponseBodyClientInstallRatioHistoryItems[];
  static names(): { [key: string]: string } {
    return {
      currentItems: 'CurrentItems',
      historyItems: 'HistoryItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentItems: { 'type': 'array', 'itemType': GetClientRatioStatisticResponseBodyClientInstallRatioCurrentItems },
      historyItems: { 'type': 'array', 'itemType': GetClientRatioStatisticResponseBodyClientInstallRatioHistoryItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientRatioStatisticResponseBodyClientOnlineRatioCurrentItemsItems extends $tea.Model {
  assetInstallCount?: number;
  calculateTime?: number;
  onlineAssetCount?: number;
  onlineRatio?: number;
  static names(): { [key: string]: string } {
    return {
      assetInstallCount: 'AssetInstallCount',
      calculateTime: 'CalculateTime',
      onlineAssetCount: 'OnlineAssetCount',
      onlineRatio: 'OnlineRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetInstallCount: 'number',
      calculateTime: 'number',
      onlineAssetCount: 'number',
      onlineRatio: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientRatioStatisticResponseBodyClientOnlineRatioCurrentItems extends $tea.Model {
  items?: GetClientRatioStatisticResponseBodyClientOnlineRatioCurrentItemsItems[];
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': GetClientRatioStatisticResponseBodyClientOnlineRatioCurrentItemsItems },
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientRatioStatisticResponseBodyClientOnlineRatioHistoryItemsItems extends $tea.Model {
  assetInstallCount?: number;
  calculateTime?: number;
  onlineAssetCount?: number;
  onlineRatio?: number;
  static names(): { [key: string]: string } {
    return {
      assetInstallCount: 'AssetInstallCount',
      calculateTime: 'CalculateTime',
      onlineAssetCount: 'OnlineAssetCount',
      onlineRatio: 'OnlineRatio',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetInstallCount: 'number',
      calculateTime: 'number',
      onlineAssetCount: 'number',
      onlineRatio: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientRatioStatisticResponseBodyClientOnlineRatioHistoryItems extends $tea.Model {
  items?: GetClientRatioStatisticResponseBodyClientOnlineRatioHistoryItemsItems[];
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      items: 'Items',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      items: { 'type': 'array', 'itemType': GetClientRatioStatisticResponseBodyClientOnlineRatioHistoryItemsItems },
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientRatioStatisticResponseBodyClientOnlineRatio extends $tea.Model {
  currentItems?: GetClientRatioStatisticResponseBodyClientOnlineRatioCurrentItems[];
  historyItems?: GetClientRatioStatisticResponseBodyClientOnlineRatioHistoryItems[];
  static names(): { [key: string]: string } {
    return {
      currentItems: 'CurrentItems',
      historyItems: 'HistoryItems',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentItems: { 'type': 'array', 'itemType': GetClientRatioStatisticResponseBodyClientOnlineRatioCurrentItems },
      historyItems: { 'type': 'array', 'itemType': GetClientRatioStatisticResponseBodyClientOnlineRatioHistoryItems },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClientUserDefineRuleResponseBodyUserDefineRuleDetail extends $tea.Model {
  actionType?: string;
  cmdline?: string;
  filePath?: string;
  gmtCreate?: number;
  gmtModified?: number;
  IP?: string;
  id?: number;
  md5List?: string;
  name?: string;
  newFilePath?: string;
  parentCmdline?: string;
  parentProcPath?: string;
  platform?: string;
  port?: number;
  portStr?: string;
  procPath?: string;
  registryContent?: string;
  registryKey?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      actionType: 'ActionType',
      cmdline: 'Cmdline',
      filePath: 'FilePath',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      IP: 'IP',
      id: 'Id',
      md5List: 'Md5List',
      name: 'Name',
      newFilePath: 'NewFilePath',
      parentCmdline: 'ParentCmdline',
      parentProcPath: 'ParentProcPath',
      platform: 'Platform',
      port: 'Port',
      portStr: 'PortStr',
      procPath: 'ProcPath',
      registryContent: 'RegistryContent',
      registryKey: 'RegistryKey',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionType: 'string',
      cmdline: 'string',
      filePath: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      IP: 'string',
      id: 'number',
      md5List: 'string',
      name: 'string',
      newFilePath: 'string',
      parentCmdline: 'string',
      parentProcPath: 'string',
      platform: 'string',
      port: 'number',
      portStr: 'string',
      procPath: 'string',
      registryContent: 'string',
      registryKey: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetCriteriaRequestCloudAssetTypes extends $tea.Model {
  assetSubType?: number;
  assetType?: number;
  static names(): { [key: string]: string } {
    return {
      assetSubType: 'AssetSubType',
      assetType: 'AssetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetSubType: 'number',
      assetType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetCriteriaResponseBodyCriteriaList extends $tea.Model {
  multiValues?: string;
  name?: string;
  type?: string;
  values?: string;
  static names(): { [key: string]: string } {
    return {
      multiValues: 'MultiValues',
      name: 'Name',
      type: 'Type',
      values: 'Values',
    };
  }

  static types(): { [key: string]: any } {
    return {
      multiValues: 'string',
      name: 'string',
      type: 'string',
      values: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetDetailRequestCloudAssetInstances extends $tea.Model {
  instanceId?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetDetailResponseBodyInstances extends $tea.Model {
  alarmStatus?: string;
  assetSubType?: number;
  assetSubTypeName?: string;
  assetType?: number;
  assetTypeName?: string;
  createdTime?: number;
  detailLink?: string;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  regionId?: string;
  riskStatus?: string;
  securityInfo?: string;
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      alarmStatus: 'AlarmStatus',
      assetSubType: 'AssetSubType',
      assetSubTypeName: 'AssetSubTypeName',
      assetType: 'AssetType',
      assetTypeName: 'AssetTypeName',
      createdTime: 'CreatedTime',
      detailLink: 'DetailLink',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      regionId: 'RegionId',
      riskStatus: 'RiskStatus',
      securityInfo: 'SecurityInfo',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmStatus: 'string',
      assetSubType: 'number',
      assetSubTypeName: 'string',
      assetType: 'number',
      assetTypeName: 'string',
      createdTime: 'number',
      detailLink: 'string',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      regionId: 'string',
      riskStatus: 'string',
      securityInfo: 'string',
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas extends $tea.Model {
  assetSubType?: number;
  assetType?: number;
  instanceCount?: number;
  instanceRiskCount?: number;
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      assetSubType: 'AssetSubType',
      assetType: 'AssetType',
      instanceCount: 'InstanceCount',
      instanceRiskCount: 'InstanceRiskCount',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetSubType: 'number',
      assetType: 'number',
      instanceCount: 'number',
      instanceRiskCount: 'number',
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCloudAssetSummaryResponseBodyGroupedFields extends $tea.Model {
  cloudAssetSummaryMetas?: GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas[];
  instanceCountTotal?: number;
  instanceRiskCountTotal?: number;
  static names(): { [key: string]: string } {
    return {
      cloudAssetSummaryMetas: 'CloudAssetSummaryMetas',
      instanceCountTotal: 'InstanceCountTotal',
      instanceRiskCountTotal: 'InstanceRiskCountTotal',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cloudAssetSummaryMetas: { 'type': 'array', 'itemType': GetCloudAssetSummaryResponseBodyGroupedFieldsCloudAssetSummaryMetas },
      instanceCountTotal: 'number',
      instanceRiskCountTotal: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterCheckItemWarningStatisticsResponseBodyData extends $tea.Model {
  highWarningCount?: number;
  lowWarningCount?: number;
  mediumWarningCount?: number;
  static names(): { [key: string]: string } {
    return {
      highWarningCount: 'HighWarningCount',
      lowWarningCount: 'LowWarningCount',
      mediumWarningCount: 'MediumWarningCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      highWarningCount: 'number',
      lowWarningCount: 'number',
      mediumWarningCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterRuleSummaryResponseBodyClusterRuleSummary extends $tea.Model {
  closeRuleCount?: number;
  interceptionCount7Day?: number;
  interceptionSwitch?: number;
  interceptionType?: number;
  openRuleCount?: number;
  ruleCount?: number;
  suggestRuleCount?: number;
  static names(): { [key: string]: string } {
    return {
      closeRuleCount: 'CloseRuleCount',
      interceptionCount7Day: 'InterceptionCount7Day',
      interceptionSwitch: 'InterceptionSwitch',
      interceptionType: 'InterceptionType',
      openRuleCount: 'OpenRuleCount',
      ruleCount: 'RuleCount',
      suggestRuleCount: 'SuggestRuleCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      closeRuleCount: 'number',
      interceptionCount7Day: 'number',
      interceptionSwitch: 'number',
      interceptionType: 'number',
      openRuleCount: 'number',
      ruleCount: 'number',
      suggestRuleCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetClusterSuspEventStatisticsResponseBodySuspStatistics extends $tea.Model {
  remind?: number;
  serious?: number;
  suspicious?: number;
  static names(): { [key: string]: string } {
    return {
      remind: 'Remind',
      serious: 'Serious',
      suspicious: 'Suspicious',
    };
  }

  static types(): { [key: string]: any } {
    return {
      remind: 'number',
      serious: 'number',
      suspicious: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetCommonSwitchConfigResponseBodyData extends $tea.Model {
  targetDefault?: string;
  targetSyncStatus?: string;
  static names(): { [key: string]: string } {
    return {
      targetDefault: 'TargetDefault',
      targetSyncStatus: 'TargetSyncStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetDefault: 'string',
      targetSyncStatus: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetContainerDefenseRuleDetailResponseBodyDataScope extends $tea.Model {
  allNamespace?: number;
  clusterId?: string;
  namespaces?: string[];
  static names(): { [key: string]: string } {
    return {
      allNamespace: 'AllNamespace',
      clusterId: 'ClusterId',
      namespaces: 'Namespaces',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allNamespace: 'number',
      clusterId: 'string',
      namespaces: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetContainerDefenseRuleDetailResponseBodyDataWhitelist extends $tea.Model {
  hash?: string[];
  image?: string[];
  path?: string[];
  static names(): { [key: string]: string } {
    return {
      hash: 'Hash',
      image: 'Image',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      hash: { 'type': 'array', 'itemType': 'string' },
      image: { 'type': 'array', 'itemType': 'string' },
      path: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetContainerDefenseRuleDetailResponseBodyData extends $tea.Model {
  aliUid?: number;
  description?: string;
  eventName?: string;
  eventType?: string;
  id?: number;
  ruleAction?: number;
  ruleName?: string;
  ruleSwitch?: number;
  ruleType?: string;
  scope?: GetContainerDefenseRuleDetailResponseBodyDataScope[];
  whitelist?: GetContainerDefenseRuleDetailResponseBodyDataWhitelist;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      description: 'Description',
      eventName: 'EventName',
      eventType: 'EventType',
      id: 'Id',
      ruleAction: 'RuleAction',
      ruleName: 'RuleName',
      ruleSwitch: 'RuleSwitch',
      ruleType: 'RuleType',
      scope: 'Scope',
      whitelist: 'Whitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'number',
      description: 'string',
      eventName: 'string',
      eventType: 'string',
      id: 'number',
      ruleAction: 'number',
      ruleName: 'string',
      ruleSwitch: 'number',
      ruleType: 'string',
      scope: { 'type': 'array', 'itemType': GetContainerDefenseRuleDetailResponseBodyDataScope },
      whitelist: GetContainerDefenseRuleDetailResponseBodyDataWhitelist,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDetectApiInvokeInfoResponseBodyData extends $tea.Model {
  authCount?: number;
  expire?: number;
  flowRate?: number;
  remainAuthCount?: number;
  saleVersion?: number;
  timeUnit?: string;
  static names(): { [key: string]: string } {
    return {
      authCount: 'AuthCount',
      expire: 'Expire',
      flowRate: 'FlowRate',
      remainAuthCount: 'RemainAuthCount',
      saleVersion: 'SaleVersion',
      timeUnit: 'TimeUnit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authCount: 'number',
      expire: 'number',
      flowRate: 'number',
      remainAuthCount: 'number',
      saleVersion: 'number',
      timeUnit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDetectReportResponseBodyData extends $tea.Model {
  basic?: string;
  fileHash?: string;
  filename?: string;
  hasData?: boolean;
  intelligences?: string;
  sandbox?: string;
  showTab?: boolean;
  threatLevel?: number;
  threatTypes?: string;
  static names(): { [key: string]: string } {
    return {
      basic: 'Basic',
      fileHash: 'FileHash',
      filename: 'Filename',
      hasData: 'HasData',
      intelligences: 'Intelligences',
      sandbox: 'Sandbox',
      showTab: 'ShowTab',
      threatLevel: 'ThreatLevel',
      threatTypes: 'ThreatTypes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      basic: 'string',
      fileHash: 'string',
      filename: 'string',
      hasData: 'boolean',
      intelligences: 'string',
      sandbox: 'string',
      showTab: 'boolean',
      threatLevel: 'number',
      threatTypes: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileDetectResultResponseBodyResultList extends $tea.Model {
  code?: string;
  ext?: string;
  hashKey?: string;
  message?: string;
  result?: number;
  score?: number;
  virusType?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      ext: 'Ext',
      hashKey: 'HashKey',
      message: 'Message',
      result: 'Result',
      score: 'Score',
      virusType: 'VirusType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      ext: 'string',
      hashKey: 'string',
      message: 'string',
      result: 'number',
      score: 'number',
      virusType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectDashboardResponseBodyData extends $tea.Model {
  enableRuleCount?: number;
  pluginCount?: number;
  pluginOfflineCount?: number;
  pluginOnlineCount?: number;
  static names(): { [key: string]: string } {
    return {
      enableRuleCount: 'EnableRuleCount',
      pluginCount: 'PluginCount',
      pluginOfflineCount: 'PluginOfflineCount',
      pluginOnlineCount: 'PluginOnlineCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enableRuleCount: 'number',
      pluginCount: 'number',
      pluginOfflineCount: 'number',
      pluginOnlineCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectEventResponseBodyData extends $tea.Model {
  alertLevel?: number;
  cmdLine?: string;
  filePath?: string;
  filePermission?: string;
  firstTime?: number;
  handleTime?: number;
  id?: number;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  latestTime?: number;
  operation?: string;
  procPath?: string;
  processId?: string;
  remark?: string;
  ruleName?: string;
  status?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      alertLevel: 'AlertLevel',
      cmdLine: 'CmdLine',
      filePath: 'FilePath',
      filePermission: 'FilePermission',
      firstTime: 'FirstTime',
      handleTime: 'HandleTime',
      id: 'Id',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      latestTime: 'LatestTime',
      operation: 'Operation',
      procPath: 'ProcPath',
      processId: 'ProcessId',
      remark: 'Remark',
      ruleName: 'RuleName',
      status: 'Status',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertLevel: 'number',
      cmdLine: 'string',
      filePath: 'string',
      filePermission: 'string',
      firstTime: 'number',
      handleTime: 'number',
      id: 'number',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      latestTime: 'number',
      operation: 'string',
      procPath: 'string',
      processId: 'string',
      remark: 'string',
      ruleName: 'string',
      status: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileProtectRuleResponseBodyData extends $tea.Model {
  action?: string;
  alertLevel?: number;
  fileOps?: string[];
  filePaths?: string[];
  id?: number;
  procPaths?: string[];
  ruleName?: string;
  status?: number;
  switchId?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      alertLevel: 'AlertLevel',
      fileOps: 'FileOps',
      filePaths: 'FilePaths',
      id: 'Id',
      procPaths: 'ProcPaths',
      ruleName: 'RuleName',
      status: 'Status',
      switchId: 'SwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      alertLevel: 'number',
      fileOps: { 'type': 'array', 'itemType': 'string' },
      filePaths: { 'type': 'array', 'itemType': 'string' },
      id: 'number',
      procPaths: { 'type': 'array', 'itemType': 'string' },
      ruleName: 'string',
      status: 'number',
      switchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetFileUploadLimitResponseBodyData extends $tea.Model {
  limit?: string;
  static names(): { [key: string]: string } {
    return {
      limit: 'Limit',
    };
  }

  static types(): { [key: string]: any } {
    return {
      limit: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotAttackStatisticsResponseBodyDataHoneypotAttackStatistics extends $tea.Model {
  statisticsCount?: number;
  statisticsValue?: string;
  static names(): { [key: string]: string } {
    return {
      statisticsCount: 'StatisticsCount',
      statisticsValue: 'StatisticsValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      statisticsCount: 'number',
      statisticsValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotAttackStatisticsResponseBodyData extends $tea.Model {
  count?: number;
  honeypotAttackStatistics?: GetHoneypotAttackStatisticsResponseBodyDataHoneypotAttackStatistics[];
  statisticsType?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      honeypotAttackStatistics: 'HoneypotAttackStatistics',
      statisticsType: 'StatisticsType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      honeypotAttackStatistics: { 'type': 'array', 'itemType': GetHoneypotAttackStatisticsResponseBodyDataHoneypotAttackStatistics },
      statisticsType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotEventTrendResponseBodyData extends $tea.Model {
  count?: number;
  keyName?: string;
  timeStamp?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      keyName: 'KeyName',
      timeStamp: 'TimeStamp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      keyName: 'string',
      timeStamp: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotNodeResponseBodyHoneypotNode extends $tea.Model {
  allowHoneypotAccessInternet?: boolean;
  createTime?: string;
  ecsInstanceId?: string;
  honeypotTotalCount?: number;
  honeypotUsedCount?: number;
  nodeId?: string;
  nodeIp?: string;
  nodeName?: string;
  probeTotalCount?: number;
  probeUsedCount?: number;
  securityGroupProbeIpList?: string[];
  totalStatus?: number;
  upgradeAvailable?: boolean;
  static names(): { [key: string]: string } {
    return {
      allowHoneypotAccessInternet: 'AllowHoneypotAccessInternet',
      createTime: 'CreateTime',
      ecsInstanceId: 'EcsInstanceId',
      honeypotTotalCount: 'HoneypotTotalCount',
      honeypotUsedCount: 'HoneypotUsedCount',
      nodeId: 'NodeId',
      nodeIp: 'NodeIp',
      nodeName: 'NodeName',
      probeTotalCount: 'ProbeTotalCount',
      probeUsedCount: 'ProbeUsedCount',
      securityGroupProbeIpList: 'SecurityGroupProbeIpList',
      totalStatus: 'TotalStatus',
      upgradeAvailable: 'UpgradeAvailable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowHoneypotAccessInternet: 'boolean',
      createTime: 'string',
      ecsInstanceId: 'string',
      honeypotTotalCount: 'number',
      honeypotUsedCount: 'number',
      nodeId: 'string',
      nodeIp: 'string',
      nodeName: 'string',
      probeTotalCount: 'number',
      probeUsedCount: 'number',
      securityGroupProbeIpList: { 'type': 'array', 'itemType': 'string' },
      totalStatus: 'number',
      upgradeAvailable: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotPresetResponseBodyDataFileInfoList extends $tea.Model {
  fileId?: string;
  fileName?: string;
  ossUrl?: string;
  static names(): { [key: string]: string } {
    return {
      fileId: 'FileId',
      fileName: 'FileName',
      ossUrl: 'OssUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fileId: 'string',
      fileName: 'string',
      ossUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotPresetResponseBodyData extends $tea.Model {
  controlNodeName?: string;
  fileInfoList?: GetHoneypotPresetResponseBodyDataFileInfoList[];
  honeypotImageDisplayName?: string;
  honeypotImageName?: string;
  honeypotPresetId?: string;
  meta?: string;
  nodeId?: string;
  presetName?: string;
  presetType?: string;
  static names(): { [key: string]: string } {
    return {
      controlNodeName: 'ControlNodeName',
      fileInfoList: 'FileInfoList',
      honeypotImageDisplayName: 'HoneypotImageDisplayName',
      honeypotImageName: 'HoneypotImageName',
      honeypotPresetId: 'HoneypotPresetId',
      meta: 'Meta',
      nodeId: 'NodeId',
      presetName: 'PresetName',
      presetType: 'PresetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      controlNodeName: 'string',
      fileInfoList: { 'type': 'array', 'itemType': GetHoneypotPresetResponseBodyDataFileInfoList },
      honeypotImageDisplayName: 'string',
      honeypotImageName: 'string',
      honeypotPresetId: 'string',
      meta: 'string',
      nodeId: 'string',
      presetName: 'string',
      presetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotProbeResponseBodyDataControlNode extends $tea.Model {
  ecsInstanceId?: string;
  nodeId?: string;
  nodeName?: string;
  static names(): { [key: string]: string } {
    return {
      ecsInstanceId: 'EcsInstanceId',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ecsInstanceId: 'string',
      nodeId: 'string',
      nodeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort extends $tea.Model {
  id?: number;
  ports?: string;
  probeId?: string;
  serviceIpList?: string[];
  status?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      ports: 'Ports',
      probeId: 'ProbeId',
      serviceIpList: 'ServiceIpList',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      ports: 'string',
      probeId: 'string',
      serviceIpList: { 'type': 'array', 'itemType': 'string' },
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList extends $tea.Model {
  bindPort?: boolean;
  endPort?: number;
  err?: string;
  fixed?: boolean;
  id?: number;
  msg?: string;
  proto?: string;
  startPort?: number;
  status?: number;
  targetPort?: number;
  static names(): { [key: string]: string } {
    return {
      bindPort: 'BindPort',
      endPort: 'EndPort',
      err: 'Err',
      fixed: 'Fixed',
      id: 'Id',
      msg: 'Msg',
      proto: 'Proto',
      startPort: 'StartPort',
      status: 'Status',
      targetPort: 'TargetPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindPort: 'boolean',
      endPort: 'number',
      err: 'string',
      fixed: 'boolean',
      id: 'number',
      msg: 'string',
      proto: 'string',
      startPort: 'number',
      status: 'number',
      targetPort: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotProbeResponseBodyDataHoneypotProbeBindList extends $tea.Model {
  bindId?: string;
  bindPortList?: GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList[];
  honeypotId?: string;
  serviceIpList?: string[];
  status?: number;
  static names(): { [key: string]: string } {
    return {
      bindId: 'BindId',
      bindPortList: 'BindPortList',
      honeypotId: 'HoneypotId',
      serviceIpList: 'ServiceIpList',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindId: 'string',
      bindPortList: { 'type': 'array', 'itemType': GetHoneypotProbeResponseBodyDataHoneypotProbeBindListBindPortList },
      honeypotId: 'string',
      serviceIpList: { 'type': 'array', 'itemType': 'string' },
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotProbeResponseBodyData extends $tea.Model {
  arp?: boolean;
  canListenIpList?: string[];
  cidrList?: string[];
  controlNode?: GetHoneypotProbeResponseBodyDataControlNode;
  cpuLoad?: number;
  deployTime?: number;
  displayName?: string;
  honeyPotProbeScanPort?: GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort;
  honeypotProbeBindList?: GetHoneypotProbeResponseBodyDataHoneypotProbeBindList[];
  hostIp?: string;
  listenIpList?: string[];
  memoryLoad?: number;
  osType?: string;
  ping?: boolean;
  probeId?: string;
  probeType?: string;
  probeVersion?: string;
  proxyIp?: string;
  status?: number;
  uuid?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      arp: 'Arp',
      canListenIpList: 'CanListenIpList',
      cidrList: 'CidrList',
      controlNode: 'ControlNode',
      cpuLoad: 'CpuLoad',
      deployTime: 'DeployTime',
      displayName: 'DisplayName',
      honeyPotProbeScanPort: 'HoneyPotProbeScanPort',
      honeypotProbeBindList: 'HoneypotProbeBindList',
      hostIp: 'HostIp',
      listenIpList: 'ListenIpList',
      memoryLoad: 'MemoryLoad',
      osType: 'OsType',
      ping: 'Ping',
      probeId: 'ProbeId',
      probeType: 'ProbeType',
      probeVersion: 'ProbeVersion',
      proxyIp: 'ProxyIp',
      status: 'Status',
      uuid: 'Uuid',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      arp: 'boolean',
      canListenIpList: { 'type': 'array', 'itemType': 'string' },
      cidrList: { 'type': 'array', 'itemType': 'string' },
      controlNode: GetHoneypotProbeResponseBodyDataControlNode,
      cpuLoad: 'number',
      deployTime: 'number',
      displayName: 'string',
      honeyPotProbeScanPort: GetHoneypotProbeResponseBodyDataHoneyPotProbeScanPort,
      honeypotProbeBindList: { 'type': 'array', 'itemType': GetHoneypotProbeResponseBodyDataHoneypotProbeBindList },
      hostIp: 'string',
      listenIpList: { 'type': 'array', 'itemType': 'string' },
      memoryLoad: 'number',
      osType: 'string',
      ping: 'boolean',
      probeId: 'string',
      probeType: 'string',
      probeVersion: 'string',
      proxyIp: 'string',
      status: 'number',
      uuid: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetHoneypotStatisticsResponseBodyData extends $tea.Model {
  totalHoneypotCount?: number;
  totalNodeStatus?: number;
  totalProbeCount?: number;
  usedHoneypotCount?: number;
  usedHostProbeCount?: number;
  usedProbeCount?: number;
  usedVpcProbeCount?: number;
  static names(): { [key: string]: string } {
    return {
      totalHoneypotCount: 'TotalHoneypotCount',
      totalNodeStatus: 'TotalNodeStatus',
      totalProbeCount: 'TotalProbeCount',
      usedHoneypotCount: 'UsedHoneypotCount',
      usedHostProbeCount: 'UsedHostProbeCount',
      usedProbeCount: 'UsedProbeCount',
      usedVpcProbeCount: 'UsedVpcProbeCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      totalHoneypotCount: 'number',
      totalNodeStatus: 'number',
      totalProbeCount: 'number',
      usedHoneypotCount: 'number',
      usedHostProbeCount: 'number',
      usedProbeCount: 'number',
      usedVpcProbeCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageEventOperationResponseBodyData extends $tea.Model {
  conditions?: string;
  eventKey?: string;
  eventName?: string;
  eventType?: string;
  id?: number;
  operationCode?: string;
  scenarios?: string;
  static names(): { [key: string]: string } {
    return {
      conditions: 'Conditions',
      eventKey: 'EventKey',
      eventName: 'EventName',
      eventType: 'EventType',
      id: 'Id',
      operationCode: 'OperationCode',
      scenarios: 'Scenarios',
    };
  }

  static types(): { [key: string]: any } {
    return {
      conditions: 'string',
      eventKey: 'string',
      eventName: 'string',
      eventType: 'string',
      id: 'number',
      operationCode: 'string',
      scenarios: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetImageScanNumInPeriodResponseBodyImageScanData extends $tea.Model {
  imageScanCount?: number;
  static names(): { [key: string]: string } {
    return {
      imageScanCount: 'ImageScanCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageScanCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailDstTarget extends $tea.Model {
  appName?: string;
  imageList?: string[];
  namespace?: string;
  ports?: string[];
  ruleType?: string;
  tagList?: string[];
  targetId?: number;
  targetName?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      imageList: 'ImageList',
      namespace: 'Namespace',
      ports: 'Ports',
      ruleType: 'RuleType',
      tagList: 'TagList',
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      imageList: { 'type': 'array', 'itemType': 'string' },
      namespace: 'string',
      ports: { 'type': 'array', 'itemType': 'string' },
      ruleType: 'string',
      tagList: { 'type': 'array', 'itemType': 'string' },
      targetId: 'number',
      targetName: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailSrcTarget extends $tea.Model {
  appName?: string;
  imageList?: string[];
  namespace?: string;
  ruleType?: string;
  tagList?: string[];
  targetId?: number;
  targetName?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      imageList: 'ImageList',
      namespace: 'Namespace',
      ruleType: 'RuleType',
      tagList: 'TagList',
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      imageList: { 'type': 'array', 'itemType': 'string' },
      namespace: 'string',
      ruleType: 'string',
      tagList: { 'type': 'array', 'itemType': 'string' },
      targetId: 'number',
      targetName: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionRuleDetailResponseBodyInterceptionRuleDetail extends $tea.Model {
  dstTarget?: GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailDstTarget;
  interceptType?: number;
  orderIndex?: number;
  ruleId?: number;
  ruleName?: string;
  ruleSwitch?: number;
  ruleType?: string;
  srcTarget?: GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailSrcTarget;
  static names(): { [key: string]: string } {
    return {
      dstTarget: 'DstTarget',
      interceptType: 'InterceptType',
      orderIndex: 'OrderIndex',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleSwitch: 'RuleSwitch',
      ruleType: 'RuleType',
      srcTarget: 'SrcTarget',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dstTarget: GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailDstTarget,
      interceptType: 'number',
      orderIndex: 'number',
      ruleId: 'number',
      ruleName: 'string',
      ruleSwitch: 'number',
      ruleType: 'string',
      srcTarget: GetInterceptionRuleDetailResponseBodyInterceptionRuleDetailSrcTarget,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionSummaryResponseBodyInterceptionSummary extends $tea.Model {
  closeClusterCount?: number;
  closeRuleCount?: number;
  clusterCount?: number;
  interceptionCountInDays?: number;
  openClusterCount?: number;
  openRuleCount?: number;
  riskCount180Day?: number;
  riskCount30Day?: number;
  riskCountToday?: number;
  ruleCount?: number;
  static names(): { [key: string]: string } {
    return {
      closeClusterCount: 'CloseClusterCount',
      closeRuleCount: 'CloseRuleCount',
      clusterCount: 'ClusterCount',
      interceptionCountInDays: 'InterceptionCountInDays',
      openClusterCount: 'OpenClusterCount',
      openRuleCount: 'OpenRuleCount',
      riskCount180Day: 'RiskCount180Day',
      riskCount30Day: 'RiskCount30Day',
      riskCountToday: 'RiskCountToday',
      ruleCount: 'RuleCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      closeClusterCount: 'number',
      closeRuleCount: 'number',
      clusterCount: 'number',
      interceptionCountInDays: 'number',
      openClusterCount: 'number',
      openRuleCount: 'number',
      riskCount180Day: 'number',
      riskCount30Day: 'number',
      riskCountToday: 'number',
      ruleCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetInterceptionTargetDetailResponseBodyRuleTarget extends $tea.Model {
  appName?: string;
  clusterId?: string;
  clusterName?: string;
  imageList?: string[];
  namespace?: string;
  tagList?: string[];
  targetId?: number;
  targetName?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      imageList: 'ImageList',
      namespace: 'Namespace',
      tagList: 'TagList',
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      clusterId: 'string',
      clusterName: 'string',
      imageList: { 'type': 'array', 'itemType': 'string' },
      namespace: 'string',
      tagList: { 'type': 'array', 'itemType': 'string' },
      targetId: 'number',
      targetName: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLastOnceTaskInfoResponseBodyTaskInfo extends $tea.Model {
  progress?: number;
  result?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      progress: 'Progress',
      result: 'Result',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      progress: 'number',
      result: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetLogMetaResponseBodyLogMeta extends $tea.Model {
  logStore?: string;
  project?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      logStore: 'LogStore',
      project: 'Project',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      logStore: 'string',
      project: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetModuleConfigResponseBodyModuleConfigListItems extends $tea.Model {
  groupId?: number;
  instanceId?: string;
  instanceName?: string;
  ip?: string;
  region?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      ip: 'Ip',
      region: 'Region',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      instanceId: 'string',
      instanceName: 'string',
      ip: 'string',
      region: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetModuleConfigResponseBodyModuleConfigList extends $tea.Model {
  configName?: string;
  items?: GetModuleConfigResponseBodyModuleConfigListItems[];
  moduleName?: string;
  static names(): { [key: string]: string } {
    return {
      configName: 'ConfigName',
      items: 'Items',
      moduleName: 'ModuleName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configName: 'string',
      items: { 'type': 'array', 'itemType': GetModuleConfigResponseBodyModuleConfigListItems },
      moduleName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetModuleConfigResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetModuleTrialAuthInfoResponseBodyDataTrialRecordList extends $tea.Model {
  authLimit?: number;
  gmtEnd?: number;
  gmtStart?: number;
  moduleCode?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      authLimit: 'AuthLimit',
      gmtEnd: 'GmtEnd',
      gmtStart: 'GmtStart',
      moduleCode: 'ModuleCode',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authLimit: 'number',
      gmtEnd: 'number',
      gmtStart: 'number',
      moduleCode: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetModuleTrialAuthInfoResponseBodyData extends $tea.Model {
  canTry?: boolean;
  moduleCode?: string;
  trialRecordList?: GetModuleTrialAuthInfoResponseBodyDataTrialRecordList[];
  static names(): { [key: string]: string } {
    return {
      canTry: 'CanTry',
      moduleCode: 'ModuleCode',
      trialRecordList: 'TrialRecordList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canTry: 'boolean',
      moduleCode: 'string',
      trialRecordList: { 'type': 'array', 'itemType': GetModuleTrialAuthInfoResponseBodyDataTrialRecordList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetObjectScanEventResponseBodyDataDetails extends $tea.Model {
  infoType?: string;
  name?: string;
  nameDisplay?: string;
  type?: string;
  value?: string;
  valueDisplay?: string;
  static names(): { [key: string]: string } {
    return {
      infoType: 'InfoType',
      name: 'Name',
      nameDisplay: 'NameDisplay',
      type: 'Type',
      value: 'Value',
      valueDisplay: 'ValueDisplay',
    };
  }

  static types(): { [key: string]: any } {
    return {
      infoType: 'string',
      name: 'string',
      nameDisplay: 'string',
      type: 'string',
      value: 'string',
      valueDisplay: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetObjectScanEventResponseBodyData extends $tea.Model {
  details?: GetObjectScanEventResponseBodyDataDetails[];
  eventName?: string;
  fileName?: string;
  md5?: string;
  static names(): { [key: string]: string } {
    return {
      details: 'Details',
      eventName: 'EventName',
      fileName: 'FileName',
      md5: 'Md5',
    };
  }

  static types(): { [key: string]: any } {
    return {
      details: { 'type': 'array', 'itemType': GetObjectScanEventResponseBodyDataDetails },
      eventName: 'string',
      fileName: 'string',
      md5: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOnceTaskResultInfoResponseBodyTaskInfo extends $tea.Model {
  status?: string;
  static names(): { [key: string]: string } {
    return {
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterBaseLineListResponseBodyData extends $tea.Model {
  alias?: string;
  classKey?: string;
  itemKey?: string;
  nameKey?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      classKey: 'ClassKey',
      itemKey: 'ItemKey',
      nameKey: 'NameKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      classKey: 'string',
      itemKey: 'string',
      nameKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterImageListResponseBodyData extends $tea.Model {
  imageName?: string;
  static names(): { [key: string]: string } {
    return {
      imageName: 'ImageName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      imageName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterLabelListResponseBodyData extends $tea.Model {
  tagName?: string;
  static names(): { [key: string]: string } {
    return {
      tagName: 'TagName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      tagName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaClusterNamespaceListResponseBodyData extends $tea.Model {
  nameSpaceName?: string;
  static names(): { [key: string]: string } {
    return {
      nameSpaceName: 'NameSpaceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nameSpaceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaPluginStatusResponseBodyInstallStatus extends $tea.Model {
  clusterId?: string;
  installStatus?: boolean;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      installStatus: 'InstallStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      installStatus: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOpaStrategyTemplateSummaryResponseBodyData extends $tea.Model {
  count?: number;
  description?: string;
  templateId?: number;
  templateName?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      description: 'Description',
      templateId: 'TemplateId',
      templateName: 'TemplateName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      description: 'string',
      templateId: 'number',
      templateName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOssBucketScanStatisticResponseBodyData extends $tea.Model {
  expireTime?: number;
  highRisk?: number;
  lowRisk?: number;
  mediumRisk?: number;
  noScanBucket?: number;
  remainAuth?: number;
  riskBucket?: number;
  scanObject?: number;
  totalBucket?: number;
  totalObject?: number;
  static names(): { [key: string]: string } {
    return {
      expireTime: 'ExpireTime',
      highRisk: 'HighRisk',
      lowRisk: 'LowRisk',
      mediumRisk: 'MediumRisk',
      noScanBucket: 'NoScanBucket',
      remainAuth: 'RemainAuth',
      riskBucket: 'RiskBucket',
      scanObject: 'ScanObject',
      totalBucket: 'TotalBucket',
      totalObject: 'TotalObject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      expireTime: 'number',
      highRisk: 'number',
      lowRisk: 'number',
      mediumRisk: 'number',
      noScanBucket: 'number',
      remainAuth: 'number',
      riskBucket: 'number',
      scanObject: 'number',
      totalBucket: 'number',
      totalObject: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOssScanConfigResponseBodyData extends $tea.Model {
  bucketNameList?: string[];
  enable?: number;
  endTime?: string;
  keySuffixList?: string[];
  scanDayList?: number[];
  startTime?: string;
  static names(): { [key: string]: string } {
    return {
      bucketNameList: 'BucketNameList',
      enable: 'Enable',
      endTime: 'EndTime',
      keySuffixList: 'KeySuffixList',
      scanDayList: 'ScanDayList',
      startTime: 'StartTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketNameList: { 'type': 'array', 'itemType': 'string' },
      enable: 'number',
      endTime: 'string',
      keySuffixList: { 'type': 'array', 'itemType': 'string' },
      scanDayList: { 'type': 'array', 'itemType': 'number' },
      startTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetPropertyScheduleConfigResponseBodyPropertyScheduleConfig extends $tea.Model {
  nextScheduleTime?: number;
  scheduleTime?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      nextScheduleTime: 'NextScheduleTime',
      scheduleTime: 'ScheduleTime',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextScheduleTime: 'number',
      scheduleTime: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSecurityScoreRuleResponseBodySecurityScoreRuleListSecurityScoreItemList extends $tea.Model {
  score?: number;
  scoreThreshold?: number;
  subRuleType?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      score: 'Score',
      scoreThreshold: 'ScoreThreshold',
      subRuleType: 'SubRuleType',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      score: 'number',
      scoreThreshold: 'number',
      subRuleType: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSecurityScoreRuleResponseBodySecurityScoreRuleList extends $tea.Model {
  ruleType?: string;
  score?: number;
  securityScoreItemList?: GetSecurityScoreRuleResponseBodySecurityScoreRuleListSecurityScoreItemList[];
  title?: string;
  static names(): { [key: string]: string } {
    return {
      ruleType: 'RuleType',
      score: 'Score',
      securityScoreItemList: 'SecurityScoreItemList',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleType: 'string',
      score: 'number',
      securityScoreItemList: { 'type': 'array', 'itemType': GetSecurityScoreRuleResponseBodySecurityScoreRuleListSecurityScoreItemList },
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSensitiveDefineRuleConfigResponseBodyDataRuleTreeRuleList extends $tea.Model {
  ruleKey?: string;
  ruleName?: string;
  selected?: boolean;
  static names(): { [key: string]: string } {
    return {
      ruleKey: 'RuleKey',
      ruleName: 'RuleName',
      selected: 'Selected',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ruleKey: 'string',
      ruleName: 'string',
      selected: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSensitiveDefineRuleConfigResponseBodyDataRuleTree extends $tea.Model {
  classKey?: string;
  className?: string;
  ruleList?: GetSensitiveDefineRuleConfigResponseBodyDataRuleTreeRuleList[];
  static names(): { [key: string]: string } {
    return {
      classKey: 'ClassKey',
      className: 'ClassName',
      ruleList: 'RuleList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      classKey: 'string',
      className: 'string',
      ruleList: { 'type': 'array', 'itemType': GetSensitiveDefineRuleConfigResponseBodyDataRuleTreeRuleList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSensitiveDefineRuleConfigResponseBodyData extends $tea.Model {
  id?: number;
  ruleCount?: number;
  ruleTree?: GetSensitiveDefineRuleConfigResponseBodyDataRuleTree[];
  selectedCount?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      ruleCount: 'RuleCount',
      ruleTree: 'RuleTree',
      selectedCount: 'SelectedCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      ruleCount: 'number',
      ruleTree: { 'type': 'array', 'itemType': GetSensitiveDefineRuleConfigResponseBodyDataRuleTree },
      selectedCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetServiceTrailResponseBodyServiceTrail extends $tea.Model {
  config?: string;
  createTime?: number;
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      createTime: 'CreateTime',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'string',
      createTime: 'number',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStrategyTemplateDetailResponseBodyDataAlarmDetailBaselineItem extends $tea.Model {
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStrategyTemplateDetailResponseBodyDataAlarmDetailBaseline extends $tea.Model {
  item?: GetStrategyTemplateDetailResponseBodyDataAlarmDetailBaselineItem[];
  riskLevel?: string[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
      riskLevel: 'RiskLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': GetStrategyTemplateDetailResponseBodyDataAlarmDetailBaselineItem },
      riskLevel: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStrategyTemplateDetailResponseBodyDataAlarmDetailMaliciousFileItem extends $tea.Model {
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStrategyTemplateDetailResponseBodyDataAlarmDetailMaliciousFile extends $tea.Model {
  item?: GetStrategyTemplateDetailResponseBodyDataAlarmDetailMaliciousFileItem[];
  riskLevel?: string[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
      riskLevel: 'RiskLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': GetStrategyTemplateDetailResponseBodyDataAlarmDetailMaliciousFileItem },
      riskLevel: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStrategyTemplateDetailResponseBodyDataAlarmDetailVulItem extends $tea.Model {
  id?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStrategyTemplateDetailResponseBodyDataAlarmDetailVul extends $tea.Model {
  item?: GetStrategyTemplateDetailResponseBodyDataAlarmDetailVulItem[];
  riskLevel?: string[];
  static names(): { [key: string]: string } {
    return {
      item: 'Item',
      riskLevel: 'RiskLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      item: { 'type': 'array', 'itemType': GetStrategyTemplateDetailResponseBodyDataAlarmDetailVulItem },
      riskLevel: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStrategyTemplateDetailResponseBodyDataAlarmDetail extends $tea.Model {
  baseline?: GetStrategyTemplateDetailResponseBodyDataAlarmDetailBaseline;
  maliciousFile?: GetStrategyTemplateDetailResponseBodyDataAlarmDetailMaliciousFile;
  vul?: GetStrategyTemplateDetailResponseBodyDataAlarmDetailVul;
  static names(): { [key: string]: string } {
    return {
      baseline: 'Baseline',
      maliciousFile: 'MaliciousFile',
      vul: 'Vul',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baseline: GetStrategyTemplateDetailResponseBodyDataAlarmDetailBaseline,
      maliciousFile: GetStrategyTemplateDetailResponseBodyDataAlarmDetailMaliciousFile,
      vul: GetStrategyTemplateDetailResponseBodyDataAlarmDetailVul,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetStrategyTemplateDetailResponseBodyData extends $tea.Model {
  alarmDetail?: GetStrategyTemplateDetailResponseBodyDataAlarmDetail;
  clusterId?: string;
  clusterName?: string;
  description?: string;
  imageName?: string[];
  label?: string[];
  maliciousImage?: boolean;
  namespace?: string[];
  ruleAction?: number;
  strategyId?: number;
  strategyName?: string;
  strategyTemplateId?: number;
  unScanedImage?: boolean;
  whiteList?: string[];
  static names(): { [key: string]: string } {
    return {
      alarmDetail: 'AlarmDetail',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      description: 'Description',
      imageName: 'ImageName',
      label: 'Label',
      maliciousImage: 'MaliciousImage',
      namespace: 'Namespace',
      ruleAction: 'RuleAction',
      strategyId: 'StrategyId',
      strategyName: 'StrategyName',
      strategyTemplateId: 'StrategyTemplateId',
      unScanedImage: 'UnScanedImage',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmDetail: GetStrategyTemplateDetailResponseBodyDataAlarmDetail,
      clusterId: 'string',
      clusterName: 'string',
      description: 'string',
      imageName: { 'type': 'array', 'itemType': 'string' },
      label: { 'type': 'array', 'itemType': 'string' },
      maliciousImage: 'boolean',
      namespace: { 'type': 'array', 'itemType': 'string' },
      ruleAction: 'number',
      strategyId: 'number',
      strategyName: 'string',
      strategyTemplateId: 'number',
      unScanedImage: 'boolean',
      whiteList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSwitchRegionDetailResponseBodyDataRegionStatus extends $tea.Model {
  ecsCount?: number;
  gmtPlanSwitchTime?: number;
  regionId?: string;
  status?: number;
  static names(): { [key: string]: string } {
    return {
      ecsCount: 'EcsCount',
      gmtPlanSwitchTime: 'GmtPlanSwitchTime',
      regionId: 'RegionId',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ecsCount: 'number',
      gmtPlanSwitchTime: 'number',
      regionId: 'string',
      status: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetSwitchRegionDetailResponseBodyData extends $tea.Model {
  gmtIsAgreeModified?: number;
  gmtNoticed?: number;
  isAgree?: string;
  isNoticed?: string;
  regionStatus?: GetSwitchRegionDetailResponseBodyDataRegionStatus[];
  static names(): { [key: string]: string } {
    return {
      gmtIsAgreeModified: 'GmtIsAgreeModified',
      gmtNoticed: 'GmtNoticed',
      isAgree: 'IsAgree',
      isNoticed: 'IsNoticed',
      regionStatus: 'RegionStatus',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtIsAgreeModified: 'number',
      gmtNoticed: 'number',
      isAgree: 'string',
      isNoticed: 'string',
      regionStatus: { 'type': 'array', 'itemType': GetSwitchRegionDetailResponseBodyDataRegionStatus },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetUserLangResponseBodySasUserLang extends $tea.Model {
  lang?: string;
  static names(): { [key: string]: string } {
    return {
      lang: 'Lang',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lang: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVirusScanConfigResponseBodyData extends $tea.Model {
  configId?: string;
  enable?: number;
  intervalPeriod?: number;
  periodUnit?: string;
  scanPath?: string[];
  scanType?: string;
  selectionKey?: string;
  targetEndTime?: number;
  targetStartTime?: number;
  taskType?: string;
  static names(): { [key: string]: string } {
    return {
      configId: 'ConfigId',
      enable: 'Enable',
      intervalPeriod: 'IntervalPeriod',
      periodUnit: 'PeriodUnit',
      scanPath: 'ScanPath',
      scanType: 'ScanType',
      selectionKey: 'SelectionKey',
      targetEndTime: 'TargetEndTime',
      targetStartTime: 'TargetStartTime',
      taskType: 'TaskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configId: 'string',
      enable: 'number',
      intervalPeriod: 'number',
      periodUnit: 'string',
      scanPath: { 'type': 'array', 'itemType': 'string' },
      scanType: 'string',
      selectionKey: 'string',
      targetEndTime: 'number',
      targetStartTime: 'number',
      taskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVirusScanLatestTaskStatisticResponseBodyData extends $tea.Model {
  completeMachine?: number;
  machineName?: string;
  progress?: string;
  riskLevel?: string;
  safeMachine?: number;
  scanMachine?: number;
  scanPath?: string[];
  scanTime?: number;
  scanType?: string;
  status?: number;
  suspiciousCount?: number;
  suspiciousMachine?: number;
  taskId?: string;
  unCompleteMachine?: number;
  static names(): { [key: string]: string } {
    return {
      completeMachine: 'CompleteMachine',
      machineName: 'MachineName',
      progress: 'Progress',
      riskLevel: 'RiskLevel',
      safeMachine: 'SafeMachine',
      scanMachine: 'ScanMachine',
      scanPath: 'ScanPath',
      scanTime: 'ScanTime',
      scanType: 'ScanType',
      status: 'Status',
      suspiciousCount: 'SuspiciousCount',
      suspiciousMachine: 'SuspiciousMachine',
      taskId: 'TaskId',
      unCompleteMachine: 'UnCompleteMachine',
    };
  }

  static types(): { [key: string]: any } {
    return {
      completeMachine: 'number',
      machineName: 'string',
      progress: 'string',
      riskLevel: 'string',
      safeMachine: 'number',
      scanMachine: 'number',
      scanPath: { 'type': 'array', 'itemType': 'string' },
      scanTime: 'number',
      scanType: 'string',
      status: 'number',
      suspiciousCount: 'number',
      suspiciousMachine: 'number',
      taskId: 'string',
      unCompleteMachine: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetVulWhitelistResponseBodyVulWhitelist extends $tea.Model {
  aliasName?: string;
  id?: number;
  name?: string;
  reason?: string;
  target?: string;
  type?: string;
  whitelist?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      id: 'Id',
      name: 'Name',
      reason: 'Reason',
      target: 'Target',
      type: 'Type',
      whitelist: 'Whitelist',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      id: 'number',
      name: 'string',
      reason: 'string',
      target: 'string',
      type: 'string',
      whitelist: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class HandleSecurityEventsResponseBodyHandleSecurityEventsResponse extends $tea.Model {
  taskId?: number;
  static names(): { [key: string]: string } {
    return {
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      taskId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class IgnoreCheckItemsRequestCheckAndRiskTypeList extends $tea.Model {
  checkId?: number;
  riskType?: string;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      riskType: 'RiskType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      riskType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessMaliciousFilesResponseBodyListDetails extends $tea.Model {
  name?: string;
  nameKey?: string;
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      nameKey: 'NameKey',
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      nameKey: 'string',
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessMaliciousFilesResponseBodyListNotes extends $tea.Model {
  note?: string;
  noteId?: string;
  noteTime?: string;
  static names(): { [key: string]: string } {
    return {
      note: 'Note',
      noteId: 'NoteId',
      noteTime: 'NoteTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      note: 'string',
      noteId: 'string',
      noteTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessMaliciousFilesResponseBodyList extends $tea.Model {
  details?: ListAgentlessMaliciousFilesResponseBodyListDetails[];
  downloadUrl?: string;
  filePath?: number;
  firstScanTimestamp?: number;
  highLight?: string;
  id?: number;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  latestScanTimestamp?: number;
  level?: string;
  maliciousMd5?: string;
  maliciousName?: string;
  maliciousType?: string;
  notes?: ListAgentlessMaliciousFilesResponseBodyListNotes[];
  operateResult?: string;
  operateTimestamp?: string;
  partition?: string;
  targetId?: string;
  targetName?: string;
  targetType?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      details: 'Details',
      downloadUrl: 'DownloadUrl',
      filePath: 'FilePath',
      firstScanTimestamp: 'FirstScanTimestamp',
      highLight: 'HighLight',
      id: 'Id',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      latestScanTimestamp: 'LatestScanTimestamp',
      level: 'Level',
      maliciousMd5: 'MaliciousMd5',
      maliciousName: 'MaliciousName',
      maliciousType: 'MaliciousType',
      notes: 'Notes',
      operateResult: 'OperateResult',
      operateTimestamp: 'OperateTimestamp',
      partition: 'Partition',
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      details: { 'type': 'array', 'itemType': ListAgentlessMaliciousFilesResponseBodyListDetails },
      downloadUrl: 'string',
      filePath: 'number',
      firstScanTimestamp: 'number',
      highLight: 'string',
      id: 'number',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      latestScanTimestamp: 'number',
      level: 'string',
      maliciousMd5: 'string',
      maliciousName: 'string',
      maliciousType: 'string',
      notes: { 'type': 'array', 'itemType': ListAgentlessMaliciousFilesResponseBodyListNotes },
      operateResult: 'string',
      operateTimestamp: 'string',
      partition: 'string',
      targetId: 'string',
      targetName: 'string',
      targetType: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessMaliciousFilesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessRelateMaliciousResponseBodyList extends $tea.Model {
  filePath?: string;
  firstScanTimestamp?: number;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  latestScanTimestamp?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      filePath: 'FilePath',
      firstScanTimestamp: 'FirstScanTimestamp',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      latestScanTimestamp: 'LatestScanTimestamp',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      filePath: 'string',
      firstScanTimestamp: 'number',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      latestScanTimestamp: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessRelateMaliciousResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessRiskUuidResponseBodyList extends $tea.Model {
  baselineCount?: number;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  maliciousCount?: number;
  scanTime?: number;
  targetId?: string;
  targetName?: string;
  uuid?: string;
  vulCount?: number;
  static names(): { [key: string]: string } {
    return {
      baselineCount: 'BaselineCount',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      maliciousCount: 'MaliciousCount',
      scanTime: 'ScanTime',
      targetId: 'TargetId',
      targetName: 'TargetName',
      uuid: 'Uuid',
      vulCount: 'VulCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      baselineCount: 'number',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      maliciousCount: 'number',
      scanTime: 'number',
      targetId: 'string',
      targetName: 'string',
      uuid: 'string',
      vulCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessRiskUuidResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessTaskResponseBodyList extends $tea.Model {
  endTime?: number;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  progress?: number;
  result?: string;
  startTime?: number;
  status?: number;
  targetName?: string;
  targetType?: number;
  taskId?: string;
  taskName?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      progress: 'Progress',
      result: 'Result',
      startTime: 'StartTime',
      status: 'Status',
      targetName: 'TargetName',
      targetType: 'TargetType',
      taskId: 'TaskId',
      taskName: 'TaskName',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      progress: 'number',
      result: 'string',
      startTime: 'number',
      status: 'number',
      targetName: 'string',
      targetType: 'number',
      taskId: 'string',
      taskName: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAgentlessTaskResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetCleanConfigResponseBodyData extends $tea.Model {
  cleanDays?: number;
  status?: number;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      cleanDays: 'CleanDays',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cleanDays: 'number',
      status: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetRefreshTaskConfigResponseBodyAssetRefreshConfig extends $tea.Model {
  refreshConfigType?: number;
  schedulePeriod?: number;
  status?: number;
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      refreshConfigType: 'RefreshConfigType',
      schedulePeriod: 'SchedulePeriod',
      status: 'Status',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      refreshConfigType: 'number',
      schedulePeriod: 'number',
      status: 'number',
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetSelectionSelectedTargetResponseBodyData extends $tea.Model {
  targetId?: string;
  targetName?: string;
  static names(): { [key: string]: string } {
    return {
      targetId: 'TargetId',
      targetName: 'TargetName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetId: 'string',
      targetName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetSelectionTargetResponseBodyData extends $tea.Model {
  targetId?: string;
  targetName?: string;
  static names(): { [key: string]: string } {
    return {
      targetId: 'TargetId',
      targetName: 'TargetName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetId: 'string',
      targetName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAssetSelectionTargetResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListAvailableHoneypotResponseBodyData extends $tea.Model {
  honeypotImageDisplayName?: string;
  honeypotImageId?: string;
  honeypotImageName?: string;
  honeypotImageType?: string;
  honeypotImageVersion?: string;
  multiports?: string;
  proto?: string;
  servicePort?: string;
  template?: string;
  static names(): { [key: string]: string } {
    return {
      honeypotImageDisplayName: 'HoneypotImageDisplayName',
      honeypotImageId: 'HoneypotImageId',
      honeypotImageName: 'HoneypotImageName',
      honeypotImageType: 'HoneypotImageType',
      honeypotImageVersion: 'HoneypotImageVersion',
      multiports: 'Multiports',
      proto: 'Proto',
      servicePort: 'ServicePort',
      template: 'Template',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeypotImageDisplayName: 'string',
      honeypotImageId: 'string',
      honeypotImageName: 'string',
      honeypotImageType: 'string',
      honeypotImageVersion: 'string',
      multiports: 'string',
      proto: 'string',
      servicePort: 'string',
      template: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckInstanceResultResponseBodyBasicData extends $tea.Model {
  id?: number;
  instanceId?: string;
  instanceName?: string;
  regionId?: string;
  status?: string;
  statusMessage?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      regionId: 'RegionId',
      status: 'Status',
      statusMessage: 'StatusMessage',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      instanceId: 'string',
      instanceName: 'string',
      regionId: 'string',
      status: 'string',
      statusMessage: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckInstanceResultResponseBodyColumnsGrids extends $tea.Model {
  key?: string;
  showName?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      showName: 'ShowName',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      showName: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckInstanceResultResponseBodyColumns extends $tea.Model {
  grids?: ListCheckInstanceResultResponseBodyColumnsGrids[];
  key?: string;
  search?: boolean;
  searchKey?: string;
  showName?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      grids: 'Grids',
      key: 'Key',
      search: 'Search',
      searchKey: 'SearchKey',
      showName: 'ShowName',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      grids: { 'type': 'array', 'itemType': ListCheckInstanceResultResponseBodyColumnsGrids },
      key: 'string',
      search: 'boolean',
      searchKey: 'string',
      showName: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckInstanceResultResponseBodyPageInfo extends $tea.Model {
  count?: string;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'string',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemResponseBodyCheckItemsCustomConfigs extends $tea.Model {
  defaultValue?: string;
  name?: string;
  showName?: string;
  typeDefine?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      defaultValue: 'DefaultValue',
      name: 'Name',
      showName: 'ShowName',
      typeDefine: 'TypeDefine',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      defaultValue: 'string',
      name: 'string',
      showName: 'string',
      typeDefine: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemResponseBodyCheckItemsDescription extends $tea.Model {
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemResponseBodyCheckItems extends $tea.Model {
  checkId?: number;
  checkShowName?: string;
  customConfigs?: ListCheckItemResponseBodyCheckItemsCustomConfigs[];
  description?: ListCheckItemResponseBodyCheckItemsDescription;
  instanceSubType?: string;
  instanceType?: string;
  riskLevel?: string;
  sectionIds?: number[];
  vendor?: string;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      checkShowName: 'CheckShowName',
      customConfigs: 'CustomConfigs',
      description: 'Description',
      instanceSubType: 'InstanceSubType',
      instanceType: 'InstanceType',
      riskLevel: 'RiskLevel',
      sectionIds: 'SectionIds',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      checkShowName: 'string',
      customConfigs: { 'type': 'array', 'itemType': ListCheckItemResponseBodyCheckItemsCustomConfigs },
      description: ListCheckItemResponseBodyCheckItemsDescription,
      instanceSubType: 'string',
      instanceType: 'string',
      riskLevel: 'string',
      sectionIds: { 'type': 'array', 'itemType': 'number' },
      vendor: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemWarningMachineResponseBodyListFixList extends $tea.Model {
  riskId?: number;
  riskName?: string;
  static names(): { [key: string]: string } {
    return {
      riskId: 'RiskId',
      riskName: 'RiskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      riskId: 'number',
      riskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemWarningMachineResponseBodyListWarningRiskList extends $tea.Model {
  riskId?: number;
  riskName?: string;
  static names(): { [key: string]: string } {
    return {
      riskId: 'RiskId',
      riskName: 'RiskName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      riskId: 'number',
      riskName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemWarningMachineResponseBodyList extends $tea.Model {
  authVersion?: number;
  bind?: boolean;
  containerId?: string;
  containerName?: string;
  fixList?: ListCheckItemWarningMachineResponseBodyListFixList[];
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  lastScanTime?: number;
  portOpen?: boolean;
  prompt?: string;
  regionId?: string;
  status?: number;
  targetId?: string;
  targetName?: string;
  targetType?: string;
  uuid?: string;
  warningRiskList?: ListCheckItemWarningMachineResponseBodyListWarningRiskList[];
  static names(): { [key: string]: string } {
    return {
      authVersion: 'AuthVersion',
      bind: 'Bind',
      containerId: 'ContainerId',
      containerName: 'ContainerName',
      fixList: 'FixList',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      lastScanTime: 'LastScanTime',
      portOpen: 'PortOpen',
      prompt: 'Prompt',
      regionId: 'RegionId',
      status: 'Status',
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
      uuid: 'Uuid',
      warningRiskList: 'WarningRiskList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authVersion: 'number',
      bind: 'boolean',
      containerId: 'string',
      containerName: 'string',
      fixList: { 'type': 'array', 'itemType': ListCheckItemWarningMachineResponseBodyListFixList },
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      lastScanTime: 'number',
      portOpen: 'boolean',
      prompt: 'string',
      regionId: 'string',
      status: 'number',
      targetId: 'string',
      targetName: 'string',
      targetType: 'string',
      uuid: 'string',
      warningRiskList: { 'type': 'array', 'itemType': ListCheckItemWarningMachineResponseBodyListWarningRiskList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemWarningMachineResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemWarningSummaryResponseBodyList extends $tea.Model {
  advice?: string;
  affiliatedRiskTypes?: string[];
  affiliatedRisks?: string[];
  alias?: string;
  checkId?: number;
  checkItem?: string;
  checkLevel?: string;
  checkType?: string;
  containerCheckItem?: boolean;
  description?: string;
  riskType?: string;
  status?: number;
  warningMachineCount?: number;
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      affiliatedRiskTypes: 'AffiliatedRiskTypes',
      affiliatedRisks: 'AffiliatedRisks',
      alias: 'Alias',
      checkId: 'CheckId',
      checkItem: 'CheckItem',
      checkLevel: 'CheckLevel',
      checkType: 'CheckType',
      containerCheckItem: 'ContainerCheckItem',
      description: 'Description',
      riskType: 'RiskType',
      status: 'Status',
      warningMachineCount: 'WarningMachineCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      affiliatedRiskTypes: { 'type': 'array', 'itemType': 'string' },
      affiliatedRisks: { 'type': 'array', 'itemType': 'string' },
      alias: 'string',
      checkId: 'number',
      checkItem: 'string',
      checkLevel: 'string',
      checkType: 'string',
      containerCheckItem: 'boolean',
      description: 'string',
      riskType: 'string',
      status: 'number',
      warningMachineCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckItemWarningSummaryResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckResultResponseBodyChecksCheckPolicies extends $tea.Model {
  requirementId?: number;
  requirementShowName?: string;
  sectionId?: number;
  sectionShowName?: string;
  standardId?: number;
  standardShowName?: string;
  static names(): { [key: string]: string } {
    return {
      requirementId: 'RequirementId',
      requirementShowName: 'RequirementShowName',
      sectionId: 'SectionId',
      sectionShowName: 'SectionShowName',
      standardId: 'StandardId',
      standardShowName: 'StandardShowName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requirementId: 'number',
      requirementShowName: 'string',
      sectionId: 'number',
      sectionShowName: 'string',
      standardId: 'number',
      standardShowName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckResultResponseBodyChecks extends $tea.Model {
  checkId?: number;
  checkPolicies?: ListCheckResultResponseBodyChecksCheckPolicies[];
  checkShowName?: string;
  instanceSubType?: string;
  instanceType?: string;
  lastCheckTime?: number;
  riskLevel?: string;
  status?: string;
  statusMessage?: string;
  taskId?: string;
  trialPermission?: boolean;
  vendor?: string;
  vendorShowName?: string;
  static names(): { [key: string]: string } {
    return {
      checkId: 'CheckId',
      checkPolicies: 'CheckPolicies',
      checkShowName: 'CheckShowName',
      instanceSubType: 'InstanceSubType',
      instanceType: 'InstanceType',
      lastCheckTime: 'LastCheckTime',
      riskLevel: 'RiskLevel',
      status: 'Status',
      statusMessage: 'StatusMessage',
      taskId: 'TaskId',
      trialPermission: 'TrialPermission',
      vendor: 'Vendor',
      vendorShowName: 'VendorShowName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkId: 'number',
      checkPolicies: { 'type': 'array', 'itemType': ListCheckResultResponseBodyChecksCheckPolicies },
      checkShowName: 'string',
      instanceSubType: 'string',
      instanceType: 'string',
      lastCheckTime: 'number',
      riskLevel: 'string',
      status: 'string',
      statusMessage: 'string',
      taskId: 'string',
      trialPermission: 'boolean',
      vendor: 'string',
      vendorShowName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckResultResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckStandardResponseBodyStandardsRequirements extends $tea.Model {
  id?: number;
  riskCheckCount?: number;
  showName?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      riskCheckCount: 'RiskCheckCount',
      showName: 'ShowName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      riskCheckCount: 'number',
      showName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCheckStandardResponseBodyStandards extends $tea.Model {
  id?: number;
  requirements?: ListCheckStandardResponseBodyStandardsRequirements[];
  showName?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      requirements: 'Requirements',
      showName: 'ShowName',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      requirements: { 'type': 'array', 'itemType': ListCheckStandardResponseBodyStandardsRequirements },
      showName: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientAlertModeResponseBodyData extends $tea.Model {
  count?: number;
  uuids?: string[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      uuids: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientUserDefineRulesResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClientUserDefineRulesResponseBodyUserDefineRuleList extends $tea.Model {
  actionType?: number;
  id?: number;
  name?: string;
  platform?: string;
  switchId?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      actionType: 'ActionType',
      id: 'Id',
      name: 'Name',
      platform: 'Platform',
      switchId: 'SwitchId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      actionType: 'number',
      id: 'number',
      name: 'string',
      platform: 'string',
      switchId: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudAssetInstancesRequestCloudAssetTypes extends $tea.Model {
  assetSubType?: number;
  assetType?: number;
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      assetSubType: 'AssetSubType',
      assetType: 'AssetType',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      assetSubType: 'number',
      assetType: 'number',
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudAssetInstancesResponseBodyInstances extends $tea.Model {
  alarmStatus?: string;
  assetSubType?: string;
  assetSubTypeName?: string;
  assetType?: number;
  assetTypeName?: string;
  createdTime?: number;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  regionId?: string;
  riskStatus?: string;
  securityInfo?: string;
  vendor?: number;
  static names(): { [key: string]: string } {
    return {
      alarmStatus: 'AlarmStatus',
      assetSubType: 'AssetSubType',
      assetSubTypeName: 'AssetSubTypeName',
      assetType: 'AssetType',
      assetTypeName: 'AssetTypeName',
      createdTime: 'CreatedTime',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      regionId: 'RegionId',
      riskStatus: 'RiskStatus',
      securityInfo: 'SecurityInfo',
      vendor: 'Vendor',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmStatus: 'string',
      assetSubType: 'string',
      assetSubTypeName: 'string',
      assetType: 'number',
      assetTypeName: 'string',
      createdTime: 'number',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      regionId: 'string',
      riskStatus: 'string',
      securityInfo: 'string',
      vendor: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudAssetInstancesResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCloudVendorRegionsResponseBodyData extends $tea.Model {
  area?: string;
  disable?: number;
  regionId?: string;
  selected?: number;
  static names(): { [key: string]: string } {
    return {
      area: 'Area',
      disable: 'Disable',
      regionId: 'RegionId',
      selected: 'Selected',
    };
  }

  static types(): { [key: string]: any } {
    return {
      area: 'string',
      disable: 'number',
      regionId: 'string',
      selected: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterCnnfStatusDetailResponseBodyData extends $tea.Model {
  clusterId?: string;
  installed?: boolean;
  instanceId?: string;
  internetIp?: string;
  intranetIp?: string;
  invalidType?: string;
  machineName?: string;
  machineType?: number;
  pluginName?: string;
  pluginVersion?: string;
  status?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      installed: 'Installed',
      instanceId: 'InstanceId',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      invalidType: 'InvalidType',
      machineName: 'MachineName',
      machineType: 'MachineType',
      pluginName: 'PluginName',
      pluginVersion: 'PluginVersion',
      status: 'Status',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      installed: 'boolean',
      instanceId: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      invalidType: 'string',
      machineName: 'string',
      machineType: 'number',
      pluginName: 'string',
      pluginVersion: 'string',
      status: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterInterceptionConfigResponseBodyClusterConfigList extends $tea.Model {
  clusterCNNFStatus?: number;
  clusterId?: string;
  clusterName?: string;
  clusterType?: string;
  interceptionSwitch?: number;
  openRuleCount?: number;
  supportCNNF?: boolean;
  totalRuleCount?: number;
  static names(): { [key: string]: string } {
    return {
      clusterCNNFStatus: 'ClusterCNNFStatus',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      clusterType: 'ClusterType',
      interceptionSwitch: 'InterceptionSwitch',
      openRuleCount: 'OpenRuleCount',
      supportCNNF: 'SupportCNNF',
      totalRuleCount: 'TotalRuleCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterCNNFStatus: 'number',
      clusterId: 'string',
      clusterName: 'string',
      clusterType: 'string',
      interceptionSwitch: 'number',
      openRuleCount: 'number',
      supportCNNF: 'boolean',
      totalRuleCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListClusterInterceptionConfigResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currrentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currrentPage: 'CurrrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currrentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListContainerDefenseRuleRequestConditions extends $tea.Model {
  type?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      type: 'Type',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      type: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListContainerDefenseRuleResponseBodyList extends $tea.Model {
  clusterCount?: number;
  clusterIdList?: string;
  description?: string;
  ruleAction?: number;
  ruleId?: number;
  ruleName?: string;
  ruleSwitch?: number;
  ruleType?: number;
  static names(): { [key: string]: string } {
    return {
      clusterCount: 'ClusterCount',
      clusterIdList: 'ClusterIdList',
      description: 'Description',
      ruleAction: 'RuleAction',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleSwitch: 'RuleSwitch',
      ruleType: 'RuleType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterCount: 'number',
      clusterIdList: 'string',
      description: 'string',
      ruleAction: 'number',
      ruleId: 'number',
      ruleName: 'string',
      ruleSwitch: 'number',
      ruleType: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListContainerDefenseRuleResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  lastRowKey?: string;
  nextToken?: string;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      lastRowKey: 'LastRowKey',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      lastRowKey: 'string',
      nextToken: 'string',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListCriteriaStrategyResponseBodyData extends $tea.Model {
  id?: number;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectEventResponseBodyEventList extends $tea.Model {
  alertLevel?: number;
  cmdLine?: string;
  filePath?: string;
  handleTime?: number;
  id?: number;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  latestTime?: number;
  operation?: string;
  procPath?: string;
  procPermission?: string;
  processId?: string;
  remark?: string;
  ruleName?: string;
  status?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      alertLevel: 'AlertLevel',
      cmdLine: 'CmdLine',
      filePath: 'FilePath',
      handleTime: 'HandleTime',
      id: 'Id',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      latestTime: 'LatestTime',
      operation: 'Operation',
      procPath: 'ProcPath',
      procPermission: 'ProcPermission',
      processId: 'ProcessId',
      remark: 'Remark',
      ruleName: 'RuleName',
      status: 'Status',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alertLevel: 'number',
      cmdLine: 'string',
      filePath: 'string',
      handleTime: 'number',
      id: 'number',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      latestTime: 'number',
      operation: 'string',
      procPath: 'string',
      procPermission: 'string',
      processId: 'string',
      remark: 'string',
      ruleName: 'string',
      status: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectEventResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectPluginStatusResponseBodyData extends $tea.Model {
  clientVersion?: string;
  installCode?: string;
  installMessage?: string;
  installed?: boolean;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  online?: boolean;
  supportFile?: boolean;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      clientVersion: 'ClientVersion',
      installCode: 'InstallCode',
      installMessage: 'InstallMessage',
      installed: 'Installed',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      online: 'Online',
      supportFile: 'SupportFile',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clientVersion: 'string',
      installCode: 'string',
      installMessage: 'string',
      installed: 'boolean',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      online: 'boolean',
      supportFile: 'boolean',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectPluginStatusResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectRuleResponseBodyFileProtectList extends $tea.Model {
  action?: string;
  alertLevel?: string;
  effectInstanceCount?: number;
  fileOps?: string[];
  filePaths?: string[];
  gmtCreate?: number;
  gmtModified?: number;
  id?: number;
  procPaths?: string[];
  ruleName?: string;
  status?: number;
  switchId?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      alertLevel: 'AlertLevel',
      effectInstanceCount: 'EffectInstanceCount',
      fileOps: 'FileOps',
      filePaths: 'FilePaths',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      procPaths: 'ProcPaths',
      ruleName: 'RuleName',
      status: 'Status',
      switchId: 'SwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      alertLevel: 'string',
      effectInstanceCount: 'number',
      fileOps: { 'type': 'array', 'itemType': 'string' },
      filePaths: { 'type': 'array', 'itemType': 'string' },
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'number',
      procPaths: { 'type': 'array', 'itemType': 'string' },
      ruleName: 'string',
      status: 'number',
      switchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListFileProtectRuleResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupsResponseBodyList extends $tea.Model {
  groupFlag?: number;
  groupId?: number;
  groupName?: string;
  static names(): { [key: string]: string } {
    return {
      groupFlag: 'GroupFlag',
      groupId: 'GroupId',
      groupName: 'GroupName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupFlag: 'number',
      groupId: 'number',
      groupName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListGroupsResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  nextToken?: string;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      nextToken: 'string',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotResponseBodyList extends $tea.Model {
  controlNodeName?: string;
  honeypotId?: string;
  honeypotImageDisplayName?: string;
  honeypotImageId?: string;
  honeypotImageName?: string;
  honeypotName?: string;
  nodeId?: string;
  presetId?: string;
  state?: string[];
  static names(): { [key: string]: string } {
    return {
      controlNodeName: 'ControlNodeName',
      honeypotId: 'HoneypotId',
      honeypotImageDisplayName: 'HoneypotImageDisplayName',
      honeypotImageId: 'HoneypotImageId',
      honeypotImageName: 'HoneypotImageName',
      honeypotName: 'HoneypotName',
      nodeId: 'NodeId',
      presetId: 'PresetId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      controlNodeName: 'string',
      honeypotId: 'string',
      honeypotImageDisplayName: 'string',
      honeypotImageId: 'string',
      honeypotImageName: 'string',
      honeypotName: 'string',
      nodeId: 'string',
      presetId: 'string',
      state: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList extends $tea.Model {
  fieldExtInfo?: string;
  fieldKey?: string;
  fieldType?: string;
  fieldValue?: string;
  static names(): { [key: string]: string } {
    return {
      fieldExtInfo: 'FieldExtInfo',
      fieldKey: 'FieldKey',
      fieldType: 'FieldType',
      fieldValue: 'FieldValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldExtInfo: 'string',
      fieldKey: 'string',
      fieldType: 'string',
      fieldValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEvents extends $tea.Model {
  alarmEventId?: number;
  alarmEventName?: string;
  alarmEventType?: string;
  alarmUniqueInfo?: string;
  eventCount?: number;
  firstTime?: number;
  lastTime?: number;
  mergeFieldList?: ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList[];
  operateStatus?: number;
  riskLevel?: string;
  static names(): { [key: string]: string } {
    return {
      alarmEventId: 'AlarmEventId',
      alarmEventName: 'AlarmEventName',
      alarmEventType: 'AlarmEventType',
      alarmUniqueInfo: 'AlarmUniqueInfo',
      eventCount: 'EventCount',
      firstTime: 'FirstTime',
      lastTime: 'LastTime',
      mergeFieldList: 'MergeFieldList',
      operateStatus: 'OperateStatus',
      riskLevel: 'RiskLevel',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmEventId: 'number',
      alarmEventName: 'string',
      alarmEventType: 'string',
      alarmUniqueInfo: 'string',
      eventCount: 'number',
      firstTime: 'number',
      lastTime: 'number',
      mergeFieldList: { 'type': 'array', 'itemType': ListHoneypotAlarmEventsResponseBodyHoneypotAlarmEventsMergeFieldList },
      operateStatus: 'number',
      riskLevel: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAlarmEventsResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAttackerPortraitResponseBodyListNetwork extends $tea.Model {
  externalIp?: string[];
  internalIp?: string[];
  realIp?: string[];
  static names(): { [key: string]: string } {
    return {
      externalIp: 'ExternalIp',
      internalIp: 'InternalIp',
      realIp: 'RealIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      externalIp: { 'type': 'array', 'itemType': 'string' },
      internalIp: { 'type': 'array', 'itemType': 'string' },
      realIp: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAttackerPortraitResponseBodyList extends $tea.Model {
  attackCount?: number;
  browser?: string[];
  host?: string[];
  lastTime?: number;
  network?: ListHoneypotAttackerPortraitResponseBodyListNetwork;
  portraitId?: string;
  social?: string[];
  static names(): { [key: string]: string } {
    return {
      attackCount: 'AttackCount',
      browser: 'Browser',
      host: 'Host',
      lastTime: 'LastTime',
      network: 'Network',
      portraitId: 'PortraitId',
      social: 'Social',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attackCount: 'number',
      browser: { 'type': 'array', 'itemType': 'string' },
      host: { 'type': 'array', 'itemType': 'string' },
      lastTime: 'number',
      network: ListHoneypotAttackerPortraitResponseBodyListNetwork,
      portraitId: 'string',
      social: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAttackerPortraitResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAttackerSourceResponseBodyList extends $tea.Model {
  eventCount?: number;
  lastTargetHoneypot?: string;
  lastTargetIp?: string;
  lastTime?: number;
  riskLevel?: string;
  srcIp?: string;
  static names(): { [key: string]: string } {
    return {
      eventCount: 'EventCount',
      lastTargetHoneypot: 'LastTargetHoneypot',
      lastTargetIp: 'LastTargetIp',
      lastTime: 'LastTime',
      riskLevel: 'RiskLevel',
      srcIp: 'SrcIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventCount: 'number',
      lastTargetHoneypot: 'string',
      lastTargetIp: 'string',
      lastTime: 'number',
      riskLevel: 'string',
      srcIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotAttackerSourceResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotEventsResponseBodyHoneypotEventsMergeFieldList extends $tea.Model {
  fieldExtInfo?: string;
  fieldKey?: string;
  fieldType?: string;
  fieldValue?: string;
  static names(): { [key: string]: string } {
    return {
      fieldExtInfo: 'FieldExtInfo',
      fieldKey: 'FieldKey',
      fieldType: 'FieldType',
      fieldValue: 'FieldValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      fieldExtInfo: 'string',
      fieldKey: 'string',
      fieldType: 'string',
      fieldValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotEventsResponseBodyHoneypotEvents extends $tea.Model {
  agentId?: string;
  agentName?: string;
  alarmEventId?: number;
  dstIp?: string;
  firstTime?: number;
  honeypotName?: string;
  lastTime?: number;
  location?: string;
  mergeFieldList?: ListHoneypotEventsResponseBodyHoneypotEventsMergeFieldList[];
  protocol?: string;
  riskLevel?: string;
  securityEventId?: number;
  srcIp?: string;
  static names(): { [key: string]: string } {
    return {
      agentId: 'AgentId',
      agentName: 'AgentName',
      alarmEventId: 'AlarmEventId',
      dstIp: 'DstIp',
      firstTime: 'FirstTime',
      honeypotName: 'HoneypotName',
      lastTime: 'LastTime',
      location: 'Location',
      mergeFieldList: 'MergeFieldList',
      protocol: 'Protocol',
      riskLevel: 'RiskLevel',
      securityEventId: 'SecurityEventId',
      srcIp: 'SrcIp',
    };
  }

  static types(): { [key: string]: any } {
    return {
      agentId: 'string',
      agentName: 'string',
      alarmEventId: 'number',
      dstIp: 'string',
      firstTime: 'number',
      honeypotName: 'string',
      lastTime: 'number',
      location: 'string',
      mergeFieldList: { 'type': 'array', 'itemType': ListHoneypotEventsResponseBodyHoneypotEventsMergeFieldList },
      protocol: 'string',
      riskLevel: 'string',
      securityEventId: 'number',
      srcIp: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotEventsResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  lastRowKey?: string;
  nextToken?: string;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      lastRowKey: 'LastRowKey',
      nextToken: 'NextToken',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      lastRowKey: 'string',
      nextToken: 'string',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotNodeResponseBodyHoneypotNodeList extends $tea.Model {
  allowHoneypotAccessInternet?: boolean;
  createTime?: string;
  defaultNode?: boolean;
  ecsInstanceId?: string;
  honeypotTotalCount?: number;
  honeypotUsedCount?: number;
  nodeId?: string;
  nodeIp?: string;
  nodeName?: string;
  probeTotalCount?: number;
  probeUsedCount?: number;
  securityGroupProbeIpList?: string[];
  totalStatus?: number;
  upgradeAvailable?: boolean;
  static names(): { [key: string]: string } {
    return {
      allowHoneypotAccessInternet: 'AllowHoneypotAccessInternet',
      createTime: 'CreateTime',
      defaultNode: 'DefaultNode',
      ecsInstanceId: 'EcsInstanceId',
      honeypotTotalCount: 'HoneypotTotalCount',
      honeypotUsedCount: 'HoneypotUsedCount',
      nodeId: 'NodeId',
      nodeIp: 'NodeIp',
      nodeName: 'NodeName',
      probeTotalCount: 'ProbeTotalCount',
      probeUsedCount: 'ProbeUsedCount',
      securityGroupProbeIpList: 'SecurityGroupProbeIpList',
      totalStatus: 'TotalStatus',
      upgradeAvailable: 'UpgradeAvailable',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowHoneypotAccessInternet: 'boolean',
      createTime: 'string',
      defaultNode: 'boolean',
      ecsInstanceId: 'string',
      honeypotTotalCount: 'number',
      honeypotUsedCount: 'number',
      nodeId: 'string',
      nodeIp: 'string',
      nodeName: 'string',
      probeTotalCount: 'number',
      probeUsedCount: 'number',
      securityGroupProbeIpList: { 'type': 'array', 'itemType': 'string' },
      totalStatus: 'number',
      upgradeAvailable: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotNodeResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotPresetResponseBodyList extends $tea.Model {
  controlNodeName?: string;
  honeypotImageDisplayName?: string;
  honeypotImageName?: string;
  honeypotPresetId?: string;
  nodeId?: string;
  presetName?: string;
  presetType?: string;
  static names(): { [key: string]: string } {
    return {
      controlNodeName: 'ControlNodeName',
      honeypotImageDisplayName: 'HoneypotImageDisplayName',
      honeypotImageName: 'HoneypotImageName',
      honeypotPresetId: 'HoneypotPresetId',
      nodeId: 'NodeId',
      presetName: 'PresetName',
      presetType: 'PresetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      controlNodeName: 'string',
      honeypotImageDisplayName: 'string',
      honeypotImageName: 'string',
      honeypotPresetId: 'string',
      nodeId: 'string',
      presetName: 'string',
      presetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotPresetResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotProbeResponseBodyListControlNode extends $tea.Model {
  ecsInstanceId?: string;
  nodeId?: string;
  nodeName?: string;
  static names(): { [key: string]: string } {
    return {
      ecsInstanceId: 'EcsInstanceId',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ecsInstanceId: 'string',
      nodeId: 'string',
      nodeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotProbeResponseBodyList extends $tea.Model {
  controlNode?: ListHoneypotProbeResponseBodyListControlNode;
  deployTime?: number;
  displayName?: string;
  hostIp?: string;
  osType?: string;
  probeId?: string;
  probeType?: string;
  probeVersion?: string;
  status?: string;
  uuid?: string;
  vpcId?: string;
  static names(): { [key: string]: string } {
    return {
      controlNode: 'ControlNode',
      deployTime: 'DeployTime',
      displayName: 'DisplayName',
      hostIp: 'HostIp',
      osType: 'OsType',
      probeId: 'ProbeId',
      probeType: 'ProbeType',
      probeVersion: 'ProbeVersion',
      status: 'Status',
      uuid: 'Uuid',
      vpcId: 'VpcId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      controlNode: ListHoneypotProbeResponseBodyListControlNode,
      deployTime: 'number',
      displayName: 'string',
      hostIp: 'string',
      osType: 'string',
      probeId: 'string',
      probeType: 'string',
      probeVersion: 'string',
      status: 'string',
      uuid: 'string',
      vpcId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListHoneypotProbeResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListImageRegistryRegionResponseBodyRegions extends $tea.Model {
  regionId?: string;
  regionName?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      regionName: 'RegionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      regionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListImageRiskResponseBodyImageRiskListEndPointList extends $tea.Model {
  domains?: string[];
  type?: string;
  static names(): { [key: string]: string } {
    return {
      domains: 'Domains',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domains: { 'type': 'array', 'itemType': 'string' },
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListImageRiskResponseBodyImageRiskList extends $tea.Model {
  digest?: string;
  endPointList?: ListImageRiskResponseBodyImageRiskListEndPointList[];
  endpoints?: string;
  image?: string;
  imageAccessType?: string;
  imageId?: string;
  internetURLs?: string;
  regionId?: string;
  registryType?: string;
  repoId?: string;
  repoName?: string;
  repoNamespace?: string;
  repoType?: string;
  statistics?: string;
  tag?: string;
  tagImmutable?: number;
  uuid?: string;
  vpcURLs?: string;
  static names(): { [key: string]: string } {
    return {
      digest: 'Digest',
      endPointList: 'EndPointList',
      endpoints: 'Endpoints',
      image: 'Image',
      imageAccessType: 'ImageAccessType',
      imageId: 'ImageId',
      internetURLs: 'InternetURLs',
      regionId: 'RegionId',
      registryType: 'RegistryType',
      repoId: 'RepoId',
      repoName: 'RepoName',
      repoNamespace: 'RepoNamespace',
      repoType: 'RepoType',
      statistics: 'Statistics',
      tag: 'Tag',
      tagImmutable: 'TagImmutable',
      uuid: 'Uuid',
      vpcURLs: 'VpcURLs',
    };
  }

  static types(): { [key: string]: any } {
    return {
      digest: 'string',
      endPointList: { 'type': 'array', 'itemType': ListImageRiskResponseBodyImageRiskListEndPointList },
      endpoints: 'string',
      image: 'string',
      imageAccessType: 'string',
      imageId: 'string',
      internetURLs: 'string',
      regionId: 'string',
      registryType: 'string',
      repoId: 'string',
      repoName: 'string',
      repoNamespace: 'string',
      repoType: 'string',
      statistics: 'string',
      tag: 'string',
      tagImmutable: 'number',
      uuid: 'string',
      vpcURLs: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListImageRiskResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes extends $tea.Model {
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceCatalogResponseBodyVendorsInstanceTypes extends $tea.Model {
  instanceSubTypes?: ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes[];
  name?: string;
  static names(): { [key: string]: string } {
    return {
      instanceSubTypes: 'InstanceSubTypes',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceSubTypes: { 'type': 'array', 'itemType': ListInstanceCatalogResponseBodyVendorsInstanceTypesInstanceSubTypes },
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceCatalogResponseBodyVendors extends $tea.Model {
  instanceTypes?: ListInstanceCatalogResponseBodyVendorsInstanceTypes[];
  name?: string;
  static names(): { [key: string]: string } {
    return {
      instanceTypes: 'InstanceTypes',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceTypes: { 'type': 'array', 'itemType': ListInstanceCatalogResponseBodyVendorsInstanceTypes },
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceRiskLevelsRequestInstanceList extends $tea.Model {
  instanceId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceRiskLevelsResponseBodyInstanceRiskLevels extends $tea.Model {
  instanceId?: string;
  level?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      level: 'Level',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      level: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceRiskNumRequestInstanceList extends $tea.Model {
  instanceId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceRiskNumResponseBodyInstanceRiskNumInstanceItem extends $tea.Model {
  instanceId?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceRiskNumResponseBodyInstanceRiskNumRiskNumEntity extends $tea.Model {
  suspiciousHighCount?: number;
  suspiciousLowCount?: number;
  suspiciousMediumCount?: number;
  vulHighCount?: number;
  vulLowCount?: number;
  vulMediumCount?: number;
  weakPassWordCount?: number;
  static names(): { [key: string]: string } {
    return {
      suspiciousHighCount: 'SuspiciousHighCount',
      suspiciousLowCount: 'SuspiciousLowCount',
      suspiciousMediumCount: 'SuspiciousMediumCount',
      vulHighCount: 'VulHighCount',
      vulLowCount: 'VulLowCount',
      vulMediumCount: 'VulMediumCount',
      weakPassWordCount: 'WeakPassWordCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      suspiciousHighCount: 'number',
      suspiciousLowCount: 'number',
      suspiciousMediumCount: 'number',
      vulHighCount: 'number',
      vulLowCount: 'number',
      vulMediumCount: 'number',
      weakPassWordCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInstanceRiskNumResponseBodyInstanceRiskNum extends $tea.Model {
  instanceItem?: ListInstanceRiskNumResponseBodyInstanceRiskNumInstanceItem;
  riskNumEntity?: ListInstanceRiskNumResponseBodyInstanceRiskNumRiskNumEntity;
  static names(): { [key: string]: string } {
    return {
      instanceItem: 'InstanceItem',
      riskNumEntity: 'RiskNumEntity',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceItem: ListInstanceRiskNumResponseBodyInstanceRiskNumInstanceItem,
      riskNumEntity: ListInstanceRiskNumResponseBodyInstanceRiskNumRiskNumEntity,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionHistoryResponseBodyInterceptionHistoryList extends $tea.Model {
  clusterId?: string;
  clusterName?: string;
  dstAppName?: string;
  dstNamespace?: string;
  dstPort?: number;
  dstRuleTargetName?: string;
  firstTime?: number;
  id?: number;
  interceptionName?: number;
  interceptionType?: number;
  lastTime?: number;
  realDstAppName?: string;
  realDstImageName?: string;
  realDstNamespace?: string;
  realDstPodName?: string;
  realInterceptionType?: number;
  realSrcAppName?: string;
  realSrcImageName?: string;
  realSrcNamespace?: string;
  realSrcPodName?: string;
  riskLevel?: number;
  ruleId?: number;
  ruleName?: string;
  srcAppName?: string;
  srcNamespace?: string;
  srcRuleTargetName?: string;
  status?: number;
  tryCount?: number;
  static names(): { [key: string]: string } {
    return {
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      dstAppName: 'DstAppName',
      dstNamespace: 'DstNamespace',
      dstPort: 'DstPort',
      dstRuleTargetName: 'DstRuleTargetName',
      firstTime: 'FirstTime',
      id: 'Id',
      interceptionName: 'InterceptionName',
      interceptionType: 'InterceptionType',
      lastTime: 'LastTime',
      realDstAppName: 'RealDstAppName',
      realDstImageName: 'RealDstImageName',
      realDstNamespace: 'RealDstNamespace',
      realDstPodName: 'RealDstPodName',
      realInterceptionType: 'RealInterceptionType',
      realSrcAppName: 'RealSrcAppName',
      realSrcImageName: 'RealSrcImageName',
      realSrcNamespace: 'RealSrcNamespace',
      realSrcPodName: 'RealSrcPodName',
      riskLevel: 'RiskLevel',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      srcAppName: 'SrcAppName',
      srcNamespace: 'SrcNamespace',
      srcRuleTargetName: 'SrcRuleTargetName',
      status: 'Status',
      tryCount: 'TryCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterId: 'string',
      clusterName: 'string',
      dstAppName: 'string',
      dstNamespace: 'string',
      dstPort: 'number',
      dstRuleTargetName: 'string',
      firstTime: 'number',
      id: 'number',
      interceptionName: 'number',
      interceptionType: 'number',
      lastTime: 'number',
      realDstAppName: 'string',
      realDstImageName: 'string',
      realDstNamespace: 'string',
      realDstPodName: 'string',
      realInterceptionType: 'number',
      realSrcAppName: 'string',
      realSrcImageName: 'string',
      realSrcNamespace: 'string',
      realSrcPodName: 'string',
      riskLevel: 'number',
      ruleId: 'number',
      ruleName: 'string',
      srcAppName: 'string',
      srcNamespace: 'string',
      srcRuleTargetName: 'string',
      status: 'number',
      tryCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionHistoryResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget extends $tea.Model {
  appName?: string;
  imageList?: string[];
  namespace?: string;
  ports?: string[];
  ruleType?: string;
  tagList?: string[];
  targetId?: number;
  targetName?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      imageList: 'ImageList',
      namespace: 'Namespace',
      ports: 'Ports',
      ruleType: 'RuleType',
      tagList: 'TagList',
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      imageList: { 'type': 'array', 'itemType': 'string' },
      namespace: 'string',
      ports: { 'type': 'array', 'itemType': 'string' },
      ruleType: 'string',
      tagList: { 'type': 'array', 'itemType': 'string' },
      targetId: 'number',
      targetName: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget extends $tea.Model {
  appName?: string;
  imageList?: string[];
  namespace?: string;
  ruleType?: string;
  tagList?: string[];
  targetId?: number;
  targetName?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      imageList: 'ImageList',
      namespace: 'Namespace',
      ruleType: 'RuleType',
      tagList: 'TagList',
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      imageList: { 'type': 'array', 'itemType': 'string' },
      namespace: 'string',
      ruleType: 'string',
      tagList: { 'type': 'array', 'itemType': 'string' },
      targetId: 'number',
      targetName: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionRulePageResponseBodyInterceptionRuleList extends $tea.Model {
  dstTarget?: ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget;
  interceptType?: number;
  orderIndex?: number;
  ruleId?: number;
  ruleName?: string;
  ruleSwitch?: number;
  ruleType?: string;
  srcTarget?: ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget;
  static names(): { [key: string]: string } {
    return {
      dstTarget: 'DstTarget',
      interceptType: 'InterceptType',
      orderIndex: 'OrderIndex',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleSwitch: 'RuleSwitch',
      ruleType: 'RuleType',
      srcTarget: 'SrcTarget',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dstTarget: ListInterceptionRulePageResponseBodyInterceptionRuleListDstTarget,
      interceptType: 'number',
      orderIndex: 'number',
      ruleId: 'number',
      ruleName: 'string',
      ruleSwitch: 'number',
      ruleType: 'string',
      srcTarget: ListInterceptionRulePageResponseBodyInterceptionRuleListSrcTarget,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionRulePageResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionTargetPageResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListInterceptionTargetPageResponseBodyRuleTargetList extends $tea.Model {
  appName?: string;
  clusterId?: string;
  clusterName?: string;
  imageList?: string[];
  namespace?: string;
  ruleType?: string;
  tagList?: string[];
  targetId?: number;
  targetName?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      appName: 'AppName',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      imageList: 'ImageList',
      namespace: 'Namespace',
      ruleType: 'RuleType',
      tagList: 'TagList',
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      appName: 'string',
      clusterId: 'string',
      clusterName: 'string',
      imageList: { 'type': 'array', 'itemType': 'string' },
      namespace: 'string',
      ruleType: 'string',
      tagList: { 'type': 'array', 'itemType': 'string' },
      targetId: 'number',
      targetName: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListObjectScanEventResponseBodyDataDetails extends $tea.Model {
  name?: string;
  nameDisplay?: string;
  type?: string;
  value?: string;
  valueDisplay?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      nameDisplay: 'NameDisplay',
      type: 'Type',
      value: 'Value',
      valueDisplay: 'ValueDisplay',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      nameDisplay: 'string',
      type: 'string',
      value: 'string',
      valueDisplay: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListObjectScanEventResponseBodyData extends $tea.Model {
  bucketName?: string;
  details?: ListObjectScanEventResponseBodyDataDetails[];
  displaySandboxResult?: string;
  eventId?: number;
  eventName?: string;
  filePath?: string;
  firstTime?: number;
  lastTime?: number;
  md5?: string;
  ossKey?: string;
  riskLevel?: string;
  sha1?: string;
  sha256?: string;
  source?: string;
  static names(): { [key: string]: string } {
    return {
      bucketName: 'BucketName',
      details: 'Details',
      displaySandboxResult: 'DisplaySandboxResult',
      eventId: 'EventId',
      eventName: 'EventName',
      filePath: 'FilePath',
      firstTime: 'FirstTime',
      lastTime: 'LastTime',
      md5: 'Md5',
      ossKey: 'OssKey',
      riskLevel: 'RiskLevel',
      sha1: 'Sha1',
      sha256: 'Sha256',
      source: 'Source',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketName: 'string',
      details: { 'type': 'array', 'itemType': ListObjectScanEventResponseBodyDataDetails },
      displaySandboxResult: 'string',
      eventId: 'number',
      eventName: 'string',
      filePath: 'string',
      firstTime: 'number',
      lastTime: 'number',
      md5: 'string',
      ossKey: 'string',
      riskLevel: 'string',
      sha1: 'string',
      sha256: 'string',
      source: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListObjectScanEventResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOssBucketResponseBodyData extends $tea.Model {
  bucketName?: string;
  message?: string;
  regionId?: string;
  storageClass?: string;
  support?: boolean;
  static names(): { [key: string]: string } {
    return {
      bucketName: 'BucketName',
      message: 'Message',
      regionId: 'RegionId',
      storageClass: 'StorageClass',
      support: 'Support',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketName: 'string',
      message: 'string',
      regionId: 'string',
      storageClass: 'string',
      support: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOssBucketScanInfoResponseBodyData extends $tea.Model {
  bucketName?: string;
  highRisk?: number;
  lastScanEndTime?: number;
  lastScanTime?: number;
  lowRisk?: number;
  mediumRisk?: number;
  message?: string;
  regionId?: string;
  scanObject?: number;
  scanned?: boolean;
  status?: number;
  storageClass?: string;
  support?: boolean;
  totalObject?: number;
  static names(): { [key: string]: string } {
    return {
      bucketName: 'BucketName',
      highRisk: 'HighRisk',
      lastScanEndTime: 'LastScanEndTime',
      lastScanTime: 'LastScanTime',
      lowRisk: 'LowRisk',
      mediumRisk: 'MediumRisk',
      message: 'Message',
      regionId: 'RegionId',
      scanObject: 'ScanObject',
      scanned: 'Scanned',
      status: 'Status',
      storageClass: 'StorageClass',
      support: 'Support',
      totalObject: 'TotalObject',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bucketName: 'string',
      highRisk: 'number',
      lastScanEndTime: 'number',
      lastScanTime: 'number',
      lowRisk: 'number',
      mediumRisk: 'number',
      message: 'string',
      regionId: 'string',
      scanObject: 'number',
      scanned: 'boolean',
      status: 'number',
      storageClass: 'string',
      support: 'boolean',
      totalObject: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListOssBucketScanInfoResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList extends $tea.Model {
  config?: boolean;
  msg?: string;
  overallConfig?: boolean;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      config: 'Config',
      msg: 'Msg',
      overallConfig: 'OverallConfig',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      config: 'boolean',
      msg: 'string',
      overallConfig: 'boolean',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigList extends $tea.Model {
  aegisSuspiciousConfigList?: ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList[];
  pluginInstallCode?: string;
  pluginName?: string;
  pluginOnlineInstalled?: boolean;
  pluginOnlineStatus?: boolean;
  pluginVersion?: string;
  static names(): { [key: string]: string } {
    return {
      aegisSuspiciousConfigList: 'AegisSuspiciousConfigList',
      pluginInstallCode: 'PluginInstallCode',
      pluginName: 'PluginName',
      pluginOnlineInstalled: 'PluginOnlineInstalled',
      pluginOnlineStatus: 'PluginOnlineStatus',
      pluginVersion: 'PluginVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aegisSuspiciousConfigList: { 'type': 'array', 'itemType': ListPluginForUuidResponseBodyAegisUuidTargetPluginConfigListAegisSuspiciousConfigList },
      pluginInstallCode: 'string',
      pluginName: 'string',
      pluginOnlineInstalled: 'boolean',
      pluginOnlineStatus: 'boolean',
      pluginVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPodRiskResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPodRiskResponseBodyPodRiskList extends $tea.Model {
  alarmCount?: number;
  clusterId?: string;
  clusterName?: string;
  createTime?: number;
  hcCount?: number;
  instanceId?: string;
  namespace?: string;
  nodeName?: string;
  pod?: string;
  podIp?: string;
  vulCount?: number;
  static names(): { [key: string]: string } {
    return {
      alarmCount: 'AlarmCount',
      clusterId: 'ClusterId',
      clusterName: 'ClusterName',
      createTime: 'CreateTime',
      hcCount: 'HcCount',
      instanceId: 'InstanceId',
      namespace: 'Namespace',
      nodeName: 'NodeName',
      pod: 'Pod',
      podIp: 'PodIp',
      vulCount: 'VulCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alarmCount: 'number',
      clusterId: 'string',
      clusterName: 'string',
      createTime: 'number',
      hcCount: 'number',
      instanceId: 'string',
      namespace: 'string',
      nodeName: 'string',
      pod: 'string',
      podIp: 'string',
      vulCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrivateRegistryListResponseBodyImageRegistryInfos extends $tea.Model {
  aliUid?: number;
  domainName?: string;
  id?: number;
  jenkinsEnv?: string;
  netType?: number;
  password?: string;
  persistenceDay?: number;
  protocolType?: number;
  regionId?: string;
  registryHostIp?: string;
  registryName?: string;
  registryType?: string;
  registryVersion?: string;
  token?: string;
  transPerHour?: number;
  userName?: string;
  vpcId?: string;
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      domainName: 'DomainName',
      id: 'Id',
      jenkinsEnv: 'JenkinsEnv',
      netType: 'NetType',
      password: 'Password',
      persistenceDay: 'PersistenceDay',
      protocolType: 'ProtocolType',
      regionId: 'RegionId',
      registryHostIp: 'RegistryHostIp',
      registryName: 'RegistryName',
      registryType: 'RegistryType',
      registryVersion: 'RegistryVersion',
      token: 'Token',
      transPerHour: 'TransPerHour',
      userName: 'UserName',
      vpcId: 'VpcId',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'number',
      domainName: 'string',
      id: 'number',
      jenkinsEnv: 'string',
      netType: 'number',
      password: 'string',
      persistenceDay: 'number',
      protocolType: 'number',
      regionId: 'string',
      registryHostIp: 'string',
      registryName: 'string',
      registryType: 'string',
      registryVersion: 'string',
      token: 'string',
      transPerHour: 'number',
      userName: 'string',
      vpcId: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListPrivateRegistryTypeResponseBodyRegistryTypeInfos extends $tea.Model {
  count?: number;
  registryType?: string;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      registryType: 'RegistryType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      registryType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListQueryRaspAppInfoResponseBodyData extends $tea.Model {
  raspAppName?: string;
  raspOnlineStatus?: number;
  raspStatus?: string;
  result?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      raspAppName: 'RaspAppName',
      raspOnlineStatus: 'RaspOnlineStatus',
      raspStatus: 'RaspStatus',
      result: 'Result',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      raspAppName: 'string',
      raspOnlineStatus: 'number',
      raspStatus: 'string',
      result: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListRuleTargetAllResponseBodyRuleTargetList extends $tea.Model {
  targetId?: number;
  targetName?: string;
  targetType?: string;
  static names(): { [key: string]: string } {
    return {
      targetId: 'TargetId',
      targetName: 'TargetName',
      targetType: 'TargetType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      targetId: 'number',
      targetName: 'string',
      targetType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemAggregationRulesResponseBodyAggregationList extends $tea.Model {
  id?: number;
  name?: string;
  ruleCount?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
      ruleCount: 'RuleCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
      ruleCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemAggregationRulesResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemClientRulesResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemClientRulesResponseBodyRuleListPolicies extends $tea.Model {
  policyKey?: string;
  policyName?: string;
  static names(): { [key: string]: string } {
    return {
      policyKey: 'PolicyKey',
      policyName: 'PolicyName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      policyKey: 'string',
      policyName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemClientRulesResponseBodyRuleList extends $tea.Model {
  aggregationName?: string;
  description?: string;
  platform?: string;
  policies?: ListSystemClientRulesResponseBodyRuleListPolicies[];
  ruleId?: number;
  ruleName?: string;
  ruleType?: number;
  status?: number;
  switchId?: string;
  static names(): { [key: string]: string } {
    return {
      aggregationName: 'AggregationName',
      description: 'Description',
      platform: 'Platform',
      policies: 'Policies',
      ruleId: 'RuleId',
      ruleName: 'RuleName',
      ruleType: 'RuleType',
      status: 'Status',
      switchId: 'SwitchId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aggregationName: 'string',
      description: 'string',
      platform: 'string',
      policies: { 'type': 'array', 'itemType': ListSystemClientRulesResponseBodyRuleListPolicies },
      ruleId: 'number',
      ruleName: 'string',
      ruleType: 'number',
      status: 'number',
      switchId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListSystemRuleAggregationTypesResponseBodyAggregationTypeList extends $tea.Model {
  id?: number;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUninstallAegisMachinesResponseBodyMachineList extends $tea.Model {
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  machineRegion?: string;
  os?: string;
  regionId?: string;
  uuid?: string;
  vendor?: number;
  vendorName?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      machineRegion: 'MachineRegion',
      os: 'Os',
      regionId: 'RegionId',
      uuid: 'Uuid',
      vendor: 'Vendor',
      vendorName: 'VendorName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      machineRegion: 'string',
      os: 'string',
      regionId: 'string',
      uuid: 'string',
      vendor: 'number',
      vendorName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUuidsByWebPathResponseBodyList extends $tea.Model {
  internetIp?: string;
  intranetIp?: string;
  machineName?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      machineName: 'MachineName',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      internetIp: 'string',
      intranetIp: 'string',
      machineName: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListUuidsByWebPathResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanMachineResponseBodyData extends $tea.Model {
  eventCount?: number;
  instanceId?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      eventCount: 'EventCount',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventCount: 'number',
      instanceId: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanMachineResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanMachineEventResponseBodyDataDetails extends $tea.Model {
  infoType?: string;
  nameDisplay?: string;
  type?: string;
  valueDisplay?: string;
  static names(): { [key: string]: string } {
    return {
      infoType: 'InfoType',
      nameDisplay: 'NameDisplay',
      type: 'Type',
      valueDisplay: 'ValueDisplay',
    };
  }

  static types(): { [key: string]: any } {
    return {
      infoType: 'string',
      nameDisplay: 'string',
      type: 'string',
      valueDisplay: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanMachineEventResponseBodyData extends $tea.Model {
  details?: ListVirusScanMachineEventResponseBodyDataDetails[];
  eventId?: number;
  eventName?: string;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  lastTimeStamp?: number;
  level?: string;
  static names(): { [key: string]: string } {
    return {
      details: 'Details',
      eventId: 'EventId',
      eventName: 'EventName',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      lastTimeStamp: 'LastTimeStamp',
      level: 'Level',
    };
  }

  static types(): { [key: string]: any } {
    return {
      details: { 'type': 'array', 'itemType': ListVirusScanMachineEventResponseBodyDataDetails },
      eventId: 'number',
      eventName: 'string',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      lastTimeStamp: 'number',
      level: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanMachineEventResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanTaskResponseBodyList extends $tea.Model {
  endTime?: number;
  instanceName?: string;
  internetIp?: string;
  intranetIp?: string;
  progress?: number;
  scanPath?: string[];
  scanType?: string;
  startTime?: number;
  status?: number;
  taskId?: string;
  taskName?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      endTime: 'EndTime',
      instanceName: 'InstanceName',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      progress: 'Progress',
      scanPath: 'ScanPath',
      scanType: 'ScanType',
      startTime: 'StartTime',
      status: 'Status',
      taskId: 'TaskId',
      taskName: 'TaskName',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      endTime: 'number',
      instanceName: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      progress: 'number',
      scanPath: { 'type': 'array', 'itemType': 'string' },
      scanType: 'string',
      startTime: 'number',
      status: 'number',
      taskId: 'string',
      taskName: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVirusScanTaskResponseBodyPageInfo extends $tea.Model {
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVulAutoRepairConfigResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVulAutoRepairConfigResponseBodyVulAutoRepairConfigList extends $tea.Model {
  aliasName?: string;
  id?: number;
  name?: string;
  reason?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      aliasName: 'AliasName',
      id: 'Id',
      name: 'Name',
      reason: 'Reason',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliasName: 'string',
      id: 'number',
      name: 'string',
      reason: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListVulGlobalConfigResponseBodyVulGlobalConfigList extends $tea.Model {
  configKey?: string;
  configValue?: string;
  static names(): { [key: string]: string } {
    return {
      configKey: 'ConfigKey',
      configValue: 'ConfigValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      configKey: 'string',
      configValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyAssetCleanConfigRequestAssetCleanConfigs extends $tea.Model {
  cleanDays?: number;
  status?: number;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      cleanDays: 'CleanDays',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cleanDays: 'number',
      status: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyCreateVulWhitelistResponseBodyVulWhitelistList extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList extends $tea.Model {
  groupId?: number;
  instanceId?: string;
  instanceName?: string;
  ip?: string;
  message?: string;
  online?: boolean;
  osVersion?: string;
  region?: string;
  success?: boolean;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      groupId: 'GroupId',
      instanceId: 'InstanceId',
      instanceName: 'InstanceName',
      ip: 'Ip',
      message: 'Message',
      online: 'Online',
      osVersion: 'OsVersion',
      region: 'Region',
      success: 'Success',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      groupId: 'number',
      instanceId: 'string',
      instanceName: 'string',
      ip: 'string',
      message: 'string',
      online: 'boolean',
      osVersion: 'string',
      region: 'string',
      success: 'boolean',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyPushAllTaskResponseBodyPushTaskRsp extends $tea.Model {
  pushTaskResultList?: ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList[];
  static names(): { [key: string]: string } {
    return {
      pushTaskResultList: 'PushTaskResultList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pushTaskResultList: { 'type': 'array', 'itemType': ModifyPushAllTaskResponseBodyPushTaskRspPushTaskResultList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyStrategyResponseBodyResult extends $tea.Model {
  strategyId?: number;
  static names(): { [key: string]: string } {
    return {
      strategyId: 'StrategyId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      strategyId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OpenSensitiveFileScanResponseBodyData extends $tea.Model {
  switchOn?: string;
  static names(): { [key: string]: string } {
    return {
      switchOn: 'SwitchOn',
    };
  }

  static types(): { [key: string]: any } {
    return {
      switchOn: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateAgentClientInstallResponseBodyAegisCelintInstallResposeList extends $tea.Model {
  instanceId?: string;
  recordId?: number;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      instanceId: 'InstanceId',
      recordId: 'RecordId',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      instanceId: 'string',
      recordId: 'number',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageImageRegistryResponseBodyList extends $tea.Model {
  blackList?: string;
  domainName?: string;
  gmtCreate?: string;
  gmtModified?: string;
  id?: number;
  imageCount?: number;
  jenkinsEnv?: string;
  netType?: number;
  password?: string;
  persistenceDay?: number;
  protocolType?: number;
  regionId?: string;
  registryHostIp?: string;
  registryName?: string;
  registryType?: string;
  token?: string;
  transPerHour?: number;
  userName?: string;
  vpcId?: string;
  whiteList?: string;
  static names(): { [key: string]: string } {
    return {
      blackList: 'BlackList',
      domainName: 'DomainName',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      imageCount: 'ImageCount',
      jenkinsEnv: 'JenkinsEnv',
      netType: 'NetType',
      password: 'Password',
      persistenceDay: 'PersistenceDay',
      protocolType: 'ProtocolType',
      regionId: 'RegionId',
      registryHostIp: 'RegistryHostIp',
      registryName: 'RegistryName',
      registryType: 'RegistryType',
      token: 'Token',
      transPerHour: 'TransPerHour',
      userName: 'UserName',
      vpcId: 'VpcId',
      whiteList: 'WhiteList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blackList: 'string',
      domainName: 'string',
      gmtCreate: 'string',
      gmtModified: 'string',
      id: 'number',
      imageCount: 'number',
      jenkinsEnv: 'string',
      netType: 'number',
      password: 'string',
      persistenceDay: 'number',
      protocolType: 'number',
      regionId: 'string',
      registryHostIp: 'string',
      registryName: 'string',
      registryType: 'string',
      token: 'string',
      transPerHour: 'number',
      userName: 'string',
      vpcId: 'string',
      whiteList: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PageImageRegistryResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublicCreateImageScanTaskResponseBodyData extends $tea.Model {
  canCreate?: boolean;
  collectTime?: number;
  execTime?: number;
  finishCount?: number;
  progress?: number;
  result?: string;
  status?: string;
  taskId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      canCreate: 'CanCreate',
      collectTime: 'CollectTime',
      execTime: 'ExecTime',
      finishCount: 'FinishCount',
      progress: 'Progress',
      result: 'Result',
      status: 'Status',
      taskId: 'TaskId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canCreate: 'boolean',
      collectTime: 'number',
      execTime: 'number',
      finishCount: 'number',
      progress: 'number',
      result: 'string',
      status: 'string',
      taskId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublicPreCheckImageScanTaskResponseBodyData extends $tea.Model {
  needAuthCount?: number;
  scanImageCount?: number;
  static names(): { [key: string]: string } {
    return {
      needAuthCount: 'NeedAuthCount',
      scanImageCount: 'ScanImageCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      needAuthCount: 'number',
      scanImageCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PublicSyncAndCreateImageScanTaskResponseBodyData extends $tea.Model {
  canCreate?: boolean;
  collectTime?: number;
  execTime?: number;
  finishCount?: number;
  progress?: number;
  result?: string;
  status?: string;
  taskId?: string;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      canCreate: 'CanCreate',
      collectTime: 'CollectTime',
      execTime: 'ExecTime',
      finishCount: 'FinishCount',
      progress: 'Progress',
      result: 'Result',
      status: 'Status',
      taskId: 'TaskId',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      canCreate: 'boolean',
      collectTime: 'number',
      execTime: 'number',
      finishCount: 'number',
      progress: 'number',
      result: 'string',
      status: 'string',
      taskId: 'string',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryAttackCountResponseBodyData extends $tea.Model {
  eventCount?: number;
  tacticId?: string;
  tacticType?: string;
  static names(): { [key: string]: string } {
    return {
      eventCount: 'EventCount',
      tacticId: 'TacticId',
      tacticType: 'TacticType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      eventCount: 'number',
      tacticId: 'string',
      tacticType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGroupedSecurityEventMarkMissListResponseBodyList extends $tea.Model {
  aliUid?: number;
  disposalWay?: string;
  eventName?: string;
  eventNameOriginal?: string;
  eventType?: string;
  eventTypeOriginal?: string;
  field?: string;
  fieldValue?: string;
  filedAliasName?: string;
  operate?: string;
  uuids?: string;
  static names(): { [key: string]: string } {
    return {
      aliUid: 'AliUid',
      disposalWay: 'DisposalWay',
      eventName: 'EventName',
      eventNameOriginal: 'EventNameOriginal',
      eventType: 'EventType',
      eventTypeOriginal: 'EventTypeOriginal',
      field: 'Field',
      fieldValue: 'FieldValue',
      filedAliasName: 'FiledAliasName',
      operate: 'Operate',
      uuids: 'Uuids',
    };
  }

  static types(): { [key: string]: any } {
    return {
      aliUid: 'number',
      disposalWay: 'string',
      eventName: 'string',
      eventNameOriginal: 'string',
      eventType: 'string',
      eventTypeOriginal: 'string',
      field: 'string',
      fieldValue: 'string',
      filedAliasName: 'string',
      operate: 'string',
      uuids: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryGroupedSecurityEventMarkMissListResponseBodyPageInfo extends $tea.Model {
  count?: number;
  currentPage?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      currentPage: 'CurrentPage',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      currentPage: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetImageSensitiveFileStatusResponseBodyData extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SetSensitiveDefineRuleConfigResponseBodyData extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StopHoneypotResponseBodyData extends $tea.Model {
  controlNodeName?: string;
  honeypotId?: string;
  honeypotImageDisplayName?: string;
  honeypotImageName?: string;
  honeypotName?: string;
  nodeId?: string;
  presetId?: string;
  state?: string[];
  static names(): { [key: string]: string } {
    return {
      controlNodeName: 'ControlNodeName',
      honeypotId: 'HoneypotId',
      honeypotImageDisplayName: 'HoneypotImageDisplayName',
      honeypotImageName: 'HoneypotImageName',
      honeypotName: 'HoneypotName',
      nodeId: 'NodeId',
      presetId: 'PresetId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      controlNodeName: 'string',
      honeypotId: 'string',
      honeypotImageDisplayName: 'string',
      honeypotImageName: 'string',
      honeypotName: 'string',
      nodeId: 'string',
      presetId: 'string',
      state: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitCheckResponseBodyData extends $tea.Model {
  operateCode?: string;
  static names(): { [key: string]: string } {
    return {
      operateCode: 'OperateCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operateCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotResponseBodyData extends $tea.Model {
  honeypotId?: string;
  honeypotImageDisplayName?: string;
  honeypotImageName?: string;
  honeypotName?: string;
  nodeId?: string;
  presetId?: string;
  state?: string[];
  static names(): { [key: string]: string } {
    return {
      honeypotId: 'HoneypotId',
      honeypotImageDisplayName: 'HoneypotImageDisplayName',
      honeypotImageName: 'HoneypotImageName',
      honeypotName: 'HoneypotName',
      nodeId: 'NodeId',
      presetId: 'PresetId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      honeypotId: 'string',
      honeypotImageDisplayName: 'string',
      honeypotImageName: 'string',
      honeypotName: 'string',
      nodeId: 'string',
      presetId: 'string',
      state: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateHoneypotProbeBindRequestBindPortList extends $tea.Model {
  bindPort?: boolean;
  endPort?: number;
  fixed?: boolean;
  id?: number;
  proto?: string;
  startPort?: number;
  targetPort?: number;
  static names(): { [key: string]: string } {
    return {
      bindPort: 'BindPort',
      endPort: 'EndPort',
      fixed: 'Fixed',
      id: 'Id',
      proto: 'Proto',
      startPort: 'StartPort',
      targetPort: 'TargetPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bindPort: 'boolean',
      endPort: 'number',
      fixed: 'boolean',
      id: 'number',
      proto: 'string',
      startPort: 'number',
      targetPort: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateImageEventOperationResponseBodyData extends $tea.Model {
  id?: number;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyCheckInstanceResultResponseBodyData extends $tea.Model {
  failInstances?: string[];
  operateCode?: string;
  static names(): { [key: string]: string } {
    return {
      failInstances: 'FailInstances',
      operateCode: 'OperateCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      failInstances: { 'type': 'array', 'itemType': 'string' },
      operateCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class VerifyCheckResultResponseBodyData extends $tea.Model {
  operateCode?: string;
  static names(): { [key: string]: string } {
    return {
      operateCode: 'OperateCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      operateCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._endpointRule = "regional";
    this._endpointMap = {
      'cn-hangzhou': "tds.aliyuncs.com",
      'cn-qingdao': "tds.aliyuncs.com",
      'cn-beijing': "tds.aliyuncs.com",
      'cn-zhangjiakou': "tds.aliyuncs.com",
      'cn-huhehaote': "tds.aliyuncs.com",
      'cn-wulanchabu': "tds.aliyuncs.com",
      'cn-shanghai': "tds.aliyuncs.com",
      'cn-nanjing': "tds.aliyuncs.com",
      'cn-fuzhou': "tds.aliyuncs.com",
      'cn-shenzhen': "tds.aliyuncs.com",
      'cn-heyuan': "tds.aliyuncs.com",
      'cn-guangzhou': "tds.aliyuncs.com",
      'cn-chengdu': "tds.aliyuncs.com",
      'cn-hongkong': "tds.aliyuncs.com",
      'ap-southeast-1': "tds.ap-southeast-1.aliyuncs.com",
      'ap-northeast-1': "tds.ap-southeast-1.aliyuncs.com",
      'ap-northeast-2': "tds.ap-southeast-1.aliyuncs.com",
      'ap-southeast-2': "tds.ap-southeast-1.aliyuncs.com",
      'ap-southeast-3': "tds.ap-southeast-1.aliyuncs.com",
      'ap-southeast-5': "tds.ap-southeast-1.aliyuncs.com",
      'ap-southeast-6': "tds.ap-southeast-1.aliyuncs.com",
      'ap-southeast-7': "tds.ap-southeast-1.aliyuncs.com",
      'us-east-1': "tds.ap-southeast-1.aliyuncs.com",
      'us-west-1': "tds.ap-southeast-1.aliyuncs.com",
      'eu-west-1': "tds.ap-southeast-1.aliyuncs.com",
      'eu-central-1': "tds.ap-southeast-1.aliyuncs.com",
      'ap-south-1': "tds.ap-southeast-1.aliyuncs.com",
      'me-east-1': "tds.ap-southeast-1.aliyuncs.com",
      'me-central-1': "tds.ap-southeast-1.aliyuncs.com",
      'cn-hangzhou-finance': "tds.aliyuncs.com",
      'cn-shanghai-finance-1': "tds.aliyuncs.com",
      'cn-shenzhen-finance-1': "tds.aliyuncs.com",
      'cn-beijing-finance-1': "tds.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("sas", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  async addAssetSelectionCriteriaWithOptions(request: AddAssetSelectionCriteriaRequest, runtime: $Util.RuntimeOptions): Promise<AddAssetSelectionCriteriaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.criteria)) {
      query["Criteria"] = request.criteria;
    }

    if (!Util.isUnset(request.criteriaOperation)) {
      query["CriteriaOperation"] = request.criteriaOperation;
    }

    if (!Util.isUnset(request.selectionKey)) {
      query["SelectionKey"] = request.selectionKey;
    }

    if (!Util.isUnset(request.targetOperationList)) {
      query["TargetOperationList"] = request.targetOperationList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddAssetSelectionCriteria",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddAssetSelectionCriteriaResponse>(await this.callApi(params, req, runtime), new AddAssetSelectionCriteriaResponse({}));
  }

  async addAssetSelectionCriteria(request: AddAssetSelectionCriteriaRequest): Promise<AddAssetSelectionCriteriaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addAssetSelectionCriteriaWithOptions(request, runtime);
  }

  async addCheckInstanceResultWhiteListWithOptions(request: AddCheckInstanceResultWhiteListRequest, runtime: $Util.RuntimeOptions): Promise<AddCheckInstanceResultWhiteListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkGroupId)) {
      query["CheckGroupId"] = request.checkGroupId;
    }

    if (!Util.isUnset(request.checkId)) {
      query["CheckId"] = request.checkId;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddCheckInstanceResultWhiteList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddCheckInstanceResultWhiteListResponse>(await this.callApi(params, req, runtime), new AddCheckInstanceResultWhiteListResponse({}));
  }

  async addCheckInstanceResultWhiteList(request: AddCheckInstanceResultWhiteListRequest): Promise<AddCheckInstanceResultWhiteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCheckInstanceResultWhiteListWithOptions(request, runtime);
  }

  async addCheckResultWhiteListWithOptions(request: AddCheckResultWhiteListRequest, runtime: $Util.RuntimeOptions): Promise<AddCheckResultWhiteListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkIds)) {
      query["CheckIds"] = request.checkIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddCheckResultWhiteList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddCheckResultWhiteListResponse>(await this.callApi(params, req, runtime), new AddCheckResultWhiteListResponse({}));
  }

  async addCheckResultWhiteList(request: AddCheckResultWhiteListRequest): Promise<AddCheckResultWhiteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addCheckResultWhiteListWithOptions(request, runtime);
  }

  async addClientUserDefineRuleWithOptions(request: AddClientUserDefineRuleRequest, runtime: $Util.RuntimeOptions): Promise<AddClientUserDefineRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionType)) {
      query["ActionType"] = request.actionType;
    }

    if (!Util.isUnset(request.cmdline)) {
      query["Cmdline"] = request.cmdline;
    }

    if (!Util.isUnset(request.filePath)) {
      query["FilePath"] = request.filePath;
    }

    if (!Util.isUnset(request.IP)) {
      query["IP"] = request.IP;
    }

    if (!Util.isUnset(request.md5List)) {
      query["Md5List"] = request.md5List;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.newFilePath)) {
      query["NewFilePath"] = request.newFilePath;
    }

    if (!Util.isUnset(request.parentCmdline)) {
      query["ParentCmdline"] = request.parentCmdline;
    }

    if (!Util.isUnset(request.parentProcPath)) {
      query["ParentProcPath"] = request.parentProcPath;
    }

    if (!Util.isUnset(request.platform)) {
      query["Platform"] = request.platform;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.portStr)) {
      query["PortStr"] = request.portStr;
    }

    if (!Util.isUnset(request.procPath)) {
      query["ProcPath"] = request.procPath;
    }

    if (!Util.isUnset(request.registryContent)) {
      query["RegistryContent"] = request.registryContent;
    }

    if (!Util.isUnset(request.registryKey)) {
      query["RegistryKey"] = request.registryKey;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddClientUserDefineRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddClientUserDefineRuleResponse>(await this.callApi(params, req, runtime), new AddClientUserDefineRuleResponse({}));
  }

  async addClientUserDefineRule(request: AddClientUserDefineRuleRequest): Promise<AddClientUserDefineRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addClientUserDefineRuleWithOptions(request, runtime);
  }

  async addContainerDefenseRuleWithOptions(tmpReq: AddContainerDefenseRuleRequest, runtime: $Util.RuntimeOptions): Promise<AddContainerDefenseRuleResponse> {
    Util.validateModel(tmpReq);
    let request = new AddContainerDefenseRuleShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.whitelist)) {
      request.whitelistShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.whitelist, "Whitelist", "json");
    }

    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.ruleAction)) {
      query["RuleAction"] = request.ruleAction;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleSwitch)) {
      query["RuleSwitch"] = request.ruleSwitch;
    }

    if (!Util.isUnset(request.ruleType)) {
      query["RuleType"] = request.ruleType;
    }

    if (!Util.isUnset(request.scope)) {
      query["Scope"] = request.scope;
    }

    if (!Util.isUnset(request.whitelistShrink)) {
      query["Whitelist"] = request.whitelistShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddContainerDefenseRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddContainerDefenseRuleResponse>(await this.callApi(params, req, runtime), new AddContainerDefenseRuleResponse({}));
  }

  async addContainerDefenseRule(request: AddContainerDefenseRuleRequest): Promise<AddContainerDefenseRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addContainerDefenseRuleWithOptions(request, runtime);
  }

  async addImageEventOperationWithOptions(request: AddImageEventOperationRequest, runtime: $Util.RuntimeOptions): Promise<AddImageEventOperationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.conditions)) {
      query["Conditions"] = request.conditions;
    }

    if (!Util.isUnset(request.eventKey)) {
      query["EventKey"] = request.eventKey;
    }

    if (!Util.isUnset(request.eventName)) {
      query["EventName"] = request.eventName;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.operationCode)) {
      query["OperationCode"] = request.operationCode;
    }

    if (!Util.isUnset(request.scenarios)) {
      query["Scenarios"] = request.scenarios;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddImageEventOperation",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddImageEventOperationResponse>(await this.callApi(params, req, runtime), new AddImageEventOperationResponse({}));
  }

  async addImageEventOperation(request: AddImageEventOperationRequest): Promise<AddImageEventOperationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addImageEventOperationWithOptions(request, runtime);
  }

  async addImageVulWhiteListWithOptions(request: AddImageVulWhiteListRequest, runtime: $Util.RuntimeOptions): Promise<AddImageVulWhiteListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.reason)) {
      query["Reason"] = request.reason;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.target)) {
      query["Target"] = request.target;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.whitelist)) {
      query["Whitelist"] = request.whitelist;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddImageVulWhiteList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddImageVulWhiteListResponse>(await this.callApi(params, req, runtime), new AddImageVulWhiteListResponse({}));
  }

  async addImageVulWhiteList(request: AddImageVulWhiteListRequest): Promise<AddImageVulWhiteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addImageVulWhiteListWithOptions(request, runtime);
  }

  async addInstallCodeWithOptions(request: AddInstallCodeRequest, runtime: $Util.RuntimeOptions): Promise<AddInstallCodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.expiredDate)) {
      query["ExpiredDate"] = request.expiredDate;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.onlyImage)) {
      query["OnlyImage"] = request.onlyImage;
    }

    if (!Util.isUnset(request.os)) {
      query["Os"] = request.os;
    }

    if (!Util.isUnset(request.proxyCluster)) {
      query["ProxyCluster"] = request.proxyCluster;
    }

    if (!Util.isUnset(request.vendorName)) {
      query["VendorName"] = request.vendorName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddInstallCode",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddInstallCodeResponse>(await this.callApi(params, req, runtime), new AddInstallCodeResponse({}));
  }

  async addInstallCode(request: AddInstallCodeRequest): Promise<AddInstallCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addInstallCodeWithOptions(request, runtime);
  }

  async addPrivateRegistryWithOptions(request: AddPrivateRegistryRequest, runtime: $Util.RuntimeOptions): Promise<AddPrivateRegistryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.extraParam)) {
      query["ExtraParam"] = request.extraParam;
    }

    if (!Util.isUnset(request.netType)) {
      query["NetType"] = request.netType;
    }

    if (!Util.isUnset(request.password)) {
      query["Password"] = request.password;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.protocolType)) {
      query["ProtocolType"] = request.protocolType;
    }

    if (!Util.isUnset(request.registryHostIp)) {
      query["RegistryHostIp"] = request.registryHostIp;
    }

    if (!Util.isUnset(request.registryRegionId)) {
      query["RegistryRegionId"] = request.registryRegionId;
    }

    if (!Util.isUnset(request.registryType)) {
      query["RegistryType"] = request.registryType;
    }

    if (!Util.isUnset(request.registryVersion)) {
      query["RegistryVersion"] = request.registryVersion;
    }

    if (!Util.isUnset(request.transPerHour)) {
      query["TransPerHour"] = request.transPerHour;
    }

    if (!Util.isUnset(request.userName)) {
      query["UserName"] = request.userName;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddPrivateRegistry",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddPrivateRegistryResponse>(await this.callApi(params, req, runtime), new AddPrivateRegistryResponse({}));
  }

  async addPrivateRegistry(request: AddPrivateRegistryRequest): Promise<AddPrivateRegistryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addPrivateRegistryWithOptions(request, runtime);
  }

  async addSasModuleTrialWithOptions(request: AddSasModuleTrialRequest, runtime: $Util.RuntimeOptions): Promise<AddSasModuleTrialResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.moduleCode)) {
      query["ModuleCode"] = request.moduleCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddSasModuleTrial",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddSasModuleTrialResponse>(await this.callApi(params, req, runtime), new AddSasModuleTrialResponse({}));
  }

  async addSasModuleTrial(request: AddSasModuleTrialRequest): Promise<AddSasModuleTrialResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addSasModuleTrialWithOptions(request, runtime);
  }

  /**
    * Security Center provides asset importance tags and custom tags. You can call the AddTagWithUuid operation to add only a custom tag to assets.
    *
    * @param request AddTagWithUuidRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return AddTagWithUuidResponse
   */
  async addTagWithUuidWithOptions(request: AddTagWithUuidRequest, runtime: $Util.RuntimeOptions): Promise<AddTagWithUuidResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tagName)) {
      query["TagName"] = request.tagName;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddTagWithUuid",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddTagWithUuidResponse>(await this.callApi(params, req, runtime), new AddTagWithUuidResponse({}));
  }

  /**
    * Security Center provides asset importance tags and custom tags. You can call the AddTagWithUuid operation to add only a custom tag to assets.
    *
    * @param request AddTagWithUuidRequest
    * @return AddTagWithUuidResponse
   */
  async addTagWithUuid(request: AddTagWithUuidRequest): Promise<AddTagWithUuidResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addTagWithUuidWithOptions(request, runtime);
  }

  async addUninstallClientsByUuidsWithOptions(request: AddUninstallClientsByUuidsRequest, runtime: $Util.RuntimeOptions): Promise<AddUninstallClientsByUuidsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.callMethod)) {
      query["CallMethod"] = request.callMethod;
    }

    if (!Util.isUnset(request.feedback)) {
      query["Feedback"] = request.feedback;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddUninstallClientsByUuids",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddUninstallClientsByUuidsResponse>(await this.callApi(params, req, runtime), new AddUninstallClientsByUuidsResponse({}));
  }

  async addUninstallClientsByUuids(request: AddUninstallClientsByUuidsRequest): Promise<AddUninstallClientsByUuidsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addUninstallClientsByUuidsWithOptions(request, runtime);
  }

  async addVpcHoneyPotWithOptions(request: AddVpcHoneyPotRequest, runtime: $Util.RuntimeOptions): Promise<AddVpcHoneyPotResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AddVpcHoneyPot",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddVpcHoneyPotResponse>(await this.callApi(params, req, runtime), new AddVpcHoneyPotResponse({}));
  }

  async addVpcHoneyPot(request: AddVpcHoneyPotRequest): Promise<AddVpcHoneyPotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addVpcHoneyPotWithOptions(request, runtime);
  }

  async advanceSecurityEventOperationsWithOptions(request: AdvanceSecurityEventOperationsRequest, runtime: $Util.RuntimeOptions): Promise<AdvanceSecurityEventOperationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventName)) {
      query["EventName"] = request.eventName;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "AdvanceSecurityEventOperations",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AdvanceSecurityEventOperationsResponse>(await this.callApi(params, req, runtime), new AdvanceSecurityEventOperationsResponse({}));
  }

  async advanceSecurityEventOperations(request: AdvanceSecurityEventOperationsRequest): Promise<AdvanceSecurityEventOperationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.advanceSecurityEventOperationsWithOptions(request, runtime);
  }

  async batchOperateCommonOverallConfigWithOptions(request: BatchOperateCommonOverallConfigRequest, runtime: $Util.RuntimeOptions): Promise<BatchOperateCommonOverallConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.typeList)) {
      query["TypeList"] = request.typeList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BatchOperateCommonOverallConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchOperateCommonOverallConfigResponse>(await this.callApi(params, req, runtime), new BatchOperateCommonOverallConfigResponse({}));
  }

  async batchOperateCommonOverallConfig(request: BatchOperateCommonOverallConfigRequest): Promise<BatchOperateCommonOverallConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchOperateCommonOverallConfigWithOptions(request, runtime);
  }

  async bindAuthToMachineWithOptions(request: BindAuthToMachineRequest, runtime: $Util.RuntimeOptions): Promise<BindAuthToMachineResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.authVersion)) {
      query["AuthVersion"] = request.authVersion;
    }

    if (!Util.isUnset(request.autoBind)) {
      query["AutoBind"] = request.autoBind;
    }

    if (!Util.isUnset(request.bind)) {
      query["Bind"] = request.bind;
    }

    if (!Util.isUnset(request.bindAll)) {
      query["BindAll"] = request.bindAll;
    }

    if (!Util.isUnset(request.criteria)) {
      query["Criteria"] = request.criteria;
    }

    if (!Util.isUnset(request.logicalExp)) {
      query["LogicalExp"] = request.logicalExp;
    }

    if (!Util.isUnset(request.unBind)) {
      query["UnBind"] = request.unBind;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "BindAuthToMachine",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindAuthToMachineResponse>(await this.callApi(params, req, runtime), new BindAuthToMachineResponse({}));
  }

  async bindAuthToMachine(request: BindAuthToMachineRequest): Promise<BindAuthToMachineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindAuthToMachineWithOptions(request, runtime);
  }

  async cancelOnceTaskWithOptions(request: CancelOnceTaskRequest, runtime: $Util.RuntimeOptions): Promise<CancelOnceTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CancelOnceTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CancelOnceTaskResponse>(await this.callApi(params, req, runtime), new CancelOnceTaskResponse({}));
  }

  async cancelOnceTask(request: CancelOnceTaskRequest): Promise<CancelOnceTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.cancelOnceTaskWithOptions(request, runtime);
  }

  async changeAssetRefreshTaskConfigWithOptions(request: ChangeAssetRefreshTaskConfigRequest, runtime: $Util.RuntimeOptions): Promise<ChangeAssetRefreshTaskConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.assetRefreshConfigs)) {
      query["AssetRefreshConfigs"] = request.assetRefreshConfigs;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeAssetRefreshTaskConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeAssetRefreshTaskConfigResponse>(await this.callApi(params, req, runtime), new ChangeAssetRefreshTaskConfigResponse({}));
  }

  async changeAssetRefreshTaskConfig(request: ChangeAssetRefreshTaskConfigRequest): Promise<ChangeAssetRefreshTaskConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeAssetRefreshTaskConfigWithOptions(request, runtime);
  }

  async changeCheckConfigWithOptions(tmpReq: ChangeCheckConfigRequest, runtime: $Util.RuntimeOptions): Promise<ChangeCheckConfigResponse> {
    Util.validateModel(tmpReq);
    let request = new ChangeCheckConfigShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.configRequirementIds)) {
      request.configRequirementIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.configRequirementIds, "ConfigRequirementIds", "json");
    }

    if (!Util.isUnset(tmpReq.configStandardIds)) {
      request.configStandardIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.configStandardIds, "ConfigStandardIds", "json");
    }

    let query = { };
    if (!Util.isUnset(request.addedCheck)) {
      query["AddedCheck"] = request.addedCheck;
    }

    if (!Util.isUnset(request.configRequirementIdsShrink)) {
      query["ConfigRequirementIds"] = request.configRequirementIdsShrink;
    }

    if (!Util.isUnset(request.configStandardIdsShrink)) {
      query["ConfigStandardIds"] = request.configStandardIdsShrink;
    }

    if (!Util.isUnset(request.configure)) {
      query["Configure"] = request.configure;
    }

    if (!Util.isUnset(request.cycleDays)) {
      query["CycleDays"] = request.cycleDays;
    }

    if (!Util.isUnset(request.enableAddCheck)) {
      query["EnableAddCheck"] = request.enableAddCheck;
    }

    if (!Util.isUnset(request.enableAutoCheck)) {
      query["EnableAutoCheck"] = request.enableAutoCheck;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.removedCheck)) {
      query["RemovedCheck"] = request.removedCheck;
    }

    if (!Util.isUnset(request.standardIds)) {
      query["StandardIds"] = request.standardIds;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.vendors)) {
      query["Vendors"] = request.vendors;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeCheckConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeCheckConfigResponse>(await this.callApi(params, req, runtime), new ChangeCheckConfigResponse({}));
  }

  async changeCheckConfig(request: ChangeCheckConfigRequest): Promise<ChangeCheckConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeCheckConfigWithOptions(request, runtime);
  }

  async changeCheckCustomConfigWithOptions(request: ChangeCheckCustomConfigRequest, runtime: $Util.RuntimeOptions): Promise<ChangeCheckCustomConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkId)) {
      query["CheckId"] = request.checkId;
    }

    if (!Util.isUnset(request.customConfigs)) {
      query["CustomConfigs"] = request.customConfigs;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeCheckCustomConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeCheckCustomConfigResponse>(await this.callApi(params, req, runtime), new ChangeCheckCustomConfigResponse({}));
  }

  async changeCheckCustomConfig(request: ChangeCheckCustomConfigRequest): Promise<ChangeCheckCustomConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeCheckCustomConfigWithOptions(request, runtime);
  }

  async changeSecurityScoreRuleWithOptions(request: ChangeSecurityScoreRuleRequest, runtime: $Util.RuntimeOptions): Promise<ChangeSecurityScoreRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resetSecurityScoreRule)) {
      query["ResetSecurityScoreRule"] = request.resetSecurityScoreRule;
    }

    if (!Util.isUnset(request.securityScoreRuleList)) {
      query["SecurityScoreRuleList"] = request.securityScoreRuleList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeSecurityScoreRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeSecurityScoreRuleResponse>(await this.callApi(params, req, runtime), new ChangeSecurityScoreRuleResponse({}));
  }

  async changeSecurityScoreRule(request: ChangeSecurityScoreRuleRequest): Promise<ChangeSecurityScoreRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeSecurityScoreRuleWithOptions(request, runtime);
  }

  async changeUserLangWithOptions(request: ChangeUserLangRequest, runtime: $Util.RuntimeOptions): Promise<ChangeUserLangResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.userLang)) {
      query["UserLang"] = request.userLang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ChangeUserLang",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ChangeUserLangResponse>(await this.callApi(params, req, runtime), new ChangeUserLangResponse({}));
  }

  async changeUserLang(request: ChangeUserLangRequest): Promise<ChangeUserLangResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.changeUserLangWithOptions(request, runtime);
  }

  async checkQuaraFileIdWithOptions(request: CheckQuaraFileIdRequest, runtime: $Util.RuntimeOptions): Promise<CheckQuaraFileIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.quaraFileIds)) {
      query["QuaraFileIds"] = request.quaraFileIds;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CheckQuaraFileId",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckQuaraFileIdResponse>(await this.callApi(params, req, runtime), new CheckQuaraFileIdResponse({}));
  }

  async checkQuaraFileId(request: CheckQuaraFileIdRequest): Promise<CheckQuaraFileIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkQuaraFileIdWithOptions(request, runtime);
  }

  async checkSecurityEventIdWithOptions(request: CheckSecurityEventIdRequest, runtime: $Util.RuntimeOptions): Promise<CheckSecurityEventIdResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.securityEventIds)) {
      query["SecurityEventIds"] = request.securityEventIds;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CheckSecurityEventId",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckSecurityEventIdResponse>(await this.callApi(params, req, runtime), new CheckSecurityEventIdResponse({}));
  }

  async checkSecurityEventId(request: CheckSecurityEventIdRequest): Promise<CheckSecurityEventIdResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkSecurityEventIdWithOptions(request, runtime);
  }

  async checkUserHasEcsWithOptions(request: CheckUserHasEcsRequest, runtime: $Util.RuntimeOptions): Promise<CheckUserHasEcsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CheckUserHasEcs",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckUserHasEcsResponse>(await this.callApi(params, req, runtime), new CheckUserHasEcsResponse({}));
  }

  async checkUserHasEcs(request: CheckUserHasEcsRequest): Promise<CheckUserHasEcsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkUserHasEcsWithOptions(request, runtime);
  }

  async confirmVirusEventsWithOptions(request: ConfirmVirusEventsRequest, runtime: $Util.RuntimeOptions): Promise<ConfirmVirusEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.operationAll)) {
      query["OperationAll"] = request.operationAll;
    }

    if (!Util.isUnset(request.operationCode)) {
      query["OperationCode"] = request.operationCode;
    }

    if (!Util.isUnset(request.operationRange)) {
      query["OperationRange"] = request.operationRange;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfirmVirusEvents",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfirmVirusEventsResponse>(await this.callApi(params, req, runtime), new ConfirmVirusEventsResponse({}));
  }

  async confirmVirusEvents(request: ConfirmVirusEventsRequest): Promise<ConfirmVirusEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.confirmVirusEventsWithOptions(request, runtime);
  }

  async createAgentlessScanTaskWithOptions(request: CreateAgentlessScanTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateAgentlessScanTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.autoDeleteDays)) {
      query["AutoDeleteDays"] = request.autoDeleteDays;
    }

    if (!Util.isUnset(request.releaseAfterScan)) {
      query["ReleaseAfterScan"] = request.releaseAfterScan;
    }

    if (!Util.isUnset(request.scanDataDisk)) {
      query["ScanDataDisk"] = request.scanDataDisk;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateAgentlessScanTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAgentlessScanTaskResponse>(await this.callApi(params, req, runtime), new CreateAgentlessScanTaskResponse({}));
  }

  async createAgentlessScanTask(request: CreateAgentlessScanTaskRequest): Promise<CreateAgentlessScanTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAgentlessScanTaskWithOptions(request, runtime);
  }

  async createAntiBruteForceRuleWithOptions(request: CreateAntiBruteForceRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateAntiBruteForceRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.defaultRule)) {
      query["DefaultRule"] = request.defaultRule;
    }

    if (!Util.isUnset(request.failCount)) {
      query["FailCount"] = request.failCount;
    }

    if (!Util.isUnset(request.forbiddenTime)) {
      query["ForbiddenTime"] = request.forbiddenTime;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.span)) {
      query["Span"] = request.span;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateAntiBruteForceRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAntiBruteForceRuleResponse>(await this.callApi(params, req, runtime), new CreateAntiBruteForceRuleResponse({}));
  }

  async createAntiBruteForceRule(request: CreateAntiBruteForceRuleRequest): Promise<CreateAntiBruteForceRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAntiBruteForceRuleWithOptions(request, runtime);
  }

  async createAssetSelectionConfigWithOptions(request: CreateAssetSelectionConfigRequest, runtime: $Util.RuntimeOptions): Promise<CreateAssetSelectionConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.businessType)) {
      query["BusinessType"] = request.businessType;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateAssetSelectionConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAssetSelectionConfigResponse>(await this.callApi(params, req, runtime), new CreateAssetSelectionConfigResponse({}));
  }

  async createAssetSelectionConfig(request: CreateAssetSelectionConfigRequest): Promise<CreateAssetSelectionConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAssetSelectionConfigWithOptions(request, runtime);
  }

  async createBackupPolicyWithOptions(tmpReq: CreateBackupPolicyRequest, runtime: $Util.RuntimeOptions): Promise<CreateBackupPolicyResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateBackupPolicyShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.policy)) {
      request.policyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.policy, "Policy", "json");
    }

    let query = { };
    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.policyShrink)) {
      query["Policy"] = request.policyShrink;
    }

    if (!Util.isUnset(request.policyRegionId)) {
      query["PolicyRegionId"] = request.policyRegionId;
    }

    if (!Util.isUnset(request.policyVersion)) {
      query["PolicyVersion"] = request.policyVersion;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateBackupPolicy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateBackupPolicyResponse>(await this.callApi(params, req, runtime), new CreateBackupPolicyResponse({}));
  }

  async createBackupPolicy(request: CreateBackupPolicyRequest): Promise<CreateBackupPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createBackupPolicyWithOptions(request, runtime);
  }

  async createContainerScanTaskWithOptions(request: CreateContainerScanTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateContainerScanTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.containerIds)) {
      query["ContainerIds"] = request.containerIds;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateContainerScanTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateContainerScanTaskResponse>(await this.callApi(params, req, runtime), new CreateContainerScanTaskResponse({}));
  }

  async createContainerScanTask(request: CreateContainerScanTaskRequest): Promise<CreateContainerScanTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createContainerScanTaskWithOptions(request, runtime);
  }

  async createContainerScanTaskByAppNameWithOptions(request: CreateContainerScanTaskByAppNameRequest, runtime: $Util.RuntimeOptions): Promise<CreateContainerScanTaskByAppNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appNames)) {
      query["AppNames"] = request.appNames;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateContainerScanTaskByAppName",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateContainerScanTaskByAppNameResponse>(await this.callApi(params, req, runtime), new CreateContainerScanTaskByAppNameResponse({}));
  }

  async createContainerScanTaskByAppName(request: CreateContainerScanTaskByAppNameRequest): Promise<CreateContainerScanTaskByAppNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createContainerScanTaskByAppNameWithOptions(request, runtime);
  }

  async createCustomBlockRecordWithOptions(request: CreateCustomBlockRecordRequest, runtime: $Util.RuntimeOptions): Promise<CreateCustomBlockRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.blockIp)) {
      query["BlockIp"] = request.blockIp;
    }

    if (!Util.isUnset(request.bound)) {
      query["Bound"] = request.bound;
    }

    if (!Util.isUnset(request.expireTime)) {
      query["ExpireTime"] = request.expireTime;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCustomBlockRecord",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCustomBlockRecordResponse>(await this.callApi(params, req, runtime), new CreateCustomBlockRecordResponse({}));
  }

  async createCustomBlockRecord(request: CreateCustomBlockRecordRequest): Promise<CreateCustomBlockRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCustomBlockRecordWithOptions(request, runtime);
  }

  async createCycleTaskWithOptions(request: CreateCycleTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateCycleTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.firstDateStr)) {
      query["FirstDateStr"] = request.firstDateStr;
    }

    if (!Util.isUnset(request.intervalPeriod)) {
      query["IntervalPeriod"] = request.intervalPeriod;
    }

    if (!Util.isUnset(request.param)) {
      query["Param"] = request.param;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.targetEndTime)) {
      query["TargetEndTime"] = request.targetEndTime;
    }

    if (!Util.isUnset(request.targetStartTime)) {
      query["TargetStartTime"] = request.targetStartTime;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCycleTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCycleTaskResponse>(await this.callApi(params, req, runtime), new CreateCycleTaskResponse({}));
  }

  async createCycleTask(request: CreateCycleTaskRequest): Promise<CreateCycleTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCycleTaskWithOptions(request, runtime);
  }

  /**
    * You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
    * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only hexadecimal MD5 hash values of complete file content are supported. You must calculate the MD5 hash value before you call this operation.
    * To calculate the hexadecimal MD5 hash value for a file, you can perform the following steps:
    * 1\\. Use the MD5 algorithm to encrypt data and generate a 128-bit hash value. You can use a tool such as MessageDigest for Java and the hashlib module for Python.
    * 2\\. Convert the hash value to a hexadecimal string. You can use a tool such as Codec for Java and the hex() function for Python.
    *
    * @param request CreateFileDetectRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateFileDetectResponse
   */
  async createFileDetectWithOptions(request: CreateFileDetectRequest, runtime: $Util.RuntimeOptions): Promise<CreateFileDetectResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.downloadUrl)) {
      query["DownloadUrl"] = request.downloadUrl;
    }

    if (!Util.isUnset(request.hashKey)) {
      query["HashKey"] = request.hashKey;
    }

    if (!Util.isUnset(request.ossKey)) {
      query["OssKey"] = request.ossKey;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateFileDetect",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateFileDetectResponse>(await this.callApi(params, req, runtime), new CreateFileDetectResponse({}));
  }

  /**
    * You can call this operation to push a file to the cloud for detection. Before you call this operation, make sure that the file is uploaded. You can call the CreateFileDetectUploadUrl operation to upload the file.
    * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only hexadecimal MD5 hash values of complete file content are supported. You must calculate the MD5 hash value before you call this operation.
    * To calculate the hexadecimal MD5 hash value for a file, you can perform the following steps:
    * 1\\. Use the MD5 algorithm to encrypt data and generate a 128-bit hash value. You can use a tool such as MessageDigest for Java and the hashlib module for Python.
    * 2\\. Convert the hash value to a hexadecimal string. You can use a tool such as Codec for Java and the hex() function for Python.
    *
    * @param request CreateFileDetectRequest
    * @return CreateFileDetectResponse
   */
  async createFileDetect(request: CreateFileDetectRequest): Promise<CreateFileDetectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFileDetectWithOptions(request, runtime);
  }

  /**
    * You can call this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
    * The form upload method is provided by OSS. For more information, see [Form upload](~~84788~~).
    * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
    *
    * @param request CreateFileDetectUploadUrlRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateFileDetectUploadUrlResponse
   */
  async createFileDetectUploadUrlWithOptions(request: CreateFileDetectUploadUrlRequest, runtime: $Util.RuntimeOptions): Promise<CreateFileDetectUploadUrlResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.hashKeyContextList)) {
      query["HashKeyContextList"] = request.hashKeyContextList;
    }

    if (!Util.isUnset(request.hashKeyList)) {
      query["HashKeyList"] = request.hashKeyList;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateFileDetectUploadUrl",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateFileDetectUploadUrlResponse>(await this.callApi(params, req, runtime), new CreateFileDetectUploadUrlResponse({}));
  }

  /**
    * You can call this operation to query the parameters that are required to upload a file for detection. If the value of the response parameter FileExist is true, the file that you want to upload for detection already exists in the cloud. In this case, you can directly push the file for detection. If the value of the response parameter FileExist is false, you must use the form upload method to upload the file to the specified Object Storage Service (OSS) bucket based on the response parameters of this operation.
    * The form upload method is provided by OSS. For more information, see [Form upload](~~84788~~).
    * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
    *
    * @param request CreateFileDetectUploadUrlRequest
    * @return CreateFileDetectUploadUrlResponse
   */
  async createFileDetectUploadUrl(request: CreateFileDetectUploadUrlRequest): Promise<CreateFileDetectUploadUrlResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFileDetectUploadUrlWithOptions(request, runtime);
  }

  async createFileProtectRuleWithOptions(request: CreateFileProtectRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateFileProtectRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertLevel)) {
      query["AlertLevel"] = request.alertLevel;
    }

    if (!Util.isUnset(request.fileOps)) {
      query["FileOps"] = request.fileOps;
    }

    if (!Util.isUnset(request.filePaths)) {
      query["FilePaths"] = request.filePaths;
    }

    if (!Util.isUnset(request.procPaths)) {
      query["ProcPaths"] = request.procPaths;
    }

    if (!Util.isUnset(request.ruleAction)) {
      query["RuleAction"] = request.ruleAction;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.switchId)) {
      query["SwitchId"] = request.switchId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateFileProtectRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateFileProtectRuleResponse>(await this.callApi(params, req, runtime), new CreateFileProtectRuleResponse({}));
  }

  async createFileProtectRule(request: CreateFileProtectRuleRequest): Promise<CreateFileProtectRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFileProtectRuleWithOptions(request, runtime);
  }

  async createFileUploadLimitWithOptions(request: CreateFileUploadLimitRequest, runtime: $Util.RuntimeOptions): Promise<CreateFileUploadLimitResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.limit)) {
      query["Limit"] = request.limit;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateFileUploadLimit",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateFileUploadLimitResponse>(await this.callApi(params, req, runtime), new CreateFileUploadLimitResponse({}));
  }

  async createFileUploadLimit(request: CreateFileUploadLimitRequest): Promise<CreateFileUploadLimitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFileUploadLimitWithOptions(request, runtime);
  }

  async createHoneypotWithOptions(request: CreateHoneypotRequest, runtime: $Util.RuntimeOptions): Promise<CreateHoneypotResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.honeypotImageId)) {
      query["HoneypotImageId"] = request.honeypotImageId;
    }

    if (!Util.isUnset(request.honeypotImageName)) {
      query["HoneypotImageName"] = request.honeypotImageName;
    }

    if (!Util.isUnset(request.honeypotName)) {
      query["HoneypotName"] = request.honeypotName;
    }

    if (!Util.isUnset(request.meta)) {
      query["Meta"] = request.meta;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateHoneypot",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateHoneypotResponse>(await this.callApi(params, req, runtime), new CreateHoneypotResponse({}));
  }

  async createHoneypot(request: CreateHoneypotRequest): Promise<CreateHoneypotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createHoneypotWithOptions(request, runtime);
  }

  async createHoneypotNodeWithOptions(request: CreateHoneypotNodeRequest, runtime: $Util.RuntimeOptions): Promise<CreateHoneypotNodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.allowHoneypotAccessInternet)) {
      query["AllowHoneypotAccessInternet"] = request.allowHoneypotAccessInternet;
    }

    if (!Util.isUnset(request.availableProbeNum)) {
      query["AvailableProbeNum"] = request.availableProbeNum;
    }

    if (!Util.isUnset(request.nodeName)) {
      query["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.securityGroupProbeIpList)) {
      query["SecurityGroupProbeIpList"] = request.securityGroupProbeIpList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateHoneypotNode",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateHoneypotNodeResponse>(await this.callApi(params, req, runtime), new CreateHoneypotNodeResponse({}));
  }

  async createHoneypotNode(request: CreateHoneypotNodeRequest): Promise<CreateHoneypotNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createHoneypotNodeWithOptions(request, runtime);
  }

  async createHoneypotPresetWithOptions(request: CreateHoneypotPresetRequest, runtime: $Util.RuntimeOptions): Promise<CreateHoneypotPresetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.honeypotImageName)) {
      query["HoneypotImageName"] = request.honeypotImageName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.meta)) {
      query["Meta"] = request.meta;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.presetName)) {
      query["PresetName"] = request.presetName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateHoneypotPreset",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateHoneypotPresetResponse>(await this.callApi(params, req, runtime), new CreateHoneypotPresetResponse({}));
  }

  async createHoneypotPreset(request: CreateHoneypotPresetRequest): Promise<CreateHoneypotPresetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createHoneypotPresetWithOptions(request, runtime);
  }

  async createHoneypotProbeWithOptions(request: CreateHoneypotProbeRequest, runtime: $Util.RuntimeOptions): Promise<CreateHoneypotProbeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.arp)) {
      query["Arp"] = request.arp;
    }

    if (!Util.isUnset(request.businessGroupId)) {
      query["BusinessGroupId"] = request.businessGroupId;
    }

    if (!Util.isUnset(request.controlNodeId)) {
      query["ControlNodeId"] = request.controlNodeId;
    }

    if (!Util.isUnset(request.displayName)) {
      query["DisplayName"] = request.displayName;
    }

    if (!Util.isUnset(request.honeypotBindList)) {
      query["HoneypotBindList"] = request.honeypotBindList;
    }

    if (!Util.isUnset(request.ping)) {
      query["Ping"] = request.ping;
    }

    if (!Util.isUnset(request.probeType)) {
      query["ProbeType"] = request.probeType;
    }

    if (!Util.isUnset(request.probeVersion)) {
      query["ProbeVersion"] = request.probeVersion;
    }

    if (!Util.isUnset(request.proxyIp)) {
      query["ProxyIp"] = request.proxyIp;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateHoneypotProbe",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateHoneypotProbeResponse>(await this.callApi(params, req, runtime), new CreateHoneypotProbeResponse({}));
  }

  async createHoneypotProbe(request: CreateHoneypotProbeRequest): Promise<CreateHoneypotProbeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createHoneypotProbeWithOptions(request, runtime);
  }

  async createHoneypotProbeBindWithOptions(request: CreateHoneypotProbeBindRequest, runtime: $Util.RuntimeOptions): Promise<CreateHoneypotProbeBindResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bindPortList)) {
      query["BindPortList"] = request.bindPortList;
    }

    if (!Util.isUnset(request.honeypotId)) {
      query["HoneypotId"] = request.honeypotId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.probeId)) {
      query["ProbeId"] = request.probeId;
    }

    if (!Util.isUnset(request.serviceIpList)) {
      query["ServiceIpList"] = request.serviceIpList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateHoneypotProbeBind",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateHoneypotProbeBindResponse>(await this.callApi(params, req, runtime), new CreateHoneypotProbeBindResponse({}));
  }

  async createHoneypotProbeBind(request: CreateHoneypotProbeBindRequest): Promise<CreateHoneypotProbeBindResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createHoneypotProbeBindWithOptions(request, runtime);
  }

  async createInterceptionRuleWithOptions(tmpReq: CreateInterceptionRuleRequest, runtime: $Util.RuntimeOptions): Promise<CreateInterceptionRuleResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateInterceptionRuleShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.dstTargetList)) {
      request.dstTargetListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dstTargetList, "DstTargetList", "json");
    }

    if (!Util.isUnset(tmpReq.srcTarget)) {
      request.srcTargetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.srcTarget, "SrcTarget", "json");
    }

    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.dstTargetListShrink)) {
      query["DstTargetList"] = request.dstTargetListShrink;
    }

    if (!Util.isUnset(request.interceptType)) {
      query["InterceptType"] = request.interceptType;
    }

    if (!Util.isUnset(request.orderIndex)) {
      query["OrderIndex"] = request.orderIndex;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleSwitch)) {
      query["RuleSwitch"] = request.ruleSwitch;
    }

    if (!Util.isUnset(request.ruleType)) {
      query["RuleType"] = request.ruleType;
    }

    if (!Util.isUnset(request.srcTargetShrink)) {
      query["SrcTarget"] = request.srcTargetShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateInterceptionRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateInterceptionRuleResponse>(await this.callApi(params, req, runtime), new CreateInterceptionRuleResponse({}));
  }

  async createInterceptionRule(request: CreateInterceptionRuleRequest): Promise<CreateInterceptionRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createInterceptionRuleWithOptions(request, runtime);
  }

  async createInterceptionTargetWithOptions(request: CreateInterceptionTargetRequest, runtime: $Util.RuntimeOptions): Promise<CreateInterceptionTargetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.imageList)) {
      query["ImageList"] = request.imageList;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.tagList)) {
      query["TagList"] = request.tagList;
    }

    if (!Util.isUnset(request.targetName)) {
      query["TargetName"] = request.targetName;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateInterceptionTarget",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateInterceptionTargetResponse>(await this.callApi(params, req, runtime), new CreateInterceptionTargetResponse({}));
  }

  async createInterceptionTarget(request: CreateInterceptionTargetRequest): Promise<CreateInterceptionTargetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createInterceptionTargetWithOptions(request, runtime);
  }

  async createJenkinsImageRegistryWithOptions(request: CreateJenkinsImageRegistryRequest, runtime: $Util.RuntimeOptions): Promise<CreateJenkinsImageRegistryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.domainName)) {
      body["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.extraParam)) {
      body["ExtraParam"] = request.extraParam;
    }

    if (!Util.isUnset(request.netType)) {
      body["NetType"] = request.netType;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.persistenceDay)) {
      body["PersistenceDay"] = request.persistenceDay;
    }

    if (!Util.isUnset(request.protocolType)) {
      body["ProtocolType"] = request.protocolType;
    }

    if (!Util.isUnset(request.regionId)) {
      body["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.registryHostIp)) {
      body["RegistryHostIp"] = request.registryHostIp;
    }

    if (!Util.isUnset(request.registryName)) {
      body["RegistryName"] = request.registryName;
    }

    if (!Util.isUnset(request.registryType)) {
      body["RegistryType"] = request.registryType;
    }

    if (!Util.isUnset(request.registryVersion)) {
      body["RegistryVersion"] = request.registryVersion;
    }

    if (!Util.isUnset(request.transPerHour)) {
      body["TransPerHour"] = request.transPerHour;
    }

    if (!Util.isUnset(request.userName)) {
      body["UserName"] = request.userName;
    }

    if (!Util.isUnset(request.vpcId)) {
      body["VpcId"] = request.vpcId;
    }

    if (!Util.isUnset(request.whiteList)) {
      body["WhiteList"] = request.whiteList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateJenkinsImageRegistry",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateJenkinsImageRegistryResponse>(await this.callApi(params, req, runtime), new CreateJenkinsImageRegistryResponse({}));
  }

  async createJenkinsImageRegistry(request: CreateJenkinsImageRegistryRequest): Promise<CreateJenkinsImageRegistryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createJenkinsImageRegistryWithOptions(request, runtime);
  }

  async createMaliciousNoteWithOptions(request: CreateMaliciousNoteRequest, runtime: $Util.RuntimeOptions): Promise<CreateMaliciousNoteResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventId)) {
      query["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.note)) {
      query["Note"] = request.note;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateMaliciousNote",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateMaliciousNoteResponse>(await this.callApi(params, req, runtime), new CreateMaliciousNoteResponse({}));
  }

  async createMaliciousNote(request: CreateMaliciousNoteRequest): Promise<CreateMaliciousNoteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createMaliciousNoteWithOptions(request, runtime);
  }

  async createOpaClusterPluginWithOptions(request: CreateOpaClusterPluginRequest, runtime: $Util.RuntimeOptions): Promise<CreateOpaClusterPluginResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterIds)) {
      query["ClusterIds"] = request.clusterIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOpaClusterPlugin",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOpaClusterPluginResponse>(await this.callApi(params, req, runtime), new CreateOpaClusterPluginResponse({}));
  }

  async createOpaClusterPlugin(request: CreateOpaClusterPluginRequest): Promise<CreateOpaClusterPluginResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOpaClusterPluginWithOptions(request, runtime);
  }

  /**
    * A server can belong only to one server group. If you call the CreateOrUpdateAssetGroup operation and the server specified in request parameters belongs to Server Group A, the server is removed from Server Group A and then added to the newly created or specified server group after the call is complete.
    *
    * @param request CreateOrUpdateAssetGroupRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateOrUpdateAssetGroupResponse
   */
  async createOrUpdateAssetGroupWithOptions(request: CreateOrUpdateAssetGroupRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrUpdateAssetGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrUpdateAssetGroup",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOrUpdateAssetGroupResponse>(await this.callApi(params, req, runtime), new CreateOrUpdateAssetGroupResponse({}));
  }

  /**
    * A server can belong only to one server group. If you call the CreateOrUpdateAssetGroup operation and the server specified in request parameters belongs to Server Group A, the server is removed from Server Group A and then added to the newly created or specified server group after the call is complete.
    *
    * @param request CreateOrUpdateAssetGroupRequest
    * @return CreateOrUpdateAssetGroupResponse
   */
  async createOrUpdateAssetGroup(request: CreateOrUpdateAssetGroupRequest): Promise<CreateOrUpdateAssetGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrUpdateAssetGroupWithOptions(request, runtime);
  }

  async createOrUpdateDingTalkWithOptions(request: CreateOrUpdateDingTalkRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrUpdateDingTalkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configList)) {
      query["ConfigList"] = request.configList;
    }

    if (!Util.isUnset(request.dingTalkLang)) {
      query["DingTalkLang"] = request.dingTalkLang;
    }

    if (!Util.isUnset(request.groupIdList)) {
      query["GroupIdList"] = request.groupIdList;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.intervalTime)) {
      query["IntervalTime"] = request.intervalTime;
    }

    if (!Util.isUnset(request.ruleActionName)) {
      query["RuleActionName"] = request.ruleActionName;
    }

    if (!Util.isUnset(request.sendUrl)) {
      query["SendUrl"] = request.sendUrl;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrUpdateDingTalk",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOrUpdateDingTalkResponse>(await this.callApi(params, req, runtime), new CreateOrUpdateDingTalkResponse({}));
  }

  async createOrUpdateDingTalk(request: CreateOrUpdateDingTalkRequest): Promise<CreateOrUpdateDingTalkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrUpdateDingTalkWithOptions(request, runtime);
  }

  async createOssBucketScanTaskWithOptions(request: CreateOssBucketScanTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateOssBucketScanTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bucketNameList)) {
      query["BucketNameList"] = request.bucketNameList;
    }

    if (!Util.isUnset(request.excludeKeySuffixList)) {
      query["ExcludeKeySuffixList"] = request.excludeKeySuffixList;
    }

    if (!Util.isUnset(request.keySuffixList)) {
      query["KeySuffixList"] = request.keySuffixList;
    }

    if (!Util.isUnset(request.scanMode)) {
      query["ScanMode"] = request.scanMode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOssBucketScanTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOssBucketScanTaskResponse>(await this.callApi(params, req, runtime), new CreateOssBucketScanTaskResponse({}));
  }

  async createOssBucketScanTask(request: CreateOssBucketScanTaskRequest): Promise<CreateOssBucketScanTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOssBucketScanTaskWithOptions(request, runtime);
  }

  async createOssScanConfigWithOptions(request: CreateOssScanConfigRequest, runtime: $Util.RuntimeOptions): Promise<CreateOssScanConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bucketNameList)) {
      query["BucketNameList"] = request.bucketNameList;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.keySuffixList)) {
      query["KeySuffixList"] = request.keySuffixList;
    }

    if (!Util.isUnset(request.scanDayList)) {
      query["ScanDayList"] = request.scanDayList;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateOssScanConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOssScanConfigResponse>(await this.callApi(params, req, runtime), new CreateOssScanConfigResponse({}));
  }

  async createOssScanConfig(request: CreateOssScanConfigRequest): Promise<CreateOssScanConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOssScanConfigWithOptions(request, runtime);
  }

  async createRestoreJobWithOptions(request: CreateRestoreJobRequest, runtime: $Util.RuntimeOptions): Promise<CreateRestoreJobResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.includes)) {
      query["Includes"] = request.includes;
    }

    if (!Util.isUnset(request.snapshotHash)) {
      query["SnapshotHash"] = request.snapshotHash;
    }

    if (!Util.isUnset(request.snapshotId)) {
      query["SnapshotId"] = request.snapshotId;
    }

    if (!Util.isUnset(request.snapshotVersion)) {
      query["SnapshotVersion"] = request.snapshotVersion;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    if (!Util.isUnset(request.target)) {
      query["Target"] = request.target;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    if (!Util.isUnset(request.vaultId)) {
      query["VaultId"] = request.vaultId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateRestoreJob",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateRestoreJobResponse>(await this.callApi(params, req, runtime), new CreateRestoreJobResponse({}));
  }

  async createRestoreJob(request: CreateRestoreJobRequest): Promise<CreateRestoreJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createRestoreJobWithOptions(request, runtime);
  }

  /**
    * For more information about service-linked roles, see [Service-linked roles](~~160674~~).
    *
    * @param request CreateServiceLinkedRoleRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return CreateServiceLinkedRoleResponse
   */
  async createServiceLinkedRoleWithOptions(request: CreateServiceLinkedRoleRequest, runtime: $Util.RuntimeOptions): Promise<CreateServiceLinkedRoleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.serviceLinkedRole)) {
      query["ServiceLinkedRole"] = request.serviceLinkedRole;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateServiceLinkedRole",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateServiceLinkedRoleResponse>(await this.callApi(params, req, runtime), new CreateServiceLinkedRoleResponse({}));
  }

  /**
    * For more information about service-linked roles, see [Service-linked roles](~~160674~~).
    *
    * @param request CreateServiceLinkedRoleRequest
    * @return CreateServiceLinkedRoleResponse
   */
  async createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): Promise<CreateServiceLinkedRoleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createServiceLinkedRoleWithOptions(request, runtime);
  }

  async createServiceTrailWithOptions(request: CreateServiceTrailRequest, runtime: $Util.RuntimeOptions): Promise<CreateServiceTrailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateServiceTrail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateServiceTrailResponse>(await this.callApi(params, req, runtime), new CreateServiceTrailResponse({}));
  }

  async createServiceTrail(request: CreateServiceTrailRequest): Promise<CreateServiceTrailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createServiceTrailWithOptions(request, runtime);
  }

  async createSimilarSecurityEventsQueryTaskWithOptions(request: CreateSimilarSecurityEventsQueryTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateSimilarSecurityEventsQueryTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.securityEventId)) {
      query["SecurityEventId"] = request.securityEventId;
    }

    if (!Util.isUnset(request.similarEventScenarioCode)) {
      query["SimilarEventScenarioCode"] = request.similarEventScenarioCode;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSimilarSecurityEventsQueryTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSimilarSecurityEventsQueryTaskResponse>(await this.callApi(params, req, runtime), new CreateSimilarSecurityEventsQueryTaskResponse({}));
  }

  async createSimilarSecurityEventsQueryTask(request: CreateSimilarSecurityEventsQueryTaskRequest): Promise<CreateSimilarSecurityEventsQueryTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSimilarSecurityEventsQueryTaskWithOptions(request, runtime);
  }

  async createSuspEventNoteWithOptions(request: CreateSuspEventNoteRequest, runtime: $Util.RuntimeOptions): Promise<CreateSuspEventNoteResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventId)) {
      query["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.note)) {
      query["Note"] = request.note;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateSuspEventNote",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSuspEventNoteResponse>(await this.callApi(params, req, runtime), new CreateSuspEventNoteResponse({}));
  }

  async createSuspEventNote(request: CreateSuspEventNoteRequest): Promise<CreateSuspEventNoteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSuspEventNoteWithOptions(request, runtime);
  }

  async createUniBackupPolicyWithOptions(tmpReq: CreateUniBackupPolicyRequest, runtime: $Util.RuntimeOptions): Promise<CreateUniBackupPolicyResponse> {
    Util.validateModel(tmpReq);
    let request = new CreateUniBackupPolicyShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.fullPlan)) {
      request.fullPlanShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fullPlan, "FullPlan", "json");
    }

    if (!Util.isUnset(tmpReq.incPlan)) {
      request.incPlanShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.incPlan, "IncPlan", "json");
    }

    let query = { };
    if (!Util.isUnset(request.accountName)) {
      query["AccountName"] = request.accountName;
    }

    if (!Util.isUnset(request.accountPassword)) {
      query["AccountPassword"] = request.accountPassword;
    }

    if (!Util.isUnset(request.databaseAddByUser)) {
      query["DatabaseAddByUser"] = request.databaseAddByUser;
    }

    if (!Util.isUnset(request.databaseType)) {
      query["DatabaseType"] = request.databaseType;
    }

    if (!Util.isUnset(request.fullPlanShrink)) {
      query["FullPlan"] = request.fullPlanShrink;
    }

    if (!Util.isUnset(request.incPlanShrink)) {
      query["IncPlan"] = request.incPlanShrink;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.policyName)) {
      query["PolicyName"] = request.policyName;
    }

    if (!Util.isUnset(request.retention)) {
      query["Retention"] = request.retention;
    }

    if (!Util.isUnset(request.speedLimiter)) {
      query["SpeedLimiter"] = request.speedLimiter;
    }

    if (!Util.isUnset(request.uniRegionId)) {
      query["UniRegionId"] = request.uniRegionId;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateUniBackupPolicy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateUniBackupPolicyResponse>(await this.callApi(params, req, runtime), new CreateUniBackupPolicyResponse({}));
  }

  async createUniBackupPolicy(request: CreateUniBackupPolicyRequest): Promise<CreateUniBackupPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createUniBackupPolicyWithOptions(request, runtime);
  }

  async createUniRestorePlanWithOptions(request: CreateUniRestorePlanRequest, runtime: $Util.RuntimeOptions): Promise<CreateUniRestorePlanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.database)) {
      query["Database"] = request.database;
    }

    if (!Util.isUnset(request.instanceUuid)) {
      query["InstanceUuid"] = request.instanceUuid;
    }

    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    if (!Util.isUnset(request.resetScn)) {
      query["ResetScn"] = request.resetScn;
    }

    if (!Util.isUnset(request.resetTime)) {
      query["ResetTime"] = request.resetTime;
    }

    if (!Util.isUnset(request.restoreInfo)) {
      query["RestoreInfo"] = request.restoreInfo;
    }

    if (!Util.isUnset(request.timePoint)) {
      query["TimePoint"] = request.timePoint;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateUniRestorePlan",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateUniRestorePlanResponse>(await this.callApi(params, req, runtime), new CreateUniRestorePlanResponse({}));
  }

  async createUniRestorePlan(request: CreateUniRestorePlanRequest): Promise<CreateUniRestorePlanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createUniRestorePlanWithOptions(request, runtime);
  }

  async createVirusScanOnceTaskWithOptions(request: CreateVirusScanOnceTaskRequest, runtime: $Util.RuntimeOptions): Promise<CreateVirusScanOnceTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.scanPath)) {
      query["ScanPath"] = request.scanPath;
    }

    if (!Util.isUnset(request.scanType)) {
      query["ScanType"] = request.scanType;
    }

    if (!Util.isUnset(request.selectionKey)) {
      query["SelectionKey"] = request.selectionKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateVirusScanOnceTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateVirusScanOnceTaskResponse>(await this.callApi(params, req, runtime), new CreateVirusScanOnceTaskResponse({}));
  }

  async createVirusScanOnceTask(request: CreateVirusScanOnceTaskRequest): Promise<CreateVirusScanOnceTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createVirusScanOnceTaskWithOptions(request, runtime);
  }

  async createVulAutoRepairConfigWithOptions(request: CreateVulAutoRepairConfigRequest, runtime: $Util.RuntimeOptions): Promise<CreateVulAutoRepairConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.reason)) {
      query["Reason"] = request.reason;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.vulAutoRepairConfigList)) {
      query["VulAutoRepairConfigList"] = request.vulAutoRepairConfigList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateVulAutoRepairConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateVulAutoRepairConfigResponse>(await this.callApi(params, req, runtime), new CreateVulAutoRepairConfigResponse({}));
  }

  async createVulAutoRepairConfig(request: CreateVulAutoRepairConfigRequest): Promise<CreateVulAutoRepairConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createVulAutoRepairConfigWithOptions(request, runtime);
  }

  async deleteAntiBruteForceRuleWithOptions(request: DeleteAntiBruteForceRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAntiBruteForceRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ids)) {
      query["Ids"] = request.ids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAntiBruteForceRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAntiBruteForceRuleResponse>(await this.callApi(params, req, runtime), new DeleteAntiBruteForceRuleResponse({}));
  }

  async deleteAntiBruteForceRule(request: DeleteAntiBruteForceRuleRequest): Promise<DeleteAntiBruteForceRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAntiBruteForceRuleWithOptions(request, runtime);
  }

  async deleteBackupPolicyWithOptions(request: DeleteBackupPolicyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteBackupPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.policyVersion)) {
      query["PolicyVersion"] = request.policyVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteBackupPolicy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteBackupPolicyResponse>(await this.callApi(params, req, runtime), new DeleteBackupPolicyResponse({}));
  }

  async deleteBackupPolicy(request: DeleteBackupPolicyRequest): Promise<DeleteBackupPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteBackupPolicyWithOptions(request, runtime);
  }

  async deleteBackupPolicyMachineWithOptions(request: DeleteBackupPolicyMachineRequest, runtime: $Util.RuntimeOptions): Promise<DeleteBackupPolicyMachineResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    if (!Util.isUnset(request.policyVersion)) {
      query["PolicyVersion"] = request.policyVersion;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteBackupPolicyMachine",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteBackupPolicyMachineResponse>(await this.callApi(params, req, runtime), new DeleteBackupPolicyMachineResponse({}));
  }

  async deleteBackupPolicyMachine(request: DeleteBackupPolicyMachineRequest): Promise<DeleteBackupPolicyMachineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteBackupPolicyMachineWithOptions(request, runtime);
  }

  async deleteBinarySecurityPolicyWithOptions(request: DeleteBinarySecurityPolicyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteBinarySecurityPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteBinarySecurityPolicy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteBinarySecurityPolicyResponse>(await this.callApi(params, req, runtime), new DeleteBinarySecurityPolicyResponse({}));
  }

  async deleteBinarySecurityPolicy(request: DeleteBinarySecurityPolicyRequest): Promise<DeleteBinarySecurityPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteBinarySecurityPolicyWithOptions(request, runtime);
  }

  async deleteClientUserDefineRuleWithOptions(request: DeleteClientUserDefineRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteClientUserDefineRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.idList)) {
      query["IdList"] = request.idList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteClientUserDefineRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteClientUserDefineRuleResponse>(await this.callApi(params, req, runtime), new DeleteClientUserDefineRuleResponse({}));
  }

  async deleteClientUserDefineRule(request: DeleteClientUserDefineRuleRequest): Promise<DeleteClientUserDefineRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteClientUserDefineRuleWithOptions(request, runtime);
  }

  async deleteContainerDefenseRuleWithOptions(request: DeleteContainerDefenseRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteContainerDefenseRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleIds)) {
      query["RuleIds"] = request.ruleIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteContainerDefenseRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteContainerDefenseRuleResponse>(await this.callApi(params, req, runtime), new DeleteContainerDefenseRuleResponse({}));
  }

  async deleteContainerDefenseRule(request: DeleteContainerDefenseRuleRequest): Promise<DeleteContainerDefenseRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteContainerDefenseRuleWithOptions(request, runtime);
  }

  async deleteCustomBlockRecordWithOptions(request: DeleteCustomBlockRecordRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCustomBlockRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCustomBlockRecord",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCustomBlockRecordResponse>(await this.callApi(params, req, runtime), new DeleteCustomBlockRecordResponse({}));
  }

  async deleteCustomBlockRecord(request: DeleteCustomBlockRecordRequest): Promise<DeleteCustomBlockRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCustomBlockRecordWithOptions(request, runtime);
  }

  async deleteCycleTaskWithOptions(request: DeleteCycleTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteCycleTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteCycleTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteCycleTaskResponse>(await this.callApi(params, req, runtime), new DeleteCycleTaskResponse({}));
  }

  async deleteCycleTask(request: DeleteCycleTaskRequest): Promise<DeleteCycleTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteCycleTaskWithOptions(request, runtime);
  }

  async deleteFileProtectRuleWithOptions(request: DeleteFileProtectRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteFileProtectRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteFileProtectRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteFileProtectRuleResponse>(await this.callApi(params, req, runtime), new DeleteFileProtectRuleResponse({}));
  }

  async deleteFileProtectRule(request: DeleteFileProtectRuleRequest): Promise<DeleteFileProtectRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteFileProtectRuleWithOptions(request, runtime);
  }

  /**
    * The **Default** server group that is provided by Security Center cannot be deleted. After you delete a group, the assets in this group are moved to the **Default** group.
    *
    * @param request DeleteGroupRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteGroupResponse
   */
  async deleteGroupWithOptions(request: DeleteGroupRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGroup",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGroupResponse>(await this.callApi(params, req, runtime), new DeleteGroupResponse({}));
  }

  /**
    * The **Default** server group that is provided by Security Center cannot be deleted. After you delete a group, the assets in this group are moved to the **Default** group.
    *
    * @param request DeleteGroupRequest
    * @return DeleteGroupResponse
   */
  async deleteGroup(request: DeleteGroupRequest): Promise<DeleteGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGroupWithOptions(request, runtime);
  }

  async deleteHoneypotWithOptions(request: DeleteHoneypotRequest, runtime: $Util.RuntimeOptions): Promise<DeleteHoneypotResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.honeypotId)) {
      query["HoneypotId"] = request.honeypotId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteHoneypot",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteHoneypotResponse>(await this.callApi(params, req, runtime), new DeleteHoneypotResponse({}));
  }

  async deleteHoneypot(request: DeleteHoneypotRequest): Promise<DeleteHoneypotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteHoneypotWithOptions(request, runtime);
  }

  async deleteHoneypotNodeWithOptions(request: DeleteHoneypotNodeRequest, runtime: $Util.RuntimeOptions): Promise<DeleteHoneypotNodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteHoneypotNode",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteHoneypotNodeResponse>(await this.callApi(params, req, runtime), new DeleteHoneypotNodeResponse({}));
  }

  async deleteHoneypotNode(request: DeleteHoneypotNodeRequest): Promise<DeleteHoneypotNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteHoneypotNodeWithOptions(request, runtime);
  }

  async deleteHoneypotPresetWithOptions(request: DeleteHoneypotPresetRequest, runtime: $Util.RuntimeOptions): Promise<DeleteHoneypotPresetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.honeypotPresetId)) {
      query["HoneypotPresetId"] = request.honeypotPresetId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteHoneypotPreset",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteHoneypotPresetResponse>(await this.callApi(params, req, runtime), new DeleteHoneypotPresetResponse({}));
  }

  async deleteHoneypotPreset(request: DeleteHoneypotPresetRequest): Promise<DeleteHoneypotPresetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteHoneypotPresetWithOptions(request, runtime);
  }

  async deleteHoneypotProbeWithOptions(request: DeleteHoneypotProbeRequest, runtime: $Util.RuntimeOptions): Promise<DeleteHoneypotProbeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.probeId)) {
      query["ProbeId"] = request.probeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteHoneypotProbe",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteHoneypotProbeResponse>(await this.callApi(params, req, runtime), new DeleteHoneypotProbeResponse({}));
  }

  async deleteHoneypotProbe(request: DeleteHoneypotProbeRequest): Promise<DeleteHoneypotProbeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteHoneypotProbeWithOptions(request, runtime);
  }

  async deleteHoneypotProbeBindWithOptions(request: DeleteHoneypotProbeBindRequest, runtime: $Util.RuntimeOptions): Promise<DeleteHoneypotProbeBindResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bindId)) {
      query["BindId"] = request.bindId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.probeId)) {
      query["ProbeId"] = request.probeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteHoneypotProbeBind",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteHoneypotProbeBindResponse>(await this.callApi(params, req, runtime), new DeleteHoneypotProbeBindResponse({}));
  }

  async deleteHoneypotProbeBind(request: DeleteHoneypotProbeBindRequest): Promise<DeleteHoneypotProbeBindResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteHoneypotProbeBindWithOptions(request, runtime);
  }

  async deleteImageEventOperationWithOptions(request: DeleteImageEventOperationRequest, runtime: $Util.RuntimeOptions): Promise<DeleteImageEventOperationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteImageEventOperation",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteImageEventOperationResponse>(await this.callApi(params, req, runtime), new DeleteImageEventOperationResponse({}));
  }

  async deleteImageEventOperation(request: DeleteImageEventOperationRequest): Promise<DeleteImageEventOperationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteImageEventOperationWithOptions(request, runtime);
  }

  async deleteImageVulWhitelistWithOptions(request: DeleteImageVulWhitelistRequest, runtime: $Util.RuntimeOptions): Promise<DeleteImageVulWhitelistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ids)) {
      query["Ids"] = request.ids;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteImageVulWhitelist",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteImageVulWhitelistResponse>(await this.callApi(params, req, runtime), new DeleteImageVulWhitelistResponse({}));
  }

  async deleteImageVulWhitelist(request: DeleteImageVulWhitelistRequest): Promise<DeleteImageVulWhitelistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteImageVulWhitelistWithOptions(request, runtime);
  }

  async deleteInstallCodeWithOptions(request: DeleteInstallCodeRequest, runtime: $Util.RuntimeOptions): Promise<DeleteInstallCodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.captchaCode)) {
      query["CaptchaCode"] = request.captchaCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteInstallCode",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteInstallCodeResponse>(await this.callApi(params, req, runtime), new DeleteInstallCodeResponse({}));
  }

  async deleteInstallCode(request: DeleteInstallCodeRequest): Promise<DeleteInstallCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteInstallCodeWithOptions(request, runtime);
  }

  async deleteInterceptionRuleWithOptions(request: DeleteInterceptionRuleRequest, runtime: $Util.RuntimeOptions): Promise<DeleteInterceptionRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.ruleIds)) {
      query["RuleIds"] = request.ruleIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteInterceptionRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteInterceptionRuleResponse>(await this.callApi(params, req, runtime), new DeleteInterceptionRuleResponse({}));
  }

  async deleteInterceptionRule(request: DeleteInterceptionRuleRequest): Promise<DeleteInterceptionRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteInterceptionRuleWithOptions(request, runtime);
  }

  async deleteInterceptionTargetWithOptions(request: DeleteInterceptionTargetRequest, runtime: $Util.RuntimeOptions): Promise<DeleteInterceptionTargetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.targetIds)) {
      query["TargetIds"] = request.targetIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteInterceptionTarget",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteInterceptionTargetResponse>(await this.callApi(params, req, runtime), new DeleteInterceptionTargetResponse({}));
  }

  async deleteInterceptionTarget(request: DeleteInterceptionTargetRequest): Promise<DeleteInterceptionTargetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteInterceptionTargetWithOptions(request, runtime);
  }

  async deleteLoginBaseConfigWithOptions(request: DeleteLoginBaseConfigRequest, runtime: $Util.RuntimeOptions): Promise<DeleteLoginBaseConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.target)) {
      query["Target"] = request.target;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteLoginBaseConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteLoginBaseConfigResponse>(await this.callApi(params, req, runtime), new DeleteLoginBaseConfigResponse({}));
  }

  async deleteLoginBaseConfig(request: DeleteLoginBaseConfigRequest): Promise<DeleteLoginBaseConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteLoginBaseConfigWithOptions(request, runtime);
  }

  async deleteMaliciousNoteWithOptions(request: DeleteMaliciousNoteRequest, runtime: $Util.RuntimeOptions): Promise<DeleteMaliciousNoteResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.noteId)) {
      query["NoteId"] = request.noteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteMaliciousNote",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteMaliciousNoteResponse>(await this.callApi(params, req, runtime), new DeleteMaliciousNoteResponse({}));
  }

  async deleteMaliciousNote(request: DeleteMaliciousNoteRequest): Promise<DeleteMaliciousNoteResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteMaliciousNoteWithOptions(request, runtime);
  }

  async deletePrivateRegistryWithOptions(request: DeletePrivateRegistryRequest, runtime: $Util.RuntimeOptions): Promise<DeletePrivateRegistryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.registryId)) {
      query["RegistryId"] = request.registryId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeletePrivateRegistry",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeletePrivateRegistryResponse>(await this.callApi(params, req, runtime), new DeletePrivateRegistryResponse({}));
  }

  async deletePrivateRegistry(request: DeletePrivateRegistryRequest): Promise<DeletePrivateRegistryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deletePrivateRegistryWithOptions(request, runtime);
  }

  async deleteSecurityEventMarkMissListWithOptions(request: DeleteSecurityEventMarkMissListRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSecurityEventMarkMissListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ids)) {
      query["Ids"] = request.ids;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSecurityEventMarkMissList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSecurityEventMarkMissListResponse>(await this.callApi(params, req, runtime), new DeleteSecurityEventMarkMissListResponse({}));
  }

  async deleteSecurityEventMarkMissList(request: DeleteSecurityEventMarkMissListRequest): Promise<DeleteSecurityEventMarkMissListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSecurityEventMarkMissListWithOptions(request, runtime);
  }

  async deleteServiceTrailWithOptions(request: DeleteServiceTrailRequest, runtime: $Util.RuntimeOptions): Promise<DeleteServiceTrailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteServiceTrail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteServiceTrailResponse>(await this.callApi(params, req, runtime), new DeleteServiceTrailResponse({}));
  }

  async deleteServiceTrail(request: DeleteServiceTrailRequest): Promise<DeleteServiceTrailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteServiceTrailWithOptions(request, runtime);
  }

  async deleteStrategyWithOptions(request: DeleteStrategyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteStrategy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteStrategyResponse>(await this.callApi(params, req, runtime), new DeleteStrategyResponse({}));
  }

  async deleteStrategy(request: DeleteStrategyRequest): Promise<DeleteStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteStrategyWithOptions(request, runtime);
  }

  async deleteSuspEventNodeWithOptions(request: DeleteSuspEventNodeRequest, runtime: $Util.RuntimeOptions): Promise<DeleteSuspEventNodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.noteId)) {
      query["NoteId"] = request.noteId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteSuspEventNode",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteSuspEventNodeResponse>(await this.callApi(params, req, runtime), new DeleteSuspEventNodeResponse({}));
  }

  async deleteSuspEventNode(request: DeleteSuspEventNodeRequest): Promise<DeleteSuspEventNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteSuspEventNodeWithOptions(request, runtime);
  }

  /**
    * Security Center provides asset importance tags and custom tags. You can call this operation to remove only the custom tag that is added to an asset.
    *
    * @param request DeleteTagWithUuidRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DeleteTagWithUuidResponse
   */
  async deleteTagWithUuidWithOptions(request: DeleteTagWithUuidRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTagWithUuidResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tagName)) {
      query["TagName"] = request.tagName;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTagWithUuid",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTagWithUuidResponse>(await this.callApi(params, req, runtime), new DeleteTagWithUuidResponse({}));
  }

  /**
    * Security Center provides asset importance tags and custom tags. You can call this operation to remove only the custom tag that is added to an asset.
    *
    * @param request DeleteTagWithUuidRequest
    * @return DeleteTagWithUuidResponse
   */
  async deleteTagWithUuid(request: DeleteTagWithUuidRequest): Promise<DeleteTagWithUuidResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTagWithUuidWithOptions(request, runtime);
  }

  async deleteUniBackupPolicyWithOptions(request: DeleteUniBackupPolicyRequest, runtime: $Util.RuntimeOptions): Promise<DeleteUniBackupPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    if (!Util.isUnset(request.policyIds)) {
      query["PolicyIds"] = request.policyIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteUniBackupPolicy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteUniBackupPolicyResponse>(await this.callApi(params, req, runtime), new DeleteUniBackupPolicyResponse({}));
  }

  async deleteUniBackupPolicy(request: DeleteUniBackupPolicyRequest): Promise<DeleteUniBackupPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteUniBackupPolicyWithOptions(request, runtime);
  }

  async deleteVpcHoneyPotWithOptions(request: DeleteVpcHoneyPotRequest, runtime: $Util.RuntimeOptions): Promise<DeleteVpcHoneyPotResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteVpcHoneyPot",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteVpcHoneyPotResponse>(await this.callApi(params, req, runtime), new DeleteVpcHoneyPotResponse({}));
  }

  async deleteVpcHoneyPot(request: DeleteVpcHoneyPotRequest): Promise<DeleteVpcHoneyPotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteVpcHoneyPotWithOptions(request, runtime);
  }

  async deleteVulWhitelistWithOptions(request: DeleteVulWhitelistRequest, runtime: $Util.RuntimeOptions): Promise<DeleteVulWhitelistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.whitelist)) {
      query["Whitelist"] = request.whitelist;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteVulWhitelist",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteVulWhitelistResponse>(await this.callApi(params, req, runtime), new DeleteVulWhitelistResponse({}));
  }

  async deleteVulWhitelist(request: DeleteVulWhitelistRequest): Promise<DeleteVulWhitelistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteVulWhitelistWithOptions(request, runtime);
  }

  async describeAccessKeyLeakDetailWithOptions(request: DescribeAccessKeyLeakDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAccessKeyLeakDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAccessKeyLeakDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAccessKeyLeakDetailResponse>(await this.callApi(params, req, runtime), new DescribeAccessKeyLeakDetailResponse({}));
  }

  async describeAccessKeyLeakDetail(request: DescribeAccessKeyLeakDetailRequest): Promise<DescribeAccessKeyLeakDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAccessKeyLeakDetailWithOptions(request, runtime);
  }

  async describeAccesskeyLeakListWithOptions(request: DescribeAccesskeyLeakListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAccesskeyLeakListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.query)) {
      query["Query"] = request.query;
    }

    if (!Util.isUnset(request.startTs)) {
      query["StartTs"] = request.startTs;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAccesskeyLeakList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAccesskeyLeakListResponse>(await this.callApi(params, req, runtime), new DescribeAccesskeyLeakListResponse({}));
  }

  async describeAccesskeyLeakList(request: DescribeAccesskeyLeakListRequest): Promise<DescribeAccesskeyLeakListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAccesskeyLeakListWithOptions(request, runtime);
  }

  async describeAffectedAssetsWithOptions(request: DescribeAffectedAssetsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAffectedAssetsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.current)) {
      query["Current"] = request.current;
    }

    if (!Util.isUnset(request.levels)) {
      query["Levels"] = request.levels;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAffectedAssets",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAffectedAssetsResponse>(await this.callApi(params, req, runtime), new DescribeAffectedAssetsResponse({}));
  }

  async describeAffectedAssets(request: DescribeAffectedAssetsRequest): Promise<DescribeAffectedAssetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAffectedAssetsWithOptions(request, runtime);
  }

  async describeAffectedMaliciousFileImagesWithOptions(request: DescribeAffectedMaliciousFileImagesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAffectedMaliciousFileImagesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.containerId)) {
      query["ContainerId"] = request.containerId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.image)) {
      query["Image"] = request.image;
    }

    if (!Util.isUnset(request.imageDigest)) {
      query["ImageDigest"] = request.imageDigest;
    }

    if (!Util.isUnset(request.imageLayer)) {
      query["ImageLayer"] = request.imageLayer;
    }

    if (!Util.isUnset(request.imageTag)) {
      query["ImageTag"] = request.imageTag;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.levels)) {
      query["Levels"] = request.levels;
    }

    if (!Util.isUnset(request.maliciousMd5)) {
      query["MaliciousMd5"] = request.maliciousMd5;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.pod)) {
      query["Pod"] = request.pod;
    }

    if (!Util.isUnset(request.repoId)) {
      query["RepoId"] = request.repoId;
    }

    if (!Util.isUnset(request.repoInstanceId)) {
      query["RepoInstanceId"] = request.repoInstanceId;
    }

    if (!Util.isUnset(request.repoName)) {
      query["RepoName"] = request.repoName;
    }

    if (!Util.isUnset(request.repoNamespace)) {
      query["RepoNamespace"] = request.repoNamespace;
    }

    if (!Util.isUnset(request.repoRegionId)) {
      query["RepoRegionId"] = request.repoRegionId;
    }

    if (!Util.isUnset(request.scanRange)) {
      query["ScanRange"] = request.scanRange;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAffectedMaliciousFileImages",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAffectedMaliciousFileImagesResponse>(await this.callApi(params, req, runtime), new DescribeAffectedMaliciousFileImagesResponse({}));
  }

  async describeAffectedMaliciousFileImages(request: DescribeAffectedMaliciousFileImagesRequest): Promise<DescribeAffectedMaliciousFileImagesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAffectedMaliciousFileImagesWithOptions(request, runtime);
  }

  async describeAgentInstallStatusWithOptions(request: DescribeAgentInstallStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAgentInstallStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAgentInstallStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAgentInstallStatusResponse>(await this.callApi(params, req, runtime), new DescribeAgentInstallStatusResponse({}));
  }

  async describeAgentInstallStatus(request: DescribeAgentInstallStatusRequest): Promise<DescribeAgentInstallStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAgentInstallStatusWithOptions(request, runtime);
  }

  async describeAlarmEventDetailWithOptions(request: DescribeAlarmEventDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAlarmEventDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alarmUniqueInfo)) {
      query["AlarmUniqueInfo"] = request.alarmUniqueInfo;
    }

    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAlarmEventDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAlarmEventDetailResponse>(await this.callApi(params, req, runtime), new DescribeAlarmEventDetailResponse({}));
  }

  async describeAlarmEventDetail(request: DescribeAlarmEventDetailRequest): Promise<DescribeAlarmEventDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAlarmEventDetailWithOptions(request, runtime);
  }

  async describeAlarmEventStackInfoWithOptions(request: DescribeAlarmEventStackInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAlarmEventStackInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventName)) {
      query["EventName"] = request.eventName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uniqueInfo)) {
      query["UniqueInfo"] = request.uniqueInfo;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAlarmEventStackInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAlarmEventStackInfoResponse>(await this.callApi(params, req, runtime), new DescribeAlarmEventStackInfoResponse({}));
  }

  async describeAlarmEventStackInfo(request: DescribeAlarmEventStackInfoRequest): Promise<DescribeAlarmEventStackInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAlarmEventStackInfoWithOptions(request, runtime);
  }

  async describeAllEntityWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeAllEntityResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeAllEntity",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAllEntityResponse>(await this.callApi(params, req, runtime), new DescribeAllEntityResponse({}));
  }

  async describeAllEntity(): Promise<DescribeAllEntityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAllEntityWithOptions(runtime);
  }

  async describeAllGroupsWithOptions(request: DescribeAllGroupsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAllGroupsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAllGroups",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAllGroupsResponse>(await this.callApi(params, req, runtime), new DescribeAllGroupsResponse({}));
  }

  async describeAllGroups(request: DescribeAllGroupsRequest): Promise<DescribeAllGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAllGroupsWithOptions(request, runtime);
  }

  async describeAllImageBaselineWithOptions(request: DescribeAllImageBaselineRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAllImageBaselineResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAllImageBaseline",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAllImageBaselineResponse>(await this.callApi(params, req, runtime), new DescribeAllImageBaselineResponse({}));
  }

  async describeAllImageBaseline(request: DescribeAllImageBaselineRequest): Promise<DescribeAllImageBaselineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAllImageBaselineWithOptions(request, runtime);
  }

  async describeAntiBruteForceRulesWithOptions(request: DescribeAntiBruteForceRulesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntiBruteForceRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntiBruteForceRules",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntiBruteForceRulesResponse>(await this.callApi(params, req, runtime), new DescribeAntiBruteForceRulesResponse({}));
  }

  async describeAntiBruteForceRules(request: DescribeAntiBruteForceRulesRequest): Promise<DescribeAntiBruteForceRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntiBruteForceRulesWithOptions(request, runtime);
  }

  async describeAppVulScanCycleWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeAppVulScanCycleResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeAppVulScanCycle",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAppVulScanCycleResponse>(await this.callApi(params, req, runtime), new DescribeAppVulScanCycleResponse({}));
  }

  async describeAppVulScanCycle(): Promise<DescribeAppVulScanCycleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAppVulScanCycleWithOptions(runtime);
  }

  async describeAssetDetailByUuidWithOptions(request: DescribeAssetDetailByUuidRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAssetDetailByUuidResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAssetDetailByUuid",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAssetDetailByUuidResponse>(await this.callApi(params, req, runtime), new DescribeAssetDetailByUuidResponse({}));
  }

  async describeAssetDetailByUuid(request: DescribeAssetDetailByUuidRequest): Promise<DescribeAssetDetailByUuidResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAssetDetailByUuidWithOptions(request, runtime);
  }

  async describeAssetDetailByUuidsWithOptions(request: DescribeAssetDetailByUuidsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAssetDetailByUuidsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAssetDetailByUuids",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAssetDetailByUuidsResponse>(await this.callApi(params, req, runtime), new DescribeAssetDetailByUuidsResponse({}));
  }

  async describeAssetDetailByUuids(request: DescribeAssetDetailByUuidsRequest): Promise<DescribeAssetDetailByUuidsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAssetDetailByUuidsWithOptions(request, runtime);
  }

  async describeAssetSummaryWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeAssetSummaryResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeAssetSummary",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAssetSummaryResponse>(await this.callApi(params, req, runtime), new DescribeAssetSummaryResponse({}));
  }

  async describeAssetSummary(): Promise<DescribeAssetSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAssetSummaryWithOptions(runtime);
  }

  async describeAssetsSecurityEventSummaryWithOptions(request: DescribeAssetsSecurityEventSummaryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAssetsSecurityEventSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.containerFieldName)) {
      query["ContainerFieldName"] = request.containerFieldName;
    }

    if (!Util.isUnset(request.containerFieldValue)) {
      query["ContainerFieldValue"] = request.containerFieldValue;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAssetsSecurityEventSummary",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAssetsSecurityEventSummaryResponse>(await this.callApi(params, req, runtime), new DescribeAssetsSecurityEventSummaryResponse({}));
  }

  async describeAssetsSecurityEventSummary(request: DescribeAssetsSecurityEventSummaryRequest): Promise<DescribeAssetsSecurityEventSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAssetsSecurityEventSummaryWithOptions(request, runtime);
  }

  async describeAttachRecordsWithOptions(request: DescribeAttachRecordsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAttachRecordsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationId)) {
      query["ApplicationId"] = request.applicationId;
    }

    if (!Util.isUnset(request.ecsUUIDList)) {
      query["EcsUUIDList"] = request.ecsUUIDList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAttachRecords",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAttachRecordsResponse>(await this.callApi(params, req, runtime), new DescribeAttachRecordsResponse({}));
  }

  async describeAttachRecords(request: DescribeAttachRecordsRequest): Promise<DescribeAttachRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAttachRecordsWithOptions(request, runtime);
  }

  async describeAttackAnalysisDataWithOptions(request: DescribeAttackAnalysisDataRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAttackAnalysisDataResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.base64)) {
      query["Base64"] = request.base64;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.data)) {
      query["Data"] = request.data;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAttackAnalysisData",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAttackAnalysisDataResponse>(await this.callApi(params, req, runtime), new DescribeAttackAnalysisDataResponse({}));
  }

  async describeAttackAnalysisData(request: DescribeAttackAnalysisDataRequest): Promise<DescribeAttackAnalysisDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAttackAnalysisDataWithOptions(request, runtime);
  }

  async describeAutoDelConfigWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeAutoDelConfigResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeAutoDelConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAutoDelConfigResponse>(await this.callApi(params, req, runtime), new DescribeAutoDelConfigResponse({}));
  }

  async describeAutoDelConfig(): Promise<DescribeAutoDelConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAutoDelConfigWithOptions(runtime);
  }

  async describeBackUpExportInfoWithOptions(request: DescribeBackUpExportInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBackUpExportInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.exportType)) {
      query["ExportType"] = request.exportType;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBackUpExportInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBackUpExportInfoResponse>(await this.callApi(params, req, runtime), new DescribeBackUpExportInfoResponse({}));
  }

  async describeBackUpExportInfo(request: DescribeBackUpExportInfoRequest): Promise<DescribeBackUpExportInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBackUpExportInfoWithOptions(request, runtime);
  }

  /**
    * You can call the DescribeBackupClients operation to query the servers on which the anti-ransomware agent is installed in a specified region.
    *
    * @param request DescribeBackupClientsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeBackupClientsResponse
   */
  async describeBackupClientsWithOptions(request: DescribeBackupClientsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBackupClientsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.supportRegionId)) {
      query["SupportRegionId"] = request.supportRegionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBackupClients",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBackupClientsResponse>(await this.callApi(params, req, runtime), new DescribeBackupClientsResponse({}));
  }

  /**
    * You can call the DescribeBackupClients operation to query the servers on which the anti-ransomware agent is installed in a specified region.
    *
    * @param request DescribeBackupClientsRequest
    * @return DescribeBackupClientsResponse
   */
  async describeBackupClients(request: DescribeBackupClientsRequest): Promise<DescribeBackupClientsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBackupClientsWithOptions(request, runtime);
  }

  async describeBackupFilesWithOptions(request: DescribeBackupFilesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBackupFilesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.path)) {
      query["Path"] = request.path;
    }

    if (!Util.isUnset(request.snapshotHash)) {
      query["SnapshotHash"] = request.snapshotHash;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBackupFiles",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBackupFilesResponse>(await this.callApi(params, req, runtime), new DescribeBackupFilesResponse({}));
  }

  async describeBackupFiles(request: DescribeBackupFilesRequest): Promise<DescribeBackupFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBackupFilesWithOptions(request, runtime);
  }

  async describeBackupMachineStatusWithOptions(request: DescribeBackupMachineStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBackupMachineStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    if (!Util.isUnset(request.policyVersion)) {
      query["PolicyVersion"] = request.policyVersion;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBackupMachineStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBackupMachineStatusResponse>(await this.callApi(params, req, runtime), new DescribeBackupMachineStatusResponse({}));
  }

  async describeBackupMachineStatus(request: DescribeBackupMachineStatusRequest): Promise<DescribeBackupMachineStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBackupMachineStatusWithOptions(request, runtime);
  }

  async describeBackupPoliciesWithOptions(request: DescribeBackupPoliciesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBackupPoliciesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.machineRemark)) {
      query["MachineRemark"] = request.machineRemark;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBackupPolicies",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBackupPoliciesResponse>(await this.callApi(params, req, runtime), new DescribeBackupPoliciesResponse({}));
  }

  async describeBackupPolicies(request: DescribeBackupPoliciesRequest): Promise<DescribeBackupPoliciesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBackupPoliciesWithOptions(request, runtime);
  }

  async describeBackupPolicyWithOptions(request: DescribeBackupPolicyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBackupPolicyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBackupPolicy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBackupPolicyResponse>(await this.callApi(params, req, runtime), new DescribeBackupPolicyResponse({}));
  }

  async describeBackupPolicy(request: DescribeBackupPolicyRequest): Promise<DescribeBackupPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBackupPolicyWithOptions(request, runtime);
  }

  /**
    * If you have created restoration tasks, you can call this operation to query the number of restoration tasks that are in the **restored** or **being restored** state.
    *
    * @param request DescribeBackupRestoreCountRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeBackupRestoreCountResponse
   */
  async describeBackupRestoreCountWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeBackupRestoreCountResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeBackupRestoreCount",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBackupRestoreCountResponse>(await this.callApi(params, req, runtime), new DescribeBackupRestoreCountResponse({}));
  }

  /**
    * If you have created restoration tasks, you can call this operation to query the number of restoration tasks that are in the **restored** or **being restored** state.
    *
    * @return DescribeBackupRestoreCountResponse
   */
  async describeBackupRestoreCount(): Promise<DescribeBackupRestoreCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBackupRestoreCountWithOptions(runtime);
  }

  async describeBruteForceRecordsWithOptions(request: DescribeBruteForceRecordsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBruteForceRecordsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.blockIp)) {
      query["BlockIp"] = request.blockIp;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBruteForceRecords",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBruteForceRecordsResponse>(await this.callApi(params, req, runtime), new DescribeBruteForceRecordsResponse({}));
  }

  async describeBruteForceRecords(request: DescribeBruteForceRecordsRequest): Promise<DescribeBruteForceRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBruteForceRecordsWithOptions(request, runtime);
  }

  async describeBruteForceSummaryWithOptions(request: DescribeBruteForceSummaryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBruteForceSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBruteForceSummary",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBruteForceSummaryResponse>(await this.callApi(params, req, runtime), new DescribeBruteForceSummaryResponse({}));
  }

  async describeBruteForceSummary(request: DescribeBruteForceSummaryRequest): Promise<DescribeBruteForceSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBruteForceSummaryWithOptions(request, runtime);
  }

  async describeCanFixVulListWithOptions(request: DescribeCanFixVulListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCanFixVulListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliasName)) {
      query["AliasName"] = request.aliasName;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.containerId)) {
      query["ContainerId"] = request.containerId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.dealed)) {
      query["Dealed"] = request.dealed;
    }

    if (!Util.isUnset(request.digest)) {
      query["Digest"] = request.digest;
    }

    if (!Util.isUnset(request.image)) {
      query["Image"] = request.image;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.necessity)) {
      query["Necessity"] = request.necessity;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.pod)) {
      query["Pod"] = request.pod;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.repoId)) {
      query["RepoId"] = request.repoId;
    }

    if (!Util.isUnset(request.repoId)) {
      query["RepoId"] = request.repoId;
    }

    if (!Util.isUnset(request.repoInstanceId)) {
      query["RepoInstanceId"] = request.repoInstanceId;
    }

    if (!Util.isUnset(request.repoName)) {
      query["RepoName"] = request.repoName;
    }

    if (!Util.isUnset(request.repoName)) {
      query["RepoName"] = request.repoName;
    }

    if (!Util.isUnset(request.repoNamespace)) {
      query["RepoNamespace"] = request.repoNamespace;
    }

    if (!Util.isUnset(request.repoRegionId)) {
      query["RepoRegionId"] = request.repoRegionId;
    }

    if (!Util.isUnset(request.scanRange)) {
      query["ScanRange"] = request.scanRange;
    }

    if (!Util.isUnset(request.statusList)) {
      query["StatusList"] = request.statusList;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCanFixVulList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCanFixVulListResponse>(await this.callApi(params, req, runtime), new DescribeCanFixVulListResponse({}));
  }

  async describeCanFixVulList(request: DescribeCanFixVulListRequest): Promise<DescribeCanFixVulListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCanFixVulListWithOptions(request, runtime);
  }

  async describeCheckEcsWarningsWithOptions(request: DescribeCheckEcsWarningsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCheckEcsWarningsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCheckEcsWarnings",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCheckEcsWarningsResponse>(await this.callApi(params, req, runtime), new DescribeCheckEcsWarningsResponse({}));
  }

  async describeCheckEcsWarnings(request: DescribeCheckEcsWarningsRequest): Promise<DescribeCheckEcsWarningsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCheckEcsWarningsWithOptions(request, runtime);
  }

  async describeCheckFixDetailsWithOptions(request: DescribeCheckFixDetailsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCheckFixDetailsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkIds)) {
      query["CheckIds"] = request.checkIds;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.riskId)) {
      query["RiskId"] = request.riskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCheckFixDetails",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCheckFixDetailsResponse>(await this.callApi(params, req, runtime), new DescribeCheckFixDetailsResponse({}));
  }

  async describeCheckFixDetails(request: DescribeCheckFixDetailsRequest): Promise<DescribeCheckFixDetailsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCheckFixDetailsWithOptions(request, runtime);
  }

  async describeCheckWarningDetailWithOptions(request: DescribeCheckWarningDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCheckWarningDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkWarningId)) {
      query["CheckWarningId"] = request.checkWarningId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCheckWarningDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCheckWarningDetailResponse>(await this.callApi(params, req, runtime), new DescribeCheckWarningDetailResponse({}));
  }

  async describeCheckWarningDetail(request: DescribeCheckWarningDetailRequest): Promise<DescribeCheckWarningDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCheckWarningDetailWithOptions(request, runtime);
  }

  async describeCheckWarningMachinesWithOptions(request: DescribeCheckWarningMachinesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCheckWarningMachinesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkId)) {
      query["CheckId"] = request.checkId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.riskId)) {
      query["RiskId"] = request.riskId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCheckWarningMachines",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCheckWarningMachinesResponse>(await this.callApi(params, req, runtime), new DescribeCheckWarningMachinesResponse({}));
  }

  async describeCheckWarningMachines(request: DescribeCheckWarningMachinesRequest): Promise<DescribeCheckWarningMachinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCheckWarningMachinesWithOptions(request, runtime);
  }

  async describeCheckWarningSummaryWithOptions(request: DescribeCheckWarningSummaryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCheckWarningSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.containerFieldName)) {
      query["ContainerFieldName"] = request.containerFieldName;
    }

    if (!Util.isUnset(request.containerFieldValue)) {
      query["ContainerFieldValue"] = request.containerFieldValue;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.riskName)) {
      query["RiskName"] = request.riskName;
    }

    if (!Util.isUnset(request.riskStatus)) {
      query["RiskStatus"] = request.riskStatus;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.typeName)) {
      query["TypeName"] = request.typeName;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCheckWarningSummary",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCheckWarningSummaryResponse>(await this.callApi(params, req, runtime), new DescribeCheckWarningSummaryResponse({}));
  }

  async describeCheckWarningSummary(request: DescribeCheckWarningSummaryRequest): Promise<DescribeCheckWarningSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCheckWarningSummaryWithOptions(request, runtime);
  }

  async describeCheckWarningsWithOptions(request: DescribeCheckWarningsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCheckWarningsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkId)) {
      query["CheckId"] = request.checkId;
    }

    if (!Util.isUnset(request.checkType)) {
      query["CheckType"] = request.checkType;
    }

    if (!Util.isUnset(request.containerName)) {
      query["ContainerName"] = request.containerName;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.riskId)) {
      query["RiskId"] = request.riskId;
    }

    if (!Util.isUnset(request.riskStatus)) {
      query["RiskStatus"] = request.riskStatus;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCheckWarnings",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCheckWarningsResponse>(await this.callApi(params, req, runtime), new DescribeCheckWarningsResponse({}));
  }

  async describeCheckWarnings(request: DescribeCheckWarningsRequest): Promise<DescribeCheckWarningsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCheckWarningsWithOptions(request, runtime);
  }

  async describeClientConfSetupWithOptions(request: DescribeClientConfSetupRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClientConfSetupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.strategyTag)) {
      query["StrategyTag"] = request.strategyTag;
    }

    if (!Util.isUnset(request.strategyTagValue)) {
      query["StrategyTagValue"] = request.strategyTagValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClientConfSetup",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeClientConfSetupResponse>(await this.callApi(params, req, runtime), new DescribeClientConfSetupResponse({}));
  }

  async describeClientConfSetup(request: DescribeClientConfSetupRequest): Promise<DescribeClientConfSetupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClientConfSetupWithOptions(request, runtime);
  }

  async describeClientConfStrategyWithOptions(request: DescribeClientConfStrategyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClientConfStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.tagValue)) {
      query["TagValue"] = request.tagValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClientConfStrategy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeClientConfStrategyResponse>(await this.callApi(params, req, runtime), new DescribeClientConfStrategyResponse({}));
  }

  async describeClientConfStrategy(request: DescribeClientConfStrategyRequest): Promise<DescribeClientConfStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClientConfStrategyWithOptions(request, runtime);
  }

  /**
    * You can search for an asset by using search conditions, such as the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can also configure a logical relationship between multiple search conditions to search for the assets that meet the search conditions.
    *
    * @param request DescribeCloudCenterInstancesRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeCloudCenterInstancesResponse
   */
  async describeCloudCenterInstancesWithOptions(request: DescribeCloudCenterInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudCenterInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.criteria)) {
      query["Criteria"] = request.criteria;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.importance)) {
      query["Importance"] = request.importance;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.logicalExp)) {
      query["LogicalExp"] = request.logicalExp;
    }

    if (!Util.isUnset(request.machineTypes)) {
      query["MachineTypes"] = request.machineTypes;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.noGroupTrace)) {
      query["NoGroupTrace"] = request.noGroupTrace;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    if (!Util.isUnset(request.useNextToken)) {
      query["UseNextToken"] = request.useNextToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCloudCenterInstances",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudCenterInstancesResponse>(await this.callApi(params, req, runtime), new DescribeCloudCenterInstancesResponse({}));
  }

  /**
    * You can search for an asset by using search conditions, such as the instance ID, instance name, virtual private cloud (VPC) ID, region, and public IP address. You can also configure a logical relationship between multiple search conditions to search for the assets that meet the search conditions.
    *
    * @param request DescribeCloudCenterInstancesRequest
    * @return DescribeCloudCenterInstancesResponse
   */
  async describeCloudCenterInstances(request: DescribeCloudCenterInstancesRequest): Promise<DescribeCloudCenterInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudCenterInstancesWithOptions(request, runtime);
  }

  async describeCloudProductFieldStatisticsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeCloudProductFieldStatisticsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeCloudProductFieldStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudProductFieldStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeCloudProductFieldStatisticsResponse({}));
  }

  async describeCloudProductFieldStatistics(): Promise<DescribeCloudProductFieldStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudProductFieldStatisticsWithOptions(runtime);
  }

  async describeClusterBasicInfoWithOptions(request: DescribeClusterBasicInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClusterBasicInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterBasicInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterBasicInfoResponse>(await this.callApi(params, req, runtime), new DescribeClusterBasicInfoResponse({}));
  }

  async describeClusterBasicInfo(request: DescribeClusterBasicInfoRequest): Promise<DescribeClusterBasicInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterBasicInfoWithOptions(request, runtime);
  }

  async describeClusterInfoListWithOptions(request: DescribeClusterInfoListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClusterInfoListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.target)) {
      query["Target"] = request.target;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterInfoList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterInfoListResponse>(await this.callApi(params, req, runtime), new DescribeClusterInfoListResponse({}));
  }

  async describeClusterInfoList(request: DescribeClusterInfoListRequest): Promise<DescribeClusterInfoListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterInfoListWithOptions(request, runtime);
  }

  async describeClusterNetworkWithOptions(request: DescribeClusterNetworkRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClusterNetworkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterNetwork",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterNetworkResponse>(await this.callApi(params, req, runtime), new DescribeClusterNetworkResponse({}));
  }

  async describeClusterNetwork(request: DescribeClusterNetworkRequest): Promise<DescribeClusterNetworkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterNetworkWithOptions(request, runtime);
  }

  async describeClusterVulStatisticsWithOptions(request: DescribeClusterVulStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeClusterVulStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.types)) {
      query["Types"] = request.types;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeClusterVulStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeClusterVulStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeClusterVulStatisticsResponse({}));
  }

  async describeClusterVulStatistics(request: DescribeClusterVulStatisticsRequest): Promise<DescribeClusterVulStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeClusterVulStatisticsWithOptions(request, runtime);
  }

  async describeCommonOverallConfigWithOptions(request: DescribeCommonOverallConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCommonOverallConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCommonOverallConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCommonOverallConfigResponse>(await this.callApi(params, req, runtime), new DescribeCommonOverallConfigResponse({}));
  }

  async describeCommonOverallConfig(request: DescribeCommonOverallConfigRequest): Promise<DescribeCommonOverallConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCommonOverallConfigWithOptions(request, runtime);
  }

  async describeCommonOverallConfigListWithOptions(request: DescribeCommonOverallConfigListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCommonOverallConfigListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.typeList)) {
      query["TypeList"] = request.typeList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCommonOverallConfigList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCommonOverallConfigListResponse>(await this.callApi(params, req, runtime), new DescribeCommonOverallConfigListResponse({}));
  }

  async describeCommonOverallConfigList(request: DescribeCommonOverallConfigListRequest): Promise<DescribeCommonOverallConfigListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCommonOverallConfigListWithOptions(request, runtime);
  }

  async describeCommonTargetConfigWithOptions(request: DescribeCommonTargetConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCommonTargetConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCommonTargetConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCommonTargetConfigResponse>(await this.callApi(params, req, runtime), new DescribeCommonTargetConfigResponse({}));
  }

  async describeCommonTargetConfig(request: DescribeCommonTargetConfigRequest): Promise<DescribeCommonTargetConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCommonTargetConfigWithOptions(request, runtime);
  }

  async describeCommonTargetResultListWithOptions(request: DescribeCommonTargetResultListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCommonTargetResultListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCommonTargetResultList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCommonTargetResultListResponse>(await this.callApi(params, req, runtime), new DescribeCommonTargetResultListResponse({}));
  }

  async describeCommonTargetResultList(request: DescribeCommonTargetResultListRequest): Promise<DescribeCommonTargetResultListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCommonTargetResultListWithOptions(request, runtime);
  }

  async describeConcernNecessityWithOptions(request: DescribeConcernNecessityRequest, runtime: $Util.RuntimeOptions): Promise<DescribeConcernNecessityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeConcernNecessity",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeConcernNecessityResponse>(await this.callApi(params, req, runtime), new DescribeConcernNecessityResponse({}));
  }

  async describeConcernNecessity(request: DescribeConcernNecessityRequest): Promise<DescribeConcernNecessityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeConcernNecessityWithOptions(request, runtime);
  }

  async describeContainerCriteriaWithOptions(request: DescribeContainerCriteriaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeContainerCriteriaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupField)) {
      query["GroupField"] = request.groupField;
    }

    if (!Util.isUnset(request.value)) {
      query["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeContainerCriteria",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeContainerCriteriaResponse>(await this.callApi(params, req, runtime), new DescribeContainerCriteriaResponse({}));
  }

  async describeContainerCriteria(request: DescribeContainerCriteriaRequest): Promise<DescribeContainerCriteriaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeContainerCriteriaWithOptions(request, runtime);
  }

  async describeContainerInstancesWithOptions(request: DescribeContainerInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeContainerInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.criteria)) {
      query["Criteria"] = request.criteria;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.logicalExp)) {
      query["LogicalExp"] = request.logicalExp;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeContainerInstances",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeContainerInstancesResponse>(await this.callApi(params, req, runtime), new DescribeContainerInstancesResponse({}));
  }

  async describeContainerInstances(request: DescribeContainerInstancesRequest): Promise<DescribeContainerInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeContainerInstancesWithOptions(request, runtime);
  }

  async describeContainerScanConfigWithOptions(request: DescribeContainerScanConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeContainerScanConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeContainerScanConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeContainerScanConfigResponse>(await this.callApi(params, req, runtime), new DescribeContainerScanConfigResponse({}));
  }

  async describeContainerScanConfig(request: DescribeContainerScanConfigRequest): Promise<DescribeContainerScanConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeContainerScanConfigWithOptions(request, runtime);
  }

  /**
    * Only users who created a Container Registry Enterprise Edition instance can call this operation.
    *
    * @param request DescribeContainerStatisticsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeContainerStatisticsResponse
   */
  async describeContainerStatisticsWithOptions(request: DescribeContainerStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeContainerStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeContainerStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeContainerStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeContainerStatisticsResponse({}));
  }

  /**
    * Only users who created a Container Registry Enterprise Edition instance can call this operation.
    *
    * @param request DescribeContainerStatisticsRequest
    * @return DescribeContainerStatisticsResponse
   */
  async describeContainerStatistics(request: DescribeContainerStatisticsRequest): Promise<DescribeContainerStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeContainerStatisticsWithOptions(request, runtime);
  }

  async describeContainerTagsWithOptions(request: DescribeContainerTagsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeContainerTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.fieldName)) {
      query["FieldName"] = request.fieldName;
    }

    if (!Util.isUnset(request.fieldValue)) {
      query["FieldValue"] = request.fieldValue;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeContainerTags",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeContainerTagsResponse>(await this.callApi(params, req, runtime), new DescribeContainerTagsResponse({}));
  }

  async describeContainerTags(request: DescribeContainerTagsRequest): Promise<DescribeContainerTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeContainerTagsWithOptions(request, runtime);
  }

  async describeCountNotScannedImageWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeCountNotScannedImageResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeCountNotScannedImage",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCountNotScannedImageResponse>(await this.callApi(params, req, runtime), new DescribeCountNotScannedImageResponse({}));
  }

  async describeCountNotScannedImage(): Promise<DescribeCountNotScannedImageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCountNotScannedImageWithOptions(runtime);
  }

  async describeCountScannedImageWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeCountScannedImageResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeCountScannedImage",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCountScannedImageResponse>(await this.callApi(params, req, runtime), new DescribeCountScannedImageResponse({}));
  }

  async describeCountScannedImage(): Promise<DescribeCountScannedImageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCountScannedImageWithOptions(runtime);
  }

  async describeCriteriaWithOptions(request: DescribeCriteriaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCriteriaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.machineTypes)) {
      query["MachineTypes"] = request.machineTypes;
    }

    if (!Util.isUnset(request.supportAutoTag)) {
      query["SupportAutoTag"] = request.supportAutoTag;
    }

    if (!Util.isUnset(request.value)) {
      query["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCriteria",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCriteriaResponse>(await this.callApi(params, req, runtime), new DescribeCriteriaResponse({}));
  }

  async describeCriteria(request: DescribeCriteriaRequest): Promise<DescribeCriteriaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCriteriaWithOptions(request, runtime);
  }

  async describeCustomBlockRecordsWithOptions(request: DescribeCustomBlockRecordsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCustomBlockRecordsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.blockIp)) {
      query["BlockIp"] = request.blockIp;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCustomBlockRecords",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCustomBlockRecordsResponse>(await this.callApi(params, req, runtime), new DescribeCustomBlockRecordsResponse({}));
  }

  async describeCustomBlockRecords(request: DescribeCustomBlockRecordsRequest): Promise<DescribeCustomBlockRecordsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCustomBlockRecordsWithOptions(request, runtime);
  }

  async describeCycleTaskListWithOptions(request: DescribeCycleTaskListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCycleTaskListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCycleTaskList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCycleTaskListResponse>(await this.callApi(params, req, runtime), new DescribeCycleTaskListResponse({}));
  }

  async describeCycleTaskList(request: DescribeCycleTaskListRequest): Promise<DescribeCycleTaskListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCycleTaskListWithOptions(request, runtime);
  }

  async describeDingTalkWithOptions(request: DescribeDingTalkRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDingTalkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleActionName)) {
      query["RuleActionName"] = request.ruleActionName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDingTalk",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDingTalkResponse>(await this.callApi(params, req, runtime), new DescribeDingTalkResponse({}));
  }

  async describeDingTalk(request: DescribeDingTalkRequest): Promise<DescribeDingTalkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDingTalkWithOptions(request, runtime);
  }

  async describeDomainCountWithOptions(request: DescribeDomainCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainCount",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainCountResponse>(await this.callApi(params, req, runtime), new DescribeDomainCountResponse({}));
  }

  async describeDomainCount(request: DescribeDomainCountRequest): Promise<DescribeDomainCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainCountWithOptions(request, runtime);
  }

  async describeDomainDetailWithOptions(request: DescribeDomainDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.domainName)) {
      query["DomainName"] = request.domainName;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainDetailResponse>(await this.callApi(params, req, runtime), new DescribeDomainDetailResponse({}));
  }

  async describeDomainDetail(request: DescribeDomainDetailRequest): Promise<DescribeDomainDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainDetailWithOptions(request, runtime);
  }

  async describeDomainListWithOptions(request: DescribeDomainListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDomainListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.domainType)) {
      query["DomainType"] = request.domainType;
    }

    if (!Util.isUnset(request.fuzzyDomain)) {
      query["FuzzyDomain"] = request.fuzzyDomain;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDomainList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDomainListResponse>(await this.callApi(params, req, runtime), new DescribeDomainListResponse({}));
  }

  async describeDomainList(request: DescribeDomainListRequest): Promise<DescribeDomainListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDomainListWithOptions(request, runtime);
  }

  async describeEmgUserAgreementWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeEmgUserAgreementResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeEmgUserAgreement",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEmgUserAgreementResponse>(await this.callApi(params, req, runtime), new DescribeEmgUserAgreementResponse({}));
  }

  async describeEmgUserAgreement(): Promise<DescribeEmgUserAgreementResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEmgUserAgreementWithOptions(runtime);
  }

  async describeEmgVulItemWithOptions(request: DescribeEmgVulItemRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEmgVulItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkType)) {
      query["CheckType"] = request.checkType;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.riskStatus)) {
      query["RiskStatus"] = request.riskStatus;
    }

    if (!Util.isUnset(request.scanType)) {
      query["ScanType"] = request.scanType;
    }

    if (!Util.isUnset(request.vulName)) {
      query["VulName"] = request.vulName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEmgVulItem",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEmgVulItemResponse>(await this.callApi(params, req, runtime), new DescribeEmgVulItemResponse({}));
  }

  async describeEmgVulItem(request: DescribeEmgVulItemRequest): Promise<DescribeEmgVulItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEmgVulItemWithOptions(request, runtime);
  }

  async describeEventLevelCountWithOptions(request: DescribeEventLevelCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEventLevelCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.containerFieldName)) {
      query["ContainerFieldName"] = request.containerFieldName;
    }

    if (!Util.isUnset(request.containerFieldValue)) {
      query["ContainerFieldValue"] = request.containerFieldValue;
    }

    if (!Util.isUnset(request.containerIds)) {
      query["ContainerIds"] = request.containerIds;
    }

    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEventLevelCount",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEventLevelCountResponse>(await this.callApi(params, req, runtime), new DescribeEventLevelCountResponse({}));
  }

  async describeEventLevelCount(request: DescribeEventLevelCountRequest): Promise<DescribeEventLevelCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEventLevelCountWithOptions(request, runtime);
  }

  async describeEventOnStageWithOptions(request: DescribeEventOnStageRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEventOnStageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEventOnStage",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEventOnStageResponse>(await this.callApi(params, req, runtime), new DescribeEventOnStageResponse({}));
  }

  async describeEventOnStage(request: DescribeEventOnStageRequest): Promise<DescribeEventOnStageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEventOnStageWithOptions(request, runtime);
  }

  async describeExcludeSystemPathWithOptions(request: DescribeExcludeSystemPathRequest, runtime: $Util.RuntimeOptions): Promise<DescribeExcludeSystemPathResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeExcludeSystemPath",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeExcludeSystemPathResponse>(await this.callApi(params, req, runtime), new DescribeExcludeSystemPathResponse({}));
  }

  async describeExcludeSystemPath(request: DescribeExcludeSystemPathRequest): Promise<DescribeExcludeSystemPathResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeExcludeSystemPathWithOptions(request, runtime);
  }

  async describeExportInfoWithOptions(request: DescribeExportInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeExportInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.exportId)) {
      query["ExportId"] = request.exportId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeExportInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeExportInfoResponse>(await this.callApi(params, req, runtime), new DescribeExportInfoResponse({}));
  }

  async describeExportInfo(request: DescribeExportInfoRequest): Promise<DescribeExportInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeExportInfoWithOptions(request, runtime);
  }

  async describeExposedCheckWarningWithOptions(request: DescribeExposedCheckWarningRequest, runtime: $Util.RuntimeOptions): Promise<DescribeExposedCheckWarningResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.typeName)) {
      query["TypeName"] = request.typeName;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeExposedCheckWarning",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeExposedCheckWarningResponse>(await this.callApi(params, req, runtime), new DescribeExposedCheckWarningResponse({}));
  }

  async describeExposedCheckWarning(request: DescribeExposedCheckWarningRequest): Promise<DescribeExposedCheckWarningResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeExposedCheckWarningWithOptions(request, runtime);
  }

  async describeExposedInstanceCriteriaWithOptions(request: DescribeExposedInstanceCriteriaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeExposedInstanceCriteriaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.value)) {
      query["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeExposedInstanceCriteria",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeExposedInstanceCriteriaResponse>(await this.callApi(params, req, runtime), new DescribeExposedInstanceCriteriaResponse({}));
  }

  async describeExposedInstanceCriteria(request: DescribeExposedInstanceCriteriaRequest): Promise<DescribeExposedInstanceCriteriaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeExposedInstanceCriteriaWithOptions(request, runtime);
  }

  async describeExposedInstanceDetailWithOptions(request: DescribeExposedInstanceDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeExposedInstanceDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeExposedInstanceDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeExposedInstanceDetailResponse>(await this.callApi(params, req, runtime), new DescribeExposedInstanceDetailResponse({}));
  }

  async describeExposedInstanceDetail(request: DescribeExposedInstanceDetailRequest): Promise<DescribeExposedInstanceDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeExposedInstanceDetailWithOptions(request, runtime);
  }

  async describeExposedInstanceListWithOptions(request: DescribeExposedInstanceListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeExposedInstanceListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.exposureComponent)) {
      query["ExposureComponent"] = request.exposureComponent;
    }

    if (!Util.isUnset(request.exposureIp)) {
      query["ExposureIp"] = request.exposureIp;
    }

    if (!Util.isUnset(request.exposurePort)) {
      query["ExposurePort"] = request.exposurePort;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.healthStatus)) {
      query["HealthStatus"] = request.healthStatus;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.vulStatus)) {
      query["VulStatus"] = request.vulStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeExposedInstanceList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeExposedInstanceListResponse>(await this.callApi(params, req, runtime), new DescribeExposedInstanceListResponse({}));
  }

  async describeExposedInstanceList(request: DescribeExposedInstanceListRequest): Promise<DescribeExposedInstanceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeExposedInstanceListWithOptions(request, runtime);
  }

  async describeExposedStatisticsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeExposedStatisticsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeExposedStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeExposedStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeExposedStatisticsResponse({}));
  }

  async describeExposedStatistics(): Promise<DescribeExposedStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeExposedStatisticsWithOptions(runtime);
  }

  async describeExposedStatisticsDetailWithOptions(request: DescribeExposedStatisticsDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeExposedStatisticsDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.statisticsType)) {
      query["StatisticsType"] = request.statisticsType;
    }

    if (!Util.isUnset(request.statisticsTypeGatewayType)) {
      query["StatisticsTypeGatewayType"] = request.statisticsTypeGatewayType;
    }

    if (!Util.isUnset(request.statisticsTypeInstanceValue)) {
      query["StatisticsTypeInstanceValue"] = request.statisticsTypeInstanceValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeExposedStatisticsDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeExposedStatisticsDetailResponse>(await this.callApi(params, req, runtime), new DescribeExposedStatisticsDetailResponse({}));
  }

  async describeExposedStatisticsDetail(request: DescribeExposedStatisticsDetailRequest): Promise<DescribeExposedStatisticsDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeExposedStatisticsDetailWithOptions(request, runtime);
  }

  async describeFieldStatisticsWithOptions(request: DescribeFieldStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFieldStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.machineTypes)) {
      query["MachineTypes"] = request.machineTypes;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFieldStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFieldStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeFieldStatisticsResponse({}));
  }

  async describeFieldStatistics(request: DescribeFieldStatisticsRequest): Promise<DescribeFieldStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFieldStatisticsWithOptions(request, runtime);
  }

  async describeFrontVulPatchListWithOptions(request: DescribeFrontVulPatchListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFrontVulPatchListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.info)) {
      query["Info"] = request.info;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.operateType)) {
      query["OperateType"] = request.operateType;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFrontVulPatchList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFrontVulPatchListResponse>(await this.callApi(params, req, runtime), new DescribeFrontVulPatchListResponse({}));
  }

  async describeFrontVulPatchList(request: DescribeFrontVulPatchListRequest): Promise<DescribeFrontVulPatchListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFrontVulPatchListWithOptions(request, runtime);
  }

  async describeGroupStructWithOptions(request: DescribeGroupStructRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGroupStructResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGroupStruct",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGroupStructResponse>(await this.callApi(params, req, runtime), new DescribeGroupStructResponse({}));
  }

  async describeGroupStruct(request: DescribeGroupStructRequest): Promise<DescribeGroupStructResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGroupStructWithOptions(request, runtime);
  }

  async describeGroupedContainerInstancesWithOptions(request: DescribeGroupedContainerInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGroupedContainerInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.criteria)) {
      query["Criteria"] = request.criteria;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.fieldValue)) {
      query["FieldValue"] = request.fieldValue;
    }

    if (!Util.isUnset(request.groupField)) {
      query["GroupField"] = request.groupField;
    }

    if (!Util.isUnset(request.logicalExp)) {
      query["LogicalExp"] = request.logicalExp;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGroupedContainerInstances",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGroupedContainerInstancesResponse>(await this.callApi(params, req, runtime), new DescribeGroupedContainerInstancesResponse({}));
  }

  async describeGroupedContainerInstances(request: DescribeGroupedContainerInstancesRequest): Promise<DescribeGroupedContainerInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGroupedContainerInstancesWithOptions(request, runtime);
  }

  async describeGroupedInstancesWithOptions(request: DescribeGroupedInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGroupedInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.fieldValue)) {
      query["FieldValue"] = request.fieldValue;
    }

    if (!Util.isUnset(request.groupField)) {
      query["GroupField"] = request.groupField;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.machineTypes)) {
      query["MachineTypes"] = request.machineTypes;
    }

    if (!Util.isUnset(request.noPage)) {
      query["NoPage"] = request.noPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.saleVersionCheckCode)) {
      query["SaleVersionCheckCode"] = request.saleVersionCheckCode;
    }

    if (!Util.isUnset(request.vendor)) {
      query["Vendor"] = request.vendor;
    }

    if (!Util.isUnset(request.vendors)) {
      query["Vendors"] = request.vendors;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGroupedInstances",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGroupedInstancesResponse>(await this.callApi(params, req, runtime), new DescribeGroupedInstancesResponse({}));
  }

  async describeGroupedInstances(request: DescribeGroupedInstancesRequest): Promise<DescribeGroupedInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGroupedInstancesWithOptions(request, runtime);
  }

  async describeGroupedMaliciousFilesWithOptions(request: DescribeGroupedMaliciousFilesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGroupedMaliciousFilesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.fuzzyMaliciousName)) {
      query["FuzzyMaliciousName"] = request.fuzzyMaliciousName;
    }

    if (!Util.isUnset(request.imageDigest)) {
      query["ImageDigest"] = request.imageDigest;
    }

    if (!Util.isUnset(request.imageLayer)) {
      query["ImageLayer"] = request.imageLayer;
    }

    if (!Util.isUnset(request.imageTag)) {
      query["ImageTag"] = request.imageTag;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.levels)) {
      query["Levels"] = request.levels;
    }

    if (!Util.isUnset(request.maliciousMd5)) {
      query["MaliciousMd5"] = request.maliciousMd5;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.repoId)) {
      query["RepoId"] = request.repoId;
    }

    if (!Util.isUnset(request.repoInstanceId)) {
      query["RepoInstanceId"] = request.repoInstanceId;
    }

    if (!Util.isUnset(request.repoName)) {
      query["RepoName"] = request.repoName;
    }

    if (!Util.isUnset(request.repoNamespace)) {
      query["RepoNamespace"] = request.repoNamespace;
    }

    if (!Util.isUnset(request.repoRegionId)) {
      query["RepoRegionId"] = request.repoRegionId;
    }

    if (!Util.isUnset(request.scanRange)) {
      query["ScanRange"] = request.scanRange;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGroupedMaliciousFiles",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGroupedMaliciousFilesResponse>(await this.callApi(params, req, runtime), new DescribeGroupedMaliciousFilesResponse({}));
  }

  async describeGroupedMaliciousFiles(request: DescribeGroupedMaliciousFilesRequest): Promise<DescribeGroupedMaliciousFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGroupedMaliciousFilesWithOptions(request, runtime);
  }

  async describeGroupedTagsWithOptions(request: DescribeGroupedTagsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGroupedTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.machineTypes)) {
      query["MachineTypes"] = request.machineTypes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGroupedTags",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGroupedTagsResponse>(await this.callApi(params, req, runtime), new DescribeGroupedTagsResponse({}));
  }

  async describeGroupedTags(request: DescribeGroupedTagsRequest): Promise<DescribeGroupedTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGroupedTagsWithOptions(request, runtime);
  }

  async describeGroupedVulWithOptions(request: DescribeGroupedVulRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGroupedVulResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliasName)) {
      query["AliasName"] = request.aliasName;
    }

    if (!Util.isUnset(request.assetType)) {
      query["AssetType"] = request.assetType;
    }

    if (!Util.isUnset(request.attachTypes)) {
      query["AttachTypes"] = request.attachTypes;
    }

    if (!Util.isUnset(request.containerFieldName)) {
      query["ContainerFieldName"] = request.containerFieldName;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.dealed)) {
      query["Dealed"] = request.dealed;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.necessity)) {
      query["Necessity"] = request.necessity;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    if (!Util.isUnset(request.searchTags)) {
      query["SearchTags"] = request.searchTags;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGroupedVul",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGroupedVulResponse>(await this.callApi(params, req, runtime), new DescribeGroupedVulResponse({}));
  }

  async describeGroupedVul(request: DescribeGroupedVulRequest): Promise<DescribeGroupedVulResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGroupedVulWithOptions(request, runtime);
  }

  async describeHcExportInfoWithOptions(request: DescribeHcExportInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHcExportInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.exportId)) {
      query["ExportId"] = request.exportId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHcExportInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHcExportInfoResponse>(await this.callApi(params, req, runtime), new DescribeHcExportInfoResponse({}));
  }

  async describeHcExportInfo(request: DescribeHcExportInfoRequest): Promise<DescribeHcExportInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHcExportInfoWithOptions(request, runtime);
  }

  async describeHoneyPotAuthWithOptions(request: DescribeHoneyPotAuthRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHoneyPotAuthResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHoneyPotAuth",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHoneyPotAuthResponse>(await this.callApi(params, req, runtime), new DescribeHoneyPotAuthResponse({}));
  }

  async describeHoneyPotAuth(request: DescribeHoneyPotAuthRequest): Promise<DescribeHoneyPotAuthResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHoneyPotAuthWithOptions(request, runtime);
  }

  async describeHoneyPotSuspStatisticsWithOptions(request: DescribeHoneyPotSuspStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeHoneyPotSuspStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.statisticsDays)) {
      query["StatisticsDays"] = request.statisticsDays;
    }

    if (!Util.isUnset(request.statisticsKeyType)) {
      query["StatisticsKeyType"] = request.statisticsKeyType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeHoneyPotSuspStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeHoneyPotSuspStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeHoneyPotSuspStatisticsResponse({}));
  }

  async describeHoneyPotSuspStatistics(request: DescribeHoneyPotSuspStatisticsRequest): Promise<DescribeHoneyPotSuspStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeHoneyPotSuspStatisticsWithOptions(request, runtime);
  }

  async describeImageWithOptions(request: DescribeImageRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.imageInstanceId)) {
      query["ImageInstanceId"] = request.imageInstanceId;
    }

    if (!Util.isUnset(request.imageRegionId)) {
      query["ImageRegionId"] = request.imageRegionId;
    }

    if (!Util.isUnset(request.imageRepoId)) {
      query["ImageRepoId"] = request.imageRepoId;
    }

    if (!Util.isUnset(request.imageTag)) {
      query["ImageTag"] = request.imageTag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImage",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageResponse>(await this.callApi(params, req, runtime), new DescribeImageResponse({}));
  }

  async describeImage(request: DescribeImageRequest): Promise<DescribeImageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageWithOptions(request, runtime);
  }

  async describeImageBaselineCheckResultWithOptions(request: DescribeImageBaselineCheckResultRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageBaselineCheckResultResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.criteria)) {
      query["Criteria"] = request.criteria;
    }

    if (!Util.isUnset(request.criteriaType)) {
      query["CriteriaType"] = request.criteriaType;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.imageUuid)) {
      query["ImageUuid"] = request.imageUuid;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.riskLevel)) {
      query["RiskLevel"] = request.riskLevel;
    }

    if (!Util.isUnset(request.scanRange)) {
      query["ScanRange"] = request.scanRange;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageBaselineCheckResult",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageBaselineCheckResultResponse>(await this.callApi(params, req, runtime), new DescribeImageBaselineCheckResultResponse({}));
  }

  async describeImageBaselineCheckResult(request: DescribeImageBaselineCheckResultRequest): Promise<DescribeImageBaselineCheckResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageBaselineCheckResultWithOptions(request, runtime);
  }

  async describeImageBaselineCheckSummaryWithOptions(request: DescribeImageBaselineCheckSummaryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageBaselineCheckSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.criteria)) {
      query["Criteria"] = request.criteria;
    }

    if (!Util.isUnset(request.criteriaType)) {
      query["CriteriaType"] = request.criteriaType;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.riskLevel)) {
      query["RiskLevel"] = request.riskLevel;
    }

    if (!Util.isUnset(request.scanRange)) {
      query["ScanRange"] = request.scanRange;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageBaselineCheckSummary",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageBaselineCheckSummaryResponse>(await this.callApi(params, req, runtime), new DescribeImageBaselineCheckSummaryResponse({}));
  }

  async describeImageBaselineCheckSummary(request: DescribeImageBaselineCheckSummaryRequest): Promise<DescribeImageBaselineCheckSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageBaselineCheckSummaryWithOptions(request, runtime);
  }

  async describeImageBaselineDetailWithOptions(request: DescribeImageBaselineDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageBaselineDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.baselineItemKey)) {
      query["BaselineItemKey"] = request.baselineItemKey;
    }

    if (!Util.isUnset(request.imageUuid)) {
      query["ImageUuid"] = request.imageUuid;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageBaselineDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageBaselineDetailResponse>(await this.callApi(params, req, runtime), new DescribeImageBaselineDetailResponse({}));
  }

  async describeImageBaselineDetail(request: DescribeImageBaselineDetailRequest): Promise<DescribeImageBaselineDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageBaselineDetailWithOptions(request, runtime);
  }

  async describeImageBaselineItemListWithOptions(request: DescribeImageBaselineItemListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageBaselineItemListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.baselineClassKey)) {
      query["BaselineClassKey"] = request.baselineClassKey;
    }

    if (!Util.isUnset(request.baselineNameKey)) {
      query["BaselineNameKey"] = request.baselineNameKey;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.imageUuid)) {
      query["ImageUuid"] = request.imageUuid;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.scanRange)) {
      query["ScanRange"] = request.scanRange;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageBaselineItemList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageBaselineItemListResponse>(await this.callApi(params, req, runtime), new DescribeImageBaselineItemListResponse({}));
  }

  async describeImageBaselineItemList(request: DescribeImageBaselineItemListRequest): Promise<DescribeImageBaselineItemListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageBaselineItemListWithOptions(request, runtime);
  }

  async describeImageBaselineStrategyWithOptions(request: DescribeImageBaselineStrategyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageBaselineStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageBaselineStrategy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageBaselineStrategyResponse>(await this.callApi(params, req, runtime), new DescribeImageBaselineStrategyResponse({}));
  }

  async describeImageBaselineStrategy(request: DescribeImageBaselineStrategyRequest): Promise<DescribeImageBaselineStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageBaselineStrategyWithOptions(request, runtime);
  }

  async describeImageCriteriaWithOptions(request: DescribeImageCriteriaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageCriteriaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.value)) {
      query["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageCriteria",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageCriteriaResponse>(await this.callApi(params, req, runtime), new DescribeImageCriteriaResponse({}));
  }

  async describeImageCriteria(request: DescribeImageCriteriaRequest): Promise<DescribeImageCriteriaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageCriteriaWithOptions(request, runtime);
  }

  async describeImageEventOperationConditionWithOptions(request: DescribeImageEventOperationConditionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageEventOperationConditionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageEventOperationCondition",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageEventOperationConditionResponse>(await this.callApi(params, req, runtime), new DescribeImageEventOperationConditionResponse({}));
  }

  async describeImageEventOperationCondition(request: DescribeImageEventOperationConditionRequest): Promise<DescribeImageEventOperationConditionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageEventOperationConditionWithOptions(request, runtime);
  }

  async describeImageEventOperationPageWithOptions(request: DescribeImageEventOperationPageRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageEventOperationPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.eventKey)) {
      query["EventKey"] = request.eventKey;
    }

    if (!Util.isUnset(request.eventName)) {
      query["EventName"] = request.eventName;
    }

    if (!Util.isUnset(request.eventType)) {
      query["EventType"] = request.eventType;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageEventOperationPage",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageEventOperationPageResponse>(await this.callApi(params, req, runtime), new DescribeImageEventOperationPageResponse({}));
  }

  async describeImageEventOperationPage(request: DescribeImageEventOperationPageRequest): Promise<DescribeImageEventOperationPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageEventOperationPageWithOptions(request, runtime);
  }

  async describeImageFixCycleConfigWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeImageFixCycleConfigResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeImageFixCycleConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageFixCycleConfigResponse>(await this.callApi(params, req, runtime), new DescribeImageFixCycleConfigResponse({}));
  }

  async describeImageFixCycleConfig(): Promise<DescribeImageFixCycleConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageFixCycleConfigWithOptions(runtime);
  }

  async describeImageFixTaskWithOptions(request: DescribeImageFixTaskRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageFixTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageFixTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageFixTaskResponse>(await this.callApi(params, req, runtime), new DescribeImageFixTaskResponse({}));
  }

  async describeImageFixTask(request: DescribeImageFixTaskRequest): Promise<DescribeImageFixTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageFixTaskWithOptions(request, runtime);
  }

  async describeImageGroupedVulListWithOptions(request: DescribeImageGroupedVulListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageGroupedVulListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliasName)) {
      query["AliasName"] = request.aliasName;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.cveId)) {
      query["CveId"] = request.cveId;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.imageDigest)) {
      query["ImageDigest"] = request.imageDigest;
    }

    if (!Util.isUnset(request.imageLayer)) {
      query["ImageLayer"] = request.imageLayer;
    }

    if (!Util.isUnset(request.imageTag)) {
      query["ImageTag"] = request.imageTag;
    }

    if (!Util.isUnset(request.isLatest)) {
      query["IsLatest"] = request.isLatest;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.necessity)) {
      query["Necessity"] = request.necessity;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.patchId)) {
      query["PatchId"] = request.patchId;
    }

    if (!Util.isUnset(request.repoId)) {
      query["RepoId"] = request.repoId;
    }

    if (!Util.isUnset(request.repoInstanceId)) {
      query["RepoInstanceId"] = request.repoInstanceId;
    }

    if (!Util.isUnset(request.repoName)) {
      query["RepoName"] = request.repoName;
    }

    if (!Util.isUnset(request.repoNamespace)) {
      query["RepoNamespace"] = request.repoNamespace;
    }

    if (!Util.isUnset(request.repoRegionId)) {
      query["RepoRegionId"] = request.repoRegionId;
    }

    if (!Util.isUnset(request.scanRange)) {
      query["ScanRange"] = request.scanRange;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageGroupedVulList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageGroupedVulListResponse>(await this.callApi(params, req, runtime), new DescribeImageGroupedVulListResponse({}));
  }

  async describeImageGroupedVulList(request: DescribeImageGroupedVulListRequest): Promise<DescribeImageGroupedVulListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageGroupedVulListWithOptions(request, runtime);
  }

  async describeImageInfoListWithOptions(request: DescribeImageInfoListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageInfoListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageInfoList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageInfoListResponse>(await this.callApi(params, req, runtime), new DescribeImageInfoListResponse({}));
  }

  async describeImageInfoList(request: DescribeImageInfoListRequest): Promise<DescribeImageInfoListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageInfoListWithOptions(request, runtime);
  }

  async describeImageInstancesWithOptions(request: DescribeImageInstancesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.criteria)) {
      query["Criteria"] = request.criteria;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.logicalExp)) {
      query["LogicalExp"] = request.logicalExp;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.scanned)) {
      query["Scanned"] = request.scanned;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageInstances",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageInstancesResponse>(await this.callApi(params, req, runtime), new DescribeImageInstancesResponse({}));
  }

  async describeImageInstances(request: DescribeImageInstancesRequest): Promise<DescribeImageInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageInstancesWithOptions(request, runtime);
  }

  async describeImageLatestScanTaskWithOptions(request: DescribeImageLatestScanTaskRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageLatestScanTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.digest)) {
      query["Digest"] = request.digest;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageLatestScanTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageLatestScanTaskResponse>(await this.callApi(params, req, runtime), new DescribeImageLatestScanTaskResponse({}));
  }

  async describeImageLatestScanTask(request: DescribeImageLatestScanTaskRequest): Promise<DescribeImageLatestScanTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageLatestScanTaskWithOptions(request, runtime);
  }

  async describeImageListBySensitiveFileWithOptions(tmpReq: DescribeImageListBySensitiveFileRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageListBySensitiveFileResponse> {
    Util.validateModel(tmpReq);
    let request = new DescribeImageListBySensitiveFileShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.scanRange)) {
      request.scanRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scanRange, "ScanRange", "json");
    }

    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.imageDigest)) {
      query["ImageDigest"] = request.imageDigest;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.repoInstanceId)) {
      query["RepoInstanceId"] = request.repoInstanceId;
    }

    if (!Util.isUnset(request.repoName)) {
      query["RepoName"] = request.repoName;
    }

    if (!Util.isUnset(request.repoNamespace)) {
      query["RepoNamespace"] = request.repoNamespace;
    }

    if (!Util.isUnset(request.riskLevel)) {
      query["RiskLevel"] = request.riskLevel;
    }

    if (!Util.isUnset(request.scanRangeShrink)) {
      query["ScanRange"] = request.scanRangeShrink;
    }

    if (!Util.isUnset(request.sensitiveFileKey)) {
      query["SensitiveFileKey"] = request.sensitiveFileKey;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageListBySensitiveFile",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageListBySensitiveFileResponse>(await this.callApi(params, req, runtime), new DescribeImageListBySensitiveFileResponse({}));
  }

  async describeImageListBySensitiveFile(request: DescribeImageListBySensitiveFileRequest): Promise<DescribeImageListBySensitiveFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageListBySensitiveFileWithOptions(request, runtime);
  }

  async describeImageListWithBaselineNameWithOptions(request: DescribeImageListWithBaselineNameRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageListWithBaselineNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.baselineNameKey)) {
      query["BaselineNameKey"] = request.baselineNameKey;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.containerId)) {
      query["ContainerId"] = request.containerId;
    }

    if (!Util.isUnset(request.criteria)) {
      query["Criteria"] = request.criteria;
    }

    if (!Util.isUnset(request.criteriaType)) {
      query["CriteriaType"] = request.criteriaType;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.image)) {
      query["Image"] = request.image;
    }

    if (!Util.isUnset(request.imageDigest)) {
      query["ImageDigest"] = request.imageDigest;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.pod)) {
      query["Pod"] = request.pod;
    }

    if (!Util.isUnset(request.repoInstanceId)) {
      query["RepoInstanceId"] = request.repoInstanceId;
    }

    if (!Util.isUnset(request.repoName)) {
      query["RepoName"] = request.repoName;
    }

    if (!Util.isUnset(request.repoNamespace)) {
      query["RepoNamespace"] = request.repoNamespace;
    }

    if (!Util.isUnset(request.scanRange)) {
      query["ScanRange"] = request.scanRange;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageListWithBaselineName",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageListWithBaselineNameResponse>(await this.callApi(params, req, runtime), new DescribeImageListWithBaselineNameResponse({}));
  }

  async describeImageListWithBaselineName(request: DescribeImageListWithBaselineNameRequest): Promise<DescribeImageListWithBaselineNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageListWithBaselineNameWithOptions(request, runtime);
  }

  async describeImageRepoCriteriaWithOptions(request: DescribeImageRepoCriteriaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageRepoCriteriaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.value)) {
      query["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageRepoCriteria",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageRepoCriteriaResponse>(await this.callApi(params, req, runtime), new DescribeImageRepoCriteriaResponse({}));
  }

  async describeImageRepoCriteria(request: DescribeImageRepoCriteriaRequest): Promise<DescribeImageRepoCriteriaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageRepoCriteriaWithOptions(request, runtime);
  }

  async describeImageRepoDetailListWithOptions(request: DescribeImageRepoDetailListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageRepoDetailListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.criteria)) {
      query["Criteria"] = request.criteria;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.logicalExp)) {
      query["LogicalExp"] = request.logicalExp;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageRepoDetailList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageRepoDetailListResponse>(await this.callApi(params, req, runtime), new DescribeImageRepoDetailListResponse({}));
  }

  async describeImageRepoDetailList(request: DescribeImageRepoDetailListRequest): Promise<DescribeImageRepoDetailListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageRepoDetailListWithOptions(request, runtime);
  }

  async describeImageRepoListWithOptions(request: DescribeImageRepoListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageRepoListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.fieldName)) {
      query["FieldName"] = request.fieldName;
    }

    if (!Util.isUnset(request.fieldValue)) {
      query["FieldValue"] = request.fieldValue;
    }

    if (!Util.isUnset(request.operateType)) {
      query["OperateType"] = request.operateType;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.repoName)) {
      query["RepoName"] = request.repoName;
    }

    if (!Util.isUnset(request.repoNamespace)) {
      query["RepoNamespace"] = request.repoNamespace;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageRepoList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageRepoListResponse>(await this.callApi(params, req, runtime), new DescribeImageRepoListResponse({}));
  }

  async describeImageRepoList(request: DescribeImageRepoListRequest): Promise<DescribeImageRepoListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageRepoListWithOptions(request, runtime);
  }

  async describeImageScanAuthCountWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeImageScanAuthCountResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeImageScanAuthCount",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageScanAuthCountResponse>(await this.callApi(params, req, runtime), new DescribeImageScanAuthCountResponse({}));
  }

  async describeImageScanAuthCount(): Promise<DescribeImageScanAuthCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageScanAuthCountWithOptions(runtime);
  }

  async describeImageScanAuthorizationWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeImageScanAuthorizationResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeImageScanAuthorization",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageScanAuthorizationResponse>(await this.callApi(params, req, runtime), new DescribeImageScanAuthorizationResponse({}));
  }

  async describeImageScanAuthorization(): Promise<DescribeImageScanAuthorizationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageScanAuthorizationWithOptions(runtime);
  }

  async describeImageSensitiveFileByKeyWithOptions(tmpReq: DescribeImageSensitiveFileByKeyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageSensitiveFileByKeyResponse> {
    Util.validateModel(tmpReq);
    let request = new DescribeImageSensitiveFileByKeyShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.scanRange)) {
      request.scanRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scanRange, "ScanRange", "json");
    }

    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.imageUuid)) {
      query["ImageUuid"] = request.imageUuid;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.scanRangeShrink)) {
      query["ScanRange"] = request.scanRangeShrink;
    }

    if (!Util.isUnset(request.sensitiveFileKey)) {
      query["SensitiveFileKey"] = request.sensitiveFileKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageSensitiveFileByKey",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageSensitiveFileByKeyResponse>(await this.callApi(params, req, runtime), new DescribeImageSensitiveFileByKeyResponse({}));
  }

  async describeImageSensitiveFileByKey(request: DescribeImageSensitiveFileByKeyRequest): Promise<DescribeImageSensitiveFileByKeyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageSensitiveFileByKeyWithOptions(request, runtime);
  }

  async describeImageSensitiveFileListWithOptions(tmpReq: DescribeImageSensitiveFileListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageSensitiveFileListResponse> {
    Util.validateModel(tmpReq);
    let request = new DescribeImageSensitiveFileListShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.scanRange)) {
      request.scanRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scanRange, "ScanRange", "json");
    }

    let query = { };
    if (!Util.isUnset(request.criteria)) {
      query["Criteria"] = request.criteria;
    }

    if (!Util.isUnset(request.criteriaType)) {
      query["CriteriaType"] = request.criteriaType;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.imageUuid)) {
      query["ImageUuid"] = request.imageUuid;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.riskLevel)) {
      query["RiskLevel"] = request.riskLevel;
    }

    if (!Util.isUnset(request.scanRangeShrink)) {
      query["ScanRange"] = request.scanRangeShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageSensitiveFileList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageSensitiveFileListResponse>(await this.callApi(params, req, runtime), new DescribeImageSensitiveFileListResponse({}));
  }

  async describeImageSensitiveFileList(request: DescribeImageSensitiveFileListRequest): Promise<DescribeImageSensitiveFileListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageSensitiveFileListWithOptions(request, runtime);
  }

  /**
    * Security Center can scan for security risks and collect statistics only for **Container Registry Enterprise Edition instances**.
    * >  Security Center cannot scan for security risks or collect statistics for **default** Container Registry instances.
    *
    * @param request DescribeImageStatisticsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeImageStatisticsResponse
   */
  async describeImageStatisticsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeImageStatisticsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeImageStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeImageStatisticsResponse({}));
  }

  /**
    * Security Center can scan for security risks and collect statistics only for **Container Registry Enterprise Edition instances**.
    * >  Security Center cannot scan for security risks or collect statistics for **default** Container Registry instances.
    *
    * @return DescribeImageStatisticsResponse
   */
  async describeImageStatistics(): Promise<DescribeImageStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageStatisticsWithOptions(runtime);
  }

  /**
    * To query the information about the recently detected image vulnerabilities, call the [PublicCreateImageScanTask](~~PublicCreateImageScanTask~~) operation. Wait 1 to 5 minutes until the call is successful and call the DescribeImageVulList operation.
    *
    * @param request DescribeImageVulListRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeImageVulListResponse
   */
  async describeImageVulListWithOptions(request: DescribeImageVulListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageVulListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliasName)) {
      query["AliasName"] = request.aliasName;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.containerId)) {
      query["ContainerId"] = request.containerId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.dealed)) {
      query["Dealed"] = request.dealed;
    }

    if (!Util.isUnset(request.digest)) {
      query["Digest"] = request.digest;
    }

    if (!Util.isUnset(request.image)) {
      query["Image"] = request.image;
    }

    if (!Util.isUnset(request.instanceId)) {
      query["InstanceId"] = request.instanceId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.necessity)) {
      query["Necessity"] = request.necessity;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.pod)) {
      query["Pod"] = request.pod;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.repoId)) {
      query["RepoId"] = request.repoId;
    }

    if (!Util.isUnset(request.repoId)) {
      query["RepoId"] = request.repoId;
    }

    if (!Util.isUnset(request.repoInstanceId)) {
      query["RepoInstanceId"] = request.repoInstanceId;
    }

    if (!Util.isUnset(request.repoName)) {
      query["RepoName"] = request.repoName;
    }

    if (!Util.isUnset(request.repoName)) {
      query["RepoName"] = request.repoName;
    }

    if (!Util.isUnset(request.repoNamespace)) {
      query["RepoNamespace"] = request.repoNamespace;
    }

    if (!Util.isUnset(request.repoRegionId)) {
      query["RepoRegionId"] = request.repoRegionId;
    }

    if (!Util.isUnset(request.scanRange)) {
      query["ScanRange"] = request.scanRange;
    }

    if (!Util.isUnset(request.statusList)) {
      query["StatusList"] = request.statusList;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageVulList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageVulListResponse>(await this.callApi(params, req, runtime), new DescribeImageVulListResponse({}));
  }

  /**
    * To query the information about the recently detected image vulnerabilities, call the [PublicCreateImageScanTask](~~PublicCreateImageScanTask~~) operation. Wait 1 to 5 minutes until the call is successful and call the DescribeImageVulList operation.
    *
    * @param request DescribeImageVulListRequest
    * @return DescribeImageVulListResponse
   */
  async describeImageVulList(request: DescribeImageVulListRequest): Promise<DescribeImageVulListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageVulListWithOptions(request, runtime);
  }

  async describeImageVulWhiteListWithOptions(request: DescribeImageVulWhiteListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeImageVulWhiteListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliasName)) {
      query["AliasName"] = request.aliasName;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeImageVulWhiteList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeImageVulWhiteListResponse>(await this.callApi(params, req, runtime), new DescribeImageVulWhiteListResponse({}));
  }

  async describeImageVulWhiteList(request: DescribeImageVulWhiteListRequest): Promise<DescribeImageVulWhiteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeImageVulWhiteListWithOptions(request, runtime);
  }

  async describeInstallCaptchaWithOptions(request: DescribeInstallCaptchaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstallCaptchaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.deadline)) {
      query["Deadline"] = request.deadline;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstallCaptcha",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstallCaptchaResponse>(await this.callApi(params, req, runtime), new DescribeInstallCaptchaResponse({}));
  }

  async describeInstallCaptcha(request: DescribeInstallCaptchaRequest): Promise<DescribeInstallCaptchaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstallCaptchaWithOptions(request, runtime);
  }

  async describeInstallCodeWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeInstallCodeResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeInstallCode",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstallCodeResponse>(await this.callApi(params, req, runtime), new DescribeInstallCodeResponse({}));
  }

  async describeInstallCode(): Promise<DescribeInstallCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstallCodeWithOptions(runtime);
  }

  /**
    * You can call this operation to query the commands that are used to manually install the Security Center agent on the server. The return result contains the installation verification code and the server information. If you want to manually install the Security Center agent on your server, you can call this operation to query installation commands.
    * ### QPS limit
    * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
    *
    * @param request DescribeInstallCodesRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeInstallCodesResponse
   */
  async describeInstallCodesWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeInstallCodesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeInstallCodes",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstallCodesResponse>(await this.callApi(params, req, runtime), new DescribeInstallCodesResponse({}));
  }

  /**
    * You can call this operation to query the commands that are used to manually install the Security Center agent on the server. The return result contains the installation verification code and the server information. If you want to manually install the Security Center agent on your server, you can call this operation to query installation commands.
    * ### QPS limit
    * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
    *
    * @return DescribeInstallCodesResponse
   */
  async describeInstallCodes(): Promise<DescribeInstallCodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstallCodesWithOptions(runtime);
  }

  async describeInstanceAntiBruteForceRulesWithOptions(request: DescribeInstanceAntiBruteForceRulesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceAntiBruteForceRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceAntiBruteForceRules",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceAntiBruteForceRulesResponse>(await this.callApi(params, req, runtime), new DescribeInstanceAntiBruteForceRulesResponse({}));
  }

  async describeInstanceAntiBruteForceRules(request: DescribeInstanceAntiBruteForceRulesRequest): Promise<DescribeInstanceAntiBruteForceRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceAntiBruteForceRulesWithOptions(request, runtime);
  }

  async describeInstanceRebootStatusWithOptions(request: DescribeInstanceRebootStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceRebootStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceRebootStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceRebootStatusResponse>(await this.callApi(params, req, runtime), new DescribeInstanceRebootStatusResponse({}));
  }

  async describeInstanceRebootStatus(request: DescribeInstanceRebootStatusRequest): Promise<DescribeInstanceRebootStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceRebootStatusWithOptions(request, runtime);
  }

  async describeInstanceStatisticsWithOptions(request: DescribeInstanceStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInstanceStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInstanceStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInstanceStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeInstanceStatisticsResponse({}));
  }

  async describeInstanceStatistics(request: DescribeInstanceStatisticsRequest): Promise<DescribeInstanceStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInstanceStatisticsWithOptions(request, runtime);
  }

  async describeIpTagsWithOptions(request: DescribeIpTagsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeIpTagsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ip)) {
      query["Ip"] = request.ip;
    }

    if (!Util.isUnset(request.securityEventId)) {
      query["SecurityEventId"] = request.securityEventId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeIpTags",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeIpTagsResponse>(await this.callApi(params, req, runtime), new DescribeIpTagsResponse({}));
  }

  async describeIpTags(request: DescribeIpTagsRequest): Promise<DescribeIpTagsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeIpTagsWithOptions(request, runtime);
  }

  async describeLatestScanTaskWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeLatestScanTaskResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeLatestScanTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLatestScanTaskResponse>(await this.callApi(params, req, runtime), new DescribeLatestScanTaskResponse({}));
  }

  async describeLatestScanTask(): Promise<DescribeLatestScanTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLatestScanTaskWithOptions(runtime);
  }

  async describeLogMetaWithOptions(request: DescribeLogMetaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLogMetaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLogMeta",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLogMetaResponse>(await this.callApi(params, req, runtime), new DescribeLogMetaResponse({}));
  }

  async describeLogMeta(request: DescribeLogMetaRequest): Promise<DescribeLogMetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLogMetaWithOptions(request, runtime);
  }

  async describeLogShipperStatusWithOptions(request: DescribeLogShipperStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLogShipperStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLogShipperStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLogShipperStatusResponse>(await this.callApi(params, req, runtime), new DescribeLogShipperStatusResponse({}));
  }

  async describeLogShipperStatus(request: DescribeLogShipperStatusRequest): Promise<DescribeLogShipperStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLogShipperStatusWithOptions(request, runtime);
  }

  async describeLoginBaseConfigsWithOptions(request: DescribeLoginBaseConfigsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLoginBaseConfigsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.target)) {
      query["Target"] = request.target;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLoginBaseConfigs",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLoginBaseConfigsResponse>(await this.callApi(params, req, runtime), new DescribeLoginBaseConfigsResponse({}));
  }

  async describeLoginBaseConfigs(request: DescribeLoginBaseConfigsRequest): Promise<DescribeLoginBaseConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLoginBaseConfigsWithOptions(request, runtime);
  }

  async describeLoginSwitchConfigsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeLoginSwitchConfigsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeLoginSwitchConfigs",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLoginSwitchConfigsResponse>(await this.callApi(params, req, runtime), new DescribeLoginSwitchConfigsResponse({}));
  }

  async describeLoginSwitchConfigs(): Promise<DescribeLoginSwitchConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLoginSwitchConfigsWithOptions(runtime);
  }

  async describeLogstoreStorageWithOptions(request: DescribeLogstoreStorageRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLogstoreStorageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLogstoreStorage",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLogstoreStorageResponse>(await this.callApi(params, req, runtime), new DescribeLogstoreStorageResponse({}));
  }

  async describeLogstoreStorage(request: DescribeLogstoreStorageRequest): Promise<DescribeLogstoreStorageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLogstoreStorageWithOptions(request, runtime);
  }

  async describeMachineCanRebootWithOptions(request: DescribeMachineCanRebootRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMachineCanRebootResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMachineCanReboot",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMachineCanRebootResponse>(await this.callApi(params, req, runtime), new DescribeMachineCanRebootResponse({}));
  }

  async describeMachineCanReboot(request: DescribeMachineCanRebootRequest): Promise<DescribeMachineCanRebootResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMachineCanRebootWithOptions(request, runtime);
  }

  async describeModuleConfigWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeModuleConfigResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeModuleConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeModuleConfigResponse>(await this.callApi(params, req, runtime), new DescribeModuleConfigResponse({}));
  }

  async describeModuleConfig(): Promise<DescribeModuleConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeModuleConfigWithOptions(runtime);
  }

  async describeMonitorAccountsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeMonitorAccountsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeMonitorAccounts",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMonitorAccountsResponse>(await this.callApi(params, req, runtime), new DescribeMonitorAccountsResponse({}));
  }

  async describeMonitorAccounts(): Promise<DescribeMonitorAccountsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMonitorAccountsWithOptions(runtime);
  }

  async describeNoticeConfigWithOptions(request: DescribeNoticeConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNoticeConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeNoticeConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeNoticeConfigResponse>(await this.callApi(params, req, runtime), new DescribeNoticeConfigResponse({}));
  }

  async describeNoticeConfig(request: DescribeNoticeConfigRequest): Promise<DescribeNoticeConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNoticeConfigWithOptions(request, runtime);
  }

  async describeNsasSuspEventTypeWithOptions(request: DescribeNsasSuspEventTypeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNsasSuspEventTypeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.containerFieldName)) {
      query["ContainerFieldName"] = request.containerFieldName;
    }

    if (!Util.isUnset(request.containerFieldValue)) {
      query["ContainerFieldValue"] = request.containerFieldValue;
    }

    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeNsasSuspEventType",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeNsasSuspEventTypeResponse>(await this.callApi(params, req, runtime), new DescribeNsasSuspEventTypeResponse({}));
  }

  async describeNsasSuspEventType(request: DescribeNsasSuspEventTypeRequest): Promise<DescribeNsasSuspEventTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNsasSuspEventTypeWithOptions(request, runtime);
  }

  async describeOfflineMachinesWithOptions(request: DescribeOfflineMachinesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOfflineMachinesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.os)) {
      query["Os"] = request.os;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionIdStr)) {
      query["RegionIdStr"] = request.regionIdStr;
    }

    if (!Util.isUnset(request.regionNo)) {
      query["RegionNo"] = request.regionNo;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.vendor)) {
      query["Vendor"] = request.vendor;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOfflineMachines",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOfflineMachinesResponse>(await this.callApi(params, req, runtime), new DescribeOfflineMachinesResponse({}));
  }

  async describeOfflineMachines(request: DescribeOfflineMachinesRequest): Promise<DescribeOfflineMachinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOfflineMachinesWithOptions(request, runtime);
  }

  async describeOnceTaskWithOptions(request: DescribeOnceTaskRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOnceTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTimeQuery)) {
      query["EndTimeQuery"] = request.endTimeQuery;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.rootTaskId)) {
      query["RootTaskId"] = request.rootTaskId;
    }

    if (!Util.isUnset(request.startTimeQuery)) {
      query["StartTimeQuery"] = request.startTimeQuery;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOnceTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOnceTaskResponse>(await this.callApi(params, req, runtime), new DescribeOnceTaskResponse({}));
  }

  async describeOnceTask(request: DescribeOnceTaskRequest): Promise<DescribeOnceTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOnceTaskWithOptions(request, runtime);
  }

  async describeOnceTaskLeafRecordPageWithOptions(request: DescribeOnceTaskLeafRecordPageRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOnceTaskLeafRecordPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.relateInfo)) {
      query["RelateInfo"] = request.relateInfo;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.statusList)) {
      query["StatusList"] = request.statusList;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOnceTaskLeafRecordPage",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOnceTaskLeafRecordPageResponse>(await this.callApi(params, req, runtime), new DescribeOnceTaskLeafRecordPageResponse({}));
  }

  async describeOnceTaskLeafRecordPage(request: DescribeOnceTaskLeafRecordPageRequest): Promise<DescribeOnceTaskLeafRecordPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOnceTaskLeafRecordPageWithOptions(request, runtime);
  }

  async describePropertyCountWithOptions(request: DescribePropertyCountRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyCount",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyCountResponse>(await this.callApi(params, req, runtime), new DescribePropertyCountResponse({}));
  }

  async describePropertyCount(request: DescribePropertyCountRequest): Promise<DescribePropertyCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyCountWithOptions(request, runtime);
  }

  async describePropertyCronDetailWithOptions(request: DescribePropertyCronDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyCronDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.extend)) {
      query["Extend"] = request.extend;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.user)) {
      query["User"] = request.user;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyCronDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyCronDetailResponse>(await this.callApi(params, req, runtime), new DescribePropertyCronDetailResponse({}));
  }

  async describePropertyCronDetail(request: DescribePropertyCronDetailRequest): Promise<DescribePropertyCronDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyCronDetailWithOptions(request, runtime);
  }

  async describePropertyCronItemWithOptions(request: DescribePropertyCronItemRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyCronItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.forceFlush)) {
      query["ForceFlush"] = request.forceFlush;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyCronItem",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyCronItemResponse>(await this.callApi(params, req, runtime), new DescribePropertyCronItemResponse({}));
  }

  async describePropertyCronItem(request: DescribePropertyCronItemRequest): Promise<DescribePropertyCronItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyCronItemWithOptions(request, runtime);
  }

  async describePropertyPortDetailWithOptions(request: DescribePropertyPortDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyPortDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bindIp)) {
      query["BindIp"] = request.bindIp;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.extend)) {
      query["Extend"] = request.extend;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.procName)) {
      query["ProcName"] = request.procName;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyPortDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyPortDetailResponse>(await this.callApi(params, req, runtime), new DescribePropertyPortDetailResponse({}));
  }

  async describePropertyPortDetail(request: DescribePropertyPortDetailRequest): Promise<DescribePropertyPortDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyPortDetailWithOptions(request, runtime);
  }

  async describePropertyPortItemWithOptions(request: DescribePropertyPortItemRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyPortItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.forceFlush)) {
      query["ForceFlush"] = request.forceFlush;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyPortItem",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyPortItemResponse>(await this.callApi(params, req, runtime), new DescribePropertyPortItemResponse({}));
  }

  async describePropertyPortItem(request: DescribePropertyPortItemRequest): Promise<DescribePropertyPortItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyPortItemWithOptions(request, runtime);
  }

  async describePropertyProcDetailWithOptions(request: DescribePropertyProcDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyProcDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cmdline)) {
      query["Cmdline"] = request.cmdline;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.extend)) {
      query["Extend"] = request.extend;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.procTimeEnd)) {
      query["ProcTimeEnd"] = request.procTimeEnd;
    }

    if (!Util.isUnset(request.procTimeStart)) {
      query["ProcTimeStart"] = request.procTimeStart;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.user)) {
      query["User"] = request.user;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyProcDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyProcDetailResponse>(await this.callApi(params, req, runtime), new DescribePropertyProcDetailResponse({}));
  }

  async describePropertyProcDetail(request: DescribePropertyProcDetailRequest): Promise<DescribePropertyProcDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyProcDetailWithOptions(request, runtime);
  }

  async describePropertyProcItemWithOptions(request: DescribePropertyProcItemRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyProcItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.forceFlush)) {
      query["ForceFlush"] = request.forceFlush;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyProcItem",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyProcItemResponse>(await this.callApi(params, req, runtime), new DescribePropertyProcItemResponse({}));
  }

  async describePropertyProcItem(request: DescribePropertyProcItemRequest): Promise<DescribePropertyProcItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyProcItemWithOptions(request, runtime);
  }

  async describePropertyScaDetailWithOptions(request: DescribePropertyScaDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyScaDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.biz)) {
      query["Biz"] = request.biz;
    }

    if (!Util.isUnset(request.bizType)) {
      query["BizType"] = request.bizType;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.pid)) {
      query["Pid"] = request.pid;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.processStartedEnd)) {
      query["ProcessStartedEnd"] = request.processStartedEnd;
    }

    if (!Util.isUnset(request.processStartedStart)) {
      query["ProcessStartedStart"] = request.processStartedStart;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.scaName)) {
      query["ScaName"] = request.scaName;
    }

    if (!Util.isUnset(request.scaNamePattern)) {
      query["ScaNamePattern"] = request.scaNamePattern;
    }

    if (!Util.isUnset(request.scaVersion)) {
      query["ScaVersion"] = request.scaVersion;
    }

    if (!Util.isUnset(request.searchInfo)) {
      query["SearchInfo"] = request.searchInfo;
    }

    if (!Util.isUnset(request.searchInfoSub)) {
      query["SearchInfoSub"] = request.searchInfoSub;
    }

    if (!Util.isUnset(request.searchItem)) {
      query["SearchItem"] = request.searchItem;
    }

    if (!Util.isUnset(request.searchItemSub)) {
      query["SearchItemSub"] = request.searchItemSub;
    }

    if (!Util.isUnset(request.user)) {
      query["User"] = request.user;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyScaDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyScaDetailResponse>(await this.callApi(params, req, runtime), new DescribePropertyScaDetailResponse({}));
  }

  async describePropertyScaDetail(request: DescribePropertyScaDetailRequest): Promise<DescribePropertyScaDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyScaDetailWithOptions(request, runtime);
  }

  async describePropertyScaItemWithOptions(request: DescribePropertyScaItemRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyScaItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.biz)) {
      query["Biz"] = request.biz;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.forceFlush)) {
      query["ForceFlush"] = request.forceFlush;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchInfo)) {
      query["SearchInfo"] = request.searchInfo;
    }

    if (!Util.isUnset(request.searchItem)) {
      query["SearchItem"] = request.searchItem;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyScaItem",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyScaItemResponse>(await this.callApi(params, req, runtime), new DescribePropertyScaItemResponse({}));
  }

  async describePropertyScaItem(request: DescribePropertyScaItemRequest): Promise<DescribePropertyScaItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyScaItemWithOptions(request, runtime);
  }

  async describePropertyScheduleConfigWithOptions(request: DescribePropertyScheduleConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyScheduleConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyScheduleConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyScheduleConfigResponse>(await this.callApi(params, req, runtime), new DescribePropertyScheduleConfigResponse({}));
  }

  async describePropertyScheduleConfig(request: DescribePropertyScheduleConfigRequest): Promise<DescribePropertyScheduleConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyScheduleConfigWithOptions(request, runtime);
  }

  async describePropertySoftwareDetailWithOptions(request: DescribePropertySoftwareDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertySoftwareDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.extend)) {
      query["Extend"] = request.extend;
    }

    if (!Util.isUnset(request.installTimeEnd)) {
      query["InstallTimeEnd"] = request.installTimeEnd;
    }

    if (!Util.isUnset(request.installTimeStart)) {
      query["InstallTimeStart"] = request.installTimeStart;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.path)) {
      query["Path"] = request.path;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.softwareVersion)) {
      query["SoftwareVersion"] = request.softwareVersion;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertySoftwareDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertySoftwareDetailResponse>(await this.callApi(params, req, runtime), new DescribePropertySoftwareDetailResponse({}));
  }

  async describePropertySoftwareDetail(request: DescribePropertySoftwareDetailRequest): Promise<DescribePropertySoftwareDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertySoftwareDetailWithOptions(request, runtime);
  }

  async describePropertySoftwareItemWithOptions(request: DescribePropertySoftwareItemRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertySoftwareItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.forceFlush)) {
      query["ForceFlush"] = request.forceFlush;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertySoftwareItem",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertySoftwareItemResponse>(await this.callApi(params, req, runtime), new DescribePropertySoftwareItemResponse({}));
  }

  async describePropertySoftwareItem(request: DescribePropertySoftwareItemRequest): Promise<DescribePropertySoftwareItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertySoftwareItemWithOptions(request, runtime);
  }

  async describePropertyTypeScaItemWithOptions(request: DescribePropertyTypeScaItemRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyTypeScaItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyTypeScaItem",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyTypeScaItemResponse>(await this.callApi(params, req, runtime), new DescribePropertyTypeScaItemResponse({}));
  }

  async describePropertyTypeScaItem(request: DescribePropertyTypeScaItemRequest): Promise<DescribePropertyTypeScaItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyTypeScaItemWithOptions(request, runtime);
  }

  async describePropertyUsageNewestWithOptions(request: DescribePropertyUsageNewestRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyUsageNewestResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyUsageNewest",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyUsageNewestResponse>(await this.callApi(params, req, runtime), new DescribePropertyUsageNewestResponse({}));
  }

  async describePropertyUsageNewest(request: DescribePropertyUsageNewestRequest): Promise<DescribePropertyUsageNewestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyUsageNewestWithOptions(request, runtime);
  }

  async describePropertyUserDetailWithOptions(request: DescribePropertyUserDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyUserDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.extend)) {
      query["Extend"] = request.extend;
    }

    if (!Util.isUnset(request.isRoot)) {
      query["IsRoot"] = request.isRoot;
    }

    if (!Util.isUnset(request.lastLoginTimeEnd)) {
      query["LastLoginTimeEnd"] = request.lastLoginTimeEnd;
    }

    if (!Util.isUnset(request.lastLoginTimeStart)) {
      query["LastLoginTimeStart"] = request.lastLoginTimeStart;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.user)) {
      query["User"] = request.user;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyUserDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyUserDetailResponse>(await this.callApi(params, req, runtime), new DescribePropertyUserDetailResponse({}));
  }

  async describePropertyUserDetail(request: DescribePropertyUserDetailRequest): Promise<DescribePropertyUserDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyUserDetailWithOptions(request, runtime);
  }

  async describePropertyUserItemWithOptions(request: DescribePropertyUserItemRequest, runtime: $Util.RuntimeOptions): Promise<DescribePropertyUserItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.forceFlush)) {
      query["ForceFlush"] = request.forceFlush;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.user)) {
      query["User"] = request.user;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePropertyUserItem",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePropertyUserItemResponse>(await this.callApi(params, req, runtime), new DescribePropertyUserItemResponse({}));
  }

  async describePropertyUserItem(request: DescribePropertyUserItemRequest): Promise<DescribePropertyUserItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePropertyUserItemWithOptions(request, runtime);
  }

  async describeQuaraFileDownloadInfoWithOptions(request: DescribeQuaraFileDownloadInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeQuaraFileDownloadInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.quaraFileId)) {
      query["QuaraFileId"] = request.quaraFileId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeQuaraFileDownloadInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeQuaraFileDownloadInfoResponse>(await this.callApi(params, req, runtime), new DescribeQuaraFileDownloadInfoResponse({}));
  }

  async describeQuaraFileDownloadInfo(request: DescribeQuaraFileDownloadInfoRequest): Promise<DescribeQuaraFileDownloadInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeQuaraFileDownloadInfoWithOptions(request, runtime);
  }

  /**
    * If the data on your servers is encrypted by ransomware, you can create a restoration task to restore the data on your servers by using backup data in Security Center.
    * >  After you enable an anti-ransomware policy, the data on your servers is backed up based on the policy. For more information about anti-ransomware policies, see [Manage protection policies](~~164781~~).
    *
    * @param request DescribeRestoreJobsRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeRestoreJobsResponse
   */
  async describeRestoreJobsWithOptions(request: DescribeRestoreJobsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRestoreJobsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.machineRemark)) {
      query["MachineRemark"] = request.machineRemark;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRestoreJobs",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRestoreJobsResponse>(await this.callApi(params, req, runtime), new DescribeRestoreJobsResponse({}));
  }

  /**
    * If the data on your servers is encrypted by ransomware, you can create a restoration task to restore the data on your servers by using backup data in Security Center.
    * >  After you enable an anti-ransomware policy, the data on your servers is backed up based on the policy. For more information about anti-ransomware policies, see [Manage protection policies](~~164781~~).
    *
    * @param request DescribeRestoreJobsRequest
    * @return DescribeRestoreJobsResponse
   */
  async describeRestoreJobs(request: DescribeRestoreJobsRequest): Promise<DescribeRestoreJobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRestoreJobsWithOptions(request, runtime);
  }

  async describeRestorePlansWithOptions(request: DescribeRestorePlansRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRestorePlansResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRestorePlans",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRestorePlansResponse>(await this.callApi(params, req, runtime), new DescribeRestorePlansResponse({}));
  }

  async describeRestorePlans(request: DescribeRestorePlansRequest): Promise<DescribeRestorePlansResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRestorePlansWithOptions(request, runtime);
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the ListCheckInstanceResult operation.
    *
    * @param request DescribeRiskCheckItemResultRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeRiskCheckItemResultResponse
   */
  // Deprecated
  async describeRiskCheckItemResultWithOptions(request: DescribeRiskCheckItemResultRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRiskCheckItemResultResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.itemId)) {
      query["ItemId"] = request.itemId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRiskCheckItemResult",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRiskCheckItemResultResponse>(await this.callApi(params, req, runtime), new DescribeRiskCheckItemResultResponse({}));
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the ListCheckInstanceResult operation.
    *
    * @param request DescribeRiskCheckItemResultRequest
    * @return DescribeRiskCheckItemResultResponse
   */
  // Deprecated
  async describeRiskCheckItemResult(request: DescribeRiskCheckItemResultRequest): Promise<DescribeRiskCheckItemResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRiskCheckItemResultWithOptions(request, runtime);
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the [ListCheckResult](~~ListCheckResult~~) operation.
    *
    * @param request DescribeRiskCheckResultRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeRiskCheckResultResponse
   */
  // Deprecated
  async describeRiskCheckResultWithOptions(request: DescribeRiskCheckResultRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRiskCheckResultResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.assetType)) {
      query["AssetType"] = request.assetType;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.itemIds)) {
      query["ItemIds"] = request.itemIds;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryFlag)) {
      query["QueryFlag"] = request.queryFlag;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.riskLevel)) {
      query["RiskLevel"] = request.riskLevel;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRiskCheckResult",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRiskCheckResultResponse>(await this.callApi(params, req, runtime), new DescribeRiskCheckResultResponse({}));
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the [ListCheckResult](~~ListCheckResult~~) operation.
    *
    * @param request DescribeRiskCheckResultRequest
    * @return DescribeRiskCheckResultResponse
   */
  // Deprecated
  async describeRiskCheckResult(request: DescribeRiskCheckResultRequest): Promise<DescribeRiskCheckResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRiskCheckResultWithOptions(request, runtime);
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the GetCheckSummary operation.
    *
    * @param request DescribeRiskCheckSummaryRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeRiskCheckSummaryResponse
   */
  // Deprecated
  async describeRiskCheckSummaryWithOptions(request: DescribeRiskCheckSummaryRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRiskCheckSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRiskCheckSummary",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRiskCheckSummaryResponse>(await this.callApi(params, req, runtime), new DescribeRiskCheckSummaryResponse({}));
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the GetCheckSummary operation.
    *
    * @param request DescribeRiskCheckSummaryRequest
    * @return DescribeRiskCheckSummaryResponse
   */
  // Deprecated
  async describeRiskCheckSummary(request: DescribeRiskCheckSummaryRequest): Promise<DescribeRiskCheckSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRiskCheckSummaryWithOptions(request, runtime);
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the ListCheckStandard operation instead.
    *
    * @param request DescribeRiskItemTypeRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeRiskItemTypeResponse
   */
  // Deprecated
  async describeRiskItemTypeWithOptions(request: DescribeRiskItemTypeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRiskItemTypeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRiskItemType",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRiskItemTypeResponse>(await this.callApi(params, req, runtime), new DescribeRiskItemTypeResponse({}));
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the ListCheckStandard operation instead.
    *
    * @param request DescribeRiskItemTypeRequest
    * @return DescribeRiskItemTypeResponse
   */
  // Deprecated
  async describeRiskItemType(request: DescribeRiskItemTypeRequest): Promise<DescribeRiskItemTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRiskItemTypeWithOptions(request, runtime);
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the ListCheckResult operation. When you call the ListCheckResult operation, set the Statuses parameter to NOT_PASS.
    *
    * @param request DescribeRiskListCheckResultRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeRiskListCheckResultResponse
   */
  // Deprecated
  async describeRiskListCheckResultWithOptions(request: DescribeRiskListCheckResultRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRiskListCheckResultResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRiskListCheckResult",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRiskListCheckResultResponse>(await this.callApi(params, req, runtime), new DescribeRiskListCheckResultResponse({}));
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the ListCheckResult operation. When you call the ListCheckResult operation, set the Statuses parameter to NOT_PASS.
    *
    * @param request DescribeRiskListCheckResultRequest
    * @return DescribeRiskListCheckResultResponse
   */
  // Deprecated
  async describeRiskListCheckResult(request: DescribeRiskListCheckResultRequest): Promise<DescribeRiskListCheckResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRiskListCheckResultWithOptions(request, runtime);
  }

  async describeRiskTypeWithOptions(request: DescribeRiskTypeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRiskTypeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRiskType",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRiskTypeResponse>(await this.callApi(params, req, runtime), new DescribeRiskTypeResponse({}));
  }

  async describeRiskType(request: DescribeRiskTypeRequest): Promise<DescribeRiskTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRiskTypeWithOptions(request, runtime);
  }

  async describeRisksWithOptions(request: DescribeRisksRequest, runtime: $Util.RuntimeOptions): Promise<DescribeRisksResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.limit)) {
      query["Limit"] = request.limit;
    }

    if (!Util.isUnset(request.riskId)) {
      query["RiskId"] = request.riskId;
    }

    if (!Util.isUnset(request.riskName)) {
      query["RiskName"] = request.riskName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeRisks",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRisksResponse>(await this.callApi(params, req, runtime), new DescribeRisksResponse({}));
  }

  async describeRisks(request: DescribeRisksRequest): Promise<DescribeRisksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRisksWithOptions(request, runtime);
  }

  async describeSasPmAgentListWithOptions(request: DescribeSasPmAgentListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSasPmAgentListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSasPmAgentList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSasPmAgentListResponse>(await this.callApi(params, req, runtime), new DescribeSasPmAgentListResponse({}));
  }

  async describeSasPmAgentList(request: DescribeSasPmAgentListRequest): Promise<DescribeSasPmAgentListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSasPmAgentListWithOptions(request, runtime);
  }

  async describeScanTaskProgressWithOptions(request: DescribeScanTaskProgressRequest, runtime: $Util.RuntimeOptions): Promise<DescribeScanTaskProgressResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeScanTaskProgress",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeScanTaskProgressResponse>(await this.callApi(params, req, runtime), new DescribeScanTaskProgressResponse({}));
  }

  async describeScanTaskProgress(request: DescribeScanTaskProgressRequest): Promise<DescribeScanTaskProgressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeScanTaskProgressWithOptions(request, runtime);
  }

  async describeScanTaskStatisticsWithOptions(request: DescribeScanTaskStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeScanTaskStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.levels)) {
      query["Levels"] = request.levels;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeScanTaskStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeScanTaskStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeScanTaskStatisticsResponse({}));
  }

  async describeScanTaskStatistics(request: DescribeScanTaskStatisticsRequest): Promise<DescribeScanTaskStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeScanTaskStatisticsWithOptions(request, runtime);
  }

  async describeSearchConditionWithOptions(request: DescribeSearchConditionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSearchConditionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSearchCondition",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSearchConditionResponse>(await this.callApi(params, req, runtime), new DescribeSearchConditionResponse({}));
  }

  async describeSearchCondition(request: DescribeSearchConditionRequest): Promise<DescribeSearchConditionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSearchConditionWithOptions(request, runtime);
  }

  async describeSecureSuggestionWithOptions(request: DescribeSecureSuggestionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSecureSuggestionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSecureSuggestion",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSecureSuggestionResponse>(await this.callApi(params, req, runtime), new DescribeSecureSuggestionResponse({}));
  }

  async describeSecureSuggestion(request: DescribeSecureSuggestionRequest): Promise<DescribeSecureSuggestionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSecureSuggestionWithOptions(request, runtime);
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the GetCheckConfig operation.
    *
    * @param request DescribeSecurityCheckScheduleConfigRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeSecurityCheckScheduleConfigResponse
   */
  // Deprecated
  async describeSecurityCheckScheduleConfigWithOptions(request: DescribeSecurityCheckScheduleConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSecurityCheckScheduleConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSecurityCheckScheduleConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSecurityCheckScheduleConfigResponse>(await this.callApi(params, req, runtime), new DescribeSecurityCheckScheduleConfigResponse({}));
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the GetCheckConfig operation.
    *
    * @param request DescribeSecurityCheckScheduleConfigRequest
    * @return DescribeSecurityCheckScheduleConfigResponse
   */
  // Deprecated
  async describeSecurityCheckScheduleConfig(request: DescribeSecurityCheckScheduleConfigRequest): Promise<DescribeSecurityCheckScheduleConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSecurityCheckScheduleConfigWithOptions(request, runtime);
  }

  async describeSecurityEventMarkMissListWithOptions(request: DescribeSecurityEventMarkMissListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSecurityEventMarkMissListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.eventName)) {
      query["EventName"] = request.eventName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSecurityEventMarkMissList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSecurityEventMarkMissListResponse>(await this.callApi(params, req, runtime), new DescribeSecurityEventMarkMissListResponse({}));
  }

  async describeSecurityEventMarkMissList(request: DescribeSecurityEventMarkMissListRequest): Promise<DescribeSecurityEventMarkMissListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSecurityEventMarkMissListWithOptions(request, runtime);
  }

  async describeSecurityEventOperationStatusWithOptions(request: DescribeSecurityEventOperationStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSecurityEventOperationStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.securityEventIds)) {
      query["SecurityEventIds"] = request.securityEventIds;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSecurityEventOperationStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSecurityEventOperationStatusResponse>(await this.callApi(params, req, runtime), new DescribeSecurityEventOperationStatusResponse({}));
  }

  async describeSecurityEventOperationStatus(request: DescribeSecurityEventOperationStatusRequest): Promise<DescribeSecurityEventOperationStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSecurityEventOperationStatusWithOptions(request, runtime);
  }

  async describeSecurityEventOperationsWithOptions(request: DescribeSecurityEventOperationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSecurityEventOperationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.securityEventId)) {
      query["SecurityEventId"] = request.securityEventId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSecurityEventOperations",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSecurityEventOperationsResponse>(await this.callApi(params, req, runtime), new DescribeSecurityEventOperationsResponse({}));
  }

  async describeSecurityEventOperations(request: DescribeSecurityEventOperationsRequest): Promise<DescribeSecurityEventOperationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSecurityEventOperationsWithOptions(request, runtime);
  }

  async describeSecurityStatInfoWithOptions(request: DescribeSecurityStatInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSecurityStatInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSecurityStatInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSecurityStatInfoResponse>(await this.callApi(params, req, runtime), new DescribeSecurityStatInfoResponse({}));
  }

  async describeSecurityStatInfo(request: DescribeSecurityStatInfoRequest): Promise<DescribeSecurityStatInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSecurityStatInfoWithOptions(request, runtime);
  }

  async describeServiceLinkedRoleStatusWithOptions(request: DescribeServiceLinkedRoleStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeServiceLinkedRoleStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.serviceLinkedRole)) {
      query["ServiceLinkedRole"] = request.serviceLinkedRole;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeServiceLinkedRoleStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeServiceLinkedRoleStatusResponse>(await this.callApi(params, req, runtime), new DescribeServiceLinkedRoleStatusResponse({}));
  }

  async describeServiceLinkedRoleStatus(request: DescribeServiceLinkedRoleStatusRequest): Promise<DescribeServiceLinkedRoleStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeServiceLinkedRoleStatusWithOptions(request, runtime);
  }

  async describeSimilarEventScenariosWithOptions(request: DescribeSimilarEventScenariosRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSimilarEventScenariosResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.securityEventId)) {
      query["SecurityEventId"] = request.securityEventId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSimilarEventScenarios",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSimilarEventScenariosResponse>(await this.callApi(params, req, runtime), new DescribeSimilarEventScenariosResponse({}));
  }

  async describeSimilarEventScenarios(request: DescribeSimilarEventScenariosRequest): Promise<DescribeSimilarEventScenariosResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSimilarEventScenariosWithOptions(request, runtime);
  }

  async describeSimilarSecurityEventsWithOptions(request: DescribeSimilarSecurityEventsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSimilarSecurityEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSimilarSecurityEvents",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSimilarSecurityEventsResponse>(await this.callApi(params, req, runtime), new DescribeSimilarSecurityEventsResponse({}));
  }

  async describeSimilarSecurityEvents(request: DescribeSimilarSecurityEventsRequest): Promise<DescribeSimilarSecurityEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSimilarSecurityEventsWithOptions(request, runtime);
  }

  async describeSnapshotsWithOptions(request: DescribeSnapshotsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSnapshotsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.apiVersion)) {
      query["ApiVersion"] = request.apiVersion;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.isAliYunEcs)) {
      query["IsAliYunEcs"] = request.isAliYunEcs;
    }

    if (!Util.isUnset(request.machineRegion)) {
      query["MachineRegion"] = request.machineRegion;
    }

    if (!Util.isUnset(request.machineRemark)) {
      query["MachineRemark"] = request.machineRemark;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.statusList)) {
      query["StatusList"] = request.statusList;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSnapshots",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSnapshotsResponse>(await this.callApi(params, req, runtime), new DescribeSnapshotsResponse({}));
  }

  async describeSnapshots(request: DescribeSnapshotsRequest): Promise<DescribeSnapshotsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSnapshotsWithOptions(request, runtime);
  }

  async describeStrategyWithOptions(request: DescribeStrategyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.customType)) {
      query["CustomType"] = request.customType;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.strategyIds)) {
      query["StrategyIds"] = request.strategyIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeStrategy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeStrategyResponse>(await this.callApi(params, req, runtime), new DescribeStrategyResponse({}));
  }

  async describeStrategy(request: DescribeStrategyRequest): Promise<DescribeStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeStrategyWithOptions(request, runtime);
  }

  async describeStrategyDetailWithOptions(request: DescribeStrategyDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeStrategyDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeStrategyDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeStrategyDetailResponse>(await this.callApi(params, req, runtime), new DescribeStrategyDetailResponse({}));
  }

  async describeStrategyDetail(request: DescribeStrategyDetailRequest): Promise<DescribeStrategyDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeStrategyDetailWithOptions(request, runtime);
  }

  async describeStrategyExecDetailWithOptions(request: DescribeStrategyExecDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeStrategyExecDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeStrategyExecDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeStrategyExecDetailResponse>(await this.callApi(params, req, runtime), new DescribeStrategyExecDetailResponse({}));
  }

  async describeStrategyExecDetail(request: DescribeStrategyExecDetailRequest): Promise<DescribeStrategyExecDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeStrategyExecDetailWithOptions(request, runtime);
  }

  async describeStrategyTargetWithOptions(request: DescribeStrategyTargetRequest, runtime: $Util.RuntimeOptions): Promise<DescribeStrategyTargetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeStrategyTarget",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeStrategyTargetResponse>(await this.callApi(params, req, runtime), new DescribeStrategyTargetResponse({}));
  }

  async describeStrategyTarget(request: DescribeStrategyTargetRequest): Promise<DescribeStrategyTargetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeStrategyTargetWithOptions(request, runtime);
  }

  async describeSummaryInfoWithOptions(request: DescribeSummaryInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSummaryInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSummaryInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSummaryInfoResponse>(await this.callApi(params, req, runtime), new DescribeSummaryInfoResponse({}));
  }

  async describeSummaryInfo(request: DescribeSummaryInfoRequest): Promise<DescribeSummaryInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSummaryInfoWithOptions(request, runtime);
  }

  async describeSupportRegionWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeSupportRegionResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeSupportRegion",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSupportRegionResponse>(await this.callApi(params, req, runtime), new DescribeSupportRegionResponse({}));
  }

  async describeSupportRegion(): Promise<DescribeSupportRegionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSupportRegionWithOptions(runtime);
  }

  async describeSuspEventDetailWithOptions(request: DescribeSuspEventDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSuspEventDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.suspiciousEventId)) {
      query["SuspiciousEventId"] = request.suspiciousEventId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSuspEventDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSuspEventDetailResponse>(await this.callApi(params, req, runtime), new DescribeSuspEventDetailResponse({}));
  }

  async describeSuspEventDetail(request: DescribeSuspEventDetailRequest): Promise<DescribeSuspEventDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSuspEventDetailWithOptions(request, runtime);
  }

  async describeSuspEventExportInfoWithOptions(request: DescribeSuspEventExportInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSuspEventExportInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.exportId)) {
      query["ExportId"] = request.exportId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSuspEventExportInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSuspEventExportInfoResponse>(await this.callApi(params, req, runtime), new DescribeSuspEventExportInfoResponse({}));
  }

  async describeSuspEventExportInfo(request: DescribeSuspEventExportInfoRequest): Promise<DescribeSuspEventExportInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSuspEventExportInfoWithOptions(request, runtime);
  }

  async describeSuspEventQuaraFilesWithOptions(request: DescribeSuspEventQuaraFilesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSuspEventQuaraFilesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.groupingId)) {
      query["GroupingId"] = request.groupingId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.quaraTag)) {
      query["QuaraTag"] = request.quaraTag;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSuspEventQuaraFiles",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSuspEventQuaraFilesResponse>(await this.callApi(params, req, runtime), new DescribeSuspEventQuaraFilesResponse({}));
  }

  async describeSuspEventQuaraFiles(request: DescribeSuspEventQuaraFilesRequest): Promise<DescribeSuspEventQuaraFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSuspEventQuaraFilesWithOptions(request, runtime);
  }

  async describeSuspEventUserSettingWithOptions(request: DescribeSuspEventUserSettingRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSuspEventUserSettingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSuspEventUserSetting",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSuspEventUserSettingResponse>(await this.callApi(params, req, runtime), new DescribeSuspEventUserSettingResponse({}));
  }

  async describeSuspEventUserSetting(request: DescribeSuspEventUserSettingRequest): Promise<DescribeSuspEventUserSettingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSuspEventUserSettingWithOptions(request, runtime);
  }

  async describeSuspEventsWithOptions(request: DescribeSuspEventsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSuspEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alarmUniqueInfo)) {
      query["AlarmUniqueInfo"] = request.alarmUniqueInfo;
    }

    if (!Util.isUnset(request.assetsTypeList)) {
      query["AssetsTypeList"] = request.assetsTypeList;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.containerFieldName)) {
      query["ContainerFieldName"] = request.containerFieldName;
    }

    if (!Util.isUnset(request.containerFieldValue)) {
      query["ContainerFieldValue"] = request.containerFieldValue;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.dealed)) {
      query["Dealed"] = request.dealed;
    }

    if (!Util.isUnset(request.eventNames)) {
      query["EventNames"] = request.eventNames;
    }

    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.levels)) {
      query["Levels"] = request.levels;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.operateErrorCodeList)) {
      query["OperateErrorCodeList"] = request.operateErrorCodeList;
    }

    if (!Util.isUnset(request.operateTimeEnd)) {
      query["OperateTimeEnd"] = request.operateTimeEnd;
    }

    if (!Util.isUnset(request.operateTimeStart)) {
      query["OperateTimeStart"] = request.operateTimeStart;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.parentEventTypes)) {
      query["ParentEventTypes"] = request.parentEventTypes;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    if (!Util.isUnset(request.sortColumn)) {
      query["SortColumn"] = request.sortColumn;
    }

    if (!Util.isUnset(request.sortType)) {
      query["SortType"] = request.sortType;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.timeEnd)) {
      query["TimeEnd"] = request.timeEnd;
    }

    if (!Util.isUnset(request.timeStart)) {
      query["TimeStart"] = request.timeStart;
    }

    if (!Util.isUnset(request.uniqueInfo)) {
      query["UniqueInfo"] = request.uniqueInfo;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.tacticId)) {
      body["TacticId"] = request.tacticId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSuspEvents",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSuspEventsResponse>(await this.callApi(params, req, runtime), new DescribeSuspEventsResponse({}));
  }

  async describeSuspEvents(request: DescribeSuspEventsRequest): Promise<DescribeSuspEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSuspEventsWithOptions(request, runtime);
  }

  async describeSuspiciousOverallConfigWithOptions(request: DescribeSuspiciousOverallConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSuspiciousOverallConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSuspiciousOverallConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSuspiciousOverallConfigResponse>(await this.callApi(params, req, runtime), new DescribeSuspiciousOverallConfigResponse({}));
  }

  async describeSuspiciousOverallConfig(request: DescribeSuspiciousOverallConfigRequest): Promise<DescribeSuspiciousOverallConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSuspiciousOverallConfigWithOptions(request, runtime);
  }

  async describeSuspiciousUUIDConfigWithOptions(request: DescribeSuspiciousUUIDConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSuspiciousUUIDConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSuspiciousUUIDConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSuspiciousUUIDConfigResponse>(await this.callApi(params, req, runtime), new DescribeSuspiciousUUIDConfigResponse({}));
  }

  async describeSuspiciousUUIDConfig(request: DescribeSuspiciousUUIDConfigRequest): Promise<DescribeSuspiciousUUIDConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSuspiciousUUIDConfigWithOptions(request, runtime);
  }

  async describeTargetWithOptions(request: DescribeTargetRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTargetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTarget",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTargetResponse>(await this.callApi(params, req, runtime), new DescribeTargetResponse({}));
  }

  async describeTarget(request: DescribeTargetRequest): Promise<DescribeTargetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTargetWithOptions(request, runtime);
  }

  async describeTaskErrorLogWithOptions(request: DescribeTaskErrorLogRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTaskErrorLogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.buildTaskId)) {
      query["BuildTaskId"] = request.buildTaskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTaskErrorLog",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTaskErrorLogResponse>(await this.callApi(params, req, runtime), new DescribeTaskErrorLogResponse({}));
  }

  async describeTaskErrorLog(request: DescribeTaskErrorLogRequest): Promise<DescribeTaskErrorLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTaskErrorLogWithOptions(request, runtime);
  }

  async describeTotalStatisticsWithOptions(request: DescribeTotalStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTotalStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTotalStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTotalStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeTotalStatisticsResponse({}));
  }

  async describeTotalStatistics(request: DescribeTotalStatisticsRequest): Promise<DescribeTotalStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTotalStatisticsWithOptions(request, runtime);
  }

  async describeTraceInfoDetailWithOptions(request: DescribeTraceInfoDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTraceInfoDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.incidentTime)) {
      query["IncidentTime"] = request.incidentTime;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    if (!Util.isUnset(request.vertexId)) {
      query["VertexId"] = request.vertexId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTraceInfoDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTraceInfoDetailResponse>(await this.callApi(params, req, runtime), new DescribeTraceInfoDetailResponse({}));
  }

  async describeTraceInfoDetail(request: DescribeTraceInfoDetailRequest): Promise<DescribeTraceInfoDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTraceInfoDetailWithOptions(request, runtime);
  }

  async describeTraceInfoNodeWithOptions(request: DescribeTraceInfoNodeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTraceInfoNodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventName)) {
      query["EventName"] = request.eventName;
    }

    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.incidentTime)) {
      query["IncidentTime"] = request.incidentTime;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    if (!Util.isUnset(request.vertexId)) {
      query["VertexId"] = request.vertexId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTraceInfoNode",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTraceInfoNodeResponse>(await this.callApi(params, req, runtime), new DescribeTraceInfoNodeResponse({}));
  }

  async describeTraceInfoNode(request: DescribeTraceInfoNodeRequest): Promise<DescribeTraceInfoNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTraceInfoNodeWithOptions(request, runtime);
  }

  async describeUniBackupDatabaseWithOptions(request: DescribeUniBackupDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUniBackupDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.databaseType)) {
      query["DatabaseType"] = request.databaseType;
    }

    if (!Util.isUnset(request.instanceName)) {
      query["InstanceName"] = request.instanceName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.queryType)) {
      query["QueryType"] = request.queryType;
    }

    if (!Util.isUnset(request.uniRegionId)) {
      query["UniRegionId"] = request.uniRegionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUniBackupDatabase",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUniBackupDatabaseResponse>(await this.callApi(params, req, runtime), new DescribeUniBackupDatabaseResponse({}));
  }

  async describeUniBackupDatabase(request: DescribeUniBackupDatabaseRequest): Promise<DescribeUniBackupDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUniBackupDatabaseWithOptions(request, runtime);
  }

  async describeUniBackupPoliciesWithOptions(request: DescribeUniBackupPoliciesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUniBackupPoliciesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.policyName)) {
      query["PolicyName"] = request.policyName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUniBackupPolicies",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUniBackupPoliciesResponse>(await this.callApi(params, req, runtime), new DescribeUniBackupPoliciesResponse({}));
  }

  async describeUniBackupPolicies(request: DescribeUniBackupPoliciesRequest): Promise<DescribeUniBackupPoliciesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUniBackupPoliciesWithOptions(request, runtime);
  }

  async describeUniBackupPolicyDetailWithOptions(request: DescribeUniBackupPolicyDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUniBackupPolicyDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUniBackupPolicyDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUniBackupPolicyDetailResponse>(await this.callApi(params, req, runtime), new DescribeUniBackupPolicyDetailResponse({}));
  }

  async describeUniBackupPolicyDetail(request: DescribeUniBackupPolicyDetailRequest): Promise<DescribeUniBackupPolicyDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUniBackupPolicyDetailWithOptions(request, runtime);
  }

  async describeUniRecoverableListWithOptions(request: DescribeUniRecoverableListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUniRecoverableListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.database)) {
      query["Database"] = request.database;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUniRecoverableList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUniRecoverableListResponse>(await this.callApi(params, req, runtime), new DescribeUniRecoverableListResponse({}));
  }

  async describeUniRecoverableList(request: DescribeUniRecoverableListRequest): Promise<DescribeUniRecoverableListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUniRecoverableListWithOptions(request, runtime);
  }

  async describeUniSupportRegionWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeUniSupportRegionResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeUniSupportRegion",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUniSupportRegionResponse>(await this.callApi(params, req, runtime), new DescribeUniSupportRegionResponse({}));
  }

  async describeUniSupportRegion(): Promise<DescribeUniSupportRegionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUniSupportRegionWithOptions(runtime);
  }

  async describeUserBackupMachinesWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeUserBackupMachinesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeUserBackupMachines",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUserBackupMachinesResponse>(await this.callApi(params, req, runtime), new DescribeUserBackupMachinesResponse({}));
  }

  async describeUserBackupMachines(): Promise<DescribeUserBackupMachinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUserBackupMachinesWithOptions(runtime);
  }

  async describeUserBaselineAuthorizationWithOptions(request: DescribeUserBaselineAuthorizationRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUserBaselineAuthorizationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUserBaselineAuthorization",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUserBaselineAuthorizationResponse>(await this.callApi(params, req, runtime), new DescribeUserBaselineAuthorizationResponse({}));
  }

  async describeUserBaselineAuthorization(request: DescribeUserBaselineAuthorizationRequest): Promise<DescribeUserBaselineAuthorizationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUserBaselineAuthorizationWithOptions(request, runtime);
  }

  async describeUserLayoutAuthorizationWithOptions(request: DescribeUserLayoutAuthorizationRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUserLayoutAuthorizationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUserLayoutAuthorization",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUserLayoutAuthorizationResponse>(await this.callApi(params, req, runtime), new DescribeUserLayoutAuthorizationResponse({}));
  }

  async describeUserLayoutAuthorization(request: DescribeUserLayoutAuthorizationRequest): Promise<DescribeUserLayoutAuthorizationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUserLayoutAuthorizationWithOptions(request, runtime);
  }

  async describeUuidsByVulNamesWithOptions(request: DescribeUuidsByVulNamesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeUuidsByVulNamesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dealed)) {
      query["Dealed"] = request.dealed;
    }

    if (!Util.isUnset(request.fieldName)) {
      query["FieldName"] = request.fieldName;
    }

    if (!Util.isUnset(request.fieldValue)) {
      query["FieldValue"] = request.fieldValue;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.level)) {
      query["Level"] = request.level;
    }

    if (!Util.isUnset(request.necessity)) {
      query["Necessity"] = request.necessity;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.searchTags)) {
      query["SearchTags"] = request.searchTags;
    }

    if (!Util.isUnset(request.statusList)) {
      query["StatusList"] = request.statusList;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.vpcInstanceIds)) {
      query["VpcInstanceIds"] = request.vpcInstanceIds;
    }

    if (!Util.isUnset(request.vulNames)) {
      query["VulNames"] = request.vulNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeUuidsByVulNames",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeUuidsByVulNamesResponse>(await this.callApi(params, req, runtime), new DescribeUuidsByVulNamesResponse({}));
  }

  async describeUuidsByVulNames(request: DescribeUuidsByVulNamesRequest): Promise<DescribeUuidsByVulNamesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeUuidsByVulNamesWithOptions(request, runtime);
  }

  async describeVendorListWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeVendorListResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeVendorList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVendorListResponse>(await this.callApi(params, req, runtime), new DescribeVendorListResponse({}));
  }

  async describeVendorList(): Promise<DescribeVendorListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVendorListWithOptions(runtime);
  }

  async describeVersionConfigWithOptions(request: DescribeVersionConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVersionConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVersionConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVersionConfigResponse>(await this.callApi(params, req, runtime), new DescribeVersionConfigResponse({}));
  }

  async describeVersionConfig(request: DescribeVersionConfigRequest): Promise<DescribeVersionConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVersionConfigWithOptions(request, runtime);
  }

  async describeVpcHoneyPotCriteriaWithOptions(request: DescribeVpcHoneyPotCriteriaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVpcHoneyPotCriteriaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVpcHoneyPotCriteria",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVpcHoneyPotCriteriaResponse>(await this.callApi(params, req, runtime), new DescribeVpcHoneyPotCriteriaResponse({}));
  }

  async describeVpcHoneyPotCriteria(request: DescribeVpcHoneyPotCriteriaRequest): Promise<DescribeVpcHoneyPotCriteriaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVpcHoneyPotCriteriaWithOptions(request, runtime);
  }

  /**
    * If you specify only the Action request parameter in your request, Security Center returns the list of all VPCs regardless of whether a honeypot is deployed on a VPC.
    *
    * @param request DescribeVpcHoneyPotListRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeVpcHoneyPotListResponse
   */
  async describeVpcHoneyPotListWithOptions(request: DescribeVpcHoneyPotListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVpcHoneyPotListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.honeyPotExistence)) {
      query["HoneyPotExistence"] = request.honeyPotExistence;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    if (!Util.isUnset(request.vpcName)) {
      query["VpcName"] = request.vpcName;
    }

    if (!Util.isUnset(request.vpcRegionId)) {
      query["VpcRegionId"] = request.vpcRegionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVpcHoneyPotList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVpcHoneyPotListResponse>(await this.callApi(params, req, runtime), new DescribeVpcHoneyPotListResponse({}));
  }

  /**
    * If you specify only the Action request parameter in your request, Security Center returns the list of all VPCs regardless of whether a honeypot is deployed on a VPC.
    *
    * @param request DescribeVpcHoneyPotListRequest
    * @return DescribeVpcHoneyPotListResponse
   */
  async describeVpcHoneyPotList(request: DescribeVpcHoneyPotListRequest): Promise<DescribeVpcHoneyPotListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVpcHoneyPotListWithOptions(request, runtime);
  }

  async describeVpcListWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeVpcListResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeVpcList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVpcListResponse>(await this.callApi(params, req, runtime), new DescribeVpcListResponse({}));
  }

  async describeVpcList(): Promise<DescribeVpcListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVpcListWithOptions(runtime);
  }

  async describeVulCheckTaskStatusDetailWithOptions(request: DescribeVulCheckTaskStatusDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVulCheckTaskStatusDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.taskIds)) {
      query["TaskIds"] = request.taskIds;
    }

    if (!Util.isUnset(request.types)) {
      query["Types"] = request.types;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVulCheckTaskStatusDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVulCheckTaskStatusDetailResponse>(await this.callApi(params, req, runtime), new DescribeVulCheckTaskStatusDetailResponse({}));
  }

  async describeVulCheckTaskStatusDetail(request: DescribeVulCheckTaskStatusDetailRequest): Promise<DescribeVulCheckTaskStatusDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVulCheckTaskStatusDetailWithOptions(request, runtime);
  }

  async describeVulConfigWithOptions(request: DescribeVulConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVulConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVulConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVulConfigResponse>(await this.callApi(params, req, runtime), new DescribeVulConfigResponse({}));
  }

  async describeVulConfig(request: DescribeVulConfigRequest): Promise<DescribeVulConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVulConfigWithOptions(request, runtime);
  }

  async describeVulDetailsWithOptions(request: DescribeVulDetailsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVulDetailsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliasName)) {
      query["AliasName"] = request.aliasName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVulDetails",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVulDetailsResponse>(await this.callApi(params, req, runtime), new DescribeVulDetailsResponse({}));
  }

  async describeVulDetails(request: DescribeVulDetailsRequest): Promise<DescribeVulDetailsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVulDetailsWithOptions(request, runtime);
  }

  /**
    * If the value of ExportStatus is success, the URL at which you can download the exported Excel file is returned.
    *
    * @param request DescribeVulExportInfoRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return DescribeVulExportInfoResponse
   */
  async describeVulExportInfoWithOptions(request: DescribeVulExportInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVulExportInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.exportId)) {
      query["ExportId"] = request.exportId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVulExportInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVulExportInfoResponse>(await this.callApi(params, req, runtime), new DescribeVulExportInfoResponse({}));
  }

  /**
    * If the value of ExportStatus is success, the URL at which you can download the exported Excel file is returned.
    *
    * @param request DescribeVulExportInfoRequest
    * @return DescribeVulExportInfoResponse
   */
  async describeVulExportInfo(request: DescribeVulExportInfoRequest): Promise<DescribeVulExportInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVulExportInfoWithOptions(request, runtime);
  }

  async describeVulFixStatisticsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeVulFixStatisticsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeVulFixStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVulFixStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeVulFixStatisticsResponse({}));
  }

  async describeVulFixStatistics(): Promise<DescribeVulFixStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVulFixStatisticsWithOptions(runtime);
  }

  async describeVulListWithOptions(request: DescribeVulListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVulListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliasName)) {
      query["AliasName"] = request.aliasName;
    }

    if (!Util.isUnset(request.attachTypes)) {
      query["AttachTypes"] = request.attachTypes;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.dealed)) {
      query["Dealed"] = request.dealed;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.necessity)) {
      query["Necessity"] = request.necessity;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    if (!Util.isUnset(request.statusList)) {
      query["StatusList"] = request.statusList;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.useNextToken)) {
      query["UseNextToken"] = request.useNextToken;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    if (!Util.isUnset(request.vpcInstanceIds)) {
      query["VpcInstanceIds"] = request.vpcInstanceIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVulList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVulListResponse>(await this.callApi(params, req, runtime), new DescribeVulListResponse({}));
  }

  async describeVulList(request: DescribeVulListRequest): Promise<DescribeVulListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVulListWithOptions(request, runtime);
  }

  async describeVulListPageWithOptions(request: DescribeVulListPageRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVulListPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.cveId)) {
      query["CveId"] = request.cveId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.vulNameLike)) {
      query["VulNameLike"] = request.vulNameLike;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVulListPage",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVulListPageResponse>(await this.callApi(params, req, runtime), new DescribeVulListPageResponse({}));
  }

  async describeVulListPage(request: DescribeVulListPageRequest): Promise<DescribeVulListPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVulListPageWithOptions(request, runtime);
  }

  async describeVulNumStatisticsWithOptions(request: DescribeVulNumStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVulNumStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVulNumStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVulNumStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeVulNumStatisticsResponse({}));
  }

  async describeVulNumStatistics(request: DescribeVulNumStatisticsRequest): Promise<DescribeVulNumStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVulNumStatisticsWithOptions(request, runtime);
  }

  async describeVulTargetConfigWithOptions(request: DescribeVulTargetConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVulTargetConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVulTargetConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVulTargetConfigResponse>(await this.callApi(params, req, runtime), new DescribeVulTargetConfigResponse({}));
  }

  async describeVulTargetConfig(request: DescribeVulTargetConfigRequest): Promise<DescribeVulTargetConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVulTargetConfigWithOptions(request, runtime);
  }

  async describeVulTargetStatisticsWithOptions(request: DescribeVulTargetStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVulTargetStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVulTargetStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVulTargetStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeVulTargetStatisticsResponse({}));
  }

  async describeVulTargetStatistics(request: DescribeVulTargetStatisticsRequest): Promise<DescribeVulTargetStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVulTargetStatisticsWithOptions(request, runtime);
  }

  async describeVulWhitelistWithOptions(request: DescribeVulWhitelistRequest, runtime: $Util.RuntimeOptions): Promise<DescribeVulWhitelistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeVulWhitelist",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeVulWhitelistResponse>(await this.callApi(params, req, runtime), new DescribeVulWhitelistResponse({}));
  }

  async describeVulWhitelist(request: DescribeVulWhitelistRequest): Promise<DescribeVulWhitelistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeVulWhitelistWithOptions(request, runtime);
  }

  async describeWarningExportInfoWithOptions(request: DescribeWarningExportInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWarningExportInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.exportId)) {
      query["ExportId"] = request.exportId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWarningExportInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWarningExportInfoResponse>(await this.callApi(params, req, runtime), new DescribeWarningExportInfoResponse({}));
  }

  async describeWarningExportInfo(request: DescribeWarningExportInfoRequest): Promise<DescribeWarningExportInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWarningExportInfoWithOptions(request, runtime);
  }

  async describeWarningMachinesWithOptions(request: DescribeWarningMachinesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWarningMachinesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.containerFieldName)) {
      query["ContainerFieldName"] = request.containerFieldName;
    }

    if (!Util.isUnset(request.containerFieldValue)) {
      query["ContainerFieldValue"] = request.containerFieldValue;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.haveRisk)) {
      query["HaveRisk"] = request.haveRisk;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.machineName)) {
      query["MachineName"] = request.machineName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.riskId)) {
      query["RiskId"] = request.riskId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWarningMachines",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWarningMachinesResponse>(await this.callApi(params, req, runtime), new DescribeWarningMachinesResponse({}));
  }

  async describeWarningMachines(request: DescribeWarningMachinesRequest): Promise<DescribeWarningMachinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWarningMachinesWithOptions(request, runtime);
  }

  async describeWebLockBindListWithOptions(request: DescribeWebLockBindListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebLockBindListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebLockBindList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebLockBindListResponse>(await this.callApi(params, req, runtime), new DescribeWebLockBindListResponse({}));
  }

  async describeWebLockBindList(request: DescribeWebLockBindListRequest): Promise<DescribeWebLockBindListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebLockBindListWithOptions(request, runtime);
  }

  async describeWebLockConfigListWithOptions(request: DescribeWebLockConfigListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebLockConfigListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebLockConfigList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebLockConfigListResponse>(await this.callApi(params, req, runtime), new DescribeWebLockConfigListResponse({}));
  }

  async describeWebLockConfigList(request: DescribeWebLockConfigListRequest): Promise<DescribeWebLockConfigListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebLockConfigListWithOptions(request, runtime);
  }

  async describeWebLockExclusiveFileTypeWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeWebLockExclusiveFileTypeResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeWebLockExclusiveFileType",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebLockExclusiveFileTypeResponse>(await this.callApi(params, req, runtime), new DescribeWebLockExclusiveFileTypeResponse({}));
  }

  async describeWebLockExclusiveFileType(): Promise<DescribeWebLockExclusiveFileTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebLockExclusiveFileTypeWithOptions(runtime);
  }

  async describeWebLockFileChangeStatisticsWithOptions(request: DescribeWebLockFileChangeStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebLockFileChangeStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebLockFileChangeStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebLockFileChangeStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeWebLockFileChangeStatisticsResponse({}));
  }

  async describeWebLockFileChangeStatistics(request: DescribeWebLockFileChangeStatisticsRequest): Promise<DescribeWebLockFileChangeStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebLockFileChangeStatisticsWithOptions(request, runtime);
  }

  async describeWebLockFileEventsWithOptions(request: DescribeWebLockFileEventsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebLockFileEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.dealed)) {
      query["Dealed"] = request.dealed;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.processName)) {
      query["ProcessName"] = request.processName;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.tsBegin)) {
      query["TsBegin"] = request.tsBegin;
    }

    if (!Util.isUnset(request.tsEnd)) {
      query["TsEnd"] = request.tsEnd;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebLockFileEvents",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebLockFileEventsResponse>(await this.callApi(params, req, runtime), new DescribeWebLockFileEventsResponse({}));
  }

  async describeWebLockFileEvents(request: DescribeWebLockFileEventsRequest): Promise<DescribeWebLockFileEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebLockFileEventsWithOptions(request, runtime);
  }

  async describeWebLockFileTypeSummaryWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeWebLockFileTypeSummaryResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeWebLockFileTypeSummary",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebLockFileTypeSummaryResponse>(await this.callApi(params, req, runtime), new DescribeWebLockFileTypeSummaryResponse({}));
  }

  async describeWebLockFileTypeSummary(): Promise<DescribeWebLockFileTypeSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebLockFileTypeSummaryWithOptions(runtime);
  }

  async describeWebLockInclusiveFileTypeWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeWebLockInclusiveFileTypeResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeWebLockInclusiveFileType",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebLockInclusiveFileTypeResponse>(await this.callApi(params, req, runtime), new DescribeWebLockInclusiveFileTypeResponse({}));
  }

  async describeWebLockInclusiveFileType(): Promise<DescribeWebLockInclusiveFileTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebLockInclusiveFileTypeWithOptions(runtime);
  }

  async describeWebLockProcessBlockStatisticsWithOptions(request: DescribeWebLockProcessBlockStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebLockProcessBlockStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebLockProcessBlockStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebLockProcessBlockStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeWebLockProcessBlockStatisticsResponse({}));
  }

  async describeWebLockProcessBlockStatistics(request: DescribeWebLockProcessBlockStatisticsRequest): Promise<DescribeWebLockProcessBlockStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebLockProcessBlockStatisticsWithOptions(request, runtime);
  }

  async describeWebLockProcessListWithOptions(request: DescribeWebLockProcessListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebLockProcessListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.processName)) {
      query["ProcessName"] = request.processName;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebLockProcessList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebLockProcessListResponse>(await this.callApi(params, req, runtime), new DescribeWebLockProcessListResponse({}));
  }

  async describeWebLockProcessList(request: DescribeWebLockProcessListRequest): Promise<DescribeWebLockProcessListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebLockProcessListWithOptions(request, runtime);
  }

  async describeWebLockStatusWithOptions(request: DescribeWebLockStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebLockStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebLockStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebLockStatusResponse>(await this.callApi(params, req, runtime), new DescribeWebLockStatusResponse({}));
  }

  async describeWebLockStatus(request: DescribeWebLockStatusRequest): Promise<DescribeWebLockStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebLockStatusWithOptions(request, runtime);
  }

  async describeWebLockTotalFileChangeCountWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeWebLockTotalFileChangeCountResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeWebLockTotalFileChangeCount",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebLockTotalFileChangeCountResponse>(await this.callApi(params, req, runtime), new DescribeWebLockTotalFileChangeCountResponse({}));
  }

  async describeWebLockTotalFileChangeCount(): Promise<DescribeWebLockTotalFileChangeCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebLockTotalFileChangeCountWithOptions(runtime);
  }

  async describeWebPathWithOptions(request: DescribeWebPathRequest, runtime: $Util.RuntimeOptions): Promise<DescribeWebPathResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeWebPath",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeWebPathResponse>(await this.callApi(params, req, runtime), new DescribeWebPathResponse({}));
  }

  async describeWebPath(request: DescribeWebPathRequest): Promise<DescribeWebPathResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeWebPathWithOptions(request, runtime);
  }

  async disableBruteForceRecordWithOptions(request: DisableBruteForceRecordRequest, runtime: $Util.RuntimeOptions): Promise<DisableBruteForceRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.blockIp)) {
      query["BlockIp"] = request.blockIp;
    }

    if (!Util.isUnset(request.bound)) {
      query["Bound"] = request.bound;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableBruteForceRecord",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableBruteForceRecordResponse>(await this.callApi(params, req, runtime), new DisableBruteForceRecordResponse({}));
  }

  async disableBruteForceRecord(request: DisableBruteForceRecordRequest): Promise<DisableBruteForceRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableBruteForceRecordWithOptions(request, runtime);
  }

  async disableCustomBlockRecordWithOptions(request: DisableCustomBlockRecordRequest, runtime: $Util.RuntimeOptions): Promise<DisableCustomBlockRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.blockIp)) {
      query["BlockIp"] = request.blockIp;
    }

    if (!Util.isUnset(request.bound)) {
      query["Bound"] = request.bound;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DisableCustomBlockRecord",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DisableCustomBlockRecordResponse>(await this.callApi(params, req, runtime), new DisableCustomBlockRecordResponse({}));
  }

  async disableCustomBlockRecord(request: DisableCustomBlockRecordRequest): Promise<DisableCustomBlockRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.disableCustomBlockRecordWithOptions(request, runtime);
  }

  async enableBruteForceRecordWithOptions(request: EnableBruteForceRecordRequest, runtime: $Util.RuntimeOptions): Promise<EnableBruteForceRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.blockIp)) {
      query["BlockIp"] = request.blockIp;
    }

    if (!Util.isUnset(request.bound)) {
      query["Bound"] = request.bound;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableBruteForceRecord",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableBruteForceRecordResponse>(await this.callApi(params, req, runtime), new EnableBruteForceRecordResponse({}));
  }

  async enableBruteForceRecord(request: EnableBruteForceRecordRequest): Promise<EnableBruteForceRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableBruteForceRecordWithOptions(request, runtime);
  }

  async enableCustomBlockRecordWithOptions(request: EnableCustomBlockRecordRequest, runtime: $Util.RuntimeOptions): Promise<EnableCustomBlockRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.blockIp)) {
      query["BlockIp"] = request.blockIp;
    }

    if (!Util.isUnset(request.bound)) {
      query["Bound"] = request.bound;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "EnableCustomBlockRecord",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<EnableCustomBlockRecordResponse>(await this.callApi(params, req, runtime), new EnableCustomBlockRecordResponse({}));
  }

  async enableCustomBlockRecord(request: EnableCustomBlockRecordRequest): Promise<EnableCustomBlockRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.enableCustomBlockRecordWithOptions(request, runtime);
  }

  async execStrategyWithOptions(request: ExecStrategyRequest, runtime: $Util.RuntimeOptions): Promise<ExecStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExecStrategy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExecStrategyResponse>(await this.callApi(params, req, runtime), new ExecStrategyResponse({}));
  }

  async execStrategy(request: ExecStrategyRequest): Promise<ExecStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.execStrategyWithOptions(request, runtime);
  }

  /**
    * You can call the operation to export the following check result lists:
    * *   The list of servers on the Host page.
    * *   The lists of image system vulnerabilities, image application vulnerabilities, image baseline check results, and malicious image samples on the Image Security page.
    * *   The list of attack analysis data on the Attack Awareness page.
    * *   The list of check results for AccessKey pair leaks on the AK leak detection page.
    *
    * @param request ExportRecordRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ExportRecordResponse
   */
  async exportRecordWithOptions(request: ExportRecordRequest, runtime: $Util.RuntimeOptions): Promise<ExportRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.exportType)) {
      query["ExportType"] = request.exportType;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.params)) {
      query["Params"] = request.params;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExportRecord",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExportRecordResponse>(await this.callApi(params, req, runtime), new ExportRecordResponse({}));
  }

  /**
    * You can call the operation to export the following check result lists:
    * *   The list of servers on the Host page.
    * *   The lists of image system vulnerabilities, image application vulnerabilities, image baseline check results, and malicious image samples on the Image Security page.
    * *   The list of attack analysis data on the Attack Awareness page.
    * *   The list of check results for AccessKey pair leaks on the AK leak detection page.
    *
    * @param request ExportRecordRequest
    * @return ExportRecordResponse
   */
  async exportRecord(request: ExportRecordRequest): Promise<ExportRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.exportRecordWithOptions(request, runtime);
  }

  async exportSuspEventsWithOptions(request: ExportSuspEventsRequest, runtime: $Util.RuntimeOptions): Promise<ExportSuspEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.assetsTypeList)) {
      query["AssetsTypeList"] = request.assetsTypeList;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.containerFieldName)) {
      query["ContainerFieldName"] = request.containerFieldName;
    }

    if (!Util.isUnset(request.containerFieldValue)) {
      query["ContainerFieldValue"] = request.containerFieldValue;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.dealed)) {
      query["Dealed"] = request.dealed;
    }

    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.levels)) {
      query["Levels"] = request.levels;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.operateErrorCodeList)) {
      query["OperateErrorCodeList"] = request.operateErrorCodeList;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.parentEventTypes)) {
      query["ParentEventTypes"] = request.parentEventTypes;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.timeEnd)) {
      query["TimeEnd"] = request.timeEnd;
    }

    if (!Util.isUnset(request.timeStart)) {
      query["TimeStart"] = request.timeStart;
    }

    if (!Util.isUnset(request.uniqueInfo)) {
      query["UniqueInfo"] = request.uniqueInfo;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExportSuspEvents",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExportSuspEventsResponse>(await this.callApi(params, req, runtime), new ExportSuspEventsResponse({}));
  }

  async exportSuspEvents(request: ExportSuspEventsRequest): Promise<ExportSuspEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.exportSuspEventsWithOptions(request, runtime);
  }

  /**
    * You can call the ExportVul operation to export the following types of vulnerabilities: Linux software vulnerabilities, Windows system vulnerabilities, Web-CMS vulnerabilities, application vulnerabilities, and urgent vulnerabilities.
    * You can use this operation together with the DescribeVulExportInfo operation. After you call the ExportVul operation to create a vulnerability export task, you can call the DescribeVulExportInfo operation to query the progress of the task by specifying the ID of the task.
    * ### Limits
    * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
    *
    * @param request ExportVulRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ExportVulResponse
   */
  async exportVulWithOptions(request: ExportVulRequest, runtime: $Util.RuntimeOptions): Promise<ExportVulResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliasName)) {
      query["AliasName"] = request.aliasName;
    }

    if (!Util.isUnset(request.attachTypes)) {
      query["AttachTypes"] = request.attachTypes;
    }

    if (!Util.isUnset(request.containerName)) {
      query["ContainerName"] = request.containerName;
    }

    if (!Util.isUnset(request.createTsEnd)) {
      query["CreateTsEnd"] = request.createTsEnd;
    }

    if (!Util.isUnset(request.createTsStart)) {
      query["CreateTsStart"] = request.createTsStart;
    }

    if (!Util.isUnset(request.cveId)) {
      query["CveId"] = request.cveId;
    }

    if (!Util.isUnset(request.dealed)) {
      query["Dealed"] = request.dealed;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.imageName)) {
      query["ImageName"] = request.imageName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.necessity)) {
      query["Necessity"] = request.necessity;
    }

    if (!Util.isUnset(request.path)) {
      query["Path"] = request.path;
    }

    if (!Util.isUnset(request.searchTags)) {
      query["SearchTags"] = request.searchTags;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    if (!Util.isUnset(request.vpcInstanceIds)) {
      query["VpcInstanceIds"] = request.vpcInstanceIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExportVul",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExportVulResponse>(await this.callApi(params, req, runtime), new ExportVulResponse({}));
  }

  /**
    * You can call the ExportVul operation to export the following types of vulnerabilities: Linux software vulnerabilities, Windows system vulnerabilities, Web-CMS vulnerabilities, application vulnerabilities, and urgent vulnerabilities.
    * You can use this operation together with the DescribeVulExportInfo operation. After you call the ExportVul operation to create a vulnerability export task, you can call the DescribeVulExportInfo operation to query the progress of the task by specifying the ID of the task.
    * ### Limits
    * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
    *
    * @param request ExportVulRequest
    * @return ExportVulResponse
   */
  async exportVul(request: ExportVulRequest): Promise<ExportVulResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.exportVulWithOptions(request, runtime);
  }

  async exportWarningWithOptions(request: ExportWarningRequest, runtime: $Util.RuntimeOptions): Promise<ExportWarningResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dealed)) {
      query["Dealed"] = request.dealed;
    }

    if (!Util.isUnset(request.exportType)) {
      query["ExportType"] = request.exportType;
    }

    if (!Util.isUnset(request.isCleartextPwd)) {
      query["IsCleartextPwd"] = request.isCleartextPwd;
    }

    if (!Util.isUnset(request.isSummaryExport)) {
      query["IsSummaryExport"] = request.isSummaryExport;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.riskIds)) {
      query["RiskIds"] = request.riskIds;
    }

    if (!Util.isUnset(request.riskLevels)) {
      query["RiskLevels"] = request.riskLevels;
    }

    if (!Util.isUnset(request.riskName)) {
      query["RiskName"] = request.riskName;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.statusList)) {
      query["StatusList"] = request.statusList;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    if (!Util.isUnset(request.subTypeNames)) {
      query["SubTypeNames"] = request.subTypeNames;
    }

    if (!Util.isUnset(request.typeName)) {
      query["TypeName"] = request.typeName;
    }

    if (!Util.isUnset(request.typeNames)) {
      query["TypeNames"] = request.typeNames;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ExportWarning",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ExportWarningResponse>(await this.callApi(params, req, runtime), new ExportWarningResponse({}));
  }

  async exportWarning(request: ExportWarningRequest): Promise<ExportWarningResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.exportWarningWithOptions(request, runtime);
  }

  async findContainerNetworkConnectWithOptions(tmpReq: FindContainerNetworkConnectRequest, runtime: $Util.RuntimeOptions): Promise<FindContainerNetworkConnectResponse> {
    Util.validateModel(tmpReq);
    let request = new FindContainerNetworkConnectShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.dstNode)) {
      request.dstNodeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dstNode, "DstNode", "json");
    }

    if (!Util.isUnset(tmpReq.srcNode)) {
      request.srcNodeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.srcNode, "SrcNode", "json");
    }

    let query = { };
    if (!Util.isUnset(request.criteriaType)) {
      query["CriteriaType"] = request.criteriaType;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.dstNodeShrink)) {
      query["DstNode"] = request.dstNodeShrink;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.srcNodeShrink)) {
      query["SrcNode"] = request.srcNodeShrink;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "FindContainerNetworkConnect",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<FindContainerNetworkConnectResponse>(await this.callApi(params, req, runtime), new FindContainerNetworkConnectResponse({}));
  }

  async findContainerNetworkConnect(request: FindContainerNetworkConnectRequest): Promise<FindContainerNetworkConnectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.findContainerNetworkConnectWithOptions(request, runtime);
  }

  async fixCheckWarningsWithOptions(request: FixCheckWarningsRequest, runtime: $Util.RuntimeOptions): Promise<FixCheckWarningsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkParams)) {
      query["CheckParams"] = request.checkParams;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.riskId)) {
      query["RiskId"] = request.riskId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "FixCheckWarnings",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<FixCheckWarningsResponse>(await this.callApi(params, req, runtime), new FixCheckWarningsResponse({}));
  }

  async fixCheckWarnings(request: FixCheckWarningsRequest): Promise<FixCheckWarningsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.fixCheckWarningsWithOptions(request, runtime);
  }

  async generateOnceTaskWithOptions(request: GenerateOnceTaskRequest, runtime: $Util.RuntimeOptions): Promise<GenerateOnceTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.param)) {
      query["Param"] = request.param;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GenerateOnceTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GenerateOnceTaskResponse>(await this.callApi(params, req, runtime), new GenerateOnceTaskResponse({}));
  }

  async generateOnceTask(request: GenerateOnceTaskRequest): Promise<GenerateOnceTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.generateOnceTaskWithOptions(request, runtime);
  }

  async getAgentlessTaskCountWithOptions(runtime: $Util.RuntimeOptions): Promise<GetAgentlessTaskCountResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetAgentlessTaskCount",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAgentlessTaskCountResponse>(await this.callApi(params, req, runtime), new GetAgentlessTaskCountResponse({}));
  }

  async getAgentlessTaskCount(): Promise<GetAgentlessTaskCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAgentlessTaskCountWithOptions(runtime);
  }

  async getAlarmMachineCountWithOptions(request: GetAlarmMachineCountRequest, runtime: $Util.RuntimeOptions): Promise<GetAlarmMachineCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAlarmMachineCount",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAlarmMachineCountResponse>(await this.callApi(params, req, runtime), new GetAlarmMachineCountResponse({}));
  }

  async getAlarmMachineCount(request: GetAlarmMachineCountRequest): Promise<GetAlarmMachineCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAlarmMachineCountWithOptions(request, runtime);
  }

  async getAppNetworkWithOptions(request: GetAppNetworkRequest, runtime: $Util.RuntimeOptions): Promise<GetAppNetworkResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAppNetwork",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAppNetworkResponse>(await this.callApi(params, req, runtime), new GetAppNetworkResponse({}));
  }

  async getAppNetwork(request: GetAppNetworkRequest): Promise<GetAppNetworkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAppNetworkWithOptions(request, runtime);
  }

  async getAssetDetailByUuidWithOptions(request: GetAssetDetailByUuidRequest, runtime: $Util.RuntimeOptions): Promise<GetAssetDetailByUuidResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAssetDetailByUuid",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAssetDetailByUuidResponse>(await this.callApi(params, req, runtime), new GetAssetDetailByUuidResponse({}));
  }

  async getAssetDetailByUuid(request: GetAssetDetailByUuidRequest): Promise<GetAssetDetailByUuidResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAssetDetailByUuidWithOptions(request, runtime);
  }

  async getAssetSelectionConfigWithOptions(request: GetAssetSelectionConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetAssetSelectionConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.businessType)) {
      query["BusinessType"] = request.businessType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAssetSelectionConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAssetSelectionConfigResponse>(await this.callApi(params, req, runtime), new GetAssetSelectionConfigResponse({}));
  }

  async getAssetSelectionConfig(request: GetAssetSelectionConfigRequest): Promise<GetAssetSelectionConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAssetSelectionConfigWithOptions(request, runtime);
  }

  async getAssetsPropertyDetailWithOptions(request: GetAssetsPropertyDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetAssetsPropertyDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.biz)) {
      query["Biz"] = request.biz;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.itemName)) {
      query["ItemName"] = request.itemName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.searchCriteriaList)) {
      query["SearchCriteriaList"] = request.searchCriteriaList;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAssetsPropertyDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAssetsPropertyDetailResponse>(await this.callApi(params, req, runtime), new GetAssetsPropertyDetailResponse({}));
  }

  async getAssetsPropertyDetail(request: GetAssetsPropertyDetailRequest): Promise<GetAssetsPropertyDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAssetsPropertyDetailWithOptions(request, runtime);
  }

  async getAssetsPropertyItemWithOptions(request: GetAssetsPropertyItemRequest, runtime: $Util.RuntimeOptions): Promise<GetAssetsPropertyItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.biz)) {
      query["Biz"] = request.biz;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.forceFlush)) {
      query["ForceFlush"] = request.forceFlush;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.searchInfo)) {
      query["SearchInfo"] = request.searchInfo;
    }

    if (!Util.isUnset(request.searchItem)) {
      query["SearchItem"] = request.searchItem;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetAssetsPropertyItem",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAssetsPropertyItemResponse>(await this.callApi(params, req, runtime), new GetAssetsPropertyItemResponse({}));
  }

  async getAssetsPropertyItem(request: GetAssetsPropertyItemRequest): Promise<GetAssetsPropertyItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAssetsPropertyItemWithOptions(request, runtime);
  }

  async getAuthVersionStatisticWithOptions(runtime: $Util.RuntimeOptions): Promise<GetAuthVersionStatisticResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetAuthVersionStatistic",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAuthVersionStatisticResponse>(await this.callApi(params, req, runtime), new GetAuthVersionStatisticResponse({}));
  }

  async getAuthVersionStatistic(): Promise<GetAuthVersionStatisticResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAuthVersionStatisticWithOptions(runtime);
  }

  async getBackupStorageCountWithOptions(runtime: $Util.RuntimeOptions): Promise<GetBackupStorageCountResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetBackupStorageCount",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetBackupStorageCountResponse>(await this.callApi(params, req, runtime), new GetBackupStorageCountResponse({}));
  }

  async getBackupStorageCount(): Promise<GetBackupStorageCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getBackupStorageCountWithOptions(runtime);
  }

  async getCheckConfigWithOptions(runtime: $Util.RuntimeOptions): Promise<GetCheckConfigResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetCheckConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCheckConfigResponse>(await this.callApi(params, req, runtime), new GetCheckConfigResponse({}));
  }

  async getCheckConfig(): Promise<GetCheckConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCheckConfigWithOptions(runtime);
  }

  async getCheckDetailWithOptions(request: GetCheckDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetCheckDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkId)) {
      query["CheckId"] = request.checkId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCheckDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCheckDetailResponse>(await this.callApi(params, req, runtime), new GetCheckDetailResponse({}));
  }

  async getCheckDetail(request: GetCheckDetailRequest): Promise<GetCheckDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCheckDetailWithOptions(request, runtime);
  }

  async getCheckProcessWithOptions(request: GetCheckProcessRequest, runtime: $Util.RuntimeOptions): Promise<GetCheckProcessResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCheckProcess",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCheckProcessResponse>(await this.callApi(params, req, runtime), new GetCheckProcessResponse({}));
  }

  async getCheckProcess(request: GetCheckProcessRequest): Promise<GetCheckProcessResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCheckProcessWithOptions(request, runtime);
  }

  async getCheckRiskStatisticsWithOptions(request: GetCheckRiskStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<GetCheckRiskStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCheckRiskStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCheckRiskStatisticsResponse>(await this.callApi(params, req, runtime), new GetCheckRiskStatisticsResponse({}));
  }

  async getCheckRiskStatistics(request: GetCheckRiskStatisticsRequest): Promise<GetCheckRiskStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCheckRiskStatisticsWithOptions(request, runtime);
  }

  async getCheckSaleWithOptions(request: GetCheckSaleRequest, runtime: $Util.RuntimeOptions): Promise<GetCheckSaleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCheckSale",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCheckSaleResponse>(await this.callApi(params, req, runtime), new GetCheckSaleResponse({}));
  }

  async getCheckSale(request: GetCheckSaleRequest): Promise<GetCheckSaleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCheckSaleWithOptions(request, runtime);
  }

  async getCheckSummaryWithOptions(request: GetCheckSummaryRequest, runtime: $Util.RuntimeOptions): Promise<GetCheckSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCheckSummary",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCheckSummaryResponse>(await this.callApi(params, req, runtime), new GetCheckSummaryResponse({}));
  }

  async getCheckSummary(request: GetCheckSummaryRequest): Promise<GetCheckSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCheckSummaryWithOptions(request, runtime);
  }

  /**
    * @deprecated : GetClientInstallationStatistic is deprecated, please use Sas::2018-12-03::GetClientRatioStatistic instead.
    *
    * @param request GetClientInstallationStatisticRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetClientInstallationStatisticResponse
   */
  // Deprecated
  async getClientInstallationStatisticWithOptions(request: GetClientInstallationStatisticRequest, runtime: $Util.RuntimeOptions): Promise<GetClientInstallationStatisticResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.timeEnd)) {
      query["TimeEnd"] = request.timeEnd;
    }

    if (!Util.isUnset(request.timeStart)) {
      query["TimeStart"] = request.timeStart;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetClientInstallationStatistic",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetClientInstallationStatisticResponse>(await this.callApi(params, req, runtime), new GetClientInstallationStatisticResponse({}));
  }

  /**
    * @deprecated : GetClientInstallationStatistic is deprecated, please use Sas::2018-12-03::GetClientRatioStatistic instead.
    *
    * @param request GetClientInstallationStatisticRequest
    * @return GetClientInstallationStatisticResponse
   */
  // Deprecated
  async getClientInstallationStatistic(request: GetClientInstallationStatisticRequest): Promise<GetClientInstallationStatisticResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getClientInstallationStatisticWithOptions(request, runtime);
  }

  async getClientRatioStatisticWithOptions(request: GetClientRatioStatisticRequest, runtime: $Util.RuntimeOptions): Promise<GetClientRatioStatisticResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceDirectoryAccountId)) {
      query["ResourceDirectoryAccountId"] = request.resourceDirectoryAccountId;
    }

    if (!Util.isUnset(request.statisticTypes)) {
      query["StatisticTypes"] = request.statisticTypes;
    }

    if (!Util.isUnset(request.timeEnd)) {
      query["TimeEnd"] = request.timeEnd;
    }

    if (!Util.isUnset(request.timeStart)) {
      query["TimeStart"] = request.timeStart;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetClientRatioStatistic",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetClientRatioStatisticResponse>(await this.callApi(params, req, runtime), new GetClientRatioStatisticResponse({}));
  }

  async getClientRatioStatistic(request: GetClientRatioStatisticRequest): Promise<GetClientRatioStatisticResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getClientRatioStatisticWithOptions(request, runtime);
  }

  async getClientUserDefineRuleWithOptions(request: GetClientUserDefineRuleRequest, runtime: $Util.RuntimeOptions): Promise<GetClientUserDefineRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetClientUserDefineRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetClientUserDefineRuleResponse>(await this.callApi(params, req, runtime), new GetClientUserDefineRuleResponse({}));
  }

  async getClientUserDefineRule(request: GetClientUserDefineRuleRequest): Promise<GetClientUserDefineRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getClientUserDefineRuleWithOptions(request, runtime);
  }

  async getCloudAssetCriteriaWithOptions(request: GetCloudAssetCriteriaRequest, runtime: $Util.RuntimeOptions): Promise<GetCloudAssetCriteriaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cloudAssetTypes)) {
      query["CloudAssetTypes"] = request.cloudAssetTypes;
    }

    if (!Util.isUnset(request.value)) {
      query["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCloudAssetCriteria",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCloudAssetCriteriaResponse>(await this.callApi(params, req, runtime), new GetCloudAssetCriteriaResponse({}));
  }

  async getCloudAssetCriteria(request: GetCloudAssetCriteriaRequest): Promise<GetCloudAssetCriteriaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCloudAssetCriteriaWithOptions(request, runtime);
  }

  async getCloudAssetDetailWithOptions(request: GetCloudAssetDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetCloudAssetDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.assetSubType)) {
      query["AssetSubType"] = request.assetSubType;
    }

    if (!Util.isUnset(request.assetType)) {
      query["AssetType"] = request.assetType;
    }

    if (!Util.isUnset(request.cloudAssetInstances)) {
      query["CloudAssetInstances"] = request.cloudAssetInstances;
    }

    if (!Util.isUnset(request.vendor)) {
      query["Vendor"] = request.vendor;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCloudAssetDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCloudAssetDetailResponse>(await this.callApi(params, req, runtime), new GetCloudAssetDetailResponse({}));
  }

  async getCloudAssetDetail(request: GetCloudAssetDetailRequest): Promise<GetCloudAssetDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCloudAssetDetailWithOptions(request, runtime);
  }

  async getCloudAssetSummaryWithOptions(runtime: $Util.RuntimeOptions): Promise<GetCloudAssetSummaryResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetCloudAssetSummary",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCloudAssetSummaryResponse>(await this.callApi(params, req, runtime), new GetCloudAssetSummaryResponse({}));
  }

  async getCloudAssetSummary(): Promise<GetCloudAssetSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCloudAssetSummaryWithOptions(runtime);
  }

  async getClusterCheckItemWarningStatisticsWithOptions(request: GetClusterCheckItemWarningStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<GetClusterCheckItemWarningStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetClusterCheckItemWarningStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetClusterCheckItemWarningStatisticsResponse>(await this.callApi(params, req, runtime), new GetClusterCheckItemWarningStatisticsResponse({}));
  }

  async getClusterCheckItemWarningStatistics(request: GetClusterCheckItemWarningStatisticsRequest): Promise<GetClusterCheckItemWarningStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getClusterCheckItemWarningStatisticsWithOptions(request, runtime);
  }

  async getClusterRuleSummaryWithOptions(request: GetClusterRuleSummaryRequest, runtime: $Util.RuntimeOptions): Promise<GetClusterRuleSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetClusterRuleSummary",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetClusterRuleSummaryResponse>(await this.callApi(params, req, runtime), new GetClusterRuleSummaryResponse({}));
  }

  async getClusterRuleSummary(request: GetClusterRuleSummaryRequest): Promise<GetClusterRuleSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getClusterRuleSummaryWithOptions(request, runtime);
  }

  async getClusterSuspEventStatisticsWithOptions(request: GetClusterSuspEventStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<GetClusterSuspEventStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetClusterSuspEventStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetClusterSuspEventStatisticsResponse>(await this.callApi(params, req, runtime), new GetClusterSuspEventStatisticsResponse({}));
  }

  async getClusterSuspEventStatistics(request: GetClusterSuspEventStatisticsRequest): Promise<GetClusterSuspEventStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getClusterSuspEventStatisticsWithOptions(request, runtime);
  }

  async getCommonSwitchConfigWithOptions(request: GetCommonSwitchConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetCommonSwitchConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetCommonSwitchConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetCommonSwitchConfigResponse>(await this.callApi(params, req, runtime), new GetCommonSwitchConfigResponse({}));
  }

  async getCommonSwitchConfig(request: GetCommonSwitchConfigRequest): Promise<GetCommonSwitchConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getCommonSwitchConfigWithOptions(request, runtime);
  }

  async getContainerDefenseRuleDetailWithOptions(request: GetContainerDefenseRuleDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetContainerDefenseRuleDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetContainerDefenseRuleDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetContainerDefenseRuleDetailResponse>(await this.callApi(params, req, runtime), new GetContainerDefenseRuleDetailResponse({}));
  }

  async getContainerDefenseRuleDetail(request: GetContainerDefenseRuleDetailRequest): Promise<GetContainerDefenseRuleDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getContainerDefenseRuleDetailWithOptions(request, runtime);
  }

  async getFileDetectApiInvokeInfoWithOptions(runtime: $Util.RuntimeOptions): Promise<GetFileDetectApiInvokeInfoResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetFileDetectApiInvokeInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFileDetectApiInvokeInfoResponse>(await this.callApi(params, req, runtime), new GetFileDetectApiInvokeInfoResponse({}));
  }

  async getFileDetectApiInvokeInfo(): Promise<GetFileDetectApiInvokeInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getFileDetectApiInvokeInfoWithOptions(runtime);
  }

  async getFileDetectReportWithOptions(request: GetFileDetectReportRequest, runtime: $Util.RuntimeOptions): Promise<GetFileDetectReportResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventId)) {
      query["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.field)) {
      query["Field"] = request.field;
    }

    if (!Util.isUnset(request.fileHash)) {
      query["FileHash"] = request.fileHash;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceType)) {
      query["SourceType"] = request.sourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetFileDetectReport",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFileDetectReportResponse>(await this.callApi(params, req, runtime), new GetFileDetectReportResponse({}));
  }

  async getFileDetectReport(request: GetFileDetectReportRequest): Promise<GetFileDetectReportResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getFileDetectReportWithOptions(request, runtime);
  }

  /**
    * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
    *
    * @param request GetFileDetectResultRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return GetFileDetectResultResponse
   */
  async getFileDetectResultWithOptions(request: GetFileDetectResultRequest, runtime: $Util.RuntimeOptions): Promise<GetFileDetectResultResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.hashKeyList)) {
      query["HashKeyList"] = request.hashKeyList;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetFileDetectResult",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFileDetectResultResponse>(await this.callApi(params, req, runtime), new GetFileDetectResultResponse({}));
  }

  /**
    * The HashKey parameter is included in all API operations that are related to the file detection feature. The parameter specifies the unique identifier of a file. Only MD5 hash values are supported. Before you call this operation, calculate the MD5 hash value of the file.
    *
    * @param request GetFileDetectResultRequest
    * @return GetFileDetectResultResponse
   */
  async getFileDetectResult(request: GetFileDetectResultRequest): Promise<GetFileDetectResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getFileDetectResultWithOptions(request, runtime);
  }

  async getFileProtectDashboardWithOptions(runtime: $Util.RuntimeOptions): Promise<GetFileProtectDashboardResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetFileProtectDashboard",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFileProtectDashboardResponse>(await this.callApi(params, req, runtime), new GetFileProtectDashboardResponse({}));
  }

  async getFileProtectDashboard(): Promise<GetFileProtectDashboardResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getFileProtectDashboardWithOptions(runtime);
  }

  async getFileProtectEventWithOptions(request: GetFileProtectEventRequest, runtime: $Util.RuntimeOptions): Promise<GetFileProtectEventResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetFileProtectEvent",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFileProtectEventResponse>(await this.callApi(params, req, runtime), new GetFileProtectEventResponse({}));
  }

  async getFileProtectEvent(request: GetFileProtectEventRequest): Promise<GetFileProtectEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getFileProtectEventWithOptions(request, runtime);
  }

  async getFileProtectEventCountWithOptions(request: GetFileProtectEventCountRequest, runtime: $Util.RuntimeOptions): Promise<GetFileProtectEventCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetFileProtectEventCount",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFileProtectEventCountResponse>(await this.callApi(params, req, runtime), new GetFileProtectEventCountResponse({}));
  }

  async getFileProtectEventCount(request: GetFileProtectEventCountRequest): Promise<GetFileProtectEventCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getFileProtectEventCountWithOptions(request, runtime);
  }

  async getFileProtectRuleWithOptions(request: GetFileProtectRuleRequest, runtime: $Util.RuntimeOptions): Promise<GetFileProtectRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetFileProtectRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFileProtectRuleResponse>(await this.callApi(params, req, runtime), new GetFileProtectRuleResponse({}));
  }

  async getFileProtectRule(request: GetFileProtectRuleRequest): Promise<GetFileProtectRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getFileProtectRuleWithOptions(request, runtime);
  }

  async getFileUploadLimitWithOptions(runtime: $Util.RuntimeOptions): Promise<GetFileUploadLimitResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetFileUploadLimit",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetFileUploadLimitResponse>(await this.callApi(params, req, runtime), new GetFileUploadLimitResponse({}));
  }

  async getFileUploadLimit(): Promise<GetFileUploadLimitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getFileUploadLimitWithOptions(runtime);
  }

  async getHoneypotAttackStatisticsWithOptions(request: GetHoneypotAttackStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<GetHoneypotAttackStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTimeStamp)) {
      query["EndTimeStamp"] = request.endTimeStamp;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.riskLevelList)) {
      query["RiskLevelList"] = request.riskLevelList;
    }

    if (!Util.isUnset(request.srcIp)) {
      query["SrcIp"] = request.srcIp;
    }

    if (!Util.isUnset(request.startTimeStamp)) {
      query["StartTimeStamp"] = request.startTimeStamp;
    }

    if (!Util.isUnset(request.statisticsType)) {
      query["StatisticsType"] = request.statisticsType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetHoneypotAttackStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetHoneypotAttackStatisticsResponse>(await this.callApi(params, req, runtime), new GetHoneypotAttackStatisticsResponse({}));
  }

  async getHoneypotAttackStatistics(request: GetHoneypotAttackStatisticsRequest): Promise<GetHoneypotAttackStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getHoneypotAttackStatisticsWithOptions(request, runtime);
  }

  async getHoneypotEventTrendWithOptions(request: GetHoneypotEventTrendRequest, runtime: $Util.RuntimeOptions): Promise<GetHoneypotEventTrendResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTimeStamp)) {
      query["EndTimeStamp"] = request.endTimeStamp;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.riskLevelList)) {
      query["RiskLevelList"] = request.riskLevelList;
    }

    if (!Util.isUnset(request.srcIp)) {
      query["SrcIp"] = request.srcIp;
    }

    if (!Util.isUnset(request.startTimeStamp)) {
      query["StartTimeStamp"] = request.startTimeStamp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetHoneypotEventTrend",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetHoneypotEventTrendResponse>(await this.callApi(params, req, runtime), new GetHoneypotEventTrendResponse({}));
  }

  async getHoneypotEventTrend(request: GetHoneypotEventTrendRequest): Promise<GetHoneypotEventTrendResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getHoneypotEventTrendWithOptions(request, runtime);
  }

  async getHoneypotNodeWithOptions(request: GetHoneypotNodeRequest, runtime: $Util.RuntimeOptions): Promise<GetHoneypotNodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetHoneypotNode",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetHoneypotNodeResponse>(await this.callApi(params, req, runtime), new GetHoneypotNodeResponse({}));
  }

  async getHoneypotNode(request: GetHoneypotNodeRequest): Promise<GetHoneypotNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getHoneypotNodeWithOptions(request, runtime);
  }

  async getHoneypotNodeMetricListWithOptions(request: GetHoneypotNodeMetricListRequest, runtime: $Util.RuntimeOptions): Promise<GetHoneypotNodeMetricListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.express)) {
      query["Express"] = request.express;
    }

    if (!Util.isUnset(request.length)) {
      query["Length"] = request.length;
    }

    if (!Util.isUnset(request.metricName)) {
      query["MetricName"] = request.metricName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.period)) {
      query["Period"] = request.period;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetHoneypotNodeMetricList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetHoneypotNodeMetricListResponse>(await this.callApi(params, req, runtime), new GetHoneypotNodeMetricListResponse({}));
  }

  async getHoneypotNodeMetricList(request: GetHoneypotNodeMetricListRequest): Promise<GetHoneypotNodeMetricListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getHoneypotNodeMetricListWithOptions(request, runtime);
  }

  async getHoneypotPresetWithOptions(request: GetHoneypotPresetRequest, runtime: $Util.RuntimeOptions): Promise<GetHoneypotPresetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.honeypotPresetId)) {
      query["HoneypotPresetId"] = request.honeypotPresetId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetHoneypotPreset",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetHoneypotPresetResponse>(await this.callApi(params, req, runtime), new GetHoneypotPresetResponse({}));
  }

  async getHoneypotPreset(request: GetHoneypotPresetRequest): Promise<GetHoneypotPresetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getHoneypotPresetWithOptions(request, runtime);
  }

  async getHoneypotProbeWithOptions(request: GetHoneypotProbeRequest, runtime: $Util.RuntimeOptions): Promise<GetHoneypotProbeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.probeId)) {
      query["ProbeId"] = request.probeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetHoneypotProbe",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetHoneypotProbeResponse>(await this.callApi(params, req, runtime), new GetHoneypotProbeResponse({}));
  }

  async getHoneypotProbe(request: GetHoneypotProbeRequest): Promise<GetHoneypotProbeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getHoneypotProbeWithOptions(request, runtime);
  }

  async getHoneypotStatisticsWithOptions(request: GetHoneypotStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<GetHoneypotStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetHoneypotStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetHoneypotStatisticsResponse>(await this.callApi(params, req, runtime), new GetHoneypotStatisticsResponse({}));
  }

  async getHoneypotStatistics(request: GetHoneypotStatisticsRequest): Promise<GetHoneypotStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getHoneypotStatisticsWithOptions(request, runtime);
  }

  async getImageEventOperationWithOptions(request: GetImageEventOperationRequest, runtime: $Util.RuntimeOptions): Promise<GetImageEventOperationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetImageEventOperation",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetImageEventOperationResponse>(await this.callApi(params, req, runtime), new GetImageEventOperationResponse({}));
  }

  async getImageEventOperation(request: GetImageEventOperationRequest): Promise<GetImageEventOperationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getImageEventOperationWithOptions(request, runtime);
  }

  async getImageScanNumInPeriodWithOptions(request: GetImageScanNumInPeriodRequest, runtime: $Util.RuntimeOptions): Promise<GetImageScanNumInPeriodResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.pastDay)) {
      query["PastDay"] = request.pastDay;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetImageScanNumInPeriod",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetImageScanNumInPeriodResponse>(await this.callApi(params, req, runtime), new GetImageScanNumInPeriodResponse({}));
  }

  async getImageScanNumInPeriod(request: GetImageScanNumInPeriodRequest): Promise<GetImageScanNumInPeriodResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getImageScanNumInPeriodWithOptions(request, runtime);
  }

  async getInterceptionRuleDetailWithOptions(request: GetInterceptionRuleDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetInterceptionRuleDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetInterceptionRuleDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInterceptionRuleDetailResponse>(await this.callApi(params, req, runtime), new GetInterceptionRuleDetailResponse({}));
  }

  async getInterceptionRuleDetail(request: GetInterceptionRuleDetailRequest): Promise<GetInterceptionRuleDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInterceptionRuleDetailWithOptions(request, runtime);
  }

  async getInterceptionSummaryWithOptions(request: GetInterceptionSummaryRequest, runtime: $Util.RuntimeOptions): Promise<GetInterceptionSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetInterceptionSummary",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInterceptionSummaryResponse>(await this.callApi(params, req, runtime), new GetInterceptionSummaryResponse({}));
  }

  async getInterceptionSummary(request: GetInterceptionSummaryRequest): Promise<GetInterceptionSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInterceptionSummaryWithOptions(request, runtime);
  }

  async getInterceptionTargetDetailWithOptions(request: GetInterceptionTargetDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetInterceptionTargetDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.targetId)) {
      query["TargetId"] = request.targetId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetInterceptionTargetDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetInterceptionTargetDetailResponse>(await this.callApi(params, req, runtime), new GetInterceptionTargetDetailResponse({}));
  }

  async getInterceptionTargetDetail(request: GetInterceptionTargetDetailRequest): Promise<GetInterceptionTargetDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getInterceptionTargetDetailWithOptions(request, runtime);
  }

  async getLastOnceTaskInfoWithOptions(request: GetLastOnceTaskInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetLastOnceTaskInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetLastOnceTaskInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetLastOnceTaskInfoResponse>(await this.callApi(params, req, runtime), new GetLastOnceTaskInfoResponse({}));
  }

  async getLastOnceTaskInfo(request: GetLastOnceTaskInfoRequest): Promise<GetLastOnceTaskInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getLastOnceTaskInfoWithOptions(request, runtime);
  }

  async getLogMetaWithOptions(request: GetLogMetaRequest, runtime: $Util.RuntimeOptions): Promise<GetLogMetaResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.logStore)) {
      query["LogStore"] = request.logStore;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetLogMeta",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetLogMetaResponse>(await this.callApi(params, req, runtime), new GetLogMetaResponse({}));
  }

  async getLogMeta(request: GetLogMetaRequest): Promise<GetLogMetaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getLogMetaWithOptions(request, runtime);
  }

  async getModuleConfigWithOptions(request: GetModuleConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetModuleConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetModuleConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetModuleConfigResponse>(await this.callApi(params, req, runtime), new GetModuleConfigResponse({}));
  }

  async getModuleConfig(request: GetModuleConfigRequest): Promise<GetModuleConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getModuleConfigWithOptions(request, runtime);
  }

  async getModuleTrialAuthInfoWithOptions(request: GetModuleTrialAuthInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetModuleTrialAuthInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.moduleCode)) {
      query["ModuleCode"] = request.moduleCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetModuleTrialAuthInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetModuleTrialAuthInfoResponse>(await this.callApi(params, req, runtime), new GetModuleTrialAuthInfoResponse({}));
  }

  async getModuleTrialAuthInfo(request: GetModuleTrialAuthInfoRequest): Promise<GetModuleTrialAuthInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getModuleTrialAuthInfoWithOptions(request, runtime);
  }

  async getObjectScanEventWithOptions(request: GetObjectScanEventRequest, runtime: $Util.RuntimeOptions): Promise<GetObjectScanEventResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.eventId)) {
      query["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetObjectScanEvent",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetObjectScanEventResponse>(await this.callApi(params, req, runtime), new GetObjectScanEventResponse({}));
  }

  async getObjectScanEvent(request: GetObjectScanEventRequest): Promise<GetObjectScanEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getObjectScanEventWithOptions(request, runtime);
  }

  async getOnceTaskResultInfoWithOptions(request: GetOnceTaskResultInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetOnceTaskResultInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOnceTaskResultInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOnceTaskResultInfoResponse>(await this.callApi(params, req, runtime), new GetOnceTaskResultInfoResponse({}));
  }

  async getOnceTaskResultInfo(request: GetOnceTaskResultInfoRequest): Promise<GetOnceTaskResultInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOnceTaskResultInfoWithOptions(request, runtime);
  }

  async getOpaClusterBaseLineListWithOptions(runtime: $Util.RuntimeOptions): Promise<GetOpaClusterBaseLineListResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetOpaClusterBaseLineList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOpaClusterBaseLineListResponse>(await this.callApi(params, req, runtime), new GetOpaClusterBaseLineListResponse({}));
  }

  async getOpaClusterBaseLineList(): Promise<GetOpaClusterBaseLineListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOpaClusterBaseLineListWithOptions(runtime);
  }

  async getOpaClusterImageListWithOptions(request: GetOpaClusterImageListRequest, runtime: $Util.RuntimeOptions): Promise<GetOpaClusterImageListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.imageName)) {
      query["ImageName"] = request.imageName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOpaClusterImageList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOpaClusterImageListResponse>(await this.callApi(params, req, runtime), new GetOpaClusterImageListResponse({}));
  }

  async getOpaClusterImageList(request: GetOpaClusterImageListRequest): Promise<GetOpaClusterImageListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOpaClusterImageListWithOptions(request, runtime);
  }

  async getOpaClusterLabelListWithOptions(request: GetOpaClusterLabelListRequest, runtime: $Util.RuntimeOptions): Promise<GetOpaClusterLabelListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tagName)) {
      query["TagName"] = request.tagName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOpaClusterLabelList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOpaClusterLabelListResponse>(await this.callApi(params, req, runtime), new GetOpaClusterLabelListResponse({}));
  }

  async getOpaClusterLabelList(request: GetOpaClusterLabelListRequest): Promise<GetOpaClusterLabelListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOpaClusterLabelListWithOptions(request, runtime);
  }

  async getOpaClusterNamespaceListWithOptions(request: GetOpaClusterNamespaceListRequest, runtime: $Util.RuntimeOptions): Promise<GetOpaClusterNamespaceListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.nameSpaceName)) {
      query["NameSpaceName"] = request.nameSpaceName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOpaClusterNamespaceList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOpaClusterNamespaceListResponse>(await this.callApi(params, req, runtime), new GetOpaClusterNamespaceListResponse({}));
  }

  async getOpaClusterNamespaceList(request: GetOpaClusterNamespaceListRequest): Promise<GetOpaClusterNamespaceListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOpaClusterNamespaceListWithOptions(request, runtime);
  }

  async getOpaPluginStatusWithOptions(request: GetOpaPluginStatusRequest, runtime: $Util.RuntimeOptions): Promise<GetOpaPluginStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterIds)) {
      query["ClusterIds"] = request.clusterIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOpaPluginStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOpaPluginStatusResponse>(await this.callApi(params, req, runtime), new GetOpaPluginStatusResponse({}));
  }

  async getOpaPluginStatus(request: GetOpaPluginStatusRequest): Promise<GetOpaPluginStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOpaPluginStatusWithOptions(request, runtime);
  }

  async getOpaStrategyTemplateSummaryWithOptions(runtime: $Util.RuntimeOptions): Promise<GetOpaStrategyTemplateSummaryResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetOpaStrategyTemplateSummary",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOpaStrategyTemplateSummaryResponse>(await this.callApi(params, req, runtime), new GetOpaStrategyTemplateSummaryResponse({}));
  }

  async getOpaStrategyTemplateSummary(): Promise<GetOpaStrategyTemplateSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOpaStrategyTemplateSummaryWithOptions(runtime);
  }

  async getOssBucketScanStatisticWithOptions(request: GetOssBucketScanStatisticRequest, runtime: $Util.RuntimeOptions): Promise<GetOssBucketScanStatisticResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bucketNameList)) {
      query["BucketNameList"] = request.bucketNameList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetOssBucketScanStatistic",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOssBucketScanStatisticResponse>(await this.callApi(params, req, runtime), new GetOssBucketScanStatisticResponse({}));
  }

  async getOssBucketScanStatistic(request: GetOssBucketScanStatisticRequest): Promise<GetOssBucketScanStatisticResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOssBucketScanStatisticWithOptions(request, runtime);
  }

  async getOssScanConfigWithOptions(runtime: $Util.RuntimeOptions): Promise<GetOssScanConfigResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetOssScanConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOssScanConfigResponse>(await this.callApi(params, req, runtime), new GetOssScanConfigResponse({}));
  }

  async getOssScanConfig(): Promise<GetOssScanConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOssScanConfigWithOptions(runtime);
  }

  async getPropertyScheduleConfigWithOptions(request: GetPropertyScheduleConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetPropertyScheduleConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetPropertyScheduleConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetPropertyScheduleConfigResponse>(await this.callApi(params, req, runtime), new GetPropertyScheduleConfigResponse({}));
  }

  async getPropertyScheduleConfig(request: GetPropertyScheduleConfigRequest): Promise<GetPropertyScheduleConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getPropertyScheduleConfigWithOptions(request, runtime);
  }

  async getRulesCountWithOptions(runtime: $Util.RuntimeOptions): Promise<GetRulesCountResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetRulesCount",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetRulesCountResponse>(await this.callApi(params, req, runtime), new GetRulesCountResponse({}));
  }

  async getRulesCount(): Promise<GetRulesCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getRulesCountWithOptions(runtime);
  }

  async getSecurityScoreRuleWithOptions(request: GetSecurityScoreRuleRequest, runtime: $Util.RuntimeOptions): Promise<GetSecurityScoreRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSecurityScoreRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSecurityScoreRuleResponse>(await this.callApi(params, req, runtime), new GetSecurityScoreRuleResponse({}));
  }

  async getSecurityScoreRule(request: GetSecurityScoreRuleRequest): Promise<GetSecurityScoreRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSecurityScoreRuleWithOptions(request, runtime);
  }

  async getSensitiveDefineRuleConfigWithOptions(request: GetSensitiveDefineRuleConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetSensitiveDefineRuleConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSensitiveDefineRuleConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSensitiveDefineRuleConfigResponse>(await this.callApi(params, req, runtime), new GetSensitiveDefineRuleConfigResponse({}));
  }

  async getSensitiveDefineRuleConfig(request: GetSensitiveDefineRuleConfigRequest): Promise<GetSensitiveDefineRuleConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSensitiveDefineRuleConfigWithOptions(request, runtime);
  }

  async getServiceTrailWithOptions(request: GetServiceTrailRequest, runtime: $Util.RuntimeOptions): Promise<GetServiceTrailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetServiceTrail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetServiceTrailResponse>(await this.callApi(params, req, runtime), new GetServiceTrailResponse({}));
  }

  async getServiceTrail(request: GetServiceTrailRequest): Promise<GetServiceTrailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getServiceTrailWithOptions(request, runtime);
  }

  async getStrategyTemplateDetailWithOptions(request: GetStrategyTemplateDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetStrategyTemplateDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetStrategyTemplateDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetStrategyTemplateDetailResponse>(await this.callApi(params, req, runtime), new GetStrategyTemplateDetailResponse({}));
  }

  async getStrategyTemplateDetail(request: GetStrategyTemplateDetailRequest): Promise<GetStrategyTemplateDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getStrategyTemplateDetailWithOptions(request, runtime);
  }

  async getSuspiciousStatisticsWithOptions(request: GetSuspiciousStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<GetSuspiciousStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupIdList)) {
      query["GroupIdList"] = request.groupIdList;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSuspiciousStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSuspiciousStatisticsResponse>(await this.callApi(params, req, runtime), new GetSuspiciousStatisticsResponse({}));
  }

  async getSuspiciousStatistics(request: GetSuspiciousStatisticsRequest): Promise<GetSuspiciousStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSuspiciousStatisticsWithOptions(request, runtime);
  }

  async getSwitchRegionDetailWithOptions(request: GetSwitchRegionDetailRequest, runtime: $Util.RuntimeOptions): Promise<GetSwitchRegionDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetSwitchRegionDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetSwitchRegionDetailResponse>(await this.callApi(params, req, runtime), new GetSwitchRegionDetailResponse({}));
  }

  async getSwitchRegionDetail(request: GetSwitchRegionDetailRequest): Promise<GetSwitchRegionDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getSwitchRegionDetailWithOptions(request, runtime);
  }

  async getUserLangWithOptions(runtime: $Util.RuntimeOptions): Promise<GetUserLangResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetUserLang",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetUserLangResponse>(await this.callApi(params, req, runtime), new GetUserLangResponse({}));
  }

  async getUserLang(): Promise<GetUserLangResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getUserLangWithOptions(runtime);
  }

  async getVirusScanConfigWithOptions(request: GetVirusScanConfigRequest, runtime: $Util.RuntimeOptions): Promise<GetVirusScanConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetVirusScanConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetVirusScanConfigResponse>(await this.callApi(params, req, runtime), new GetVirusScanConfigResponse({}));
  }

  async getVirusScanConfig(request: GetVirusScanConfigRequest): Promise<GetVirusScanConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getVirusScanConfigWithOptions(request, runtime);
  }

  async getVirusScanLatestTaskStatisticWithOptions(runtime: $Util.RuntimeOptions): Promise<GetVirusScanLatestTaskStatisticResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetVirusScanLatestTaskStatistic",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetVirusScanLatestTaskStatisticResponse>(await this.callApi(params, req, runtime), new GetVirusScanLatestTaskStatisticResponse({}));
  }

  async getVirusScanLatestTaskStatistic(): Promise<GetVirusScanLatestTaskStatisticResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getVirusScanLatestTaskStatisticWithOptions(runtime);
  }

  async getVulStatisticsWithOptions(request: GetVulStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<GetVulStatisticsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupIdList)) {
      query["GroupIdList"] = request.groupIdList;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.typeList)) {
      query["TypeList"] = request.typeList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetVulStatistics",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetVulStatisticsResponse>(await this.callApi(params, req, runtime), new GetVulStatisticsResponse({}));
  }

  async getVulStatistics(request: GetVulStatisticsRequest): Promise<GetVulStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getVulStatisticsWithOptions(request, runtime);
  }

  async getVulWhitelistWithOptions(request: GetVulWhitelistRequest, runtime: $Util.RuntimeOptions): Promise<GetVulWhitelistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.vulWhitelistId)) {
      query["VulWhitelistId"] = request.vulWhitelistId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "GetVulWhitelist",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetVulWhitelistResponse>(await this.callApi(params, req, runtime), new GetVulWhitelistResponse({}));
  }

  async getVulWhitelist(request: GetVulWhitelistRequest): Promise<GetVulWhitelistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getVulWhitelistWithOptions(request, runtime);
  }

  async handleSecurityEventsWithOptions(request: HandleSecurityEventsRequest, runtime: $Util.RuntimeOptions): Promise<HandleSecurityEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.markBatch)) {
      query["MarkBatch"] = request.markBatch;
    }

    if (!Util.isUnset(request.markMissParam)) {
      query["MarkMissParam"] = request.markMissParam;
    }

    if (!Util.isUnset(request.operationCode)) {
      query["OperationCode"] = request.operationCode;
    }

    if (!Util.isUnset(request.operationParams)) {
      query["OperationParams"] = request.operationParams;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.securityEventIds)) {
      query["SecurityEventIds"] = request.securityEventIds;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "HandleSecurityEvents",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<HandleSecurityEventsResponse>(await this.callApi(params, req, runtime), new HandleSecurityEventsResponse({}));
  }

  async handleSecurityEvents(request: HandleSecurityEventsRequest): Promise<HandleSecurityEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.handleSecurityEventsWithOptions(request, runtime);
  }

  async handleSimilarSecurityEventsWithOptions(request: HandleSimilarSecurityEventsRequest, runtime: $Util.RuntimeOptions): Promise<HandleSimilarSecurityEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.markMissParam)) {
      query["MarkMissParam"] = request.markMissParam;
    }

    if (!Util.isUnset(request.operationCode)) {
      query["OperationCode"] = request.operationCode;
    }

    if (!Util.isUnset(request.operationParams)) {
      query["OperationParams"] = request.operationParams;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "HandleSimilarSecurityEvents",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<HandleSimilarSecurityEventsResponse>(await this.callApi(params, req, runtime), new HandleSimilarSecurityEventsResponse({}));
  }

  async handleSimilarSecurityEvents(request: HandleSimilarSecurityEventsRequest): Promise<HandleSimilarSecurityEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.handleSimilarSecurityEventsWithOptions(request, runtime);
  }

  async ignoreCheckItemsWithOptions(request: IgnoreCheckItemsRequest, runtime: $Util.RuntimeOptions): Promise<IgnoreCheckItemsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkAndRiskTypeList)) {
      query["CheckAndRiskTypeList"] = request.checkAndRiskTypeList;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.reason)) {
      query["Reason"] = request.reason;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "IgnoreCheckItems",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<IgnoreCheckItemsResponse>(await this.callApi(params, req, runtime), new IgnoreCheckItemsResponse({}));
  }

  async ignoreCheckItems(request: IgnoreCheckItemsRequest): Promise<IgnoreCheckItemsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.ignoreCheckItemsWithOptions(request, runtime);
  }

  async ignoreHcCheckWarningsWithOptions(request: IgnoreHcCheckWarningsRequest, runtime: $Util.RuntimeOptions): Promise<IgnoreHcCheckWarningsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkIds)) {
      query["CheckIds"] = request.checkIds;
    }

    if (!Util.isUnset(request.checkWarningIds)) {
      query["CheckWarningIds"] = request.checkWarningIds;
    }

    if (!Util.isUnset(request.reason)) {
      query["Reason"] = request.reason;
    }

    if (!Util.isUnset(request.riskId)) {
      query["RiskId"] = request.riskId;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "IgnoreHcCheckWarnings",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<IgnoreHcCheckWarningsResponse>(await this.callApi(params, req, runtime), new IgnoreHcCheckWarningsResponse({}));
  }

  async ignoreHcCheckWarnings(request: IgnoreHcCheckWarningsRequest): Promise<IgnoreHcCheckWarningsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.ignoreHcCheckWarningsWithOptions(request, runtime);
  }

  async installBackupClientWithOptions(request: InstallBackupClientRequest, runtime: $Util.RuntimeOptions): Promise<InstallBackupClientResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyVersion)) {
      query["PolicyVersion"] = request.policyVersion;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InstallBackupClient",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InstallBackupClientResponse>(await this.callApi(params, req, runtime), new InstallBackupClientResponse({}));
  }

  async installBackupClient(request: InstallBackupClientRequest): Promise<InstallBackupClientResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installBackupClientWithOptions(request, runtime);
  }

  /**
    * > Before you call this operation, make sure that the Security Center agent on your servers is online and the servers can access Alibaba Cloud services.
    *
    * @param request InstallCloudMonitorRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return InstallCloudMonitorResponse
   */
  async installCloudMonitorWithOptions(request: InstallCloudMonitorRequest, runtime: $Util.RuntimeOptions): Promise<InstallCloudMonitorResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.agentAccessKey)) {
      query["AgentAccessKey"] = request.agentAccessKey;
    }

    if (!Util.isUnset(request.agentSecretKey)) {
      query["AgentSecretKey"] = request.agentSecretKey;
    }

    if (!Util.isUnset(request.argusVersion)) {
      query["ArgusVersion"] = request.argusVersion;
    }

    if (!Util.isUnset(request.instanceIdList)) {
      query["InstanceIdList"] = request.instanceIdList;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InstallCloudMonitor",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InstallCloudMonitorResponse>(await this.callApi(params, req, runtime), new InstallCloudMonitorResponse({}));
  }

  /**
    * > Before you call this operation, make sure that the Security Center agent on your servers is online and the servers can access Alibaba Cloud services.
    *
    * @param request InstallCloudMonitorRequest
    * @return InstallCloudMonitorResponse
   */
  async installCloudMonitor(request: InstallCloudMonitorRequest): Promise<InstallCloudMonitorResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installCloudMonitorWithOptions(request, runtime);
  }

  async installPmAgentWithOptions(request: InstallPmAgentRequest, runtime: $Util.RuntimeOptions): Promise<InstallPmAgentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InstallPmAgent",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InstallPmAgentResponse>(await this.callApi(params, req, runtime), new InstallPmAgentResponse({}));
  }

  async installPmAgent(request: InstallPmAgentRequest): Promise<InstallPmAgentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installPmAgentWithOptions(request, runtime);
  }

  async installRaspAttachWithOptions(request: InstallRaspAttachRequest, runtime: $Util.RuntimeOptions): Promise<InstallRaspAttachResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationId)) {
      query["ApplicationId"] = request.applicationId;
    }

    if (!Util.isUnset(request.ecsUUIDList)) {
      query["EcsUUIDList"] = request.ecsUUIDList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InstallRaspAttach",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InstallRaspAttachResponse>(await this.callApi(params, req, runtime), new InstallRaspAttachResponse({}));
  }

  async installRaspAttach(request: InstallRaspAttachRequest): Promise<InstallRaspAttachResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installRaspAttachWithOptions(request, runtime);
  }

  async installUniBackupAgentWithOptions(request: InstallUniBackupAgentRequest, runtime: $Util.RuntimeOptions): Promise<InstallUniBackupAgentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "InstallUniBackupAgent",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InstallUniBackupAgentResponse>(await this.callApi(params, req, runtime), new InstallUniBackupAgentResponse({}));
  }

  async installUniBackupAgent(request: InstallUniBackupAgentRequest): Promise<InstallUniBackupAgentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installUniBackupAgentWithOptions(request, runtime);
  }

  async joinWebLockProcessWhiteListWithOptions(request: JoinWebLockProcessWhiteListRequest, runtime: $Util.RuntimeOptions): Promise<JoinWebLockProcessWhiteListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.processPaths)) {
      query["ProcessPaths"] = request.processPaths;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "JoinWebLockProcessWhiteList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<JoinWebLockProcessWhiteListResponse>(await this.callApi(params, req, runtime), new JoinWebLockProcessWhiteListResponse({}));
  }

  async joinWebLockProcessWhiteList(request: JoinWebLockProcessWhiteListRequest): Promise<JoinWebLockProcessWhiteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.joinWebLockProcessWhiteListWithOptions(request, runtime);
  }

  async listAgentlessMaliciousFilesWithOptions(request: ListAgentlessMaliciousFilesRequest, runtime: $Util.RuntimeOptions): Promise<ListAgentlessMaliciousFilesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.dealed)) {
      query["Dealed"] = request.dealed;
    }

    if (!Util.isUnset(request.eventId)) {
      query["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.fuzzyMaliciousName)) {
      query["FuzzyMaliciousName"] = request.fuzzyMaliciousName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.levels)) {
      query["Levels"] = request.levels;
    }

    if (!Util.isUnset(request.maliciousMd5)) {
      query["MaliciousMd5"] = request.maliciousMd5;
    }

    if (!Util.isUnset(request.maliciousType)) {
      query["MaliciousType"] = request.maliciousType;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAgentlessMaliciousFiles",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAgentlessMaliciousFilesResponse>(await this.callApi(params, req, runtime), new ListAgentlessMaliciousFilesResponse({}));
  }

  async listAgentlessMaliciousFiles(request: ListAgentlessMaliciousFilesRequest): Promise<ListAgentlessMaliciousFilesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAgentlessMaliciousFilesWithOptions(request, runtime);
  }

  async listAgentlessRegionWithOptions(runtime: $Util.RuntimeOptions): Promise<ListAgentlessRegionResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "ListAgentlessRegion",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAgentlessRegionResponse>(await this.callApi(params, req, runtime), new ListAgentlessRegionResponse({}));
  }

  async listAgentlessRegion(): Promise<ListAgentlessRegionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAgentlessRegionWithOptions(runtime);
  }

  async listAgentlessRelateMaliciousWithOptions(request: ListAgentlessRelateMaliciousRequest, runtime: $Util.RuntimeOptions): Promise<ListAgentlessRelateMaliciousResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.eventId)) {
      query["EventId"] = request.eventId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAgentlessRelateMalicious",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAgentlessRelateMaliciousResponse>(await this.callApi(params, req, runtime), new ListAgentlessRelateMaliciousResponse({}));
  }

  async listAgentlessRelateMalicious(request: ListAgentlessRelateMaliciousRequest): Promise<ListAgentlessRelateMaliciousResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAgentlessRelateMaliciousWithOptions(request, runtime);
  }

  async listAgentlessRiskUuidWithOptions(request: ListAgentlessRiskUuidRequest, runtime: $Util.RuntimeOptions): Promise<ListAgentlessRiskUuidResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.internetIp)) {
      query["InternetIp"] = request.internetIp;
    }

    if (!Util.isUnset(request.intranetIp)) {
      query["IntranetIp"] = request.intranetIp;
    }

    if (!Util.isUnset(request.machineName)) {
      query["MachineName"] = request.machineName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.risk)) {
      query["Risk"] = request.risk;
    }

    if (!Util.isUnset(request.targetName)) {
      query["TargetName"] = request.targetName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAgentlessRiskUuid",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAgentlessRiskUuidResponse>(await this.callApi(params, req, runtime), new ListAgentlessRiskUuidResponse({}));
  }

  async listAgentlessRiskUuid(request: ListAgentlessRiskUuidRequest): Promise<ListAgentlessRiskUuidResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAgentlessRiskUuidWithOptions(request, runtime);
  }

  async listAgentlessTaskWithOptions(request: ListAgentlessTaskRequest, runtime: $Util.RuntimeOptions): Promise<ListAgentlessTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.internetIp)) {
      query["InternetIp"] = request.internetIp;
    }

    if (!Util.isUnset(request.intranetIp)) {
      query["IntranetIp"] = request.intranetIp;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.machineName)) {
      query["MachineName"] = request.machineName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.rootTask)) {
      query["RootTask"] = request.rootTask;
    }

    if (!Util.isUnset(request.rootTaskId)) {
      query["RootTaskId"] = request.rootTaskId;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.targetName)) {
      query["TargetName"] = request.targetName;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAgentlessTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAgentlessTaskResponse>(await this.callApi(params, req, runtime), new ListAgentlessTaskResponse({}));
  }

  async listAgentlessTask(request: ListAgentlessTaskRequest): Promise<ListAgentlessTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAgentlessTaskWithOptions(request, runtime);
  }

  async listAssetCleanConfigWithOptions(runtime: $Util.RuntimeOptions): Promise<ListAssetCleanConfigResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "ListAssetCleanConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAssetCleanConfigResponse>(await this.callApi(params, req, runtime), new ListAssetCleanConfigResponse({}));
  }

  async listAssetCleanConfig(): Promise<ListAssetCleanConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAssetCleanConfigWithOptions(runtime);
  }

  async listAssetRefreshTaskConfigWithOptions(request: ListAssetRefreshTaskConfigRequest, runtime: $Util.RuntimeOptions): Promise<ListAssetRefreshTaskConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.refreshConfigType)) {
      query["RefreshConfigType"] = request.refreshConfigType;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.targetId)) {
      query["TargetId"] = request.targetId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAssetRefreshTaskConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAssetRefreshTaskConfigResponse>(await this.callApi(params, req, runtime), new ListAssetRefreshTaskConfigResponse({}));
  }

  async listAssetRefreshTaskConfig(request: ListAssetRefreshTaskConfigRequest): Promise<ListAssetRefreshTaskConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAssetRefreshTaskConfigWithOptions(request, runtime);
  }

  async listAssetSelectionSelectedTargetWithOptions(request: ListAssetSelectionSelectedTargetRequest, runtime: $Util.RuntimeOptions): Promise<ListAssetSelectionSelectedTargetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.selectionKey)) {
      query["SelectionKey"] = request.selectionKey;
    }

    if (!Util.isUnset(request.targetList)) {
      query["TargetList"] = request.targetList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAssetSelectionSelectedTarget",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAssetSelectionSelectedTargetResponse>(await this.callApi(params, req, runtime), new ListAssetSelectionSelectedTargetResponse({}));
  }

  async listAssetSelectionSelectedTarget(request: ListAssetSelectionSelectedTargetRequest): Promise<ListAssetSelectionSelectedTargetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAssetSelectionSelectedTargetWithOptions(request, runtime);
  }

  async listAssetSelectionTargetWithOptions(request: ListAssetSelectionTargetRequest, runtime: $Util.RuntimeOptions): Promise<ListAssetSelectionTargetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.selectionKey)) {
      query["SelectionKey"] = request.selectionKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAssetSelectionTarget",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAssetSelectionTargetResponse>(await this.callApi(params, req, runtime), new ListAssetSelectionTargetResponse({}));
  }

  async listAssetSelectionTarget(request: ListAssetSelectionTargetRequest): Promise<ListAssetSelectionTargetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAssetSelectionTargetWithOptions(request, runtime);
  }

  async listAvailableHoneypotWithOptions(request: ListAvailableHoneypotRequest, runtime: $Util.RuntimeOptions): Promise<ListAvailableHoneypotResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListAvailableHoneypot",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListAvailableHoneypotResponse>(await this.callApi(params, req, runtime), new ListAvailableHoneypotResponse({}));
  }

  async listAvailableHoneypot(request: ListAvailableHoneypotRequest): Promise<ListAvailableHoneypotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listAvailableHoneypotWithOptions(request, runtime);
  }

  async listCheckInstanceResultWithOptions(request: ListCheckInstanceResultRequest, runtime: $Util.RuntimeOptions): Promise<ListCheckInstanceResultResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkId)) {
      query["CheckId"] = request.checkId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.instanceIdKey)) {
      query["InstanceIdKey"] = request.instanceIdKey;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.instanceNameKey)) {
      query["InstanceNameKey"] = request.instanceNameKey;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionIdKey)) {
      query["RegionIdKey"] = request.regionIdKey;
    }

    if (!Util.isUnset(request.sortTypes)) {
      query["SortTypes"] = request.sortTypes;
    }

    if (!Util.isUnset(request.statuses)) {
      query["Statuses"] = request.statuses;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCheckInstanceResult",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCheckInstanceResultResponse>(await this.callApi(params, req, runtime), new ListCheckInstanceResultResponse({}));
  }

  async listCheckInstanceResult(request: ListCheckInstanceResultRequest): Promise<ListCheckInstanceResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCheckInstanceResultWithOptions(request, runtime);
  }

  async listCheckItemWithOptions(request: ListCheckItemRequest, runtime: $Util.RuntimeOptions): Promise<ListCheckItemResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCheckItem",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCheckItemResponse>(await this.callApi(params, req, runtime), new ListCheckItemResponse({}));
  }

  async listCheckItem(request: ListCheckItemRequest): Promise<ListCheckItemResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCheckItemWithOptions(request, runtime);
  }

  async listCheckItemWarningMachineWithOptions(request: ListCheckItemWarningMachineRequest, runtime: $Util.RuntimeOptions): Promise<ListCheckItemWarningMachineResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkId)) {
      query["CheckId"] = request.checkId;
    }

    if (!Util.isUnset(request.containerFieldName)) {
      query["ContainerFieldName"] = request.containerFieldName;
    }

    if (!Util.isUnset(request.containerFieldValue)) {
      query["ContainerFieldValue"] = request.containerFieldValue;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.riskType)) {
      query["RiskType"] = request.riskType;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCheckItemWarningMachine",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCheckItemWarningMachineResponse>(await this.callApi(params, req, runtime), new ListCheckItemWarningMachineResponse({}));
  }

  async listCheckItemWarningMachine(request: ListCheckItemWarningMachineRequest): Promise<ListCheckItemWarningMachineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCheckItemWarningMachineWithOptions(request, runtime);
  }

  async listCheckItemWarningSummaryWithOptions(request: ListCheckItemWarningSummaryRequest, runtime: $Util.RuntimeOptions): Promise<ListCheckItemWarningSummaryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkItemFuzzy)) {
      query["CheckItemFuzzy"] = request.checkItemFuzzy;
    }

    if (!Util.isUnset(request.checkLevel)) {
      query["CheckLevel"] = request.checkLevel;
    }

    if (!Util.isUnset(request.checkType)) {
      query["CheckType"] = request.checkType;
    }

    if (!Util.isUnset(request.checkWarningStatus)) {
      query["CheckWarningStatus"] = request.checkWarningStatus;
    }

    if (!Util.isUnset(request.containerFieldName)) {
      query["ContainerFieldName"] = request.containerFieldName;
    }

    if (!Util.isUnset(request.containerFieldValue)) {
      query["ContainerFieldValue"] = request.containerFieldValue;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.riskType)) {
      query["RiskType"] = request.riskType;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCheckItemWarningSummary",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCheckItemWarningSummaryResponse>(await this.callApi(params, req, runtime), new ListCheckItemWarningSummaryResponse({}));
  }

  async listCheckItemWarningSummary(request: ListCheckItemWarningSummaryRequest): Promise<ListCheckItemWarningSummaryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCheckItemWarningSummaryWithOptions(request, runtime);
  }

  async listCheckResultWithOptions(request: ListCheckResultRequest, runtime: $Util.RuntimeOptions): Promise<ListCheckResultResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkKey)) {
      query["CheckKey"] = request.checkKey;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.customParam)) {
      query["CustomParam"] = request.customParam;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.instanceTypes)) {
      query["InstanceTypes"] = request.instanceTypes;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requirementIds)) {
      query["RequirementIds"] = request.requirementIds;
    }

    if (!Util.isUnset(request.riskLevels)) {
      query["RiskLevels"] = request.riskLevels;
    }

    if (!Util.isUnset(request.sortTypes)) {
      query["SortTypes"] = request.sortTypes;
    }

    if (!Util.isUnset(request.standardIds)) {
      query["StandardIds"] = request.standardIds;
    }

    if (!Util.isUnset(request.statuses)) {
      query["Statuses"] = request.statuses;
    }

    if (!Util.isUnset(request.types)) {
      query["Types"] = request.types;
    }

    if (!Util.isUnset(request.vendors)) {
      query["Vendors"] = request.vendors;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCheckResult",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCheckResultResponse>(await this.callApi(params, req, runtime), new ListCheckResultResponse({}));
  }

  async listCheckResult(request: ListCheckResultRequest): Promise<ListCheckResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCheckResultWithOptions(request, runtime);
  }

  async listCheckStandardWithOptions(request: ListCheckStandardRequest, runtime: $Util.RuntimeOptions): Promise<ListCheckStandardResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.instanceSubTypes)) {
      query["InstanceSubTypes"] = request.instanceSubTypes;
    }

    if (!Util.isUnset(request.instanceTypes)) {
      query["InstanceTypes"] = request.instanceTypes;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.vendors)) {
      query["Vendors"] = request.vendors;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCheckStandard",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCheckStandardResponse>(await this.callApi(params, req, runtime), new ListCheckStandardResponse({}));
  }

  async listCheckStandard(request: ListCheckStandardRequest): Promise<ListCheckStandardResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCheckStandardWithOptions(request, runtime);
  }

  async listClientAlertModeWithOptions(request: ListClientAlertModeRequest, runtime: $Util.RuntimeOptions): Promise<ListClientAlertModeResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClientAlertMode",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClientAlertModeResponse>(await this.callApi(params, req, runtime), new ListClientAlertModeResponse({}));
  }

  async listClientAlertMode(request: ListClientAlertModeRequest): Promise<ListClientAlertModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClientAlertModeWithOptions(request, runtime);
  }

  async listClientUserDefineRuleTypesWithOptions(runtime: $Util.RuntimeOptions): Promise<ListClientUserDefineRuleTypesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "ListClientUserDefineRuleTypes",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClientUserDefineRuleTypesResponse>(await this.callApi(params, req, runtime), new ListClientUserDefineRuleTypesResponse({}));
  }

  async listClientUserDefineRuleTypes(): Promise<ListClientUserDefineRuleTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClientUserDefineRuleTypesWithOptions(runtime);
  }

  async listClientUserDefineRulesWithOptions(request: ListClientUserDefineRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListClientUserDefineRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClientUserDefineRules",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClientUserDefineRulesResponse>(await this.callApi(params, req, runtime), new ListClientUserDefineRulesResponse({}));
  }

  async listClientUserDefineRules(request: ListClientUserDefineRulesRequest): Promise<ListClientUserDefineRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClientUserDefineRulesWithOptions(request, runtime);
  }

  async listCloudAssetInstancesWithOptions(request: ListCloudAssetInstancesRequest, runtime: $Util.RuntimeOptions): Promise<ListCloudAssetInstancesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cloudAssetTypes)) {
      query["CloudAssetTypes"] = request.cloudAssetTypes;
    }

    if (!Util.isUnset(request.criteria)) {
      query["Criteria"] = request.criteria;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.logicalExp)) {
      query["LogicalExp"] = request.logicalExp;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCloudAssetInstances",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCloudAssetInstancesResponse>(await this.callApi(params, req, runtime), new ListCloudAssetInstancesResponse({}));
  }

  async listCloudAssetInstances(request: ListCloudAssetInstancesRequest): Promise<ListCloudAssetInstancesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCloudAssetInstancesWithOptions(request, runtime);
  }

  async listCloudVendorRegionsWithOptions(request: ListCloudVendorRegionsRequest, runtime: $Util.RuntimeOptions): Promise<ListCloudVendorRegionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.vendor)) {
      query["Vendor"] = request.vendor;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCloudVendorRegions",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCloudVendorRegionsResponse>(await this.callApi(params, req, runtime), new ListCloudVendorRegionsResponse({}));
  }

  async listCloudVendorRegions(request: ListCloudVendorRegionsRequest): Promise<ListCloudVendorRegionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCloudVendorRegionsWithOptions(request, runtime);
  }

  async listClusterCnnfStatusDetailWithOptions(request: ListClusterCnnfStatusDetailRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterCnnfStatusDetailResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterIds)) {
      query["ClusterIds"] = request.clusterIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterCnnfStatusDetail",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClusterCnnfStatusDetailResponse>(await this.callApi(params, req, runtime), new ListClusterCnnfStatusDetailResponse({}));
  }

  async listClusterCnnfStatusDetail(request: ListClusterCnnfStatusDetailRequest): Promise<ListClusterCnnfStatusDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterCnnfStatusDetailWithOptions(request, runtime);
  }

  async listClusterInterceptionConfigWithOptions(request: ListClusterInterceptionConfigRequest, runtime: $Util.RuntimeOptions): Promise<ListClusterInterceptionConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterCNNFStatus)) {
      query["ClusterCNNFStatus"] = request.clusterCNNFStatus;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.clusterName)) {
      query["ClusterName"] = request.clusterName;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListClusterInterceptionConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListClusterInterceptionConfigResponse>(await this.callApi(params, req, runtime), new ListClusterInterceptionConfigResponse({}));
  }

  async listClusterInterceptionConfig(request: ListClusterInterceptionConfigRequest): Promise<ListClusterInterceptionConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listClusterInterceptionConfigWithOptions(request, runtime);
  }

  async listContainerDefenseRuleWithOptions(request: ListContainerDefenseRuleRequest, runtime: $Util.RuntimeOptions): Promise<ListContainerDefenseRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.conditions)) {
      query["Conditions"] = request.conditions;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.isDefaultRule)) {
      query["IsDefaultRule"] = request.isDefaultRule;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleType)) {
      query["RuleType"] = request.ruleType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListContainerDefenseRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListContainerDefenseRuleResponse>(await this.callApi(params, req, runtime), new ListContainerDefenseRuleResponse({}));
  }

  async listContainerDefenseRule(request: ListContainerDefenseRuleRequest): Promise<ListContainerDefenseRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listContainerDefenseRuleWithOptions(request, runtime);
  }

  async listCriteriaStrategyWithOptions(request: ListCriteriaStrategyRequest, runtime: $Util.RuntimeOptions): Promise<ListCriteriaStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.imageName)) {
      query["ImageName"] = request.imageName;
    }

    if (!Util.isUnset(request.label)) {
      query["Label"] = request.label;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.strategyName)) {
      query["StrategyName"] = request.strategyName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListCriteriaStrategy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListCriteriaStrategyResponse>(await this.callApi(params, req, runtime), new ListCriteriaStrategyResponse({}));
  }

  async listCriteriaStrategy(request: ListCriteriaStrategyRequest): Promise<ListCriteriaStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listCriteriaStrategyWithOptions(request, runtime);
  }

  async listFileProtectEventWithOptions(request: ListFileProtectEventRequest, runtime: $Util.RuntimeOptions): Promise<ListFileProtectEventResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertLevels)) {
      query["AlertLevels"] = request.alertLevels;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListFileProtectEvent",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListFileProtectEventResponse>(await this.callApi(params, req, runtime), new ListFileProtectEventResponse({}));
  }

  async listFileProtectEvent(request: ListFileProtectEventRequest): Promise<ListFileProtectEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFileProtectEventWithOptions(request, runtime);
  }

  async listFileProtectPluginStatusWithOptions(request: ListFileProtectPluginStatusRequest, runtime: $Util.RuntimeOptions): Promise<ListFileProtectPluginStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.switchId)) {
      query["SwitchId"] = request.switchId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListFileProtectPluginStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListFileProtectPluginStatusResponse>(await this.callApi(params, req, runtime), new ListFileProtectPluginStatusResponse({}));
  }

  async listFileProtectPluginStatus(request: ListFileProtectPluginStatusRequest): Promise<ListFileProtectPluginStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFileProtectPluginStatusWithOptions(request, runtime);
  }

  async listFileProtectRuleWithOptions(request: ListFileProtectRuleRequest, runtime: $Util.RuntimeOptions): Promise<ListFileProtectRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertLevel)) {
      query["AlertLevel"] = request.alertLevel;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleAction)) {
      query["RuleAction"] = request.ruleAction;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListFileProtectRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListFileProtectRuleResponse>(await this.callApi(params, req, runtime), new ListFileProtectRuleResponse({}));
  }

  async listFileProtectRule(request: ListFileProtectRuleRequest): Promise<ListFileProtectRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listFileProtectRuleWithOptions(request, runtime);
  }

  async listGroupsWithOptions(request: ListGroupsRequest, runtime: $Util.RuntimeOptions): Promise<ListGroupsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.useNextToken)) {
      query["UseNextToken"] = request.useNextToken;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListGroups",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListGroupsResponse>(await this.callApi(params, req, runtime), new ListGroupsResponse({}));
  }

  async listGroups(request: ListGroupsRequest): Promise<ListGroupsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listGroupsWithOptions(request, runtime);
  }

  async listHoneypotWithOptions(request: ListHoneypotRequest, runtime: $Util.RuntimeOptions): Promise<ListHoneypotResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.honeypotIds)) {
      query["HoneypotIds"] = request.honeypotIds;
    }

    if (!Util.isUnset(request.honeypotName)) {
      query["HoneypotName"] = request.honeypotName;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeName)) {
      query["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListHoneypot",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListHoneypotResponse>(await this.callApi(params, req, runtime), new ListHoneypotResponse({}));
  }

  async listHoneypot(request: ListHoneypotRequest): Promise<ListHoneypotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listHoneypotWithOptions(request, runtime);
  }

  async listHoneypotAlarmEventsWithOptions(request: ListHoneypotAlarmEventsRequest, runtime: $Util.RuntimeOptions): Promise<ListHoneypotAlarmEventsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListHoneypotAlarmEvents",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListHoneypotAlarmEventsResponse>(await this.callApi(params, req, runtime), new ListHoneypotAlarmEventsResponse({}));
  }

  async listHoneypotAlarmEvents(request: ListHoneypotAlarmEventsRequest): Promise<ListHoneypotAlarmEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listHoneypotAlarmEventsWithOptions(request, runtime);
  }

  async listHoneypotAttackerPortraitWithOptions(request: ListHoneypotAttackerPortraitRequest, runtime: $Util.RuntimeOptions): Promise<ListHoneypotAttackerPortraitResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTimeStamp)) {
      query["EndTimeStamp"] = request.endTimeStamp;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.srcIp)) {
      query["SrcIp"] = request.srcIp;
    }

    if (!Util.isUnset(request.startTimeStamp)) {
      query["StartTimeStamp"] = request.startTimeStamp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListHoneypotAttackerPortrait",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListHoneypotAttackerPortraitResponse>(await this.callApi(params, req, runtime), new ListHoneypotAttackerPortraitResponse({}));
  }

  async listHoneypotAttackerPortrait(request: ListHoneypotAttackerPortraitRequest): Promise<ListHoneypotAttackerPortraitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listHoneypotAttackerPortraitWithOptions(request, runtime);
  }

  async listHoneypotAttackerSourceWithOptions(request: ListHoneypotAttackerSourceRequest, runtime: $Util.RuntimeOptions): Promise<ListHoneypotAttackerSourceResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTimeStamp)) {
      query["EndTimeStamp"] = request.endTimeStamp;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.riskLevelList)) {
      query["RiskLevelList"] = request.riskLevelList;
    }

    if (!Util.isUnset(request.srcIp)) {
      query["SrcIp"] = request.srcIp;
    }

    if (!Util.isUnset(request.startTimeStamp)) {
      query["StartTimeStamp"] = request.startTimeStamp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListHoneypotAttackerSource",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListHoneypotAttackerSourceResponse>(await this.callApi(params, req, runtime), new ListHoneypotAttackerSourceResponse({}));
  }

  async listHoneypotAttackerSource(request: ListHoneypotAttackerSourceRequest): Promise<ListHoneypotAttackerSourceResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listHoneypotAttackerSourceWithOptions(request, runtime);
  }

  async listHoneypotEventsWithOptions(request: ListHoneypotEventsRequest, runtime: $Util.RuntimeOptions): Promise<ListHoneypotEventsResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListHoneypotEvents",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListHoneypotEventsResponse>(await this.callApi(params, req, runtime), new ListHoneypotEventsResponse({}));
  }

  async listHoneypotEvents(request: ListHoneypotEventsRequest): Promise<ListHoneypotEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listHoneypotEventsWithOptions(request, runtime);
  }

  async listHoneypotNodeWithOptions(request: ListHoneypotNodeRequest, runtime: $Util.RuntimeOptions): Promise<ListHoneypotNodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeName)) {
      query["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListHoneypotNode",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListHoneypotNodeResponse>(await this.callApi(params, req, runtime), new ListHoneypotNodeResponse({}));
  }

  async listHoneypotNode(request: ListHoneypotNodeRequest): Promise<ListHoneypotNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listHoneypotNodeWithOptions(request, runtime);
  }

  async listHoneypotPresetWithOptions(request: ListHoneypotPresetRequest, runtime: $Util.RuntimeOptions): Promise<ListHoneypotPresetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.honeypotImageName)) {
      query["HoneypotImageName"] = request.honeypotImageName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeName)) {
      query["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.presetName)) {
      query["PresetName"] = request.presetName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListHoneypotPreset",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListHoneypotPresetResponse>(await this.callApi(params, req, runtime), new ListHoneypotPresetResponse({}));
  }

  async listHoneypotPreset(request: ListHoneypotPresetRequest): Promise<ListHoneypotPresetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listHoneypotPresetWithOptions(request, runtime);
  }

  async listHoneypotProbeWithOptions(request: ListHoneypotProbeRequest, runtime: $Util.RuntimeOptions): Promise<ListHoneypotProbeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.displayName)) {
      query["DisplayName"] = request.displayName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.probeStatus)) {
      query["ProbeStatus"] = request.probeStatus;
    }

    if (!Util.isUnset(request.probeType)) {
      query["ProbeType"] = request.probeType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListHoneypotProbe",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListHoneypotProbeResponse>(await this.callApi(params, req, runtime), new ListHoneypotProbeResponse({}));
  }

  async listHoneypotProbe(request: ListHoneypotProbeRequest): Promise<ListHoneypotProbeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listHoneypotProbeWithOptions(request, runtime);
  }

  async listHoneypotProbeUuidWithOptions(request: ListHoneypotProbeUuidRequest, runtime: $Util.RuntimeOptions): Promise<ListHoneypotProbeUuidResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.controlNodeId)) {
      query["ControlNodeId"] = request.controlNodeId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.probeType)) {
      query["ProbeType"] = request.probeType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListHoneypotProbeUuid",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListHoneypotProbeUuidResponse>(await this.callApi(params, req, runtime), new ListHoneypotProbeUuidResponse({}));
  }

  async listHoneypotProbeUuid(request: ListHoneypotProbeUuidRequest): Promise<ListHoneypotProbeUuidResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listHoneypotProbeUuidWithOptions(request, runtime);
  }

  async listImageRegistryRegionWithOptions(runtime: $Util.RuntimeOptions): Promise<ListImageRegistryRegionResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "ListImageRegistryRegion",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListImageRegistryRegionResponse>(await this.callApi(params, req, runtime), new ListImageRegistryRegionResponse({}));
  }

  async listImageRegistryRegion(): Promise<ListImageRegistryRegionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listImageRegistryRegionWithOptions(runtime);
  }

  async listImageRiskWithOptions(request: ListImageRiskRequest, runtime: $Util.RuntimeOptions): Promise<ListImageRiskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.imageName)) {
      query["ImageName"] = request.imageName;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListImageRisk",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListImageRiskResponse>(await this.callApi(params, req, runtime), new ListImageRiskResponse({}));
  }

  async listImageRisk(request: ListImageRiskRequest): Promise<ListImageRiskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listImageRiskWithOptions(request, runtime);
  }

  async listInstanceCatalogWithOptions(request: ListInstanceCatalogRequest, runtime: $Util.RuntimeOptions): Promise<ListInstanceCatalogResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.regionId)) {
      query["RegionId"] = request.regionId;
    }

    if (!Util.isUnset(request.requirementIds)) {
      query["RequirementIds"] = request.requirementIds;
    }

    if (!Util.isUnset(request.standardIds)) {
      query["StandardIds"] = request.standardIds;
    }

    if (!Util.isUnset(request.types)) {
      query["Types"] = request.types;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInstanceCatalog",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstanceCatalogResponse>(await this.callApi(params, req, runtime), new ListInstanceCatalogResponse({}));
  }

  async listInstanceCatalog(request: ListInstanceCatalogRequest): Promise<ListInstanceCatalogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstanceCatalogWithOptions(request, runtime);
  }

  async listInstanceRiskLevelsWithOptions(request: ListInstanceRiskLevelsRequest, runtime: $Util.RuntimeOptions): Promise<ListInstanceRiskLevelsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceList)) {
      query["InstanceList"] = request.instanceList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInstanceRiskLevels",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstanceRiskLevelsResponse>(await this.callApi(params, req, runtime), new ListInstanceRiskLevelsResponse({}));
  }

  async listInstanceRiskLevels(request: ListInstanceRiskLevelsRequest): Promise<ListInstanceRiskLevelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstanceRiskLevelsWithOptions(request, runtime);
  }

  async listInstanceRiskNumWithOptions(request: ListInstanceRiskNumRequest, runtime: $Util.RuntimeOptions): Promise<ListInstanceRiskNumResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceList)) {
      query["InstanceList"] = request.instanceList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInstanceRiskNum",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInstanceRiskNumResponse>(await this.callApi(params, req, runtime), new ListInstanceRiskNumResponse({}));
  }

  async listInstanceRiskNum(request: ListInstanceRiskNumRequest): Promise<ListInstanceRiskNumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInstanceRiskNumWithOptions(request, runtime);
  }

  async listInterceptionHistoryWithOptions(request: ListInterceptionHistoryRequest, runtime: $Util.RuntimeOptions): Promise<ListInterceptionHistoryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.historyName)) {
      query["HistoryName"] = request.historyName;
    }

    if (!Util.isUnset(request.interceptionTypes)) {
      query["InterceptionTypes"] = request.interceptionTypes;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInterceptionHistory",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInterceptionHistoryResponse>(await this.callApi(params, req, runtime), new ListInterceptionHistoryResponse({}));
  }

  async listInterceptionHistory(request: ListInterceptionHistoryRequest): Promise<ListInterceptionHistoryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInterceptionHistoryWithOptions(request, runtime);
  }

  async listInterceptionRulePageWithOptions(request: ListInterceptionRulePageRequest, runtime: $Util.RuntimeOptions): Promise<ListInterceptionRulePageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.criteria)) {
      query["Criteria"] = request.criteria;
    }

    if (!Util.isUnset(request.criteriaType)) {
      query["CriteriaType"] = request.criteriaType;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInterceptionRulePage",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInterceptionRulePageResponse>(await this.callApi(params, req, runtime), new ListInterceptionRulePageResponse({}));
  }

  async listInterceptionRulePage(request: ListInterceptionRulePageRequest): Promise<ListInterceptionRulePageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInterceptionRulePageWithOptions(request, runtime);
  }

  async listInterceptionTargetPageWithOptions(request: ListInterceptionTargetPageRequest, runtime: $Util.RuntimeOptions): Promise<ListInterceptionTargetPageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.imageList)) {
      query["ImageList"] = request.imageList;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.tagList)) {
      query["TagList"] = request.tagList;
    }

    if (!Util.isUnset(request.targetName)) {
      query["TargetName"] = request.targetName;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListInterceptionTargetPage",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListInterceptionTargetPageResponse>(await this.callApi(params, req, runtime), new ListInterceptionTargetPageResponse({}));
  }

  async listInterceptionTargetPage(request: ListInterceptionTargetPageRequest): Promise<ListInterceptionTargetPageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listInterceptionTargetPageWithOptions(request, runtime);
  }

  async listObjectScanEventWithOptions(request: ListObjectScanEventRequest, runtime: $Util.RuntimeOptions): Promise<ListObjectScanEventResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bucketName)) {
      query["BucketName"] = request.bucketName;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.eventName)) {
      query["EventName"] = request.eventName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.md5)) {
      query["Md5"] = request.md5;
    }

    if (!Util.isUnset(request.ossKey)) {
      query["OssKey"] = request.ossKey;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.riskLevel)) {
      query["RiskLevel"] = request.riskLevel;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.timeEnd)) {
      query["TimeEnd"] = request.timeEnd;
    }

    if (!Util.isUnset(request.timeStart)) {
      query["TimeStart"] = request.timeStart;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListObjectScanEvent",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListObjectScanEventResponse>(await this.callApi(params, req, runtime), new ListObjectScanEventResponse({}));
  }

  async listObjectScanEvent(request: ListObjectScanEventRequest): Promise<ListObjectScanEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listObjectScanEventWithOptions(request, runtime);
  }

  async listOssBucketWithOptions(request: ListOssBucketRequest, runtime: $Util.RuntimeOptions): Promise<ListOssBucketResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bucketName)) {
      query["BucketName"] = request.bucketName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOssBucket",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOssBucketResponse>(await this.callApi(params, req, runtime), new ListOssBucketResponse({}));
  }

  async listOssBucket(request: ListOssBucketRequest): Promise<ListOssBucketResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOssBucketWithOptions(request, runtime);
  }

  async listOssBucketScanInfoWithOptions(request: ListOssBucketScanInfoRequest, runtime: $Util.RuntimeOptions): Promise<ListOssBucketScanInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bucketName)) {
      query["BucketName"] = request.bucketName;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.fuzzBucketName)) {
      query["FuzzBucketName"] = request.fuzzBucketName;
    }

    if (!Util.isUnset(request.hasRisk)) {
      query["HasRisk"] = request.hasRisk;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListOssBucketScanInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListOssBucketScanInfoResponse>(await this.callApi(params, req, runtime), new ListOssBucketScanInfoResponse({}));
  }

  async listOssBucketScanInfo(request: ListOssBucketScanInfoRequest): Promise<ListOssBucketScanInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listOssBucketScanInfoWithOptions(request, runtime);
  }

  async listPluginForUuidWithOptions(tmpReq: ListPluginForUuidRequest, runtime: $Util.RuntimeOptions): Promise<ListPluginForUuidResponse> {
    Util.validateModel(tmpReq);
    let request = new ListPluginForUuidShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.types)) {
      request.typesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.types, "Types", "simple");
    }

    let query = { };
    if (!Util.isUnset(request.typesShrink)) {
      query["Types"] = request.typesShrink;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPluginForUuid",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListPluginForUuidResponse>(await this.callApi(params, req, runtime), new ListPluginForUuidResponse({}));
  }

  async listPluginForUuid(request: ListPluginForUuidRequest): Promise<ListPluginForUuidResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPluginForUuidWithOptions(request, runtime);
  }

  async listPodRiskWithOptions(request: ListPodRiskRequest, runtime: $Util.RuntimeOptions): Promise<ListPodRiskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.podName)) {
      query["PodName"] = request.podName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPodRisk",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListPodRiskResponse>(await this.callApi(params, req, runtime), new ListPodRiskResponse({}));
  }

  async listPodRisk(request: ListPodRiskRequest): Promise<ListPodRiskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPodRiskWithOptions(request, runtime);
  }

  async listPrivateRegistryListWithOptions(request: ListPrivateRegistryListRequest, runtime: $Util.RuntimeOptions): Promise<ListPrivateRegistryListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.registryType)) {
      query["RegistryType"] = request.registryType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPrivateRegistryList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListPrivateRegistryListResponse>(await this.callApi(params, req, runtime), new ListPrivateRegistryListResponse({}));
  }

  async listPrivateRegistryList(request: ListPrivateRegistryListRequest): Promise<ListPrivateRegistryListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPrivateRegistryListWithOptions(request, runtime);
  }

  async listPrivateRegistryTypeWithOptions(request: ListPrivateRegistryTypeRequest, runtime: $Util.RuntimeOptions): Promise<ListPrivateRegistryTypeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListPrivateRegistryType",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListPrivateRegistryTypeResponse>(await this.callApi(params, req, runtime), new ListPrivateRegistryTypeResponse({}));
  }

  async listPrivateRegistryType(request: ListPrivateRegistryTypeRequest): Promise<ListPrivateRegistryTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listPrivateRegistryTypeWithOptions(request, runtime);
  }

  async listQueryRaspAppInfoWithOptions(request: ListQueryRaspAppInfoRequest, runtime: $Util.RuntimeOptions): Promise<ListQueryRaspAppInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListQueryRaspAppInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListQueryRaspAppInfoResponse>(await this.callApi(params, req, runtime), new ListQueryRaspAppInfoResponse({}));
  }

  async listQueryRaspAppInfo(request: ListQueryRaspAppInfoRequest): Promise<ListQueryRaspAppInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listQueryRaspAppInfoWithOptions(request, runtime);
  }

  async listRuleTargetAllWithOptions(request: ListRuleTargetAllRequest, runtime: $Util.RuntimeOptions): Promise<ListRuleTargetAllResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListRuleTargetAll",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListRuleTargetAllResponse>(await this.callApi(params, req, runtime), new ListRuleTargetAllResponse({}));
  }

  async listRuleTargetAll(request: ListRuleTargetAllRequest): Promise<ListRuleTargetAllResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listRuleTargetAllWithOptions(request, runtime);
  }

  async listSupportObjectSuffixWithOptions(runtime: $Util.RuntimeOptions): Promise<ListSupportObjectSuffixResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "ListSupportObjectSuffix",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSupportObjectSuffixResponse>(await this.callApi(params, req, runtime), new ListSupportObjectSuffixResponse({}));
  }

  async listSupportObjectSuffix(): Promise<ListSupportObjectSuffixResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSupportObjectSuffixWithOptions(runtime);
  }

  async listSystemAggregationRulesWithOptions(request: ListSystemAggregationRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListSystemAggregationRulesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSystemAggregationRules",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSystemAggregationRulesResponse>(await this.callApi(params, req, runtime), new ListSystemAggregationRulesResponse({}));
  }

  async listSystemAggregationRules(request: ListSystemAggregationRulesRequest): Promise<ListSystemAggregationRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSystemAggregationRulesWithOptions(request, runtime);
  }

  async listSystemClientRuleTypesWithOptions(runtime: $Util.RuntimeOptions): Promise<ListSystemClientRuleTypesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "ListSystemClientRuleTypes",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSystemClientRuleTypesResponse>(await this.callApi(params, req, runtime), new ListSystemClientRuleTypesResponse({}));
  }

  async listSystemClientRuleTypes(): Promise<ListSystemClientRuleTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSystemClientRuleTypesWithOptions(runtime);
  }

  async listSystemClientRulesWithOptions(request: ListSystemClientRulesRequest, runtime: $Util.RuntimeOptions): Promise<ListSystemClientRulesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aggregationIds)) {
      query["AggregationIds"] = request.aggregationIds;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.isContainer)) {
      query["IsContainer"] = request.isContainer;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleTypes)) {
      query["RuleTypes"] = request.ruleTypes;
    }

    if (!Util.isUnset(request.systemType)) {
      query["SystemType"] = request.systemType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSystemClientRules",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSystemClientRulesResponse>(await this.callApi(params, req, runtime), new ListSystemClientRulesResponse({}));
  }

  async listSystemClientRules(request: ListSystemClientRulesRequest): Promise<ListSystemClientRulesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSystemClientRulesWithOptions(request, runtime);
  }

  async listSystemRuleAggregationTypesWithOptions(request: ListSystemRuleAggregationTypesRequest, runtime: $Util.RuntimeOptions): Promise<ListSystemRuleAggregationTypesResponse> {
    Util.validateModel(request);
    let query = OpenApiUtil.query(Util.toMap(request));
    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListSystemRuleAggregationTypes",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "GET",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListSystemRuleAggregationTypesResponse>(await this.callApi(params, req, runtime), new ListSystemRuleAggregationTypesResponse({}));
  }

  async listSystemRuleAggregationTypes(request: ListSystemRuleAggregationTypesRequest): Promise<ListSystemRuleAggregationTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listSystemRuleAggregationTypesWithOptions(request, runtime);
  }

  async listUninstallAegisMachinesWithOptions(request: ListUninstallAegisMachinesRequest, runtime: $Util.RuntimeOptions): Promise<ListUninstallAegisMachinesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.os)) {
      query["Os"] = request.os;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.regionIdStr)) {
      query["RegionIdStr"] = request.regionIdStr;
    }

    if (!Util.isUnset(request.regionNo)) {
      query["RegionNo"] = request.regionNo;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.vendor)) {
      query["Vendor"] = request.vendor;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUninstallAegisMachines",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListUninstallAegisMachinesResponse>(await this.callApi(params, req, runtime), new ListUninstallAegisMachinesResponse({}));
  }

  async listUninstallAegisMachines(request: ListUninstallAegisMachinesRequest): Promise<ListUninstallAegisMachinesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listUninstallAegisMachinesWithOptions(request, runtime);
  }

  async listUuidsByWebPathWithOptions(request: ListUuidsByWebPathRequest, runtime: $Util.RuntimeOptions): Promise<ListUuidsByWebPathResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.webPath)) {
      query["WebPath"] = request.webPath;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListUuidsByWebPath",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListUuidsByWebPathResponse>(await this.callApi(params, req, runtime), new ListUuidsByWebPathResponse({}));
  }

  async listUuidsByWebPath(request: ListUuidsByWebPathRequest): Promise<ListUuidsByWebPathResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listUuidsByWebPathWithOptions(request, runtime);
  }

  async listVirusScanMachineWithOptions(request: ListVirusScanMachineRequest, runtime: $Util.RuntimeOptions): Promise<ListVirusScanMachineResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListVirusScanMachine",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListVirusScanMachineResponse>(await this.callApi(params, req, runtime), new ListVirusScanMachineResponse({}));
  }

  async listVirusScanMachine(request: ListVirusScanMachineRequest): Promise<ListVirusScanMachineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listVirusScanMachineWithOptions(request, runtime);
  }

  async listVirusScanMachineEventWithOptions(request: ListVirusScanMachineEventRequest, runtime: $Util.RuntimeOptions): Promise<ListVirusScanMachineEventResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.operateTaskId)) {
      query["OperateTaskId"] = request.operateTaskId;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListVirusScanMachineEvent",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListVirusScanMachineEventResponse>(await this.callApi(params, req, runtime), new ListVirusScanMachineEventResponse({}));
  }

  async listVirusScanMachineEvent(request: ListVirusScanMachineEventRequest): Promise<ListVirusScanMachineEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listVirusScanMachineEventWithOptions(request, runtime);
  }

  async listVirusScanTaskWithOptions(request: ListVirusScanTaskRequest, runtime: $Util.RuntimeOptions): Promise<ListVirusScanTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.internetIp)) {
      query["InternetIp"] = request.internetIp;
    }

    if (!Util.isUnset(request.intranetIp)) {
      query["IntranetIp"] = request.intranetIp;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.machineName)) {
      query["MachineName"] = request.machineName;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.rootTask)) {
      query["RootTask"] = request.rootTask;
    }

    if (!Util.isUnset(request.rootTaskId)) {
      query["RootTaskId"] = request.rootTaskId;
    }

    if (!Util.isUnset(request.scanType)) {
      query["ScanType"] = request.scanType;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.statusList)) {
      query["StatusList"] = request.statusList;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListVirusScanTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListVirusScanTaskResponse>(await this.callApi(params, req, runtime), new ListVirusScanTaskResponse({}));
  }

  async listVirusScanTask(request: ListVirusScanTaskRequest): Promise<ListVirusScanTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listVirusScanTaskWithOptions(request, runtime);
  }

  async listVulAutoRepairConfigWithOptions(request: ListVulAutoRepairConfigRequest, runtime: $Util.RuntimeOptions): Promise<ListVulAutoRepairConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.aliasName)) {
      query["AliasName"] = request.aliasName;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListVulAutoRepairConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListVulAutoRepairConfigResponse>(await this.callApi(params, req, runtime), new ListVulAutoRepairConfigResponse({}));
  }

  async listVulAutoRepairConfig(request: ListVulAutoRepairConfigRequest): Promise<ListVulAutoRepairConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listVulAutoRepairConfigWithOptions(request, runtime);
  }

  async listVulGlobalConfigWithOptions(request: ListVulGlobalConfigRequest, runtime: $Util.RuntimeOptions): Promise<ListVulGlobalConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configKey)) {
      query["ConfigKey"] = request.configKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListVulGlobalConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListVulGlobalConfigResponse>(await this.callApi(params, req, runtime), new ListVulGlobalConfigResponse({}));
  }

  async listVulGlobalConfig(request: ListVulGlobalConfigRequest): Promise<ListVulGlobalConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listVulGlobalConfigWithOptions(request, runtime);
  }

  async modifyAccessKeyLeakDealWithOptions(request: ModifyAccessKeyLeakDealRequest, runtime: $Util.RuntimeOptions): Promise<ModifyAccessKeyLeakDealResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.idList)) {
      query["IdList"] = request.idList;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyAccessKeyLeakDeal",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyAccessKeyLeakDealResponse>(await this.callApi(params, req, runtime), new ModifyAccessKeyLeakDealResponse({}));
  }

  async modifyAccessKeyLeakDeal(request: ModifyAccessKeyLeakDealRequest): Promise<ModifyAccessKeyLeakDealResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyAccessKeyLeakDealWithOptions(request, runtime);
  }

  async modifyAntiBruteForceRuleWithOptions(request: ModifyAntiBruteForceRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifyAntiBruteForceRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.defaultRule)) {
      query["DefaultRule"] = request.defaultRule;
    }

    if (!Util.isUnset(request.failCount)) {
      query["FailCount"] = request.failCount;
    }

    if (!Util.isUnset(request.forbiddenTime)) {
      query["ForbiddenTime"] = request.forbiddenTime;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.span)) {
      query["Span"] = request.span;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyAntiBruteForceRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyAntiBruteForceRuleResponse>(await this.callApi(params, req, runtime), new ModifyAntiBruteForceRuleResponse({}));
  }

  async modifyAntiBruteForceRule(request: ModifyAntiBruteForceRuleRequest): Promise<ModifyAntiBruteForceRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyAntiBruteForceRuleWithOptions(request, runtime);
  }

  async modifyAppVulScanCycleWithOptions(request: ModifyAppVulScanCycleRequest, runtime: $Util.RuntimeOptions): Promise<ModifyAppVulScanCycleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.cycle)) {
      query["Cycle"] = request.cycle;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyAppVulScanCycle",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyAppVulScanCycleResponse>(await this.callApi(params, req, runtime), new ModifyAppVulScanCycleResponse({}));
  }

  async modifyAppVulScanCycle(request: ModifyAppVulScanCycleRequest): Promise<ModifyAppVulScanCycleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyAppVulScanCycleWithOptions(request, runtime);
  }

  async modifyAssetCleanConfigWithOptions(request: ModifyAssetCleanConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyAssetCleanConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.assetCleanConfigs)) {
      query["AssetCleanConfigs"] = request.assetCleanConfigs;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyAssetCleanConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyAssetCleanConfigResponse>(await this.callApi(params, req, runtime), new ModifyAssetCleanConfigResponse({}));
  }

  async modifyAssetCleanConfig(request: ModifyAssetCleanConfigRequest): Promise<ModifyAssetCleanConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyAssetCleanConfigWithOptions(request, runtime);
  }

  /**
    * You can call the ModifyAssetGroup operation to change the server group to which one or more servers belong. After you create a server group by calling the [CreateOrUpdateAssetGroup](~~CreateOrUpdateAssetGroup~~) operation, you can call the ModifyAssetGroup operation to change the server group to which your servers belong.
    * ### Limits
    * You can call this API operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
    *
    * @param request ModifyAssetGroupRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ModifyAssetGroupResponse
   */
  async modifyAssetGroupWithOptions(request: ModifyAssetGroupRequest, runtime: $Util.RuntimeOptions): Promise<ModifyAssetGroupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupId)) {
      query["GroupId"] = request.groupId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyAssetGroup",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyAssetGroupResponse>(await this.callApi(params, req, runtime), new ModifyAssetGroupResponse({}));
  }

  /**
    * You can call the ModifyAssetGroup operation to change the server group to which one or more servers belong. After you create a server group by calling the [CreateOrUpdateAssetGroup](~~CreateOrUpdateAssetGroup~~) operation, you can call the ModifyAssetGroup operation to change the server group to which your servers belong.
    * ### Limits
    * You can call this API operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
    *
    * @param request ModifyAssetGroupRequest
    * @return ModifyAssetGroupResponse
   */
  async modifyAssetGroup(request: ModifyAssetGroupRequest): Promise<ModifyAssetGroupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyAssetGroupWithOptions(request, runtime);
  }

  async modifyAssetImportantWithOptions(request: ModifyAssetImportantRequest, runtime: $Util.RuntimeOptions): Promise<ModifyAssetImportantResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.importantCode)) {
      query["ImportantCode"] = request.importantCode;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyAssetImportant",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyAssetImportantResponse>(await this.callApi(params, req, runtime), new ModifyAssetImportantResponse({}));
  }

  async modifyAssetImportant(request: ModifyAssetImportantRequest): Promise<ModifyAssetImportantResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyAssetImportantWithOptions(request, runtime);
  }

  async modifyAutoDelConfigWithOptions(request: ModifyAutoDelConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyAutoDelConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.days)) {
      query["Days"] = request.days;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyAutoDelConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyAutoDelConfigResponse>(await this.callApi(params, req, runtime), new ModifyAutoDelConfigResponse({}));
  }

  async modifyAutoDelConfig(request: ModifyAutoDelConfigRequest): Promise<ModifyAutoDelConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyAutoDelConfigWithOptions(request, runtime);
  }

  async modifyBackupPolicyWithOptions(tmpReq: ModifyBackupPolicyRequest, runtime: $Util.RuntimeOptions): Promise<ModifyBackupPolicyResponse> {
    Util.validateModel(tmpReq);
    let request = new ModifyBackupPolicyShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.policy)) {
      request.policyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.policy, "Policy", "json");
    }

    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.policyShrink)) {
      query["Policy"] = request.policyShrink;
    }

    if (!Util.isUnset(request.policyRegionId)) {
      query["PolicyRegionId"] = request.policyRegionId;
    }

    if (!Util.isUnset(request.policyVersion)) {
      query["PolicyVersion"] = request.policyVersion;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyBackupPolicy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyBackupPolicyResponse>(await this.callApi(params, req, runtime), new ModifyBackupPolicyResponse({}));
  }

  async modifyBackupPolicy(request: ModifyBackupPolicyRequest): Promise<ModifyBackupPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyBackupPolicyWithOptions(request, runtime);
  }

  async modifyBackupPolicyStatusWithOptions(request: ModifyBackupPolicyStatusRequest, runtime: $Util.RuntimeOptions): Promise<ModifyBackupPolicyStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.policyVersion)) {
      query["PolicyVersion"] = request.policyVersion;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyBackupPolicyStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyBackupPolicyStatusResponse>(await this.callApi(params, req, runtime), new ModifyBackupPolicyStatusResponse({}));
  }

  async modifyBackupPolicyStatus(request: ModifyBackupPolicyStatusRequest): Promise<ModifyBackupPolicyStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyBackupPolicyStatusWithOptions(request, runtime);
  }

  async modifyClearLogstoreStorageWithOptions(request: ModifyClearLogstoreStorageRequest, runtime: $Util.RuntimeOptions): Promise<ModifyClearLogstoreStorageResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.userLogStore)) {
      query["UserLogStore"] = request.userLogStore;
    }

    if (!Util.isUnset(request.userProject)) {
      query["UserProject"] = request.userProject;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyClearLogstoreStorage",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyClearLogstoreStorageResponse>(await this.callApi(params, req, runtime), new ModifyClearLogstoreStorageResponse({}));
  }

  async modifyClearLogstoreStorage(request: ModifyClearLogstoreStorageRequest): Promise<ModifyClearLogstoreStorageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyClearLogstoreStorageWithOptions(request, runtime);
  }

  async modifyClientConfSetupWithOptions(request: ModifyClientConfSetupRequest, runtime: $Util.RuntimeOptions): Promise<ModifyClientConfSetupResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.strategyConfig)) {
      query["StrategyConfig"] = request.strategyConfig;
    }

    if (!Util.isUnset(request.strategyTag)) {
      query["StrategyTag"] = request.strategyTag;
    }

    if (!Util.isUnset(request.strategyTagValue)) {
      query["StrategyTagValue"] = request.strategyTagValue;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyClientConfSetup",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyClientConfSetupResponse>(await this.callApi(params, req, runtime), new ModifyClientConfSetupResponse({}));
  }

  async modifyClientConfSetup(request: ModifyClientConfSetupRequest): Promise<ModifyClientConfSetupResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyClientConfSetupWithOptions(request, runtime);
  }

  async modifyClientConfStrategyWithOptions(request: ModifyClientConfStrategyRequest, runtime: $Util.RuntimeOptions): Promise<ModifyClientConfStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    if (!Util.isUnset(request.tagExt)) {
      query["TagExt"] = request.tagExt;
    }

    if (!Util.isUnset(request.tagValue)) {
      query["TagValue"] = request.tagValue;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyClientConfStrategy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyClientConfStrategyResponse>(await this.callApi(params, req, runtime), new ModifyClientConfStrategyResponse({}));
  }

  async modifyClientConfStrategy(request: ModifyClientConfStrategyRequest): Promise<ModifyClientConfStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyClientConfStrategyWithOptions(request, runtime);
  }

  async modifyClientUserDefineRuleWithOptions(request: ModifyClientUserDefineRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifyClientUserDefineRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.actionType)) {
      query["ActionType"] = request.actionType;
    }

    if (!Util.isUnset(request.cmdline)) {
      query["Cmdline"] = request.cmdline;
    }

    if (!Util.isUnset(request.filePath)) {
      query["FilePath"] = request.filePath;
    }

    if (!Util.isUnset(request.IP)) {
      query["IP"] = request.IP;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.md5List)) {
      query["Md5List"] = request.md5List;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.newFilePath)) {
      query["NewFilePath"] = request.newFilePath;
    }

    if (!Util.isUnset(request.parentCmdline)) {
      query["ParentCmdline"] = request.parentCmdline;
    }

    if (!Util.isUnset(request.parentProcPath)) {
      query["ParentProcPath"] = request.parentProcPath;
    }

    if (!Util.isUnset(request.platform)) {
      query["Platform"] = request.platform;
    }

    if (!Util.isUnset(request.port)) {
      query["Port"] = request.port;
    }

    if (!Util.isUnset(request.portStr)) {
      query["PortStr"] = request.portStr;
    }

    if (!Util.isUnset(request.procPath)) {
      query["ProcPath"] = request.procPath;
    }

    if (!Util.isUnset(request.registryContent)) {
      query["RegistryContent"] = request.registryContent;
    }

    if (!Util.isUnset(request.registryKey)) {
      query["RegistryKey"] = request.registryKey;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyClientUserDefineRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyClientUserDefineRuleResponse>(await this.callApi(params, req, runtime), new ModifyClientUserDefineRuleResponse({}));
  }

  async modifyClientUserDefineRule(request: ModifyClientUserDefineRuleRequest): Promise<ModifyClientUserDefineRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyClientUserDefineRuleWithOptions(request, runtime);
  }

  async modifyClusterCnnfStatusUserConfirmWithOptions(request: ModifyClusterCnnfStatusUserConfirmRequest, runtime: $Util.RuntimeOptions): Promise<ModifyClusterCnnfStatusUserConfirmResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterIds)) {
      query["ClusterIds"] = request.clusterIds;
    }

    if (!Util.isUnset(request.userConfirm)) {
      query["UserConfirm"] = request.userConfirm;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyClusterCnnfStatusUserConfirm",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyClusterCnnfStatusUserConfirmResponse>(await this.callApi(params, req, runtime), new ModifyClusterCnnfStatusUserConfirmResponse({}));
  }

  async modifyClusterCnnfStatusUserConfirm(request: ModifyClusterCnnfStatusUserConfirmRequest): Promise<ModifyClusterCnnfStatusUserConfirmResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyClusterCnnfStatusUserConfirmWithOptions(request, runtime);
  }

  async modifyConcernNecessityWithOptions(request: ModifyConcernNecessityRequest, runtime: $Util.RuntimeOptions): Promise<ModifyConcernNecessityResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.concernNecessity)) {
      query["ConcernNecessity"] = request.concernNecessity;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyConcernNecessity",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyConcernNecessityResponse>(await this.callApi(params, req, runtime), new ModifyConcernNecessityResponse({}));
  }

  async modifyConcernNecessity(request: ModifyConcernNecessityRequest): Promise<ModifyConcernNecessityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyConcernNecessityWithOptions(request, runtime);
  }

  async modifyContainerScanConfigWithOptions(request: ModifyContainerScanConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyContainerScanConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appNames)) {
      query["AppNames"] = request.appNames;
    }

    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyContainerScanConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyContainerScanConfigResponse>(await this.callApi(params, req, runtime), new ModifyContainerScanConfigResponse({}));
  }

  async modifyContainerScanConfig(request: ModifyContainerScanConfigRequest): Promise<ModifyContainerScanConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyContainerScanConfigWithOptions(request, runtime);
  }

  async modifyCreateVulWhitelistWithOptions(request: ModifyCreateVulWhitelistRequest, runtime: $Util.RuntimeOptions): Promise<ModifyCreateVulWhitelistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.reason)) {
      query["Reason"] = request.reason;
    }

    if (!Util.isUnset(request.targetInfo)) {
      query["TargetInfo"] = request.targetInfo;
    }

    if (!Util.isUnset(request.whitelist)) {
      query["Whitelist"] = request.whitelist;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyCreateVulWhitelist",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyCreateVulWhitelistResponse>(await this.callApi(params, req, runtime), new ModifyCreateVulWhitelistResponse({}));
  }

  async modifyCreateVulWhitelist(request: ModifyCreateVulWhitelistRequest): Promise<ModifyCreateVulWhitelistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyCreateVulWhitelistWithOptions(request, runtime);
  }

  async modifyCustomBlockRecordWithOptions(request: ModifyCustomBlockRecordRequest, runtime: $Util.RuntimeOptions): Promise<ModifyCustomBlockRecordResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.blockIp)) {
      query["BlockIp"] = request.blockIp;
    }

    if (!Util.isUnset(request.bound)) {
      query["Bound"] = request.bound;
    }

    if (!Util.isUnset(request.expireTime)) {
      query["ExpireTime"] = request.expireTime;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyCustomBlockRecord",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyCustomBlockRecordResponse>(await this.callApi(params, req, runtime), new ModifyCustomBlockRecordResponse({}));
  }

  async modifyCustomBlockRecord(request: ModifyCustomBlockRecordRequest): Promise<ModifyCustomBlockRecordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyCustomBlockRecordWithOptions(request, runtime);
  }

  async modifyCycleTaskWithOptions(request: ModifyCycleTaskRequest, runtime: $Util.RuntimeOptions): Promise<ModifyCycleTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.configId)) {
      query["ConfigId"] = request.configId;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.firstDateStr)) {
      query["FirstDateStr"] = request.firstDateStr;
    }

    if (!Util.isUnset(request.intervalPeriod)) {
      query["IntervalPeriod"] = request.intervalPeriod;
    }

    if (!Util.isUnset(request.param)) {
      query["Param"] = request.param;
    }

    if (!Util.isUnset(request.periodUnit)) {
      query["PeriodUnit"] = request.periodUnit;
    }

    if (!Util.isUnset(request.targetEndTime)) {
      query["TargetEndTime"] = request.targetEndTime;
    }

    if (!Util.isUnset(request.targetStartTime)) {
      query["TargetStartTime"] = request.targetStartTime;
    }

    if (!Util.isUnset(request.taskName)) {
      query["TaskName"] = request.taskName;
    }

    if (!Util.isUnset(request.taskType)) {
      query["TaskType"] = request.taskType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyCycleTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyCycleTaskResponse>(await this.callApi(params, req, runtime), new ModifyCycleTaskResponse({}));
  }

  async modifyCycleTask(request: ModifyCycleTaskRequest): Promise<ModifyCycleTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyCycleTaskWithOptions(request, runtime);
  }

  async modifyEmgVulSubmitWithOptions(request: ModifyEmgVulSubmitRequest, runtime: $Util.RuntimeOptions): Promise<ModifyEmgVulSubmitResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.userAgreement)) {
      query["UserAgreement"] = request.userAgreement;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyEmgVulSubmit",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyEmgVulSubmitResponse>(await this.callApi(params, req, runtime), new ModifyEmgVulSubmitResponse({}));
  }

  async modifyEmgVulSubmit(request: ModifyEmgVulSubmitRequest): Promise<ModifyEmgVulSubmitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyEmgVulSubmitWithOptions(request, runtime);
  }

  async modifyGroupPropertyWithOptions(request: ModifyGroupPropertyRequest, runtime: $Util.RuntimeOptions): Promise<ModifyGroupPropertyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.data)) {
      query["Data"] = request.data;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyGroupProperty",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyGroupPropertyResponse>(await this.callApi(params, req, runtime), new ModifyGroupPropertyResponse({}));
  }

  async modifyGroupProperty(request: ModifyGroupPropertyRequest): Promise<ModifyGroupPropertyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyGroupPropertyWithOptions(request, runtime);
  }

  async modifyImageFixCycleConfigWithOptions(request: ModifyImageFixCycleConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyImageFixCycleConfigResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.imageFixCycle)) {
      body["ImageFixCycle"] = request.imageFixCycle;
    }

    if (!Util.isUnset(request.imageFixSwitch)) {
      body["ImageFixSwitch"] = request.imageFixSwitch;
    }

    if (!Util.isUnset(request.imageFixTarget)) {
      body["ImageFixTarget"] = request.imageFixTarget;
    }

    if (!Util.isUnset(request.imageTimeRange)) {
      body["ImageTimeRange"] = request.imageTimeRange;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyImageFixCycleConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyImageFixCycleConfigResponse>(await this.callApi(params, req, runtime), new ModifyImageFixCycleConfigResponse({}));
  }

  async modifyImageFixCycleConfig(request: ModifyImageFixCycleConfigRequest): Promise<ModifyImageFixCycleConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyImageFixCycleConfigWithOptions(request, runtime);
  }

  async modifyInstanceAntiBruteForceRuleWithOptions(request: ModifyInstanceAntiBruteForceRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInstanceAntiBruteForceRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.newRuleId)) {
      query["NewRuleId"] = request.newRuleId;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInstanceAntiBruteForceRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInstanceAntiBruteForceRuleResponse>(await this.callApi(params, req, runtime), new ModifyInstanceAntiBruteForceRuleResponse({}));
  }

  async modifyInstanceAntiBruteForceRule(request: ModifyInstanceAntiBruteForceRuleRequest): Promise<ModifyInstanceAntiBruteForceRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInstanceAntiBruteForceRuleWithOptions(request, runtime);
  }

  async modifyInterceptionRuleWithOptions(tmpReq: ModifyInterceptionRuleRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInterceptionRuleResponse> {
    Util.validateModel(tmpReq);
    let request = new ModifyInterceptionRuleShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.dstTarget)) {
      request.dstTargetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dstTarget, "DstTarget", "json");
    }

    if (!Util.isUnset(tmpReq.srcTarget)) {
      request.srcTargetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.srcTarget, "SrcTarget", "json");
    }

    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.dstTargetShrink)) {
      query["DstTarget"] = request.dstTargetShrink;
    }

    if (!Util.isUnset(request.interceptType)) {
      query["InterceptType"] = request.interceptType;
    }

    if (!Util.isUnset(request.orderIndex)) {
      query["OrderIndex"] = request.orderIndex;
    }

    if (!Util.isUnset(request.ruleId)) {
      query["RuleId"] = request.ruleId;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.ruleSwitch)) {
      query["RuleSwitch"] = request.ruleSwitch;
    }

    if (!Util.isUnset(request.srcTargetShrink)) {
      query["SrcTarget"] = request.srcTargetShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInterceptionRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInterceptionRuleResponse>(await this.callApi(params, req, runtime), new ModifyInterceptionRuleResponse({}));
  }

  async modifyInterceptionRule(request: ModifyInterceptionRuleRequest): Promise<ModifyInterceptionRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInterceptionRuleWithOptions(request, runtime);
  }

  async modifyInterceptionRuleSwitchWithOptions(request: ModifyInterceptionRuleSwitchRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInterceptionRuleSwitchResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterId)) {
      query["ClusterId"] = request.clusterId;
    }

    if (!Util.isUnset(request.ruleIds)) {
      query["RuleIds"] = request.ruleIds;
    }

    if (!Util.isUnset(request.ruleSwitch)) {
      query["RuleSwitch"] = request.ruleSwitch;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInterceptionRuleSwitch",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInterceptionRuleSwitchResponse>(await this.callApi(params, req, runtime), new ModifyInterceptionRuleSwitchResponse({}));
  }

  async modifyInterceptionRuleSwitch(request: ModifyInterceptionRuleSwitchRequest): Promise<ModifyInterceptionRuleSwitchResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInterceptionRuleSwitchWithOptions(request, runtime);
  }

  async modifyInterceptionTargetWithOptions(request: ModifyInterceptionTargetRequest, runtime: $Util.RuntimeOptions): Promise<ModifyInterceptionTargetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.appName)) {
      query["AppName"] = request.appName;
    }

    if (!Util.isUnset(request.imageList)) {
      query["ImageList"] = request.imageList;
    }

    if (!Util.isUnset(request.namespace)) {
      query["Namespace"] = request.namespace;
    }

    if (!Util.isUnset(request.tagList)) {
      query["TagList"] = request.tagList;
    }

    if (!Util.isUnset(request.targetId)) {
      query["TargetId"] = request.targetId;
    }

    if (!Util.isUnset(request.targetName)) {
      query["TargetName"] = request.targetName;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyInterceptionTarget",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyInterceptionTargetResponse>(await this.callApi(params, req, runtime), new ModifyInterceptionTargetResponse({}));
  }

  async modifyInterceptionTarget(request: ModifyInterceptionTargetRequest): Promise<ModifyInterceptionTargetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyInterceptionTargetWithOptions(request, runtime);
  }

  async modifyLogMetaStatusWithOptions(request: ModifyLogMetaStatusRequest, runtime: $Util.RuntimeOptions): Promise<ModifyLogMetaStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.logStore)) {
      query["LogStore"] = request.logStore;
    }

    if (!Util.isUnset(request.project)) {
      query["Project"] = request.project;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyLogMetaStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyLogMetaStatusResponse>(await this.callApi(params, req, runtime), new ModifyLogMetaStatusResponse({}));
  }

  async modifyLogMetaStatus(request: ModifyLogMetaStatusRequest): Promise<ModifyLogMetaStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyLogMetaStatusWithOptions(request, runtime);
  }

  async modifyLoginBaseConfigWithOptions(request: ModifyLoginBaseConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyLoginBaseConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.target)) {
      query["Target"] = request.target;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyLoginBaseConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyLoginBaseConfigResponse>(await this.callApi(params, req, runtime), new ModifyLoginBaseConfigResponse({}));
  }

  async modifyLoginBaseConfig(request: ModifyLoginBaseConfigRequest): Promise<ModifyLoginBaseConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyLoginBaseConfigWithOptions(request, runtime);
  }

  async modifyLoginSwitchConfigWithOptions(request: ModifyLoginSwitchConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyLoginSwitchConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.item)) {
      query["Item"] = request.item;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyLoginSwitchConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyLoginSwitchConfigResponse>(await this.callApi(params, req, runtime), new ModifyLoginSwitchConfigResponse({}));
  }

  async modifyLoginSwitchConfig(request: ModifyLoginSwitchConfigRequest): Promise<ModifyLoginSwitchConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyLoginSwitchConfigWithOptions(request, runtime);
  }

  async modifyNoticeConfigWithOptions(request: ModifyNoticeConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyNoticeConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.project)) {
      query["Project"] = request.project;
    }

    if (!Util.isUnset(request.route)) {
      query["Route"] = request.route;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.timeLimit)) {
      query["TimeLimit"] = request.timeLimit;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyNoticeConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyNoticeConfigResponse>(await this.callApi(params, req, runtime), new ModifyNoticeConfigResponse({}));
  }

  async modifyNoticeConfig(request: ModifyNoticeConfigRequest): Promise<ModifyNoticeConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyNoticeConfigWithOptions(request, runtime);
  }

  /**
    * **Prerequisites** [Simple Log Service](https://www.alibabacloud.com/help/en/log-service/latest/billable-items) is activated. A service-linked role for Security Center is created, and Security Center is authorized to access cloud resources. You can call the [CreateServiceLinkedRole](~~CreateServiceLinkedRole~~) operation to create a service-linked role for Security Center and authorize Security Center to access cloud resources. **Scenarios** Before you use the log analysis feature of Security Center, you must call the [ModifyOpenLogShipper](~~ModifyOpenLogShipper~~) operation to activate Simple Log Service.
    *
    * @param request ModifyOpenLogShipperRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ModifyOpenLogShipperResponse
   */
  async modifyOpenLogShipperWithOptions(request: ModifyOpenLogShipperRequest, runtime: $Util.RuntimeOptions): Promise<ModifyOpenLogShipperResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyOpenLogShipper",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyOpenLogShipperResponse>(await this.callApi(params, req, runtime), new ModifyOpenLogShipperResponse({}));
  }

  /**
    * **Prerequisites** [Simple Log Service](https://www.alibabacloud.com/help/en/log-service/latest/billable-items) is activated. A service-linked role for Security Center is created, and Security Center is authorized to access cloud resources. You can call the [CreateServiceLinkedRole](~~CreateServiceLinkedRole~~) operation to create a service-linked role for Security Center and authorize Security Center to access cloud resources. **Scenarios** Before you use the log analysis feature of Security Center, you must call the [ModifyOpenLogShipper](~~ModifyOpenLogShipper~~) operation to activate Simple Log Service.
    *
    * @param request ModifyOpenLogShipperRequest
    * @return ModifyOpenLogShipperResponse
   */
  async modifyOpenLogShipper(request: ModifyOpenLogShipperRequest): Promise<ModifyOpenLogShipperResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyOpenLogShipperWithOptions(request, runtime);
  }

  async modifyOperateVulWithOptions(request: ModifyOperateVulRequest, runtime: $Util.RuntimeOptions): Promise<ModifyOperateVulResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.info)) {
      query["Info"] = request.info;
    }

    if (!Util.isUnset(request.operateType)) {
      query["OperateType"] = request.operateType;
    }

    if (!Util.isUnset(request.reason)) {
      query["Reason"] = request.reason;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyOperateVul",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyOperateVulResponse>(await this.callApi(params, req, runtime), new ModifyOperateVulResponse({}));
  }

  async modifyOperateVul(request: ModifyOperateVulRequest): Promise<ModifyOperateVulResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyOperateVulWithOptions(request, runtime);
  }

  async modifyPropertyScheduleConfigWithOptions(request: ModifyPropertyScheduleConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyPropertyScheduleConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.scheduleTime)) {
      query["ScheduleTime"] = request.scheduleTime;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyPropertyScheduleConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyPropertyScheduleConfigResponse>(await this.callApi(params, req, runtime), new ModifyPropertyScheduleConfigResponse({}));
  }

  async modifyPropertyScheduleConfig(request: ModifyPropertyScheduleConfigRequest): Promise<ModifyPropertyScheduleConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyPropertyScheduleConfigWithOptions(request, runtime);
  }

  async modifyPushAllTaskWithOptions(request: ModifyPushAllTaskRequest, runtime: $Util.RuntimeOptions): Promise<ModifyPushAllTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.tasks)) {
      query["Tasks"] = request.tasks;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyPushAllTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyPushAllTaskResponse>(await this.callApi(params, req, runtime), new ModifyPushAllTaskResponse({}));
  }

  async modifyPushAllTask(request: ModifyPushAllTaskRequest): Promise<ModifyPushAllTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyPushAllTaskWithOptions(request, runtime);
  }

  async modifyRefreshProcessInfoWithOptions(request: ModifyRefreshProcessInfoRequest, runtime: $Util.RuntimeOptions): Promise<ModifyRefreshProcessInfoResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyRefreshProcessInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyRefreshProcessInfoResponse>(await this.callApi(params, req, runtime), new ModifyRefreshProcessInfoResponse({}));
  }

  async modifyRefreshProcessInfo(request: ModifyRefreshProcessInfoRequest): Promise<ModifyRefreshProcessInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyRefreshProcessInfoWithOptions(request, runtime);
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the following operations:
    * \\-To **ignore a check item**, use the AddCheckResultWhiteList operation.
    * \\-To **cancel ignoring a check item**, use the RemoveCheckResultWhiteList operation.
    *
    * @param request ModifyRiskCheckStatusRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ModifyRiskCheckStatusResponse
   */
  // Deprecated
  async modifyRiskCheckStatusWithOptions(request: ModifyRiskCheckStatusRequest, runtime: $Util.RuntimeOptions): Promise<ModifyRiskCheckStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.itemId)) {
      query["ItemId"] = request.itemId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyRiskCheckStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyRiskCheckStatusResponse>(await this.callApi(params, req, runtime), new ModifyRiskCheckStatusResponse({}));
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the following operations:
    * \\-To **ignore a check item**, use the AddCheckResultWhiteList operation.
    * \\-To **cancel ignoring a check item**, use the RemoveCheckResultWhiteList operation.
    *
    * @param request ModifyRiskCheckStatusRequest
    * @return ModifyRiskCheckStatusResponse
   */
  // Deprecated
  async modifyRiskCheckStatus(request: ModifyRiskCheckStatusRequest): Promise<ModifyRiskCheckStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyRiskCheckStatusWithOptions(request, runtime);
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the following operations:
    * \\-To **ignore a risk item**, use the AddCheckInstanceResultWhiteList operation.
    * \\-To **cancel ignoring a risk item**, use the RemoveCheckInstanceResultWhiteList operation.
    *
    * @param request ModifyRiskSingleResultStatusRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ModifyRiskSingleResultStatusResponse
   */
  // Deprecated
  async modifyRiskSingleResultStatusWithOptions(request: ModifyRiskSingleResultStatusRequest, runtime: $Util.RuntimeOptions): Promise<ModifyRiskSingleResultStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.ids)) {
      query["Ids"] = request.ids;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyRiskSingleResultStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyRiskSingleResultStatusResponse>(await this.callApi(params, req, runtime), new ModifyRiskSingleResultStatusResponse({}));
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the following operations:
    * \\-To **ignore a risk item**, use the AddCheckInstanceResultWhiteList operation.
    * \\-To **cancel ignoring a risk item**, use the RemoveCheckInstanceResultWhiteList operation.
    *
    * @param request ModifyRiskSingleResultStatusRequest
    * @return ModifyRiskSingleResultStatusResponse
   */
  // Deprecated
  async modifyRiskSingleResultStatus(request: ModifyRiskSingleResultStatusRequest): Promise<ModifyRiskSingleResultStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyRiskSingleResultStatusWithOptions(request, runtime);
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the ChangeCheckConfig operation.
    *
    * @param request ModifySecurityCheckScheduleConfigRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ModifySecurityCheckScheduleConfigResponse
   */
  // Deprecated
  async modifySecurityCheckScheduleConfigWithOptions(request: ModifySecurityCheckScheduleConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifySecurityCheckScheduleConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.daysOfWeek)) {
      query["DaysOfWeek"] = request.daysOfWeek;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifySecurityCheckScheduleConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifySecurityCheckScheduleConfigResponse>(await this.callApi(params, req, runtime), new ModifySecurityCheckScheduleConfigResponse({}));
  }

  /**
    * @deprecated
    * This operation is phased out. You can use the ChangeCheckConfig operation.
    *
    * @param request ModifySecurityCheckScheduleConfigRequest
    * @return ModifySecurityCheckScheduleConfigResponse
   */
  // Deprecated
  async modifySecurityCheckScheduleConfig(request: ModifySecurityCheckScheduleConfigRequest): Promise<ModifySecurityCheckScheduleConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifySecurityCheckScheduleConfigWithOptions(request, runtime);
  }

  async modifySecurityEventMarkMissIndividuallyWithOptions(request: ModifySecurityEventMarkMissIndividuallyRequest, runtime: $Util.RuntimeOptions): Promise<ModifySecurityEventMarkMissIndividuallyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.deleteMarkMissParam)) {
      body["DeleteMarkMissParam"] = request.deleteMarkMissParam;
    }

    if (!Util.isUnset(request.from)) {
      body["From"] = request.from;
    }

    if (!Util.isUnset(request.insertMarkMissParam)) {
      body["InsertMarkMissParam"] = request.insertMarkMissParam;
    }

    if (!Util.isUnset(request.lang)) {
      body["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifySecurityEventMarkMissIndividually",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifySecurityEventMarkMissIndividuallyResponse>(await this.callApi(params, req, runtime), new ModifySecurityEventMarkMissIndividuallyResponse({}));
  }

  async modifySecurityEventMarkMissIndividually(request: ModifySecurityEventMarkMissIndividuallyRequest): Promise<ModifySecurityEventMarkMissIndividuallyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifySecurityEventMarkMissIndividuallyWithOptions(request, runtime);
  }

  async modifyStartVulScanWithOptions(request: ModifyStartVulScanRequest, runtime: $Util.RuntimeOptions): Promise<ModifyStartVulScanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.types)) {
      query["Types"] = request.types;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyStartVulScan",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyStartVulScanResponse>(await this.callApi(params, req, runtime), new ModifyStartVulScanResponse({}));
  }

  async modifyStartVulScan(request: ModifyStartVulScanRequest): Promise<ModifyStartVulScanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyStartVulScanWithOptions(request, runtime);
  }

  async modifyStrategyWithOptions(request: ModifyStrategyRequest, runtime: $Util.RuntimeOptions): Promise<ModifyStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.customType)) {
      query["CustomType"] = request.customType;
    }

    if (!Util.isUnset(request.cycleDays)) {
      query["CycleDays"] = request.cycleDays;
    }

    if (!Util.isUnset(request.cycleStartTime)) {
      query["CycleStartTime"] = request.cycleStartTime;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.riskCustomParams)) {
      query["RiskCustomParams"] = request.riskCustomParams;
    }

    if (!Util.isUnset(request.riskSubTypeName)) {
      query["RiskSubTypeName"] = request.riskSubTypeName;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyStrategy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyStrategyResponse>(await this.callApi(params, req, runtime), new ModifyStrategyResponse({}));
  }

  async modifyStrategy(request: ModifyStrategyRequest): Promise<ModifyStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyStrategyWithOptions(request, runtime);
  }

  async modifyStrategyTargetWithOptions(request: ModifyStrategyTargetRequest, runtime: $Util.RuntimeOptions): Promise<ModifyStrategyTargetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.target)) {
      query["Target"] = request.target;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyStrategyTarget",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyStrategyTargetResponse>(await this.callApi(params, req, runtime), new ModifyStrategyTargetResponse({}));
  }

  async modifyStrategyTarget(request: ModifyStrategyTargetRequest): Promise<ModifyStrategyTargetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyStrategyTargetWithOptions(request, runtime);
  }

  async modifyTagWithUuidWithOptions(request: ModifyTagWithUuidRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTagWithUuidResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.machineTypes)) {
      query["MachineTypes"] = request.machineTypes;
    }

    if (!Util.isUnset(request.tagId)) {
      query["TagId"] = request.tagId;
    }

    if (!Util.isUnset(request.tagList)) {
      query["TagList"] = request.tagList;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTagWithUuid",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTagWithUuidResponse>(await this.callApi(params, req, runtime), new ModifyTagWithUuidResponse({}));
  }

  async modifyTagWithUuid(request: ModifyTagWithUuidRequest): Promise<ModifyTagWithUuidResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTagWithUuidWithOptions(request, runtime);
  }

  async modifyUniBackupPolicyWithOptions(tmpReq: ModifyUniBackupPolicyRequest, runtime: $Util.RuntimeOptions): Promise<ModifyUniBackupPolicyResponse> {
    Util.validateModel(tmpReq);
    let request = new ModifyUniBackupPolicyShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.fullPlan)) {
      request.fullPlanShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fullPlan, "FullPlan", "json");
    }

    if (!Util.isUnset(tmpReq.incPlan)) {
      request.incPlanShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.incPlan, "IncPlan", "json");
    }

    let query = { };
    if (!Util.isUnset(request.accountName)) {
      query["AccountName"] = request.accountName;
    }

    if (!Util.isUnset(request.accountPassword)) {
      query["AccountPassword"] = request.accountPassword;
    }

    if (!Util.isUnset(request.fullPlanShrink)) {
      query["FullPlan"] = request.fullPlanShrink;
    }

    if (!Util.isUnset(request.incPlanShrink)) {
      query["IncPlan"] = request.incPlanShrink;
    }

    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    if (!Util.isUnset(request.policyName)) {
      query["PolicyName"] = request.policyName;
    }

    if (!Util.isUnset(request.policyStatus)) {
      query["PolicyStatus"] = request.policyStatus;
    }

    if (!Util.isUnset(request.retention)) {
      query["Retention"] = request.retention;
    }

    if (!Util.isUnset(request.speedLimiter)) {
      query["SpeedLimiter"] = request.speedLimiter;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyUniBackupPolicy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyUniBackupPolicyResponse>(await this.callApi(params, req, runtime), new ModifyUniBackupPolicyResponse({}));
  }

  async modifyUniBackupPolicy(request: ModifyUniBackupPolicyRequest): Promise<ModifyUniBackupPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyUniBackupPolicyWithOptions(request, runtime);
  }

  async modifyVpcHoneyPotWithOptions(request: ModifyVpcHoneyPotRequest, runtime: $Util.RuntimeOptions): Promise<ModifyVpcHoneyPotResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.honeyPotAction)) {
      query["HoneyPotAction"] = request.honeyPotAction;
    }

    if (!Util.isUnset(request.vpcId)) {
      query["VpcId"] = request.vpcId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyVpcHoneyPot",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyVpcHoneyPotResponse>(await this.callApi(params, req, runtime), new ModifyVpcHoneyPotResponse({}));
  }

  async modifyVpcHoneyPot(request: ModifyVpcHoneyPotRequest): Promise<ModifyVpcHoneyPotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyVpcHoneyPotWithOptions(request, runtime);
  }

  async modifyVulConfigWithOptions(request: ModifyVulConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyVulConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyVulConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyVulConfigResponse>(await this.callApi(params, req, runtime), new ModifyVulConfigResponse({}));
  }

  async modifyVulConfig(request: ModifyVulConfigRequest): Promise<ModifyVulConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyVulConfigWithOptions(request, runtime);
  }

  async modifyVulTargetWithOptions(request: ModifyVulTargetRequest, runtime: $Util.RuntimeOptions): Promise<ModifyVulTargetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.target)) {
      query["Target"] = request.target;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyVulTarget",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyVulTargetResponse>(await this.callApi(params, req, runtime), new ModifyVulTargetResponse({}));
  }

  async modifyVulTarget(request: ModifyVulTargetRequest): Promise<ModifyVulTargetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyVulTargetWithOptions(request, runtime);
  }

  async modifyVulTargetConfigWithOptions(request: ModifyVulTargetConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyVulTargetConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyVulTargetConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyVulTargetConfigResponse>(await this.callApi(params, req, runtime), new ModifyVulTargetConfigResponse({}));
  }

  async modifyVulTargetConfig(request: ModifyVulTargetConfigRequest): Promise<ModifyVulTargetConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyVulTargetConfigWithOptions(request, runtime);
  }

  async modifyVulWhitelistTargetWithOptions(request: ModifyVulWhitelistTargetRequest, runtime: $Util.RuntimeOptions): Promise<ModifyVulWhitelistTargetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.reason)) {
      query["Reason"] = request.reason;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.targetInfo)) {
      query["TargetInfo"] = request.targetInfo;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyVulWhitelistTarget",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyVulWhitelistTargetResponse>(await this.callApi(params, req, runtime), new ModifyVulWhitelistTargetResponse({}));
  }

  async modifyVulWhitelistTarget(request: ModifyVulWhitelistTargetRequest): Promise<ModifyVulWhitelistTargetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyVulWhitelistTargetWithOptions(request, runtime);
  }

  async modifyWebLockCreateConfigWithOptions(request: ModifyWebLockCreateConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebLockCreateConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.defenceMode)) {
      query["DefenceMode"] = request.defenceMode;
    }

    if (!Util.isUnset(request.dir)) {
      query["Dir"] = request.dir;
    }

    if (!Util.isUnset(request.exclusiveDir)) {
      query["ExclusiveDir"] = request.exclusiveDir;
    }

    if (!Util.isUnset(request.exclusiveFile)) {
      query["ExclusiveFile"] = request.exclusiveFile;
    }

    if (!Util.isUnset(request.exclusiveFileType)) {
      query["ExclusiveFileType"] = request.exclusiveFileType;
    }

    if (!Util.isUnset(request.inclusiveFile)) {
      query["InclusiveFile"] = request.inclusiveFile;
    }

    if (!Util.isUnset(request.inclusiveFileType)) {
      query["InclusiveFileType"] = request.inclusiveFileType;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.localBackupDir)) {
      query["LocalBackupDir"] = request.localBackupDir;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebLockCreateConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebLockCreateConfigResponse>(await this.callApi(params, req, runtime), new ModifyWebLockCreateConfigResponse({}));
  }

  async modifyWebLockCreateConfig(request: ModifyWebLockCreateConfigRequest): Promise<ModifyWebLockCreateConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebLockCreateConfigWithOptions(request, runtime);
  }

  /**
    * After you delete a directory that has web tamper proofing enabled on a server, files in the directory are no longer protected by web tamper proofing. The information about the websites that are hosted on the server may be maliciously modified by attackers. Proceed with caution.
    *
    * @param request ModifyWebLockDeleteConfigRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return ModifyWebLockDeleteConfigResponse
   */
  async modifyWebLockDeleteConfigWithOptions(request: ModifyWebLockDeleteConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebLockDeleteConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebLockDeleteConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebLockDeleteConfigResponse>(await this.callApi(params, req, runtime), new ModifyWebLockDeleteConfigResponse({}));
  }

  /**
    * After you delete a directory that has web tamper proofing enabled on a server, files in the directory are no longer protected by web tamper proofing. The information about the websites that are hosted on the server may be maliciously modified by attackers. Proceed with caution.
    *
    * @param request ModifyWebLockDeleteConfigRequest
    * @return ModifyWebLockDeleteConfigResponse
   */
  async modifyWebLockDeleteConfig(request: ModifyWebLockDeleteConfigRequest): Promise<ModifyWebLockDeleteConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebLockDeleteConfigWithOptions(request, runtime);
  }

  async modifyWebLockProcessStatusWithOptions(request: ModifyWebLockProcessStatusRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebLockProcessStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dealAll)) {
      query["DealAll"] = request.dealAll;
    }

    if (!Util.isUnset(request.operateInfo)) {
      query["OperateInfo"] = request.operateInfo;
    }

    if (!Util.isUnset(request.processPath)) {
      query["ProcessPath"] = request.processPath;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebLockProcessStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebLockProcessStatusResponse>(await this.callApi(params, req, runtime), new ModifyWebLockProcessStatusResponse({}));
  }

  async modifyWebLockProcessStatus(request: ModifyWebLockProcessStatusRequest): Promise<ModifyWebLockProcessStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebLockProcessStatusWithOptions(request, runtime);
  }

  async modifyWebLockStartWithOptions(request: ModifyWebLockStartRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebLockStartResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.defenceMode)) {
      query["DefenceMode"] = request.defenceMode;
    }

    if (!Util.isUnset(request.dir)) {
      query["Dir"] = request.dir;
    }

    if (!Util.isUnset(request.exclusiveDir)) {
      query["ExclusiveDir"] = request.exclusiveDir;
    }

    if (!Util.isUnset(request.exclusiveFile)) {
      query["ExclusiveFile"] = request.exclusiveFile;
    }

    if (!Util.isUnset(request.exclusiveFileType)) {
      query["ExclusiveFileType"] = request.exclusiveFileType;
    }

    if (!Util.isUnset(request.inclusiveFileType)) {
      query["InclusiveFileType"] = request.inclusiveFileType;
    }

    if (!Util.isUnset(request.localBackupDir)) {
      query["LocalBackupDir"] = request.localBackupDir;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebLockStart",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebLockStartResponse>(await this.callApi(params, req, runtime), new ModifyWebLockStartResponse({}));
  }

  async modifyWebLockStart(request: ModifyWebLockStartRequest): Promise<ModifyWebLockStartResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebLockStartWithOptions(request, runtime);
  }

  async modifyWebLockStatusWithOptions(request: ModifyWebLockStatusRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebLockStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebLockStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebLockStatusResponse>(await this.callApi(params, req, runtime), new ModifyWebLockStatusResponse({}));
  }

  async modifyWebLockStatus(request: ModifyWebLockStatusRequest): Promise<ModifyWebLockStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebLockStatusWithOptions(request, runtime);
  }

  async modifyWebLockUnbindWithOptions(request: ModifyWebLockUnbindRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebLockUnbindResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebLockUnbind",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebLockUnbindResponse>(await this.callApi(params, req, runtime), new ModifyWebLockUnbindResponse({}));
  }

  async modifyWebLockUnbind(request: ModifyWebLockUnbindRequest): Promise<ModifyWebLockUnbindResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebLockUnbindWithOptions(request, runtime);
  }

  async modifyWebLockUpdateConfigWithOptions(request: ModifyWebLockUpdateConfigRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebLockUpdateConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.defenceMode)) {
      query["DefenceMode"] = request.defenceMode;
    }

    if (!Util.isUnset(request.dir)) {
      query["Dir"] = request.dir;
    }

    if (!Util.isUnset(request.exclusiveDir)) {
      query["ExclusiveDir"] = request.exclusiveDir;
    }

    if (!Util.isUnset(request.exclusiveFile)) {
      query["ExclusiveFile"] = request.exclusiveFile;
    }

    if (!Util.isUnset(request.exclusiveFileType)) {
      query["ExclusiveFileType"] = request.exclusiveFileType;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.inclusiveFile)) {
      query["InclusiveFile"] = request.inclusiveFile;
    }

    if (!Util.isUnset(request.inclusiveFileType)) {
      query["InclusiveFileType"] = request.inclusiveFileType;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.localBackupDir)) {
      query["LocalBackupDir"] = request.localBackupDir;
    }

    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebLockUpdateConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebLockUpdateConfigResponse>(await this.callApi(params, req, runtime), new ModifyWebLockUpdateConfigResponse({}));
  }

  async modifyWebLockUpdateConfig(request: ModifyWebLockUpdateConfigRequest): Promise<ModifyWebLockUpdateConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebLockUpdateConfigWithOptions(request, runtime);
  }

  async modifyWebPathWithOptions(request: ModifyWebPathRequest, runtime: $Util.RuntimeOptions): Promise<ModifyWebPathResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.target)) {
      query["Target"] = request.target;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ModifyWebPath",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyWebPathResponse>(await this.callApi(params, req, runtime), new ModifyWebPathResponse({}));
  }

  async modifyWebPath(request: ModifyWebPathRequest): Promise<ModifyWebPathResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyWebPathWithOptions(request, runtime);
  }

  async openSensitiveFileScanWithOptions(request: OpenSensitiveFileScanRequest, runtime: $Util.RuntimeOptions): Promise<OpenSensitiveFileScanResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.switchOn)) {
      query["SwitchOn"] = request.switchOn;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OpenSensitiveFileScan",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OpenSensitiveFileScanResponse>(await this.callApi(params, req, runtime), new OpenSensitiveFileScanResponse({}));
  }

  async openSensitiveFileScan(request: OpenSensitiveFileScanRequest): Promise<OpenSensitiveFileScanResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.openSensitiveFileScanWithOptions(request, runtime);
  }

  async operateAgentClientInstallWithOptions(request: OperateAgentClientInstallRequest, runtime: $Util.RuntimeOptions): Promise<OperateAgentClientInstallResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.os)) {
      query["Os"] = request.os;
    }

    if (!Util.isUnset(request.region)) {
      query["Region"] = request.region;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperateAgentClientInstall",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperateAgentClientInstallResponse>(await this.callApi(params, req, runtime), new OperateAgentClientInstallResponse({}));
  }

  async operateAgentClientInstall(request: OperateAgentClientInstallRequest): Promise<OperateAgentClientInstallResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operateAgentClientInstallWithOptions(request, runtime);
  }

  async operateBucketScanTaskWithOptions(request: OperateBucketScanTaskRequest, runtime: $Util.RuntimeOptions): Promise<OperateBucketScanTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bucketName)) {
      query["BucketName"] = request.bucketName;
    }

    if (!Util.isUnset(request.operateCode)) {
      query["OperateCode"] = request.operateCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperateBucketScanTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperateBucketScanTaskResponse>(await this.callApi(params, req, runtime), new OperateBucketScanTaskResponse({}));
  }

  async operateBucketScanTask(request: OperateBucketScanTaskRequest): Promise<OperateBucketScanTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operateBucketScanTaskWithOptions(request, runtime);
  }

  async operateCommonOverallConfigWithOptions(request: OperateCommonOverallConfigRequest, runtime: $Util.RuntimeOptions): Promise<OperateCommonOverallConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperateCommonOverallConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperateCommonOverallConfigResponse>(await this.callApi(params, req, runtime), new OperateCommonOverallConfigResponse({}));
  }

  async operateCommonOverallConfig(request: OperateCommonOverallConfigRequest): Promise<OperateCommonOverallConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operateCommonOverallConfigWithOptions(request, runtime);
  }

  async operateCommonTargetConfigWithOptions(request: OperateCommonTargetConfigRequest, runtime: $Util.RuntimeOptions): Promise<OperateCommonTargetConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.fieldName)) {
      query["FieldName"] = request.fieldName;
    }

    if (!Util.isUnset(request.fieldValue)) {
      query["FieldValue"] = request.fieldValue;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.targetOperations)) {
      query["TargetOperations"] = request.targetOperations;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperateCommonTargetConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperateCommonTargetConfigResponse>(await this.callApi(params, req, runtime), new OperateCommonTargetConfigResponse({}));
  }

  async operateCommonTargetConfig(request: OperateCommonTargetConfigRequest): Promise<OperateCommonTargetConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operateCommonTargetConfigWithOptions(request, runtime);
  }

  async operateImageBaselineWhitelistWithOptions(request: OperateImageBaselineWhitelistRequest, runtime: $Util.RuntimeOptions): Promise<OperateImageBaselineWhitelistResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.baselineItemKeyList)) {
      query["BaselineItemKeyList"] = request.baselineItemKeyList;
    }

    if (!Util.isUnset(request.imageUuid)) {
      query["ImageUuid"] = request.imageUuid;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.operation)) {
      query["Operation"] = request.operation;
    }

    if (!Util.isUnset(request.scanRange)) {
      query["ScanRange"] = request.scanRange;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperateImageBaselineWhitelist",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperateImageBaselineWhitelistResponse>(await this.callApi(params, req, runtime), new OperateImageBaselineWhitelistResponse({}));
  }

  async operateImageBaselineWhitelist(request: OperateImageBaselineWhitelistRequest): Promise<OperateImageBaselineWhitelistResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operateImageBaselineWhitelistWithOptions(request, runtime);
  }

  async operateImageVulWithOptions(request: OperateImageVulRequest, runtime: $Util.RuntimeOptions): Promise<OperateImageVulResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.info)) {
      query["Info"] = request.info;
    }

    if (!Util.isUnset(request.operateType)) {
      query["OperateType"] = request.operateType;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperateImageVul",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperateImageVulResponse>(await this.callApi(params, req, runtime), new OperateImageVulResponse({}));
  }

  async operateImageVul(request: OperateImageVulRequest): Promise<OperateImageVulResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operateImageVulWithOptions(request, runtime);
  }

  async operateSuspiciousOverallConfigWithOptions(request: OperateSuspiciousOverallConfigRequest, runtime: $Util.RuntimeOptions): Promise<OperateSuspiciousOverallConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.noTargetAsOn)) {
      query["NoTargetAsOn"] = request.noTargetAsOn;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperateSuspiciousOverallConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperateSuspiciousOverallConfigResponse>(await this.callApi(params, req, runtime), new OperateSuspiciousOverallConfigResponse({}));
  }

  async operateSuspiciousOverallConfig(request: OperateSuspiciousOverallConfigRequest): Promise<OperateSuspiciousOverallConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operateSuspiciousOverallConfigWithOptions(request, runtime);
  }

  async operateSuspiciousTargetConfigWithOptions(request: OperateSuspiciousTargetConfigRequest, runtime: $Util.RuntimeOptions): Promise<OperateSuspiciousTargetConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.targetOperations)) {
      query["TargetOperations"] = request.targetOperations;
    }

    if (!Util.isUnset(request.targetType)) {
      query["TargetType"] = request.targetType;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperateSuspiciousTargetConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperateSuspiciousTargetConfigResponse>(await this.callApi(params, req, runtime), new OperateSuspiciousTargetConfigResponse({}));
  }

  async operateSuspiciousTargetConfig(request: OperateSuspiciousTargetConfigRequest): Promise<OperateSuspiciousTargetConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operateSuspiciousTargetConfigWithOptions(request, runtime);
  }

  async operateVirusEventsWithOptions(request: OperateVirusEventsRequest, runtime: $Util.RuntimeOptions): Promise<OperateVirusEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.operationAll)) {
      query["OperationAll"] = request.operationAll;
    }

    if (!Util.isUnset(request.operationCode)) {
      query["OperationCode"] = request.operationCode;
    }

    if (!Util.isUnset(request.operationRange)) {
      query["OperationRange"] = request.operationRange;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperateVirusEvents",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperateVirusEventsResponse>(await this.callApi(params, req, runtime), new OperateVirusEventsResponse({}));
  }

  async operateVirusEvents(request: OperateVirusEventsRequest): Promise<OperateVirusEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operateVirusEventsWithOptions(request, runtime);
  }

  async operateVulsWithOptions(request: OperateVulsRequest, runtime: $Util.RuntimeOptions): Promise<OperateVulsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.operateType)) {
      query["OperateType"] = request.operateType;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    if (!Util.isUnset(request.vulNames)) {
      query["VulNames"] = request.vulNames;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperateVuls",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperateVulsResponse>(await this.callApi(params, req, runtime), new OperateVulsResponse({}));
  }

  async operateVuls(request: OperateVulsRequest): Promise<OperateVulsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operateVulsWithOptions(request, runtime);
  }

  async operateWebLockFileEventsWithOptions(request: OperateWebLockFileEventsRequest, runtime: $Util.RuntimeOptions): Promise<OperateWebLockFileEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.dealAll)) {
      query["DealAll"] = request.dealAll;
    }

    if (!Util.isUnset(request.eventIds)) {
      query["EventIds"] = request.eventIds;
    }

    if (!Util.isUnset(request.operationCode)) {
      query["OperationCode"] = request.operationCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperateWebLockFileEvents",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperateWebLockFileEventsResponse>(await this.callApi(params, req, runtime), new OperateWebLockFileEventsResponse({}));
  }

  async operateWebLockFileEvents(request: OperateWebLockFileEventsRequest): Promise<OperateWebLockFileEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operateWebLockFileEventsWithOptions(request, runtime);
  }

  async operationCancelIgnoreSuspEventWithOptions(request: OperationCancelIgnoreSuspEventRequest, runtime: $Util.RuntimeOptions): Promise<OperationCancelIgnoreSuspEventResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    if (!Util.isUnset(request.securityEventIds)) {
      query["SecurityEventIds"] = request.securityEventIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperationCancelIgnoreSuspEvent",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperationCancelIgnoreSuspEventResponse>(await this.callApi(params, req, runtime), new OperationCancelIgnoreSuspEventResponse({}));
  }

  async operationCancelIgnoreSuspEvent(request: OperationCancelIgnoreSuspEventRequest): Promise<OperationCancelIgnoreSuspEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operationCancelIgnoreSuspEventWithOptions(request, runtime);
  }

  async operationSuspEventsWithOptions(request: OperationSuspEventsRequest, runtime: $Util.RuntimeOptions): Promise<OperationSuspEventsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.operation)) {
      query["Operation"] = request.operation;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.subOperation)) {
      query["SubOperation"] = request.subOperation;
    }

    if (!Util.isUnset(request.suspiciousEventIds)) {
      query["SuspiciousEventIds"] = request.suspiciousEventIds;
    }

    if (!Util.isUnset(request.warnType)) {
      query["WarnType"] = request.warnType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "OperationSuspEvents",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperationSuspEventsResponse>(await this.callApi(params, req, runtime), new OperationSuspEventsResponse({}));
  }

  async operationSuspEvents(request: OperationSuspEventsRequest): Promise<OperationSuspEventsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operationSuspEventsWithOptions(request, runtime);
  }

  async pageImageRegistryWithOptions(request: PageImageRegistryRequest, runtime: $Util.RuntimeOptions): Promise<PageImageRegistryResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.currentPage)) {
      body["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.registryNameLike)) {
      body["RegistryNameLike"] = request.registryNameLike;
    }

    if (!Util.isUnset(request.registryTypeInList)) {
      body["RegistryTypeInList"] = request.registryTypeInList;
    }

    if (!Util.isUnset(request.registryTypeNotInList)) {
      body["RegistryTypeNotInList"] = request.registryTypeNotInList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "PageImageRegistry",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PageImageRegistryResponse>(await this.callApi(params, req, runtime), new PageImageRegistryResponse({}));
  }

  async pageImageRegistry(request: PageImageRegistryRequest): Promise<PageImageRegistryResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pageImageRegistryWithOptions(request, runtime);
  }

  async pauseClientWithOptions(request: PauseClientRequest, runtime: $Util.RuntimeOptions): Promise<PauseClientResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    if (!Util.isUnset(request.value)) {
      query["Value"] = request.value;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PauseClient",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PauseClientResponse>(await this.callApi(params, req, runtime), new PauseClientResponse({}));
  }

  async pauseClient(request: PauseClientRequest): Promise<PauseClientResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.pauseClientWithOptions(request, runtime);
  }

  /**
    * Before you call the PublicCreateImageScanTask operation, we recommend that you call the [PublicPreCheckImageScanTask](~~PublicPreCheckImageScanTask~~) operation to query the number of images to scan and the quota for container image scan to be consumed by the image scan task. Make sure that the remaining quota for container image scan is sufficient. This prevents the task from being stopped due to an insufficient quota.
    *
    * @param request PublicCreateImageScanTaskRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return PublicCreateImageScanTaskResponse
   */
  async publicCreateImageScanTaskWithOptions(request: PublicCreateImageScanTaskRequest, runtime: $Util.RuntimeOptions): Promise<PublicCreateImageScanTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.digests)) {
      query["Digests"] = request.digests;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.regionIds)) {
      query["RegionIds"] = request.regionIds;
    }

    if (!Util.isUnset(request.registryTypes)) {
      query["RegistryTypes"] = request.registryTypes;
    }

    if (!Util.isUnset(request.repoIds)) {
      query["RepoIds"] = request.repoIds;
    }

    if (!Util.isUnset(request.repoNames)) {
      query["RepoNames"] = request.repoNames;
    }

    if (!Util.isUnset(request.repoNamespaces)) {
      query["RepoNamespaces"] = request.repoNamespaces;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PublicCreateImageScanTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublicCreateImageScanTaskResponse>(await this.callApi(params, req, runtime), new PublicCreateImageScanTaskResponse({}));
  }

  /**
    * Before you call the PublicCreateImageScanTask operation, we recommend that you call the [PublicPreCheckImageScanTask](~~PublicPreCheckImageScanTask~~) operation to query the number of images to scan and the quota for container image scan to be consumed by the image scan task. Make sure that the remaining quota for container image scan is sufficient. This prevents the task from being stopped due to an insufficient quota.
    *
    * @param request PublicCreateImageScanTaskRequest
    * @return PublicCreateImageScanTaskResponse
   */
  async publicCreateImageScanTask(request: PublicCreateImageScanTaskRequest): Promise<PublicCreateImageScanTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publicCreateImageScanTaskWithOptions(request, runtime);
  }

  async publicPreCheckImageScanTaskWithOptions(request: PublicPreCheckImageScanTaskRequest, runtime: $Util.RuntimeOptions): Promise<PublicPreCheckImageScanTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.digests)) {
      query["Digests"] = request.digests;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    if (!Util.isUnset(request.regionIds)) {
      query["RegionIds"] = request.regionIds;
    }

    if (!Util.isUnset(request.registryTypes)) {
      query["RegistryTypes"] = request.registryTypes;
    }

    if (!Util.isUnset(request.repoIds)) {
      query["RepoIds"] = request.repoIds;
    }

    if (!Util.isUnset(request.repoNames)) {
      query["RepoNames"] = request.repoNames;
    }

    if (!Util.isUnset(request.repoNamespaces)) {
      query["RepoNamespaces"] = request.repoNamespaces;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.tags)) {
      query["Tags"] = request.tags;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PublicPreCheckImageScanTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublicPreCheckImageScanTaskResponse>(await this.callApi(params, req, runtime), new PublicPreCheckImageScanTaskResponse({}));
  }

  async publicPreCheckImageScanTask(request: PublicPreCheckImageScanTaskRequest): Promise<PublicPreCheckImageScanTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publicPreCheckImageScanTaskWithOptions(request, runtime);
  }

  async publicSyncAndCreateImageScanTaskWithOptions(request: PublicSyncAndCreateImageScanTaskRequest, runtime: $Util.RuntimeOptions): Promise<PublicSyncAndCreateImageScanTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.images)) {
      query["Images"] = request.images;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "PublicSyncAndCreateImageScanTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<PublicSyncAndCreateImageScanTaskResponse>(await this.callApi(params, req, runtime), new PublicSyncAndCreateImageScanTaskResponse({}));
  }

  async publicSyncAndCreateImageScanTask(request: PublicSyncAndCreateImageScanTaskRequest): Promise<PublicSyncAndCreateImageScanTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.publicSyncAndCreateImageScanTaskWithOptions(request, runtime);
  }

  async queryAttackCountWithOptions(request: QueryAttackCountRequest, runtime: $Util.RuntimeOptions): Promise<QueryAttackCountResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.from)) {
      body["From"] = request.from;
    }

    if (!Util.isUnset(request.lang)) {
      body["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryAttackCount",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryAttackCountResponse>(await this.callApi(params, req, runtime), new QueryAttackCountResponse({}));
  }

  async queryAttackCount(request: QueryAttackCountRequest): Promise<QueryAttackCountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryAttackCountWithOptions(request, runtime);
  }

  async queryDiscoverDatabaseWithOptions(request: QueryDiscoverDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<QueryDiscoverDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.createMark)) {
      query["CreateMark"] = request.createMark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryDiscoverDatabase",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryDiscoverDatabaseResponse>(await this.callApi(params, req, runtime), new QueryDiscoverDatabaseResponse({}));
  }

  async queryDiscoverDatabase(request: QueryDiscoverDatabaseRequest): Promise<QueryDiscoverDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryDiscoverDatabaseWithOptions(request, runtime);
  }

  /**
    * You can call the QueryGroupIdByGroupName operation to query the ID of an asset group to which your assets belong by using the name of the asset group. When you call operations such as [GetSuspiciousStatistics](~~GetSuspiciousStatistics~~) and [DeleteGroup](~~DeleteGroup~~), you must specify the ID of the asset group. To query the ID of an asset group, call the QueryGroupIdByGroupName operation.
    * ### Limits
    * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
    *
    * @param request QueryGroupIdByGroupNameRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return QueryGroupIdByGroupNameResponse
   */
  async queryGroupIdByGroupNameWithOptions(request: QueryGroupIdByGroupNameRequest, runtime: $Util.RuntimeOptions): Promise<QueryGroupIdByGroupNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.groupName)) {
      query["GroupName"] = request.groupName;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryGroupIdByGroupName",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryGroupIdByGroupNameResponse>(await this.callApi(params, req, runtime), new QueryGroupIdByGroupNameResponse({}));
  }

  /**
    * You can call the QueryGroupIdByGroupName operation to query the ID of an asset group to which your assets belong by using the name of the asset group. When you call operations such as [GetSuspiciousStatistics](~~GetSuspiciousStatistics~~) and [DeleteGroup](~~DeleteGroup~~), you must specify the ID of the asset group. To query the ID of an asset group, call the QueryGroupIdByGroupName operation.
    * ### Limits
    * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
    *
    * @param request QueryGroupIdByGroupNameRequest
    * @return QueryGroupIdByGroupNameResponse
   */
  async queryGroupIdByGroupName(request: QueryGroupIdByGroupNameRequest): Promise<QueryGroupIdByGroupNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryGroupIdByGroupNameWithOptions(request, runtime);
  }

  async queryGroupedSecurityEventMarkMissListWithOptions(request: QueryGroupedSecurityEventMarkMissListRequest, runtime: $Util.RuntimeOptions): Promise<QueryGroupedSecurityEventMarkMissListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.disposalWay)) {
      query["DisposalWay"] = request.disposalWay;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.currentPage)) {
      body["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.eventName)) {
      body["EventName"] = request.eventName;
    }

    if (!Util.isUnset(request.from)) {
      body["From"] = request.from;
    }

    if (!Util.isUnset(request.lang)) {
      body["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.remark)) {
      body["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryGroupedSecurityEventMarkMissList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryGroupedSecurityEventMarkMissListResponse>(await this.callApi(params, req, runtime), new QueryGroupedSecurityEventMarkMissListResponse({}));
  }

  async queryGroupedSecurityEventMarkMissList(request: QueryGroupedSecurityEventMarkMissListRequest): Promise<QueryGroupedSecurityEventMarkMissListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryGroupedSecurityEventMarkMissListWithOptions(request, runtime);
  }

  async queryJenkinsImageRegistryPersistenceDayWithOptions(request: QueryJenkinsImageRegistryPersistenceDayRequest, runtime: $Util.RuntimeOptions): Promise<QueryJenkinsImageRegistryPersistenceDayResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryJenkinsImageRegistryPersistenceDay",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryJenkinsImageRegistryPersistenceDayResponse>(await this.callApi(params, req, runtime), new QueryJenkinsImageRegistryPersistenceDayResponse({}));
  }

  async queryJenkinsImageRegistryPersistenceDay(request: QueryJenkinsImageRegistryPersistenceDayRequest): Promise<QueryJenkinsImageRegistryPersistenceDayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryJenkinsImageRegistryPersistenceDayWithOptions(request, runtime);
  }

  async queryPreCheckDatabaseWithOptions(request: QueryPreCheckDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<QueryPreCheckDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.instanceUuid)) {
      query["InstanceUuid"] = request.instanceUuid;
    }

    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    if (!Util.isUnset(request.uniRegionId)) {
      query["UniRegionId"] = request.uniRegionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "QueryPreCheckDatabase",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryPreCheckDatabaseResponse>(await this.callApi(params, req, runtime), new QueryPreCheckDatabaseResponse({}));
  }

  async queryPreCheckDatabase(request: QueryPreCheckDatabaseRequest): Promise<QueryPreCheckDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryPreCheckDatabaseWithOptions(request, runtime);
  }

  async rebootMachineWithOptions(request: RebootMachineRequest, runtime: $Util.RuntimeOptions): Promise<RebootMachineResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RebootMachine",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RebootMachineResponse>(await this.callApi(params, req, runtime), new RebootMachineResponse({}));
  }

  async rebootMachine(request: RebootMachineRequest): Promise<RebootMachineResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rebootMachineWithOptions(request, runtime);
  }

  async refreshAssetsWithOptions(request: RefreshAssetsRequest, runtime: $Util.RuntimeOptions): Promise<RefreshAssetsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.assetType)) {
      query["AssetType"] = request.assetType;
    }

    if (!Util.isUnset(request.cloudAssetSubType)) {
      query["CloudAssetSubType"] = request.cloudAssetSubType;
    }

    if (!Util.isUnset(request.cloudAssetType)) {
      query["CloudAssetType"] = request.cloudAssetType;
    }

    if (!Util.isUnset(request.vendor)) {
      query["Vendor"] = request.vendor;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RefreshAssets",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RefreshAssetsResponse>(await this.callApi(params, req, runtime), new RefreshAssetsResponse({}));
  }

  async refreshAssets(request: RefreshAssetsRequest): Promise<RefreshAssetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshAssetsWithOptions(request, runtime);
  }

  async refreshContainerAssetsWithOptions(request: RefreshContainerAssetsRequest, runtime: $Util.RuntimeOptions): Promise<RefreshContainerAssetsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.assetType)) {
      query["AssetType"] = request.assetType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RefreshContainerAssets",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RefreshContainerAssetsResponse>(await this.callApi(params, req, runtime), new RefreshContainerAssetsResponse({}));
  }

  async refreshContainerAssets(request: RefreshContainerAssetsRequest): Promise<RefreshContainerAssetsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshContainerAssetsWithOptions(request, runtime);
  }

  async refreshOssBucketScanInfoWithOptions(runtime: $Util.RuntimeOptions): Promise<RefreshOssBucketScanInfoResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "RefreshOssBucketScanInfo",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RefreshOssBucketScanInfoResponse>(await this.callApi(params, req, runtime), new RefreshOssBucketScanInfoResponse({}));
  }

  async refreshOssBucketScanInfo(): Promise<RefreshOssBucketScanInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.refreshOssBucketScanInfoWithOptions(runtime);
  }

  async removeCheckInstanceResultWhiteListWithOptions(request: RemoveCheckInstanceResultWhiteListRequest, runtime: $Util.RuntimeOptions): Promise<RemoveCheckInstanceResultWhiteListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkId)) {
      query["CheckId"] = request.checkId;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveCheckInstanceResultWhiteList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveCheckInstanceResultWhiteListResponse>(await this.callApi(params, req, runtime), new RemoveCheckInstanceResultWhiteListResponse({}));
  }

  async removeCheckInstanceResultWhiteList(request: RemoveCheckInstanceResultWhiteListRequest): Promise<RemoveCheckInstanceResultWhiteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeCheckInstanceResultWhiteListWithOptions(request, runtime);
  }

  async removeCheckResultWhiteListWithOptions(request: RemoveCheckResultWhiteListRequest, runtime: $Util.RuntimeOptions): Promise<RemoveCheckResultWhiteListResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkGroupId)) {
      query["CheckGroupId"] = request.checkGroupId;
    }

    if (!Util.isUnset(request.checkIds)) {
      query["CheckIds"] = request.checkIds;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RemoveCheckResultWhiteList",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RemoveCheckResultWhiteListResponse>(await this.callApi(params, req, runtime), new RemoveCheckResultWhiteListResponse({}));
  }

  async removeCheckResultWhiteList(request: RemoveCheckResultWhiteListRequest): Promise<RemoveCheckResultWhiteListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.removeCheckResultWhiteListWithOptions(request, runtime);
  }

  async retryAgentlessTaskWithOptions(request: RetryAgentlessTaskRequest, runtime: $Util.RuntimeOptions): Promise<RetryAgentlessTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.taskId)) {
      query["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RetryAgentlessTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RetryAgentlessTaskResponse>(await this.callApi(params, req, runtime), new RetryAgentlessTaskResponse({}));
  }

  async retryAgentlessTask(request: RetryAgentlessTaskRequest): Promise<RetryAgentlessTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.retryAgentlessTaskWithOptions(request, runtime);
  }

  async retryInstallProbeWithOptions(request: RetryInstallProbeRequest, runtime: $Util.RuntimeOptions): Promise<RetryInstallProbeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.probeId)) {
      query["ProbeId"] = request.probeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RetryInstallProbe",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RetryInstallProbeResponse>(await this.callApi(params, req, runtime), new RetryInstallProbeResponse({}));
  }

  async retryInstallProbe(request: RetryInstallProbeRequest): Promise<RetryInstallProbeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.retryInstallProbeWithOptions(request, runtime);
  }

  async rollbackSuspEventQuaraFileWithOptions(request: RollbackSuspEventQuaraFileRequest, runtime: $Util.RuntimeOptions): Promise<RollbackSuspEventQuaraFileResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.quaraFileId)) {
      query["QuaraFileId"] = request.quaraFileId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "RollbackSuspEventQuaraFile",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RollbackSuspEventQuaraFileResponse>(await this.callApi(params, req, runtime), new RollbackSuspEventQuaraFileResponse({}));
  }

  async rollbackSuspEventQuaraFile(request: RollbackSuspEventQuaraFileRequest): Promise<RollbackSuspEventQuaraFileResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rollbackSuspEventQuaraFileWithOptions(request, runtime);
  }

  async sasInstallCodeWithOptions(request: SasInstallCodeRequest, runtime: $Util.RuntimeOptions): Promise<SasInstallCodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SasInstallCode",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SasInstallCodeResponse>(await this.callApi(params, req, runtime), new SasInstallCodeResponse({}));
  }

  async sasInstallCode(request: SasInstallCodeRequest): Promise<SasInstallCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.sasInstallCodeWithOptions(request, runtime);
  }

  async saveImageBaselineStrategyWithOptions(request: SaveImageBaselineStrategyRequest, runtime: $Util.RuntimeOptions): Promise<SaveImageBaselineStrategyResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.baselineItemList)) {
      query["BaselineItemList"] = request.baselineItemList;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.strategyId)) {
      query["StrategyId"] = request.strategyId;
    }

    if (!Util.isUnset(request.strategyName)) {
      query["StrategyName"] = request.strategyName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SaveImageBaselineStrategy",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SaveImageBaselineStrategyResponse>(await this.callApi(params, req, runtime), new SaveImageBaselineStrategyResponse({}));
  }

  async saveImageBaselineStrategy(request: SaveImageBaselineStrategyRequest): Promise<SaveImageBaselineStrategyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.saveImageBaselineStrategyWithOptions(request, runtime);
  }

  async saveSuspEventUserSettingWithOptions(request: SaveSuspEventUserSettingRequest, runtime: $Util.RuntimeOptions): Promise<SaveSuspEventUserSettingResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.from)) {
      query["From"] = request.from;
    }

    if (!Util.isUnset(request.levelsOn)) {
      query["LevelsOn"] = request.levelsOn;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SaveSuspEventUserSetting",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SaveSuspEventUserSettingResponse>(await this.callApi(params, req, runtime), new SaveSuspEventUserSettingResponse({}));
  }

  async saveSuspEventUserSetting(request: SaveSuspEventUserSettingRequest): Promise<SaveSuspEventUserSettingResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.saveSuspEventUserSettingWithOptions(request, runtime);
  }

  async setClusterInterceptionConfigWithOptions(request: SetClusterInterceptionConfigRequest, runtime: $Util.RuntimeOptions): Promise<SetClusterInterceptionConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.clusterIds)) {
      query["ClusterIds"] = request.clusterIds;
    }

    if (!Util.isUnset(request.switchOn)) {
      query["SwitchOn"] = request.switchOn;
    }

    if (!Util.isUnset(request.switchType)) {
      query["SwitchType"] = request.switchType;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetClusterInterceptionConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetClusterInterceptionConfigResponse>(await this.callApi(params, req, runtime), new SetClusterInterceptionConfigResponse({}));
  }

  async setClusterInterceptionConfig(request: SetClusterInterceptionConfigRequest): Promise<SetClusterInterceptionConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setClusterInterceptionConfigWithOptions(request, runtime);
  }

  async setImageSensitiveFileStatusWithOptions(request: SetImageSensitiveFileStatusRequest, runtime: $Util.RuntimeOptions): Promise<SetImageSensitiveFileStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.imageUuids)) {
      query["ImageUuids"] = request.imageUuids;
    }

    if (!Util.isUnset(request.sensitiveFileKey)) {
      query["SensitiveFileKey"] = request.sensitiveFileKey;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetImageSensitiveFileStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetImageSensitiveFileStatusResponse>(await this.callApi(params, req, runtime), new SetImageSensitiveFileStatusResponse({}));
  }

  async setImageSensitiveFileStatus(request: SetImageSensitiveFileStatusRequest): Promise<SetImageSensitiveFileStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setImageSensitiveFileStatusWithOptions(request, runtime);
  }

  async setRegistryScanDayNumWithOptions(request: SetRegistryScanDayNumRequest, runtime: $Util.RuntimeOptions): Promise<SetRegistryScanDayNumResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.scanDayNum)) {
      query["ScanDayNum"] = request.scanDayNum;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetRegistryScanDayNum",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetRegistryScanDayNumResponse>(await this.callApi(params, req, runtime), new SetRegistryScanDayNumResponse({}));
  }

  async setRegistryScanDayNum(request: SetRegistryScanDayNumRequest): Promise<SetRegistryScanDayNumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setRegistryScanDayNumWithOptions(request, runtime);
  }

  async setSensitiveDefineRuleConfigWithOptions(request: SetSensitiveDefineRuleConfigRequest, runtime: $Util.RuntimeOptions): Promise<SetSensitiveDefineRuleConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.config)) {
      query["Config"] = request.config;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SetSensitiveDefineRuleConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SetSensitiveDefineRuleConfigResponse>(await this.callApi(params, req, runtime), new SetSensitiveDefineRuleConfigResponse({}));
  }

  async setSensitiveDefineRuleConfig(request: SetSensitiveDefineRuleConfigRequest): Promise<SetSensitiveDefineRuleConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.setSensitiveDefineRuleConfigWithOptions(request, runtime);
  }

  /**
    * @deprecated
    *
    * @param request StartBaselineSecurityCheckRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return StartBaselineSecurityCheckResponse
   */
  // Deprecated
  async startBaselineSecurityCheckWithOptions(request: StartBaselineSecurityCheckRequest, runtime: $Util.RuntimeOptions): Promise<StartBaselineSecurityCheckResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.itemIds)) {
      query["ItemIds"] = request.itemIds;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.resourceOwnerId)) {
      query["ResourceOwnerId"] = request.resourceOwnerId;
    }

    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartBaselineSecurityCheck",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartBaselineSecurityCheckResponse>(await this.callApi(params, req, runtime), new StartBaselineSecurityCheckResponse({}));
  }

  /**
    * @deprecated
    *
    * @param request StartBaselineSecurityCheckRequest
    * @return StartBaselineSecurityCheckResponse
   */
  // Deprecated
  async startBaselineSecurityCheck(request: StartBaselineSecurityCheckRequest): Promise<StartBaselineSecurityCheckResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startBaselineSecurityCheckWithOptions(request, runtime);
  }

  async startDiscoverDatabaseTaskWithOptions(runtime: $Util.RuntimeOptions): Promise<StartDiscoverDatabaseTaskResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "StartDiscoverDatabaseTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartDiscoverDatabaseTaskResponse>(await this.callApi(params, req, runtime), new StartDiscoverDatabaseTaskResponse({}));
  }

  async startDiscoverDatabaseTask(): Promise<StartDiscoverDatabaseTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startDiscoverDatabaseTaskWithOptions(runtime);
  }

  async startPreCheckDatabaseWithOptions(request: StartPreCheckDatabaseRequest, runtime: $Util.RuntimeOptions): Promise<StartPreCheckDatabaseResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.databaseType)) {
      query["DatabaseType"] = request.databaseType;
    }

    if (!Util.isUnset(request.instanceUuid)) {
      query["InstanceUuid"] = request.instanceUuid;
    }

    if (!Util.isUnset(request.uniRegionId)) {
      query["UniRegionId"] = request.uniRegionId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartPreCheckDatabase",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartPreCheckDatabaseResponse>(await this.callApi(params, req, runtime), new StartPreCheckDatabaseResponse({}));
  }

  async startPreCheckDatabase(request: StartPreCheckDatabaseRequest): Promise<StartPreCheckDatabaseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startPreCheckDatabaseWithOptions(request, runtime);
  }

  async startVirusScanTaskWithOptions(request: StartVirusScanTaskRequest, runtime: $Util.RuntimeOptions): Promise<StartVirusScanTaskResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.targetInfo)) {
      query["TargetInfo"] = request.targetInfo;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StartVirusScanTask",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartVirusScanTaskResponse>(await this.callApi(params, req, runtime), new StartVirusScanTaskResponse({}));
  }

  async startVirusScanTask(request: StartVirusScanTaskRequest): Promise<StartVirusScanTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startVirusScanTaskWithOptions(request, runtime);
  }

  async stopHoneypotWithOptions(request: StopHoneypotRequest, runtime: $Util.RuntimeOptions): Promise<StopHoneypotResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.honeypotId)) {
      query["HoneypotId"] = request.honeypotId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "StopHoneypot",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StopHoneypotResponse>(await this.callApi(params, req, runtime), new StopHoneypotResponse({}));
  }

  async stopHoneypot(request: StopHoneypotRequest): Promise<StopHoneypotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.stopHoneypotWithOptions(request, runtime);
  }

  async submitCheckWithOptions(request: SubmitCheckRequest, runtime: $Util.RuntimeOptions): Promise<SubmitCheckResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.scanRange)) {
      query["ScanRange"] = request.scanRange;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "SubmitCheck",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SubmitCheckResponse>(await this.callApi(params, req, runtime), new SubmitCheckResponse({}));
  }

  async submitCheck(request: SubmitCheckRequest): Promise<SubmitCheckResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitCheckWithOptions(request, runtime);
  }

  /**
    * If you no longer require protection for servers that are not deployed on Alibaba Cloud, you can call this operation to unbind the servers from Security Center. After you unbind a server that is not deployed on Alibaba Cloud from Security Center, the server no longer consumes the quota of protected servers or protected server vCPUs. This way, you can install the Security Center agent on other servers to meet your business requirements.
    * > You can unbind only the servers that are not deployed on Alibaba Cloud from Security Center. If you use an Alibaba Cloud Elastic Compute Service (ECS) instance, you do not need to unbind the ECS instance. If you uninstall the Security Center agent from an ECS instance, the ECS instance still exists as a disconnected server in the asset list of the Security Center console. The ECS instance is not removed from the asset list.
    * **Prerequisites**
    * *   The server that you want to unbind from Security Center is not deployed on Alibaba Cloud and the Security Center agent is disabled for the server. In this case, the agent is in the Close state and Security Center does not protect the server. You can call the [PauseClient](~~PauseClient~~) operation to disable the agent.
    * *   The client protection feature is disabled for the server that you want to unbind from Security Center. For more information about how to disable the client protection feature, see [Use the client protection feature](https://www.alibabacloud.com/help/en/security-center/latest/local-file-detection-engine).
    *
    * @param request UnbindAegisRequest
    * @param runtime runtime options for this request RuntimeOptions
    * @return UnbindAegisResponse
   */
  async unbindAegisWithOptions(request: UnbindAegisRequest, runtime: $Util.RuntimeOptions): Promise<UnbindAegisResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UnbindAegis",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnbindAegisResponse>(await this.callApi(params, req, runtime), new UnbindAegisResponse({}));
  }

  /**
    * If you no longer require protection for servers that are not deployed on Alibaba Cloud, you can call this operation to unbind the servers from Security Center. After you unbind a server that is not deployed on Alibaba Cloud from Security Center, the server no longer consumes the quota of protected servers or protected server vCPUs. This way, you can install the Security Center agent on other servers to meet your business requirements.
    * > You can unbind only the servers that are not deployed on Alibaba Cloud from Security Center. If you use an Alibaba Cloud Elastic Compute Service (ECS) instance, you do not need to unbind the ECS instance. If you uninstall the Security Center agent from an ECS instance, the ECS instance still exists as a disconnected server in the asset list of the Security Center console. The ECS instance is not removed from the asset list.
    * **Prerequisites**
    * *   The server that you want to unbind from Security Center is not deployed on Alibaba Cloud and the Security Center agent is disabled for the server. In this case, the agent is in the Close state and Security Center does not protect the server. You can call the [PauseClient](~~PauseClient~~) operation to disable the agent.
    * *   The client protection feature is disabled for the server that you want to unbind from Security Center. For more information about how to disable the client protection feature, see [Use the client protection feature](https://www.alibabacloud.com/help/en/security-center/latest/local-file-detection-engine).
    *
    * @param request UnbindAegisRequest
    * @return UnbindAegisResponse
   */
  async unbindAegis(request: UnbindAegisRequest): Promise<UnbindAegisResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unbindAegisWithOptions(request, runtime);
  }

  async uninstallBackupClientWithOptions(request: UninstallBackupClientRequest, runtime: $Util.RuntimeOptions): Promise<UninstallBackupClientResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyVersion)) {
      query["PolicyVersion"] = request.policyVersion;
    }

    if (!Util.isUnset(request.uuid)) {
      query["Uuid"] = request.uuid;
    }

    if (!Util.isUnset(request.uuidList)) {
      query["UuidList"] = request.uuidList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UninstallBackupClient",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UninstallBackupClientResponse>(await this.callApi(params, req, runtime), new UninstallBackupClientResponse({}));
  }

  async uninstallBackupClient(request: UninstallBackupClientRequest): Promise<UninstallBackupClientResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.uninstallBackupClientWithOptions(request, runtime);
  }

  async uninstallRaspAttachWithOptions(request: UninstallRaspAttachRequest, runtime: $Util.RuntimeOptions): Promise<UninstallRaspAttachResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.applicationId)) {
      query["ApplicationId"] = request.applicationId;
    }

    if (!Util.isUnset(request.ecsUUIDList)) {
      query["EcsUUIDList"] = request.ecsUUIDList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UninstallRaspAttach",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UninstallRaspAttachResponse>(await this.callApi(params, req, runtime), new UninstallRaspAttachResponse({}));
  }

  async uninstallRaspAttach(request: UninstallRaspAttachRequest): Promise<UninstallRaspAttachResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.uninstallRaspAttachWithOptions(request, runtime);
  }

  async uninstallUniBackupAgentWithOptions(request: UninstallUniBackupAgentRequest, runtime: $Util.RuntimeOptions): Promise<UninstallUniBackupAgentResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.policyId)) {
      query["PolicyId"] = request.policyId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UninstallUniBackupAgent",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UninstallUniBackupAgentResponse>(await this.callApi(params, req, runtime), new UninstallUniBackupAgentResponse({}));
  }

  async uninstallUniBackupAgent(request: UninstallUniBackupAgentRequest): Promise<UninstallUniBackupAgentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.uninstallUniBackupAgentWithOptions(request, runtime);
  }

  async updateAlarmEventWithOptions(request: UpdateAlarmEventRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAlarmEventResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alarmEventIdList)) {
      body["AlarmEventIdList"] = request.alarmEventIdList;
    }

    if (!Util.isUnset(request.lang)) {
      body["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.operationCode)) {
      body["OperationCode"] = request.operationCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAlarmEvent",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateAlarmEventResponse>(await this.callApi(params, req, runtime), new UpdateAlarmEventResponse({}));
  }

  async updateAlarmEvent(request: UpdateAlarmEventRequest): Promise<UpdateAlarmEventResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAlarmEventWithOptions(request, runtime);
  }

  async updateClientAlertModeWithOptions(request: UpdateClientAlertModeRequest, runtime: $Util.RuntimeOptions): Promise<UpdateClientAlertModeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.mode)) {
      query["Mode"] = request.mode;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateClientAlertMode",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateClientAlertModeResponse>(await this.callApi(params, req, runtime), new UpdateClientAlertModeResponse({}));
  }

  async updateClientAlertMode(request: UpdateClientAlertModeRequest): Promise<UpdateClientAlertModeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateClientAlertModeWithOptions(request, runtime);
  }

  async updateCommonSwitchConfigWithOptions(request: UpdateCommonSwitchConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateCommonSwitchConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.targetDefault)) {
      query["TargetDefault"] = request.targetDefault;
    }

    if (!Util.isUnset(request.type)) {
      query["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateCommonSwitchConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateCommonSwitchConfigResponse>(await this.callApi(params, req, runtime), new UpdateCommonSwitchConfigResponse({}));
  }

  async updateCommonSwitchConfig(request: UpdateCommonSwitchConfigRequest): Promise<UpdateCommonSwitchConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateCommonSwitchConfigWithOptions(request, runtime);
  }

  async updateFileProtectEventStatusWithOptions(request: UpdateFileProtectEventStatusRequest, runtime: $Util.RuntimeOptions): Promise<UpdateFileProtectEventStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFileProtectEventStatus",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateFileProtectEventStatusResponse>(await this.callApi(params, req, runtime), new UpdateFileProtectEventStatusResponse({}));
  }

  async updateFileProtectEventStatus(request: UpdateFileProtectEventStatusRequest): Promise<UpdateFileProtectEventStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateFileProtectEventStatusWithOptions(request, runtime);
  }

  async updateFileProtectRemarkWithOptions(request: UpdateFileProtectRemarkRequest, runtime: $Util.RuntimeOptions): Promise<UpdateFileProtectRemarkResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.remark)) {
      query["Remark"] = request.remark;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFileProtectRemark",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateFileProtectRemarkResponse>(await this.callApi(params, req, runtime), new UpdateFileProtectRemarkResponse({}));
  }

  async updateFileProtectRemark(request: UpdateFileProtectRemarkRequest): Promise<UpdateFileProtectRemarkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateFileProtectRemarkWithOptions(request, runtime);
  }

  async updateFileProtectRuleWithOptions(request: UpdateFileProtectRuleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateFileProtectRuleResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.alertLevel)) {
      query["AlertLevel"] = request.alertLevel;
    }

    if (!Util.isUnset(request.fileOps)) {
      query["FileOps"] = request.fileOps;
    }

    if (!Util.isUnset(request.filePaths)) {
      query["FilePaths"] = request.filePaths;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.procPaths)) {
      query["ProcPaths"] = request.procPaths;
    }

    if (!Util.isUnset(request.ruleAction)) {
      query["RuleAction"] = request.ruleAction;
    }

    if (!Util.isUnset(request.ruleName)) {
      query["RuleName"] = request.ruleName;
    }

    if (!Util.isUnset(request.status)) {
      query["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFileProtectRule",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateFileProtectRuleResponse>(await this.callApi(params, req, runtime), new UpdateFileProtectRuleResponse({}));
  }

  async updateFileProtectRule(request: UpdateFileProtectRuleRequest): Promise<UpdateFileProtectRuleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateFileProtectRuleWithOptions(request, runtime);
  }

  async updateFileUploadLimitWithOptions(request: UpdateFileUploadLimitRequest, runtime: $Util.RuntimeOptions): Promise<UpdateFileUploadLimitResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.limit)) {
      query["Limit"] = request.limit;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateFileUploadLimit",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateFileUploadLimitResponse>(await this.callApi(params, req, runtime), new UpdateFileUploadLimitResponse({}));
  }

  async updateFileUploadLimit(request: UpdateFileUploadLimitRequest): Promise<UpdateFileUploadLimitResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateFileUploadLimitWithOptions(request, runtime);
  }

  async updateHoneypotWithOptions(request: UpdateHoneypotRequest, runtime: $Util.RuntimeOptions): Promise<UpdateHoneypotResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.honeypotId)) {
      query["HoneypotId"] = request.honeypotId;
    }

    if (!Util.isUnset(request.honeypotName)) {
      query["HoneypotName"] = request.honeypotName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.meta)) {
      query["Meta"] = request.meta;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateHoneypot",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateHoneypotResponse>(await this.callApi(params, req, runtime), new UpdateHoneypotResponse({}));
  }

  async updateHoneypot(request: UpdateHoneypotRequest): Promise<UpdateHoneypotResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateHoneypotWithOptions(request, runtime);
  }

  async updateHoneypotNodeWithOptions(request: UpdateHoneypotNodeRequest, runtime: $Util.RuntimeOptions): Promise<UpdateHoneypotNodeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.availableProbeNum)) {
      query["AvailableProbeNum"] = request.availableProbeNum;
    }

    if (!Util.isUnset(request.nodeId)) {
      query["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeName)) {
      query["NodeName"] = request.nodeName;
    }

    if (!Util.isUnset(request.securityGroupProbeIpList)) {
      query["SecurityGroupProbeIpList"] = request.securityGroupProbeIpList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateHoneypotNode",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateHoneypotNodeResponse>(await this.callApi(params, req, runtime), new UpdateHoneypotNodeResponse({}));
  }

  async updateHoneypotNode(request: UpdateHoneypotNodeRequest): Promise<UpdateHoneypotNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateHoneypotNodeWithOptions(request, runtime);
  }

  async updateHoneypotPresetWithOptions(request: UpdateHoneypotPresetRequest, runtime: $Util.RuntimeOptions): Promise<UpdateHoneypotPresetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.honeypotImageName)) {
      query["HoneypotImageName"] = request.honeypotImageName;
    }

    if (!Util.isUnset(request.honeypotPresetId)) {
      query["HoneypotPresetId"] = request.honeypotPresetId;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.meta)) {
      query["Meta"] = request.meta;
    }

    if (!Util.isUnset(request.presetName)) {
      query["PresetName"] = request.presetName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateHoneypotPreset",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateHoneypotPresetResponse>(await this.callApi(params, req, runtime), new UpdateHoneypotPresetResponse({}));
  }

  async updateHoneypotPreset(request: UpdateHoneypotPresetRequest): Promise<UpdateHoneypotPresetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateHoneypotPresetWithOptions(request, runtime);
  }

  async updateHoneypotProbeWithOptions(request: UpdateHoneypotProbeRequest, runtime: $Util.RuntimeOptions): Promise<UpdateHoneypotProbeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.arp)) {
      query["Arp"] = request.arp;
    }

    if (!Util.isUnset(request.displayName)) {
      query["DisplayName"] = request.displayName;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.ping)) {
      query["Ping"] = request.ping;
    }

    if (!Util.isUnset(request.probeId)) {
      query["ProbeId"] = request.probeId;
    }

    if (!Util.isUnset(request.serviceIpList)) {
      query["ServiceIpList"] = request.serviceIpList;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateHoneypotProbe",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateHoneypotProbeResponse>(await this.callApi(params, req, runtime), new UpdateHoneypotProbeResponse({}));
  }

  async updateHoneypotProbe(request: UpdateHoneypotProbeRequest): Promise<UpdateHoneypotProbeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateHoneypotProbeWithOptions(request, runtime);
  }

  async updateHoneypotProbeBindWithOptions(request: UpdateHoneypotProbeBindRequest, runtime: $Util.RuntimeOptions): Promise<UpdateHoneypotProbeBindResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bindId)) {
      query["BindId"] = request.bindId;
    }

    if (!Util.isUnset(request.bindPortList)) {
      query["BindPortList"] = request.bindPortList;
    }

    if (!Util.isUnset(request.bindType)) {
      query["BindType"] = request.bindType;
    }

    if (!Util.isUnset(request.currentPage)) {
      query["CurrentPage"] = request.currentPage;
    }

    if (!Util.isUnset(request.honeypotId)) {
      query["HoneypotId"] = request.honeypotId;
    }

    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.pageSize)) {
      query["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.ports)) {
      query["Ports"] = request.ports;
    }

    if (!Util.isUnset(request.probeId)) {
      query["ProbeId"] = request.probeId;
    }

    if (!Util.isUnset(request.serviceIpList)) {
      query["ServiceIpList"] = request.serviceIpList;
    }

    if (!Util.isUnset(request.setStatus)) {
      query["SetStatus"] = request.setStatus;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateHoneypotProbeBind",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateHoneypotProbeBindResponse>(await this.callApi(params, req, runtime), new UpdateHoneypotProbeBindResponse({}));
  }

  async updateHoneypotProbeBind(request: UpdateHoneypotProbeBindRequest): Promise<UpdateHoneypotProbeBindResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateHoneypotProbeBindWithOptions(request, runtime);
  }

  async updateImageEventOperationWithOptions(request: UpdateImageEventOperationRequest, runtime: $Util.RuntimeOptions): Promise<UpdateImageEventOperationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.scenarios)) {
      query["Scenarios"] = request.scenarios;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateImageEventOperation",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateImageEventOperationResponse>(await this.callApi(params, req, runtime), new UpdateImageEventOperationResponse({}));
  }

  async updateImageEventOperation(request: UpdateImageEventOperationRequest): Promise<UpdateImageEventOperationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateImageEventOperationWithOptions(request, runtime);
  }

  async updateImageVulWhitelistTargetWithOptions(request: UpdateImageVulWhitelistTargetRequest, runtime: $Util.RuntimeOptions): Promise<UpdateImageVulWhitelistTargetResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    if (!Util.isUnset(request.lang)) {
      query["Lang"] = request.lang;
    }

    if (!Util.isUnset(request.reason)) {
      query["Reason"] = request.reason;
    }

    if (!Util.isUnset(request.source)) {
      query["Source"] = request.source;
    }

    if (!Util.isUnset(request.target)) {
      query["Target"] = request.target;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateImageVulWhitelistTarget",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateImageVulWhitelistTargetResponse>(await this.callApi(params, req, runtime), new UpdateImageVulWhitelistTargetResponse({}));
  }

  async updateImageVulWhitelistTarget(request: UpdateImageVulWhitelistTargetRequest): Promise<UpdateImageVulWhitelistTargetResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateImageVulWhitelistTargetWithOptions(request, runtime);
  }

  async updateJenkinsImageRegistryNameWithOptions(request: UpdateJenkinsImageRegistryNameRequest, runtime: $Util.RuntimeOptions): Promise<UpdateJenkinsImageRegistryNameResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.registryId)) {
      body["RegistryId"] = request.registryId;
    }

    if (!Util.isUnset(request.registryName)) {
      body["RegistryName"] = request.registryName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateJenkinsImageRegistryName",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateJenkinsImageRegistryNameResponse>(await this.callApi(params, req, runtime), new UpdateJenkinsImageRegistryNameResponse({}));
  }

  async updateJenkinsImageRegistryName(request: UpdateJenkinsImageRegistryNameRequest): Promise<UpdateJenkinsImageRegistryNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateJenkinsImageRegistryNameWithOptions(request, runtime);
  }

  async updateJenkinsImageRegistryPersistenceDayWithOptions(request: UpdateJenkinsImageRegistryPersistenceDayRequest, runtime: $Util.RuntimeOptions): Promise<UpdateJenkinsImageRegistryPersistenceDayResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.sourceIp)) {
      query["SourceIp"] = request.sourceIp;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.persistenceDay)) {
      body["PersistenceDay"] = request.persistenceDay;
    }

    if (!Util.isUnset(request.registryId)) {
      body["RegistryId"] = request.registryId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateJenkinsImageRegistryPersistenceDay",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateJenkinsImageRegistryPersistenceDayResponse>(await this.callApi(params, req, runtime), new UpdateJenkinsImageRegistryPersistenceDayResponse({}));
  }

  async updateJenkinsImageRegistryPersistenceDay(request: UpdateJenkinsImageRegistryPersistenceDayRequest): Promise<UpdateJenkinsImageRegistryPersistenceDayResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateJenkinsImageRegistryPersistenceDayWithOptions(request, runtime);
  }

  async updateOssScanConfigWithOptions(request: UpdateOssScanConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateOssScanConfigResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bucketNameList)) {
      query["BucketNameList"] = request.bucketNameList;
    }

    if (!Util.isUnset(request.enable)) {
      query["Enable"] = request.enable;
    }

    if (!Util.isUnset(request.endTime)) {
      query["EndTime"] = request.endTime;
    }

    if (!Util.isUnset(request.keySuffixList)) {
      query["KeySuffixList"] = request.keySuffixList;
    }

    if (!Util.isUnset(request.scanDayList)) {
      query["ScanDayList"] = request.scanDayList;
    }

    if (!Util.isUnset(request.startTime)) {
      query["StartTime"] = request.startTime;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateOssScanConfig",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateOssScanConfigResponse>(await this.callApi(params, req, runtime), new UpdateOssScanConfigResponse({}));
  }

  async updateOssScanConfig(request: UpdateOssScanConfigRequest): Promise<UpdateOssScanConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateOssScanConfigWithOptions(request, runtime);
  }

  async updateSelectionKeyByTypeWithOptions(request: UpdateSelectionKeyByTypeRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSelectionKeyByTypeResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.businessType)) {
      query["BusinessType"] = request.businessType;
    }

    if (!Util.isUnset(request.selectionKey)) {
      query["SelectionKey"] = request.selectionKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSelectionKeyByType",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSelectionKeyByTypeResponse>(await this.callApi(params, req, runtime), new UpdateSelectionKeyByTypeResponse({}));
  }

  async updateSelectionKeyByType(request: UpdateSelectionKeyByTypeRequest): Promise<UpdateSelectionKeyByTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSelectionKeyByTypeWithOptions(request, runtime);
  }

  async upgradeBackupPolicyVersionWithOptions(request: UpgradeBackupPolicyVersionRequest, runtime: $Util.RuntimeOptions): Promise<UpgradeBackupPolicyVersionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.id)) {
      query["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UpgradeBackupPolicyVersion",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpgradeBackupPolicyVersionResponse>(await this.callApi(params, req, runtime), new UpgradeBackupPolicyVersionResponse({}));
  }

  async upgradeBackupPolicyVersion(request: UpgradeBackupPolicyVersionRequest): Promise<UpgradeBackupPolicyVersionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.upgradeBackupPolicyVersionWithOptions(request, runtime);
  }

  async validateHcWarningsWithOptions(request: ValidateHcWarningsRequest, runtime: $Util.RuntimeOptions): Promise<ValidateHcWarningsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkIds)) {
      query["CheckIds"] = request.checkIds;
    }

    if (!Util.isUnset(request.riskIds)) {
      query["RiskIds"] = request.riskIds;
    }

    if (!Util.isUnset(request.uuids)) {
      query["Uuids"] = request.uuids;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ValidateHcWarnings",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ValidateHcWarningsResponse>(await this.callApi(params, req, runtime), new ValidateHcWarningsResponse({}));
  }

  async validateHcWarnings(request: ValidateHcWarningsRequest): Promise<ValidateHcWarningsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.validateHcWarningsWithOptions(request, runtime);
  }

  async verifyCheckInstanceResultWithOptions(request: VerifyCheckInstanceResultRequest, runtime: $Util.RuntimeOptions): Promise<VerifyCheckInstanceResultResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkId)) {
      query["CheckId"] = request.checkId;
    }

    if (!Util.isUnset(request.instanceIds)) {
      query["InstanceIds"] = request.instanceIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "VerifyCheckInstanceResult",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<VerifyCheckInstanceResultResponse>(await this.callApi(params, req, runtime), new VerifyCheckInstanceResultResponse({}));
  }

  async verifyCheckInstanceResult(request: VerifyCheckInstanceResultRequest): Promise<VerifyCheckInstanceResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.verifyCheckInstanceResultWithOptions(request, runtime);
  }

  async verifyCheckResultWithOptions(request: VerifyCheckResultRequest, runtime: $Util.RuntimeOptions): Promise<VerifyCheckResultResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.checkIds)) {
      query["CheckIds"] = request.checkIds;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "VerifyCheckResult",
      version: "2018-12-03",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<VerifyCheckResultResponse>(await this.callApi(params, req, runtime), new VerifyCheckResultResponse({}));
  }

  async verifyCheckResult(request: VerifyCheckResultRequest): Promise<VerifyCheckResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.verifyCheckResultWithOptions(request, runtime);
  }

}
