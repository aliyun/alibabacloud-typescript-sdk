// This file is auto-generated, don't edit it
/**
 *
 */
import Util, * as $Util from '@alicloud/tea-util';
import OpenApi, * as $OpenApi from '@alicloud/openapi-client';
import OpenApiUtil from '@alicloud/openapi-util';
import EndpointUtil from '@alicloud/endpoint-util';
import * as $tea from '@alicloud/tea-typescript';

export class AntChainPurposeResponse extends $tea.Model {
  chainPurposeExtend?: string;
  chainPurposeItem?: string;
  createTime?: string;
  purpose?: string;
  recordList?: ChainPurpose[];
  status?: string;
  static names(): { [key: string]: string } {
    return {
      chainPurposeExtend: 'ChainPurposeExtend',
      chainPurposeItem: 'ChainPurposeItem',
      createTime: 'CreateTime',
      purpose: 'Purpose',
      recordList: 'RecordList',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chainPurposeExtend: 'string',
      chainPurposeItem: 'string',
      createTime: 'string',
      purpose: 'string',
      recordList: { 'type': 'array', 'itemType': ChainPurpose },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AntChainPurposeResponseAli extends $tea.Model {
  recordList?: ChainPurposeInfoAli[];
  status?: string;
  static names(): { [key: string]: string } {
    return {
      recordList: 'RecordList',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      recordList: { 'type': 'array', 'itemType': ChainPurposeInfoAli },
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChainPurpose extends $tea.Model {
  extend?: boolean;
  id?: string;
  item?: boolean;
  key?: string;
  name?: string;
  purposeItem?: string;
  status?: string;
  time?: string;
  static names(): { [key: string]: string } {
    return {
      extend: 'Extend',
      id: 'Id',
      item: 'Item',
      key: 'Key',
      name: 'Name',
      purposeItem: 'PurposeItem',
      status: 'Status',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extend: 'boolean',
      id: 'string',
      item: 'boolean',
      key: 'string',
      name: 'string',
      purposeItem: 'string',
      status: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChainPurposeInfoAli extends $tea.Model {
  chainPurposeExtend?: string;
  chainPurposeItem?: string;
  id?: string;
  key?: string;
  purpose?: string;
  status?: string;
  time?: string;
  static names(): { [key: string]: string } {
    return {
      chainPurposeExtend: 'ChainPurposeExtend',
      chainPurposeItem: 'ChainPurposeItem',
      id: 'Id',
      key: 'Key',
      purpose: 'Purpose',
      status: 'Status',
      time: 'Time',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chainPurposeExtend: 'string',
      chainPurposeItem: 'string',
      id: 'string',
      key: 'string',
      purpose: 'string',
      status: 'string',
      time: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ChainPurposeListAli extends $tea.Model {
  extend?: boolean;
  id?: string;
  item?: boolean;
  key?: string;
  purpose?: string;
  static names(): { [key: string]: string } {
    return {
      extend: 'Extend',
      id: 'Id',
      item: 'Item',
      key: 'Key',
      purpose: 'Purpose',
    };
  }

  static types(): { [key: string]: any } {
    return {
      extend: 'boolean',
      id: 'string',
      item: 'boolean',
      key: 'string',
      purpose: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckPointStructBody extends $tea.Model {
  errorCount?: string;
  height?: string;
  index?: string;
  lastError?: string;
  totalCount?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      errorCount: 'ErrorCount',
      height: 'Height',
      index: 'Index',
      lastError: 'LastError',
      totalCount: 'TotalCount',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCount: 'string',
      height: 'string',
      index: 'string',
      lastError: 'string',
      totalCount: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CommonResponsePageableStructBody extends $tea.Model {
  current?: string;
  list?: TriggerLogDTOStructBody[];
  pageSize?: string;
  total?: string;
  static names(): { [key: string]: string } {
    return {
      current: 'Current',
      list: 'List',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'string',
      list: { 'type': 'array', 'itemType': TriggerLogDTOStructBody },
      pageSize: 'string',
      total: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class PositionStructBody extends $tea.Model {
  errorCount?: string;
  height?: string;
  index?: string;
  lastError?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      errorCount: 'ErrorCount',
      height: 'Height',
      index: 'Index',
      lastError: 'LastError',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCount: 'string',
      height: 'string',
      index: 'string',
      lastError: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerDTOStructBody extends $tea.Model {
  checkpoint?: CheckPointStructBody;
  createTime?: string;
  errorMessage?: string;
  name?: string;
  option?: string;
  pendingErrorLogs?: string;
  source?: string;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      checkpoint: 'Checkpoint',
      createTime: 'CreateTime',
      errorMessage: 'ErrorMessage',
      name: 'Name',
      option: 'Option',
      pendingErrorLogs: 'PendingErrorLogs',
      source: 'Source',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      checkpoint: CheckPointStructBody,
      createTime: 'string',
      errorMessage: 'string',
      name: 'string',
      option: 'string',
      pendingErrorLogs: 'string',
      source: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TriggerLogDTOStructBody extends $tea.Model {
  createTime?: string;
  modifyTime?: string;
  position?: PositionStructBody;
  status?: string;
  uuid?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      modifyTime: 'ModifyTime',
      position: 'Position',
      status: 'Status',
      uuid: 'Uuid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      modifyTime: 'string',
      position: PositionStructBody,
      status: 'string',
      uuid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AcceptEthereumInvitationRequest extends $tea.Model {
  code?: string;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AcceptEthereumInvitationResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AcceptEthereumInvitationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AcceptEthereumInvitationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AcceptEthereumInvitationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AcceptInvitationRequest extends $tea.Model {
  code?: string;
  isAccepted?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      isAccepted: 'IsAccepted',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      isAccepted: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AcceptInvitationResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AcceptInvitationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AcceptInvitationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AcceptInvitationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAntChainSubnetMemberCheckRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAntChainSubnetMemberCheckResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: AddAntChainSubnetMemberCheckResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: AddAntChainSubnetMemberCheckResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAntChainSubnetMemberCheckResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddAntChainSubnetMemberCheckResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddAntChainSubnetMemberCheckResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAntChainSubnetNodeCheckRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAntChainSubnetNodeCheckResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: AddAntChainSubnetNodeCheckResponseBodyResult[];
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': AddAntChainSubnetNodeCheckResponseBodyResult },
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAntChainSubnetNodeCheckResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddAntChainSubnetNodeCheckResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddAntChainSubnetNodeCheckResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddEthereumNodeRequest extends $tea.Model {
  description?: string;
  ethereumId?: string;
  externalNode?: boolean;
  nodeName?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      ethereumId: 'EthereumId',
      externalNode: 'ExternalNode',
      nodeName: 'NodeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      ethereumId: 'string',
      externalNode: 'boolean',
      nodeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddEthereumNodeResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: AddEthereumNodeResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: AddEthereumNodeResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddEthereumNodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddEthereumNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddEthereumNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelRequest extends $tea.Model {
  channelId?: string;
  description?: string;
  joinRequest?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      description: 'Description',
      joinRequest: 'JoinRequest',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      description: 'string',
      joinRequest: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: AddFabricExternalOrganizationToChannelResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: AddFabricExternalOrganizationToChannelResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddFabricExternalOrganizationToChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddFabricExternalOrganizationToChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricOrganizationToExternalChannelRequest extends $tea.Model {
  joinResponse?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      joinResponse: 'JoinResponse',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      joinResponse: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricOrganizationToExternalChannelResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: AddFabricOrganizationToExternalChannelResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': AddFabricOrganizationToExternalChannelResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricOrganizationToExternalChannelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: AddFabricOrganizationToExternalChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: AddFabricOrganizationToExternalChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainRequest extends $tea.Model {
  bizid?: string;
  consortiumId?: string;
  uploadReq?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      consortiumId: 'ConsortiumId',
      uploadReq: 'UploadReq',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      consortiumId: 'string',
      uploadReq: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApplyAntChainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApplyAntChainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainCertificateRequest extends $tea.Model {
  antChainId?: string;
  uploadReq?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      uploadReq: 'UploadReq',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      uploadReq: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainCertificateResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApplyAntChainCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApplyAntChainCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainCertificateWithKeyAutoCreationRequest extends $tea.Model {
  antChainId?: string;
  commonName?: string;
  consortiumId?: string;
  countryName?: string;
  localityName?: string;
  organizationName?: string;
  organizationUnitName?: string;
  password?: string;
  stateOrProvinceName?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      commonName: 'CommonName',
      consortiumId: 'ConsortiumId',
      countryName: 'CountryName',
      localityName: 'LocalityName',
      organizationName: 'OrganizationName',
      organizationUnitName: 'OrganizationUnitName',
      password: 'Password',
      stateOrProvinceName: 'StateOrProvinceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      commonName: 'string',
      consortiumId: 'string',
      countryName: 'string',
      localityName: 'string',
      organizationName: 'string',
      organizationUnitName: 'string',
      password: 'string',
      stateOrProvinceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainCertificateWithKeyAutoCreationResponseBody extends $tea.Model {
  requestId?: string;
  result?: ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainCertificateWithKeyAutoCreationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApplyAntChainCertificateWithKeyAutoCreationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApplyAntChainCertificateWithKeyAutoCreationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainWithKeyAutoCreationRequest extends $tea.Model {
  antChainId?: string;
  commonName?: string;
  consortiumId?: string;
  countryName?: string;
  localityName?: string;
  organizationName?: string;
  organizationUnitName?: string;
  password?: string;
  stateOrProvinceName?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      commonName: 'CommonName',
      consortiumId: 'ConsortiumId',
      countryName: 'CountryName',
      localityName: 'LocalityName',
      organizationName: 'OrganizationName',
      organizationUnitName: 'OrganizationUnitName',
      password: 'Password',
      stateOrProvinceName: 'StateOrProvinceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      commonName: 'string',
      consortiumId: 'string',
      countryName: 'string',
      localityName: 'string',
      organizationName: 'string',
      organizationUnitName: 'string',
      password: 'string',
      stateOrProvinceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainWithKeyAutoCreationResponseBody extends $tea.Model {
  requestId?: string;
  result?: ApplyAntChainWithKeyAutoCreationResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: ApplyAntChainWithKeyAutoCreationResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainWithKeyAutoCreationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApplyAntChainWithKeyAutoCreationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApplyAntChainWithKeyAutoCreationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyBlockchainRequest extends $tea.Model {
  account?: string;
  accountPubKey?: string;
  accountRecoverPubKey?: string;
  blockchain?: string;
  uploadReq?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      accountPubKey: 'AccountPubKey',
      accountRecoverPubKey: 'AccountRecoverPubKey',
      blockchain: 'Blockchain',
      uploadReq: 'UploadReq',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      accountPubKey: 'string',
      accountRecoverPubKey: 'string',
      blockchain: 'string',
      uploadReq: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyBlockchainResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyBlockchainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApplyBlockchainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApplyBlockchainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyBlockchainWithKeyAutoCreationRequest extends $tea.Model {
  bizid?: string;
  commonName?: string;
  countryName?: string;
  localityName?: string;
  organizationName?: string;
  organizationUnitName?: string;
  password?: string;
  stateOrProvinceName?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      commonName: 'CommonName',
      countryName: 'CountryName',
      localityName: 'LocalityName',
      organizationName: 'OrganizationName',
      organizationUnitName: 'OrganizationUnitName',
      password: 'Password',
      stateOrProvinceName: 'StateOrProvinceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      commonName: 'string',
      countryName: 'string',
      localityName: 'string',
      organizationName: 'string',
      organizationUnitName: 'string',
      password: 'string',
      stateOrProvinceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyBlockchainWithKeyAutoCreationResponseBody extends $tea.Model {
  requestId?: string;
  result?: ApplyBlockchainWithKeyAutoCreationResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: ApplyBlockchainWithKeyAutoCreationResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyBlockchainWithKeyAutoCreationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApplyBlockchainWithKeyAutoCreationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApplyBlockchainWithKeyAutoCreationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyPublicAntChainRequest extends $tea.Model {
  bizid?: string;
  consortiumId?: string;
  uploadReq?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      consortiumId: 'ConsortiumId',
      uploadReq: 'UploadReq',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      consortiumId: 'string',
      uploadReq: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyPublicAntChainResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyPublicAntChainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApplyPublicAntChainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApplyPublicAntChainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyPublicAntChainWithKeyAutoCreationRequest extends $tea.Model {
  bizid?: string;
  commonName?: string;
  countryName?: string;
  localityName?: string;
  organizationName?: string;
  organizationUnitName?: string;
  password?: string;
  stateOrProvinceName?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      commonName: 'CommonName',
      countryName: 'CountryName',
      localityName: 'LocalityName',
      organizationName: 'OrganizationName',
      organizationUnitName: 'OrganizationUnitName',
      password: 'Password',
      stateOrProvinceName: 'StateOrProvinceName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      commonName: 'string',
      countryName: 'string',
      localityName: 'string',
      organizationName: 'string',
      organizationUnitName: 'string',
      password: 'string',
      stateOrProvinceName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyPublicAntChainWithKeyAutoCreationResponseBody extends $tea.Model {
  requestId?: string;
  result?: ApplyPublicAntChainWithKeyAutoCreationResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: ApplyPublicAntChainWithKeyAutoCreationResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyPublicAntChainWithKeyAutoCreationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApplyPublicAntChainWithKeyAutoCreationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApplyPublicAntChainWithKeyAutoCreationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveEthereumInviteeRequest extends $tea.Model {
  id?: string;
  invitee?: ApproveEthereumInviteeRequestInvitee[];
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      invitee: 'Invitee',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
      invitee: { 'type': 'array', 'itemType': ApproveEthereumInviteeRequestInvitee },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveEthereumInviteeResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveEthereumInviteeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApproveEthereumInviteeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApproveEthereumInviteeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveFabricChaincodeDefinitionRequest extends $tea.Model {
  chaincodeId?: string;
  chaincodePackageId?: string;
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      chaincodePackageId: 'ChaincodePackageId',
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      chaincodePackageId: 'string',
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveFabricChaincodeDefinitionResponseBody extends $tea.Model {
  chaincodeDefinitionId?: string;
  chaincodePackageId?: string;
  errorCode?: number;
  initRequired?: boolean;
  requestId?: string;
  result?: ApproveFabricChaincodeDefinitionResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      chaincodeDefinitionId: 'ChaincodeDefinitionId',
      chaincodePackageId: 'ChaincodePackageId',
      errorCode: 'ErrorCode',
      initRequired: 'InitRequired',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeDefinitionId: 'string',
      chaincodePackageId: 'string',
      errorCode: 'number',
      initRequired: 'boolean',
      requestId: 'string',
      result: ApproveFabricChaincodeDefinitionResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveFabricChaincodeDefinitionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ApproveFabricChaincodeDefinitionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ApproveFabricChaincodeDefinitionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest extends $tea.Model {
  antChainId?: string;
  phoneList?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      phoneList: 'PhoneList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      phoneList: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddAntChainMiniAppQRCodeAuthorizedUsersShrinkRequest extends $tea.Model {
  antChainId?: string;
  phoneListShrink?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      phoneListShrink: 'PhoneList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      phoneListShrink: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindFabricManagementChaincodeRequest extends $tea.Model {
  chaincodeId?: string;
  channelId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      channelId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindFabricManagementChaincodeResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: BindFabricManagementChaincodeResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: BindFabricManagementChaincodeResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindFabricManagementChaincodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: BindFabricManagementChaincodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: BindFabricManagementChaincodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckConsortiumDomainRequest extends $tea.Model {
  domainCode?: string;
  static names(): { [key: string]: string } {
    return {
      domainCode: 'DomainCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domainCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckConsortiumDomainResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: CheckConsortiumDomainResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: CheckConsortiumDomainResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckConsortiumDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckConsortiumDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckConsortiumDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckOrganizationDomainRequest extends $tea.Model {
  domain?: string;
  domainCode?: string;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      domainCode: 'DomainCode',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      domainCode: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckOrganizationDomainResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: CheckOrganizationDomainResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: CheckOrganizationDomainResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckOrganizationDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CheckOrganizationDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CheckOrganizationDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmConsortiumMemberRequest extends $tea.Model {
  consortiumId?: string;
  organization?: ConfirmConsortiumMemberRequestOrganization[];
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      organization: 'Organization',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      organization: { 'type': 'array', 'itemType': ConfirmConsortiumMemberRequestOrganization },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmConsortiumMemberResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: boolean;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmConsortiumMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ConfirmConsortiumMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ConfirmConsortiumMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyAntChainContractProjectRequest extends $tea.Model {
  projectDescription?: string;
  projectId?: string;
  projectName?: string;
  projectVersion?: string;
  static names(): { [key: string]: string } {
    return {
      projectDescription: 'ProjectDescription',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      projectVersion: 'ProjectVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectDescription: 'string',
      projectId: 'string',
      projectName: 'string',
      projectVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyAntChainContractProjectResponseBody extends $tea.Model {
  requestId?: string;
  result?: CopyAntChainContractProjectResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: CopyAntChainContractProjectResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyAntChainContractProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CopyAntChainContractProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CopyAntChainContractProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccessTokenRequest extends $tea.Model {
  accessTokenLifetime?: string;
  organizationId?: string;
  refreshTokenLifetime?: string;
  scope?: string;
  static names(): { [key: string]: string } {
    return {
      accessTokenLifetime: 'AccessTokenLifetime',
      organizationId: 'OrganizationId',
      refreshTokenLifetime: 'RefreshTokenLifetime',
      scope: 'Scope',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessTokenLifetime: 'string',
      organizationId: 'string',
      refreshTokenLifetime: 'string',
      scope: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccessTokenResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: CreateAccessTokenResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: CreateAccessTokenResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccessTokenResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAccessTokenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAccessTokenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccountRequest extends $tea.Model {
  account?: string;
  accountPubKey?: string;
  accountRecoverPubKey?: string;
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      accountPubKey: 'AccountPubKey',
      accountRecoverPubKey: 'AccountRecoverPubKey',
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      accountPubKey: 'string',
      accountRecoverPubKey: 'string',
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccountResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAccountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAccountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccountWithKeyPairAutoCreationRequest extends $tea.Model {
  account?: string;
  bizid?: string;
  password?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      bizid: 'Bizid',
      password: 'Password',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      bizid: 'string',
      password: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccountWithKeyPairAutoCreationResponseBody extends $tea.Model {
  requestId?: string;
  result?: CreateAccountWithKeyPairAutoCreationResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: CreateAccountWithKeyPairAutoCreationResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccountWithKeyPairAutoCreationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAccountWithKeyPairAutoCreationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAccountWithKeyPairAutoCreationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainRequest extends $tea.Model {
  antChainName?: string;
  blockchainRegionId?: string;
  cipherSuit?: string;
  consortiumId?: string;
  liveTime?: number;
  merkleTreeSuit?: string;
  nodeNum?: number;
  resourceSize?: number;
  tlsAlgo?: string;
  static names(): { [key: string]: string } {
    return {
      antChainName: 'AntChainName',
      blockchainRegionId: 'BlockchainRegionId',
      cipherSuit: 'CipherSuit',
      consortiumId: 'ConsortiumId',
      liveTime: 'LiveTime',
      merkleTreeSuit: 'MerkleTreeSuit',
      nodeNum: 'NodeNum',
      resourceSize: 'ResourceSize',
      tlsAlgo: 'TlsAlgo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainName: 'string',
      blockchainRegionId: 'string',
      cipherSuit: 'string',
      consortiumId: 'string',
      liveTime: 'number',
      merkleTreeSuit: 'string',
      nodeNum: 'number',
      resourceSize: 'number',
      tlsAlgo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainResponseBody extends $tea.Model {
  requestId?: string;
  result?: CreateAntChainResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: CreateAntChainResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAntChainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAntChainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainAccountRequest extends $tea.Model {
  account?: string;
  accountPubKey?: string;
  accountRecoverPubKey?: string;
  antChainId?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      accountPubKey: 'AccountPubKey',
      accountRecoverPubKey: 'AccountRecoverPubKey',
      antChainId: 'AntChainId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      accountPubKey: 'string',
      accountRecoverPubKey: 'string',
      antChainId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainAccountResponseBody extends $tea.Model {
  requestId?: string;
  result?: CreateAntChainAccountResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: CreateAntChainAccountResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainAccountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAntChainAccountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAntChainAccountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainAccountWithKeyPairAutoCreationRequest extends $tea.Model {
  account?: string;
  antChainId?: string;
  password?: string;
  recoverPassword?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      antChainId: 'AntChainId',
      password: 'Password',
      recoverPassword: 'RecoverPassword',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      antChainId: 'string',
      password: 'string',
      recoverPassword: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainAccountWithKeyPairAutoCreationResponseBody extends $tea.Model {
  requestId?: string;
  result?: CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainAccountWithKeyPairAutoCreationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAntChainAccountWithKeyPairAutoCreationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAntChainAccountWithKeyPairAutoCreationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainConsortiumRequest extends $tea.Model {
  consortiumDescription?: string;
  consortiumName?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumDescription: 'ConsortiumDescription',
      consortiumName: 'ConsortiumName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumDescription: 'string',
      consortiumName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainConsortiumResponseBody extends $tea.Model {
  requestId?: string;
  result?: CreateAntChainConsortiumResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: CreateAntChainConsortiumResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainConsortiumResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAntChainConsortiumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAntChainConsortiumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainContractContentRequest extends $tea.Model {
  content?: string;
  contentName?: string;
  isDirectory?: boolean;
  parentContentId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentName: 'ContentName',
      isDirectory: 'IsDirectory',
      parentContentId: 'ParentContentId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentName: 'string',
      isDirectory: 'boolean',
      parentContentId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainContractContentResponseBody extends $tea.Model {
  requestId?: string;
  result?: CreateAntChainContractContentResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: CreateAntChainContractContentResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainContractContentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAntChainContractContentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAntChainContractContentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainContractProjectRequest extends $tea.Model {
  consortiumId?: string;
  projectDescription?: string;
  projectName?: string;
  projectVersion?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      projectDescription: 'ProjectDescription',
      projectName: 'ProjectName',
      projectVersion: 'ProjectVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      projectDescription: 'string',
      projectName: 'string',
      projectVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainContractProjectResponseBody extends $tea.Model {
  requestId?: string;
  result?: CreateAntChainContractProjectResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: CreateAntChainContractProjectResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainContractProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateAntChainContractProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateAntChainContractProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBlockchainRequest extends $tea.Model {
  bizid?: string;
  blockchainRegionId?: string;
  blockchainType?: string;
  cipherSuit?: string;
  liveTime?: number;
  machineNum?: number;
  merkleTreeSuit?: string;
  size?: number;
  tlsAlgo?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      blockchainRegionId: 'BlockchainRegionId',
      blockchainType: 'BlockchainType',
      cipherSuit: 'CipherSuit',
      liveTime: 'LiveTime',
      machineNum: 'MachineNum',
      merkleTreeSuit: 'MerkleTreeSuit',
      size: 'Size',
      tlsAlgo: 'TlsAlgo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      blockchainRegionId: 'string',
      blockchainType: 'string',
      cipherSuit: 'string',
      liveTime: 'number',
      machineNum: 'number',
      merkleTreeSuit: 'string',
      size: 'number',
      tlsAlgo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBlockchainResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBlockchainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateBlockchainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateBlockchainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBlockchainApplicationRequest extends $tea.Model {
  bizid?: string;
  blockchainRegionId?: string;
  blockchainType?: string;
  cipherSuit?: string;
  liveTime?: number;
  machineNum?: number;
  merkleTreeSuit?: string;
  size?: number;
  tlsAlgo?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      blockchainRegionId: 'BlockchainRegionId',
      blockchainType: 'BlockchainType',
      cipherSuit: 'CipherSuit',
      liveTime: 'LiveTime',
      machineNum: 'MachineNum',
      merkleTreeSuit: 'MerkleTreeSuit',
      size: 'Size',
      tlsAlgo: 'TlsAlgo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      blockchainRegionId: 'string',
      blockchainType: 'string',
      cipherSuit: 'string',
      liveTime: 'number',
      machineNum: 'number',
      merkleTreeSuit: 'string',
      size: 'number',
      tlsAlgo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBlockchainApplicationResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBlockchainApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateBlockchainApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateBlockchainApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBlockchainApplyRequest extends $tea.Model {
  bizid?: string;
  liveTime?: number;
  machineNum?: number;
  size?: number;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      liveTime: 'LiveTime',
      machineNum: 'MachineNum',
      size: 'Size',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      liveTime: 'number',
      machineNum: 'number',
      size: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBlockchainApplyResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateBlockchainApplyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateBlockchainApplyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateBlockchainApplyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChaincodeRequest extends $tea.Model {
  channelId?: string;
  consortiumId?: string;
  endorsePolicy?: string;
  location?: string;
  organizationId?: string;
  ossBucket?: string;
  ossUrl?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      consortiumId: 'ConsortiumId',
      endorsePolicy: 'EndorsePolicy',
      location: 'Location',
      organizationId: 'OrganizationId',
      ossBucket: 'OssBucket',
      ossUrl: 'OssUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      consortiumId: 'string',
      endorsePolicy: 'string',
      location: 'string',
      organizationId: 'string',
      ossBucket: 'string',
      ossUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChaincodeResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: CreateChaincodeResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: CreateChaincodeResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChaincodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateChaincodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateChaincodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChannelRequest extends $tea.Model {
  batchTimeout?: number;
  channelName?: string;
  consortiumId?: string;
  maxMessageCount?: number;
  organization?: CreateChannelRequestOrganization[];
  preferredMaxBytes?: number;
  static names(): { [key: string]: string } {
    return {
      batchTimeout: 'BatchTimeout',
      channelName: 'ChannelName',
      consortiumId: 'ConsortiumId',
      maxMessageCount: 'MaxMessageCount',
      organization: 'Organization',
      preferredMaxBytes: 'PreferredMaxBytes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchTimeout: 'number',
      channelName: 'string',
      consortiumId: 'string',
      maxMessageCount: 'number',
      organization: { 'type': 'array', 'itemType': CreateChannelRequestOrganization },
      preferredMaxBytes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChannelResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: CreateChannelResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: CreateChannelResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChannelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChannelMemberRequest extends $tea.Model {
  channelId?: string;
  organization?: CreateChannelMemberRequestOrganization[];
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      organization: 'Organization',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      organization: { 'type': 'array', 'itemType': CreateChannelMemberRequestOrganization },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChannelMemberResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: boolean;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChannelMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateChannelMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateChannelMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudIntegrationServiceTokenRequest extends $tea.Model {
  organizationId?: string;
  service?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
      service: 'Service',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
      service: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudIntegrationServiceTokenResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudIntegrationServiceTokenResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCloudIntegrationServiceTokenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCloudIntegrationServiceTokenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudServiceIntegrationRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudServiceIntegrationResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: boolean;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudServiceIntegrationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCloudServiceIntegrationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCloudServiceIntegrationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudServiceSessionRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudServiceSessionResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateCloudServiceSessionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateCloudServiceSessionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateCloudServiceSessionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsortiumRequest extends $tea.Model {
  channelPolicy?: string;
  description?: string;
  domain?: string;
  duration?: number;
  location?: string;
  majorVersion?: string;
  name?: string;
  ordererType?: string;
  orderersCount?: number;
  organization?: CreateConsortiumRequestOrganization[];
  peersCount?: number;
  pricingCycle?: string;
  specName?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      channelPolicy: 'ChannelPolicy',
      description: 'Description',
      domain: 'Domain',
      duration: 'Duration',
      location: 'Location',
      majorVersion: 'MajorVersion',
      name: 'Name',
      ordererType: 'OrdererType',
      orderersCount: 'OrderersCount',
      organization: 'Organization',
      peersCount: 'PeersCount',
      pricingCycle: 'PricingCycle',
      specName: 'SpecName',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelPolicy: 'string',
      description: 'string',
      domain: 'string',
      duration: 'number',
      location: 'string',
      majorVersion: 'string',
      name: 'string',
      ordererType: 'string',
      orderersCount: 'number',
      organization: { 'type': 'array', 'itemType': CreateConsortiumRequestOrganization },
      peersCount: 'number',
      pricingCycle: 'string',
      specName: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsortiumResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: CreateConsortiumResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: CreateConsortiumResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsortiumResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateConsortiumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateConsortiumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsortiumMemberRequest extends $tea.Model {
  code?: string;
  consortiumId?: string;
  organization?: CreateConsortiumMemberRequestOrganization[];
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      consortiumId: 'ConsortiumId',
      organization: 'Organization',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      consortiumId: 'string',
      organization: { 'type': 'array', 'itemType': CreateConsortiumMemberRequestOrganization },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsortiumMemberResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: boolean;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsortiumMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateConsortiumMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateConsortiumMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEcosphereRequest extends $tea.Model {
  channelPolicy?: string;
  consortiumName?: string;
  description?: string;
  duration?: number;
  location?: string;
  majorVersion?: string;
  ordererDomain?: string;
  ordererType?: string;
  orderersCount?: number;
  organization?: CreateEcosphereRequestOrganization[];
  peersCount?: number;
  pricingCycle?: string;
  specName?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      channelPolicy: 'ChannelPolicy',
      consortiumName: 'ConsortiumName',
      description: 'Description',
      duration: 'Duration',
      location: 'Location',
      majorVersion: 'MajorVersion',
      ordererDomain: 'OrdererDomain',
      ordererType: 'OrdererType',
      orderersCount: 'OrderersCount',
      organization: 'Organization',
      peersCount: 'PeersCount',
      pricingCycle: 'PricingCycle',
      specName: 'SpecName',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelPolicy: 'string',
      consortiumName: 'string',
      description: 'string',
      duration: 'number',
      location: 'string',
      majorVersion: 'string',
      ordererDomain: 'string',
      ordererType: 'string',
      orderersCount: 'number',
      organization: { 'type': 'array', 'itemType': CreateEcosphereRequestOrganization },
      peersCount: 'number',
      pricingCycle: 'string',
      specName: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEcosphereResponseBody extends $tea.Model {
  errorCode?: number;
  errorMessage?: string;
  requestId?: string;
  result?: CreateEcosphereResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      errorMessage: 'ErrorMessage',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      errorMessage: 'string',
      requestId: 'string',
      result: CreateEcosphereResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEcosphereResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEcosphereResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEcosphereResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEthereumRequest extends $tea.Model {
  consensus?: string;
  description?: string;
  difficulty?: string;
  gas?: string;
  name?: string;
  networkId?: string;
  node?: CreateEthereumRequestNode[];
  region?: string;
  static names(): { [key: string]: string } {
    return {
      consensus: 'Consensus',
      description: 'Description',
      difficulty: 'Difficulty',
      gas: 'Gas',
      name: 'Name',
      networkId: 'NetworkId',
      node: 'Node',
      region: 'Region',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consensus: 'string',
      description: 'string',
      difficulty: 'string',
      gas: 'string',
      name: 'string',
      networkId: 'string',
      node: { 'type': 'array', 'itemType': CreateEthereumRequestNode },
      region: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEthereumResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: CreateEthereumResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: CreateEthereumResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEthereumResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEthereumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEthereumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEthereumInvitationRequest extends $tea.Model {
  ethereumId?: string;
  static names(): { [key: string]: string } {
    return {
      ethereumId: 'EthereumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ethereumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEthereumInvitationResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: CreateEthereumInvitationResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: CreateEthereumInvitationResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEthereumInvitationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateEthereumInvitationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateEthereumInvitationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFabricChaincodePackageRequest extends $tea.Model {
  location?: string;
  organizationId?: string;
  ossBucket?: string;
  ossUrl?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      organizationId: 'OrganizationId',
      ossBucket: 'OssBucket',
      ossUrl: 'OssUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      organizationId: 'string',
      ossBucket: 'string',
      ossUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFabricChaincodePackageResponseBody extends $tea.Model {
  errorCode?: number;
  message?: string;
  requestId?: string;
  result?: CreateFabricChaincodePackageResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      message: 'string',
      requestId: 'string',
      result: CreateFabricChaincodePackageResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFabricChaincodePackageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateFabricChaincodePackageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateFabricChaincodePackageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrganizationRequest extends $tea.Model {
  description?: string;
  domain?: string;
  duration?: number;
  location?: string;
  majorVersion?: string;
  name?: string;
  peersCount?: number;
  pricingCycle?: string;
  specName?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      domain: 'Domain',
      duration: 'Duration',
      location: 'Location',
      majorVersion: 'MajorVersion',
      name: 'Name',
      peersCount: 'PeersCount',
      pricingCycle: 'PricingCycle',
      specName: 'SpecName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      domain: 'string',
      duration: 'number',
      location: 'string',
      majorVersion: 'string',
      name: 'string',
      peersCount: 'number',
      pricingCycle: 'string',
      specName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrganizationResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: CreateOrganizationResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: CreateOrganizationResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrganizationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrganizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrganizationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrganizationUserRequest extends $tea.Model {
  attrs?: string;
  organizationId?: string;
  password?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      attrs: 'Attrs',
      organizationId: 'OrganizationId',
      password: 'Password',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attrs: 'string',
      organizationId: 'string',
      password: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrganizationUserResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: CreateOrganizationUserResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: CreateOrganizationUserResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrganizationUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOrganizationUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOrganizationUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOwnAccountRequest extends $tea.Model {
  bizid?: string;
  identity?: string;
  publicKey?: string;
  recoveryKey?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      identity: 'Identity',
      publicKey: 'PublicKey',
      recoveryKey: 'RecoveryKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      identity: 'string',
      publicKey: 'string',
      recoveryKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOwnAccountResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOwnAccountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateOwnAccountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateOwnAccountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePublicAccountWithKeyPairAutoCreationRequest extends $tea.Model {
  account?: string;
  bizid?: string;
  password?: string;
  recoverPassword?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      bizid: 'Bizid',
      password: 'Password',
      recoverPassword: 'RecoverPassword',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      bizid: 'string',
      password: 'string',
      recoverPassword: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePublicAccountWithKeyPairAutoCreationResponseBody extends $tea.Model {
  requestId?: string;
  result?: CreatePublicAccountWithKeyPairAutoCreationResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: CreatePublicAccountWithKeyPairAutoCreationResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePublicAccountWithKeyPairAutoCreationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePublicAccountWithKeyPairAutoCreationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePublicAccountWithKeyPairAutoCreationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePublicAntChainAccountRequest extends $tea.Model {
  account?: string;
  accountPubKey?: string;
  accountRecoverPubKey?: string;
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      accountPubKey: 'AccountPubKey',
      accountRecoverPubKey: 'AccountRecoverPubKey',
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      accountPubKey: 'string',
      accountRecoverPubKey: 'string',
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePublicAntChainAccountResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePublicAntChainAccountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreatePublicAntChainAccountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreatePublicAntChainAccountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSmartContractJobResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: CreateSmartContractJobResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: CreateSmartContractJobResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSmartContractJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateSmartContractJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateSmartContractJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTriggerRequest extends $tea.Model {
  channelId?: string;
  name?: string;
  options?: string;
  organizationId?: string;
  source?: string;
  status?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      name: 'Name',
      options: 'Options',
      organizationId: 'OrganizationId',
      source: 'Source',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      name: 'string',
      options: 'string',
      organizationId: 'string',
      source: 'string',
      status: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTriggerResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: CreateTriggerResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: CreateTriggerResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTriggerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: CreateTriggerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: CreateTriggerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntChainConsortiumRequest extends $tea.Model {
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntChainConsortiumResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntChainConsortiumResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAntChainConsortiumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAntChainConsortiumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntChainContractContentRequest extends $tea.Model {
  contentId?: string;
  static names(): { [key: string]: string } {
    return {
      contentId: 'ContentId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contentId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntChainContractContentResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntChainContractContentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAntChainContractContentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAntChainContractContentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntChainContractProjectRequest extends $tea.Model {
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntChainContractProjectResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntChainContractProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAntChainContractProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAntChainContractProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntChainMiniAppQRCodeAuthorizedUserRequest extends $tea.Model {
  antChainId?: string;
  phone?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      phone: 'Phone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      phone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteAntChainMiniAppQRCodeAuthorizedUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteChaincodeRequest extends $tea.Model {
  chaincodeId?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteChaincodeResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteChaincodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteChaincodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteChaincodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskRequest extends $tea.Model {
  channelId?: string;
  organizationId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      organizationId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DeleteGovernanceTaskResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DeleteGovernanceTaskResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteGovernanceTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteGovernanceTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTriggerRequest extends $tea.Model {
  channelId?: string;
  name?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      name: 'Name',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      name: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTriggerResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DeleteTriggerResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DeleteTriggerResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTriggerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DeleteTriggerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DeleteTriggerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainAccountsRequest extends $tea.Model {
  antChainId?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainAccountsResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainAccountsResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainAccountsResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainAccountsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainAccountsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainAccountsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainAccountsNewRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainAccountsNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainAccountsNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainAccountsNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainAccountsNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainAccountsNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainAccountsNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainApplicationsRequest extends $tea.Model {
  bizid?: string;
  current?: number;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      current: 'Current',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      current: 'number',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainApplicationsResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainApplicationsResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainApplicationsResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainApplicationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainApplicationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainApplicationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainBlockRequest extends $tea.Model {
  antChainId?: string;
  height?: number;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      height: 'Height',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      height: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainBlockResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainBlockResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainBlockResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainBlockResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainBlockResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainBlockResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainBlockNewRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  height?: number;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
      height: 'Height',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
      height: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainBlockNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainBlockNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainBlockNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainBlockNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainBlockNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainBlockNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainCertificateApplicationsRequest extends $tea.Model {
  antChainId?: string;
  pageNumber?: number;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainCertificateApplicationsResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainCertificateApplicationsResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainCertificateApplicationsResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainCertificateApplicationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainCertificateApplicationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainCertificateApplicationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainCertificateApplicationsNewRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  pageNumber?: number;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainCertificateApplicationsNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainCertificateApplicationsNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainCertificateApplicationsNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainCertificateApplicationsNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainCertificateApplicationsNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainCertificateApplicationsNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConfigOptionsRequest extends $tea.Model {
  purpose?: string;
  static names(): { [key: string]: string } {
    return {
      purpose: 'Purpose',
    };
  }

  static types(): { [key: string]: any } {
    return {
      purpose: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConfigOptionsResponseBody extends $tea.Model {
  requestId?: string;
  result?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConfigOptionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainConfigOptionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainConfigOptionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConsortiumsRequest extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConsortiumsResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainConsortiumsResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainConsortiumsResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConsortiumsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainConsortiumsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainConsortiumsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConsortiumsNewRequest extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConsortiumsNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainConsortiumsNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainConsortiumsNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConsortiumsNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainConsortiumsNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainConsortiumsNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectContentTreeRequest extends $tea.Model {
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectContentTreeResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainContractProjectContentTreeResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainContractProjectContentTreeResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectContentTreeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainContractProjectContentTreeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainContractProjectContentTreeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectContentTreeNewRequest extends $tea.Model {
  consortiumId?: string;
  projectId?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      projectId: 'ProjectId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      projectId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectContentTreeNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: string;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: 'string',
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectContentTreeNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainContractProjectContentTreeNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainContractProjectContentTreeNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectsRequest extends $tea.Model {
  consortiumId?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectsResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainContractProjectsResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainContractProjectsResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainContractProjectsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainContractProjectsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectsNewRequest extends $tea.Model {
  consortiumId?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectsNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainContractProjectsNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainContractProjectsNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectsNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainContractProjectsNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainContractProjectsNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainDownloadPathsRequest extends $tea.Model {
  antChainId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainDownloadPathsResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainDownloadPathsResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainDownloadPathsResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainDownloadPathsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainDownloadPathsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainDownloadPathsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainDownloadPathsNewRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainDownloadPathsNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainDownloadPathsNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainDownloadPathsNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainDownloadPathsNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainDownloadPathsNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainDownloadPathsNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainInformationRequest extends $tea.Model {
  antChainId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainInformationResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainInformationResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainInformationResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainInformationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainInformationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainInformationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainInformationNewRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainInformationNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainInformationNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainInformationNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainInformationNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainInformationNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainInformationNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainLatestBlocksRequest extends $tea.Model {
  antChainId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainLatestBlocksResponseBody extends $tea.Model {
  requestId?: string;
  result?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainLatestBlocksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainLatestBlocksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainLatestBlocksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainLatestBlocksNewRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainLatestBlocksNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainLatestBlocksNewResponseBodyResult[];
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeAntChainLatestBlocksNewResponseBodyResult },
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainLatestBlocksNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainLatestBlocksNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainLatestBlocksNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainLatestTransactionDigestsRequest extends $tea.Model {
  antChainId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainLatestTransactionDigestsResponseBody extends $tea.Model {
  requestId?: string;
  result?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainLatestTransactionDigestsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainLatestTransactionDigestsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainLatestTransactionDigestsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainLatestTransactionDigestsNewRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainLatestTransactionDigestsNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: string[];
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': 'string' },
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainLatestTransactionDigestsNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainLatestTransactionDigestsNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainLatestTransactionDigestsNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMembersRequest extends $tea.Model {
  consortiumId?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMembersResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainMembersResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainMembersResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMembersNewRequest extends $tea.Model {
  consortiumId?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMembersNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainMembersNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainMembersNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMembersNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainMembersNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainMembersNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest extends $tea.Model {
  antChainId?: string;
  QRCodeType?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      QRCodeType: 'QRCodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      QRCodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest extends $tea.Model {
  antChainId?: string;
  QRCodeType?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      QRCodeType: 'QRCodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      QRCodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest extends $tea.Model {
  antChainId?: string;
  pageNumber?: number;
  pageSize?: number;
  QRCodeType?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      QRCodeType: 'QRCodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      QRCodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest extends $tea.Model {
  antChainId?: string;
  pageNumber?: number;
  pageSize?: number;
  QRCodeType?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      QRCodeType: 'QRCodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
      QRCodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserTransactionQRCodeRequest extends $tea.Model {
  antChainId?: string;
  transactionHash?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      transactionHash: 'TransactionHash',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      transactionHash: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserTransactionQRCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest extends $tea.Model {
  antChainId?: string;
  contractId?: string;
  transactionHash?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      contractId: 'ContractId',
      transactionHash: 'TransactionHash',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      contractId: 'string',
      transactionHash: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainNodesNewRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainNodesNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: string[];
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': 'string' },
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainNodesNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainNodesNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainNodesNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainQRCodeAuthorizationRequest extends $tea.Model {
  antChainId?: string;
  QRCodeType?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      QRCodeType: 'QRCodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      QRCodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainQRCodeAuthorizationResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainQRCodeAuthorizationResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainQRCodeAuthorizationResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainQRCodeAuthorizationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainQRCodeAuthorizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainQRCodeAuthorizationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainQRCodeAuthorizationNewRequest extends $tea.Model {
  antChainId?: string;
  QRCodeType?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      QRCodeType: 'QRCodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      QRCodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainQRCodeAuthorizationNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainQRCodeAuthorizationNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainQRCodeAuthorizationNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainQRCodeAuthorizationNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainQRCodeAuthorizationNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainQRCodeAuthorizationNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainRegionNamesRequest extends $tea.Model {
  locale?: string;
  static names(): { [key: string]: string } {
    return {
      locale: 'Locale',
    };
  }

  static types(): { [key: string]: any } {
    return {
      locale: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainRegionNamesResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainRegionNamesResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeAntChainRegionNamesResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainRegionNamesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainRegionNamesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainRegionNamesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainRegionsForSaleResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainRegionsForSaleResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeAntChainRegionsForSaleResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainRegionsForSaleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainRegionsForSaleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainRegionsForSaleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainResourceTypesResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainResourceTypesResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeAntChainResourceTypesResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainResourceTypesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainResourceTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainResourceTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainRestRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainRestResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainRestResponseBodyResult[];
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeAntChainRestResponseBodyResult },
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainRestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainRestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainRestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetListRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetListResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainSubnetListResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainSubnetListResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainSubnetListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainSubnetListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetMemberListRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  pageNumber?: string;
  pageSize?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
      pageNumber: 'string',
      pageSize: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetMemberListResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainSubnetMemberListResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainSubnetMemberListResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetMemberListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainSubnetMemberListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainSubnetMemberListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetNodeListRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetNodeListResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainSubnetNodeListResponseBodyResult[];
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeAntChainSubnetNodeListResponseBodyResult },
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetNodeListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainSubnetNodeListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainSubnetNodeListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionRequest extends $tea.Model {
  antChainId?: string;
  hash?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      hash: 'Hash',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      hash: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainTransactionResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainTransactionResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainTransactionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainTransactionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionNewRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  hash?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
      hash: 'Hash',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
      hash: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainTransactionNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainTransactionNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainTransactionNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainTransactionNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionReceiptNewRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  hash?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
      hash: 'Hash',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
      hash: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionReceiptNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainTransactionReceiptNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainTransactionReceiptNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionReceiptNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainTransactionReceiptNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainTransactionReceiptNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionStatisticsRequest extends $tea.Model {
  antChainId?: string;
  end?: number;
  start?: number;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      end: 'End',
      start: 'Start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      end: 'number',
      start: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionStatisticsResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainTransactionStatisticsResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeAntChainTransactionStatisticsResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionStatisticsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainTransactionStatisticsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainTransactionStatisticsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionStatisticsNewRequest extends $tea.Model {
  antChainId?: string;
  consortiumId?: string;
  end?: number;
  start?: number;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      consortiumId: 'ConsortiumId',
      end: 'End',
      start: 'Start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      consortiumId: 'string',
      end: 'number',
      start: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionStatisticsNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainTransactionStatisticsNewResponseBodyResult[];
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeAntChainTransactionStatisticsNewResponseBodyResult },
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionStatisticsNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainTransactionStatisticsNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainTransactionStatisticsNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainsRequest extends $tea.Model {
  consortiumId?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainsResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntChainsResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAntChainsResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainsNewRequest extends $tea.Model {
  consortiumId?: string;
  pageNumber?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      pageNumber: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainsNewResponseBody extends $tea.Model {
  code?: string;
  httpStatusCode?: string;
  message?: string;
  requestId?: string;
  result?: DescribeAntChainsNewResponseBodyResult;
  resultCode?: string;
  resultMessage?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      httpStatusCode: 'HttpStatusCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      resultCode: 'ResultCode',
      resultMessage: 'ResultMessage',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      httpStatusCode: 'string',
      message: 'string',
      requestId: 'string',
      result: DescribeAntChainsNewResponseBodyResult,
      resultCode: 'string',
      resultMessage: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainsNewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntChainsNewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntChainsNewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntRegionsRequest extends $tea.Model {
  locale?: string;
  static names(): { [key: string]: string } {
    return {
      locale: 'Locale',
    };
  }

  static types(): { [key: string]: any } {
    return {
      locale: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntRegionsResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAntRegionsResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeAntRegionsResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntRegionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAntRegionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAntRegionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppliesRequest extends $tea.Model {
  bizid?: string;
  current?: number;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      current: 'Current',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      current: 'number',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppliesResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeAppliesResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeAppliesResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppliesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeAppliesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeAppliesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBcSchemaRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBcSchemaResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeBcSchemaResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeBcSchemaResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBcSchemaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBcSchemaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBcSchemaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockRequest extends $tea.Model {
  bizid?: string;
  height?: number;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      height: 'Height',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      height: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeBlockResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeBlockResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBlockResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBlockResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainApplicationRequest extends $tea.Model {
  bizid?: string;
  current?: number;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      current: 'Current',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      current: 'number',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainApplicationResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeBlockchainApplicationResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeBlockchainApplicationResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBlockchainApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBlockchainApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainConfigOptionRequest extends $tea.Model {
  purpose?: string;
  static names(): { [key: string]: string } {
    return {
      purpose: 'Purpose',
    };
  }

  static types(): { [key: string]: any } {
    return {
      purpose: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainConfigOptionResponseBody extends $tea.Model {
  requestId?: string;
  result?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainConfigOptionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBlockchainConfigOptionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBlockchainConfigOptionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainCreateTaskRequest extends $tea.Model {
  current?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'Current',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainCreateTaskResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeBlockchainCreateTaskResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeBlockchainCreateTaskResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainCreateTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBlockchainCreateTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBlockchainCreateTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainCreationConfigOptionsRequest extends $tea.Model {
  purpose?: string;
  static names(): { [key: string]: string } {
    return {
      purpose: 'Purpose',
    };
  }

  static types(): { [key: string]: any } {
    return {
      purpose: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainCreationConfigOptionsResponseBody extends $tea.Model {
  requestId?: string;
  result?: { [key: string]: any };
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainCreationConfigOptionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBlockchainCreationConfigOptionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBlockchainCreationConfigOptionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainInfoRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainInfoResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeBlockchainInfoResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeBlockchainInfoResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBlockchainInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBlockchainInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeBlockchainSchemaResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeBlockchainSchemaResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBlockchainSchemaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBlockchainSchemaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaDetailRequest extends $tea.Model {
  bizid?: string;
  schemaId?: number;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      schemaId: 'SchemaId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      schemaId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaDetailResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeBlockchainSchemaDetailResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeBlockchainSchemaDetailResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBlockchainSchemaDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBlockchainSchemaDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaFileOSSPropertiesRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaFileOSSPropertiesResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeBlockchainSchemaFileOSSPropertiesResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeBlockchainSchemaFileOSSPropertiesResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaFileOSSPropertiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBlockchainSchemaFileOSSPropertiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBlockchainSchemaFileOSSPropertiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaTemplatesResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeBlockchainSchemaTemplatesResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeBlockchainSchemaTemplatesResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeBlockchainSchemaTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeBlockchainSchemaTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCSIGatewayEndpointRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCSIGatewayEndpointResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCSIGatewayEndpointResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCSIGatewayEndpointResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCSIGatewayEndpointResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCandidateOrganizationsRequest extends $tea.Model {
  location?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCandidateOrganizationsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeCandidateOrganizationsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeCandidateOrganizationsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCandidateOrganizationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCandidateOrganizationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCandidateOrganizationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChaincodeCollectionConfigRequest extends $tea.Model {
  chaincodeId?: string;
  location?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChaincodeCollectionConfigResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChaincodeCollectionConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeChaincodeCollectionConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeChaincodeCollectionConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChaincodeDefinitionTaskRequest extends $tea.Model {
  chaincodeId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChaincodeDefinitionTaskResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeChaincodeDefinitionTaskResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeChaincodeDefinitionTaskResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChaincodeDefinitionTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeChaincodeDefinitionTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeChaincodeDefinitionTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChaincodeUploadPolicyRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChaincodeUploadPolicyResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeChaincodeUploadPolicyResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeChaincodeUploadPolicyResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChaincodeUploadPolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeChaincodeUploadPolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeChaincodeUploadPolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChannelChaincodesRequest extends $tea.Model {
  channelId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChannelChaincodesResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeChannelChaincodesResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeChannelChaincodesResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChannelChaincodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeChannelChaincodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeChannelChaincodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChannelMembersRequest extends $tea.Model {
  channelId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChannelMembersResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeChannelMembersResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeChannelMembersResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChannelMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeChannelMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeChannelMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChannelTriggersRequest extends $tea.Model {
  channelId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChannelTriggersResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeChannelTriggersResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeChannelTriggersResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChannelTriggersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeChannelTriggersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeChannelTriggersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudIntegrationServiceTokenRequest extends $tea.Model {
  organizationId?: string;
  service?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
      service: 'Service',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
      service: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudIntegrationServiceTokenResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeCloudIntegrationServiceTokenResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeCloudIntegrationServiceTokenResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudIntegrationServiceTokenResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCloudIntegrationServiceTokenResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudIntegrationServiceTokenResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudServiceOrganizationStatusRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudServiceOrganizationStatusResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeCloudServiceOrganizationStatusResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeCloudServiceOrganizationStatusResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudServiceOrganizationStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCloudServiceOrganizationStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudServiceOrganizationStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudServiceTypeStatusRequest extends $tea.Model {
  organizationId?: string;
  serviceType?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
      serviceType: 'ServiceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
      serviceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudServiceTypeStatusResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeCloudServiceTypeStatusResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeCloudServiceTypeStatusResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudServiceTypeStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeCloudServiceTypeStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeCloudServiceTypeStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumAdminStatusRequest extends $tea.Model {
  location?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumAdminStatusResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeConsortiumAdminStatusResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeConsortiumAdminStatusResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumAdminStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeConsortiumAdminStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeConsortiumAdminStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumChaincodesRequest extends $tea.Model {
  consortiumId?: string;
  location?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumChaincodesResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeConsortiumChaincodesResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeConsortiumChaincodesResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumChaincodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeConsortiumChaincodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeConsortiumChaincodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumChannelsRequest extends $tea.Model {
  consortiumId?: string;
  location?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumChannelsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeConsortiumChannelsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeConsortiumChannelsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumChannelsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeConsortiumChannelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeConsortiumChannelsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumConfigResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeConsortiumConfigResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeConsortiumConfigResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeConsortiumConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeConsortiumConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumDeletableRequest extends $tea.Model {
  consortiumId?: string;
  location?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumDeletableResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeConsortiumDeletableResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeConsortiumDeletableResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumDeletableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeConsortiumDeletableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeConsortiumDeletableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumMemberApprovalRequest extends $tea.Model {
  consortiumId?: string;
  location?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumMemberApprovalResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeConsortiumMemberApprovalResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeConsortiumMemberApprovalResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumMemberApprovalResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeConsortiumMemberApprovalResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeConsortiumMemberApprovalResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumMembersRequest extends $tea.Model {
  consortiumId?: string;
  location?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumMembersResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeConsortiumMembersResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeConsortiumMembersResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeConsortiumMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeConsortiumMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumOrderersRequest extends $tea.Model {
  consortiumId?: string;
  location?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumOrderersResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeConsortiumOrderersResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeConsortiumOrderersResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumOrderersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeConsortiumOrderersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeConsortiumOrderersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumSpecsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeConsortiumSpecsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeConsortiumSpecsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumSpecsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeConsortiumSpecsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeConsortiumSpecsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumsRequest extends $tea.Model {
  consortiumId?: string;
  location?: string;
  tag?: DescribeConsortiumsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      location: 'Location',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      location: 'string',
      tag: { 'type': 'array', 'itemType': DescribeConsortiumsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeConsortiumsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeConsortiumsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeConsortiumsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeConsortiumsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDownloadPathsRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDownloadPathsResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeDownloadPathsResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeDownloadPathsResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDownloadPathsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDownloadPathsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDownloadPathsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDownloadPathsOfContractChainRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDownloadPathsOfContractChainResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeDownloadPathsOfContractChainResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeDownloadPathsOfContractChainResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDownloadPathsOfContractChainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDownloadPathsOfContractChainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDownloadPathsOfContractChainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDownloadPathsOfNotaryChainRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDownloadPathsOfNotaryChainResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeDownloadPathsOfNotaryChainResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeDownloadPathsOfNotaryChainResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDownloadPathsOfNotaryChainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeDownloadPathsOfNotaryChainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeDownloadPathsOfNotaryChainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEcosphereSpecsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeEcosphereSpecsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeEcosphereSpecsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEcosphereSpecsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEcosphereSpecsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEcosphereSpecsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumRequest extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeEthereumResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeEthereumResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEthereumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEthereumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumClientUsersRequest extends $tea.Model {
  nodeId?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumClientUsersResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeEthereumClientUsersResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeEthereumClientUsersResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumClientUsersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEthereumClientUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEthereumClientUsersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumDeletableRequest extends $tea.Model {
  ethereumId?: string;
  static names(): { [key: string]: string } {
    return {
      ethereumId: 'EthereumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ethereumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumDeletableResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeEthereumDeletableResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeEthereumDeletableResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumDeletableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEthereumDeletableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEthereumDeletableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumInvitaionRequest extends $tea.Model {
  token?: string;
  static names(): { [key: string]: string } {
    return {
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumInvitaionResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeEthereumInvitaionResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeEthereumInvitaionResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumInvitaionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEthereumInvitaionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEthereumInvitaionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumInviteeRequest extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumInviteeResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeEthereumInviteeResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeEthereumInviteeResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumInviteeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEthereumInviteeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEthereumInviteeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeRequest extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeEthereumNodeResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeEthereumNodeResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEthereumNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEthereumNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeConfigurationRequest extends $tea.Model {
  nodeId?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeConfigurationResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeEthereumNodeConfigurationResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeEthereumNodeConfigurationResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeConfigurationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEthereumNodeConfigurationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEthereumNodeConfigurationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeInfoRequest extends $tea.Model {
  nodeId?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeInfoResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEthereumNodeInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEthereumNodeInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeLogsRequest extends $tea.Model {
  lines?: string;
  nodeId?: string;
  target?: string;
  static names(): { [key: string]: string } {
    return {
      lines: 'Lines',
      nodeId: 'NodeId',
      target: 'Target',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lines: 'string',
      nodeId: 'string',
      target: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeLogsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEthereumNodeLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEthereumNodeLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodesResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeEthereumNodesResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeEthereumNodesResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEthereumNodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEthereumNodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeEthereumsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeEthereumsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeEthereumsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeEthereumsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExplorerRequest extends $tea.Model {
  exBody?: string;
  exMethod?: string;
  exUrl?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      exBody: 'ExBody',
      exMethod: 'ExMethod',
      exUrl: 'ExUrl',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      exBody: 'string',
      exMethod: 'string',
      exUrl: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExplorerResponseBody extends $tea.Model {
  dynamicCode?: string;
  dynamicMessage?: string;
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExplorerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeExplorerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeExplorerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExplorerURLRequest extends $tea.Model {
  nodeId?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExplorerURLResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeExplorerURLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeExplorerURLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeExplorerURLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChaincodeEndorsePolicyRequest extends $tea.Model {
  chaincodeName?: string;
  channelId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeName: 'ChaincodeName',
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeName: 'string',
      channelId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChaincodeEndorsePolicyResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChaincodeEndorsePolicyResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeFabricChaincodeEndorsePolicyResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFabricChaincodeEndorsePolicyResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChaincodeLogsRequest extends $tea.Model {
  chaincodeId?: string;
  lines?: string;
  offset?: number;
  organizationId?: string;
  peerName?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      lines: 'Lines',
      offset: 'Offset',
      organizationId: 'OrganizationId',
      peerName: 'PeerName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      lines: 'string',
      offset: 'number',
      organizationId: 'string',
      peerName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChaincodeLogsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChaincodeLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeFabricChaincodeLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFabricChaincodeLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelConfigRequest extends $tea.Model {
  channelId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelConfigResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeFabricChannelConfigResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeFabricChannelConfigResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeFabricChannelConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFabricChannelConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelOrdererRequest extends $tea.Model {
  channelId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelOrdererResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeFabricChannelOrdererResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeFabricChannelOrdererResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelOrdererResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeFabricChannelOrdererResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFabricChannelOrdererResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelOrganizationsRequest extends $tea.Model {
  channelId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelOrganizationsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeFabricChannelOrganizationsResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeFabricChannelOrganizationsResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelOrganizationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeFabricChannelOrganizationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFabricChannelOrganizationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricJoinRequestRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricJoinRequestResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricJoinRequestResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeFabricJoinRequestResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFabricJoinRequestResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricJoinResponseRequest extends $tea.Model {
  channelId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricJoinResponseResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricJoinResponseResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeFabricJoinResponseResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFabricJoinResponseResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricManagementChaincodesRequest extends $tea.Model {
  channelId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricManagementChaincodesResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeFabricManagementChaincodesResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeFabricManagementChaincodesResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricManagementChaincodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeFabricManagementChaincodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFabricManagementChaincodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricOrganizationChaincodePackageRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricOrganizationChaincodePackageResponseBody extends $tea.Model {
  errorCode?: number;
  message?: string;
  requestId?: string;
  result?: string[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      message: 'string',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': 'string' },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricOrganizationChaincodePackageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeFabricOrganizationChaincodePackageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFabricOrganizationChaincodePackageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricOrganizationEgressRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricOrganizationEgressResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': 'string' },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricOrganizationEgressResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeFabricOrganizationEgressResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFabricOrganizationEgressResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricPeerChannelsRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricPeerChannelsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': 'string' },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricPeerChannelsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeFabricPeerChannelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeFabricPeerChannelsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskRequest extends $tea.Model {
  channelId?: string;
  organizationId?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      organizationId: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeGovernanceTaskResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeGovernanceTaskResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGovernanceTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGovernanceTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksRequest extends $tea.Model {
  channelId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeGovernanceTasksResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeGovernanceTasksResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeGovernanceTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeGovernanceTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvitationCodeRequest extends $tea.Model {
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvitationCodeResponseBody extends $tea.Model {
  dynamicCode?: string;
  dynamicMessage?: string;
  errorCode?: number;
  requestId?: string;
  result?: DescribeInvitationCodeResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'number',
      requestId: 'string',
      result: DescribeInvitationCodeResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvitationCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInvitationCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInvitationCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvitationListRequest extends $tea.Model {
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvitationListResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeInvitationListResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeInvitationListResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvitationListResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInvitationListResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInvitationListResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInviterRequest extends $tea.Model {
  code?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInviterResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeInviterResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeInviterResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInviterResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeInviterResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeInviterResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatest15BlocksRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatest15BlocksResponseBody extends $tea.Model {
  requestId?: string;
  result?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatest15BlocksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeLatest15BlocksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLatest15BlocksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatest15TransDigestsRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatest15TransDigestsResponseBody extends $tea.Model {
  requestId?: string;
  result?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatest15TransDigestsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeLatest15TransDigestsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLatest15TransDigestsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatestBlocksRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatestBlocksResponseBody extends $tea.Model {
  requestId?: string;
  result?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatestBlocksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeLatestBlocksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLatestBlocksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatestTransactionDigestsRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatestTransactionDigestsResponseBody extends $tea.Model {
  requestId?: string;
  result?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeLatestTransactionDigestsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeLatestTransactionDigestsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeLatestTransactionDigestsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMemberRoleRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMemberRoleResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeMemberRoleResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeMemberRoleResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMemberRoleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMemberRoleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMemberRoleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMembersRequest extends $tea.Model {
  bizid?: string;
  current?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      current: 'Current',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      current: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMembersResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeMembersResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeMembersResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricRequest extends $tea.Model {
  bizid?: string;
  innerIp?: string;
  metric?: string;
  period?: string;
  port?: string;
  timeArea?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      innerIp: 'InnerIp',
      metric: 'Metric',
      period: 'Period',
      port: 'Port',
      timeArea: 'TimeArea',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      innerIp: 'string',
      metric: 'string',
      period: 'string',
      port: 'string',
      timeArea: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMetricResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMetricResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMetricResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMyBlockchainsResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeMyBlockchainsResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeMyBlockchainsResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMyBlockchainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMyBlockchainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMyBlockchainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMyBlockchanInfosResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeMyBlockchanInfosResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeMyBlockchanInfosResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMyBlockchanInfosResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMyBlockchanInfosResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMyBlockchanInfosResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMySuccessAppliesResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeMySuccessAppliesResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeMySuccessAppliesResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMySuccessAppliesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMySuccessAppliesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMySuccessAppliesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMySuccessfulApplicationResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeMySuccessfulApplicationResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeMySuccessfulApplicationResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMySuccessfulApplicationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeMySuccessfulApplicationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeMySuccessfulApplicationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetstatURLRequest extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetstatURLResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeNetstatURLResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeNetstatURLResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeNetstatURLResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrdererLogsRequest extends $tea.Model {
  consortiumId?: string;
  lines?: string;
  ordererName?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      lines: 'Lines',
      ordererName: 'OrdererName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      lines: 'string',
      ordererName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrdererLogsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrdererLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOrdererLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrdererLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationRequest extends $tea.Model {
  location?: string;
  organizationId?: string;
  tag?: DescribeOrganizationRequestTag[];
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      organizationId: 'OrganizationId',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      organizationId: 'string',
      tag: { 'type': 'array', 'itemType': DescribeOrganizationRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeOrganizationResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeOrganizationResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOrganizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrganizationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationChaincodesRequest extends $tea.Model {
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationChaincodesResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeOrganizationChaincodesResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeOrganizationChaincodesResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationChaincodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOrganizationChaincodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrganizationChaincodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationChannelsRequest extends $tea.Model {
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationChannelsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeOrganizationChannelsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeOrganizationChannelsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationChannelsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOrganizationChannelsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrganizationChannelsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationDeletableRequest extends $tea.Model {
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationDeletableResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeOrganizationDeletableResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeOrganizationDeletableResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationDeletableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOrganizationDeletableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrganizationDeletableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationMembersRequest extends $tea.Model {
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationMembersResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeOrganizationMembersResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeOrganizationMembersResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationMembersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOrganizationMembersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrganizationMembersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationPeersRequest extends $tea.Model {
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationPeersResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeOrganizationPeersResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeOrganizationPeersResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationPeersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOrganizationPeersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrganizationPeersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationSpecsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeOrganizationSpecsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeOrganizationSpecsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationSpecsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOrganizationSpecsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrganizationSpecsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationTriggersRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationTriggersResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeOrganizationTriggersResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeOrganizationTriggersResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationTriggersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOrganizationTriggersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrganizationTriggersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationUserCertsRequest extends $tea.Model {
  organizationId?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationUserCertsResponseBody extends $tea.Model {
  dynamicCode?: string;
  dynamicMessage?: string;
  errorCode?: number;
  requestId?: string;
  result?: DescribeOrganizationUserCertsResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'number',
      requestId: 'string',
      result: DescribeOrganizationUserCertsResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationUserCertsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOrganizationUserCertsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrganizationUserCertsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationUsersRequest extends $tea.Model {
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationUsersResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeOrganizationUsersResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeOrganizationUsersResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationUsersResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOrganizationUsersResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrganizationUsersResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationsRequest extends $tea.Model {
  location?: string;
  tag?: DescribeOrganizationsRequestTag[];
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      tag: { 'type': 'array', 'itemType': DescribeOrganizationsRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeOrganizationsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeOrganizationsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOrganizationsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrganizationsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrgnaizationChaincodesRequest extends $tea.Model {
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrgnaizationChaincodesResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeOrgnaizationChaincodesResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeOrgnaizationChaincodesResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrgnaizationChaincodesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOrgnaizationChaincodesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOrgnaizationChaincodesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOssPropertiesRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOssPropertiesResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeOssPropertiesResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeOssPropertiesResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOssPropertiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeOssPropertiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeOssPropertiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePeerLogsRequest extends $tea.Model {
  lines?: string;
  organizationId?: string;
  peerName?: string;
  static names(): { [key: string]: string } {
    return {
      lines: 'Lines',
      organizationId: 'OrganizationId',
      peerName: 'PeerName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      lines: 'string',
      organizationId: 'string',
      peerName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePeerLogsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePeerLogsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePeerLogsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePeerLogsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePublicAntChainContractProjectContentTreeResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribePublicAntChainContractProjectContentTreeResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribePublicAntChainContractProjectContentTreeResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePublicAntChainContractProjectContentTreeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePublicAntChainContractProjectContentTreeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePublicAntChainContractProjectContentTreeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePublicAntChainDownloadPathsRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePublicAntChainDownloadPathsResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribePublicAntChainDownloadPathsResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribePublicAntChainDownloadPathsResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePublicAntChainDownloadPathsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePublicAntChainDownloadPathsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePublicAntChainDownloadPathsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePublicCloudIDEEnvConfigsRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePublicCloudIDEEnvConfigsResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribePublicCloudIDEEnvConfigsResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribePublicCloudIDEEnvConfigsResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePublicCloudIDEEnvConfigsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribePublicCloudIDEEnvConfigsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribePublicCloudIDEEnvConfigsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeQRCodeAccessLogRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeQRCodeAccessLogResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeQRCodeAccessLogResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeQRCodeAccessLogResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeQRCodeAccessLogResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeQRCodeAccessLogResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeQRCodeAccessLogResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeQRCodeAuthorityRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeQRCodeAuthorityResponseBody extends $tea.Model {
  requestId?: string;
  result?: boolean;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeQRCodeAuthorityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeQRCodeAuthorityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeQRCodeAuthorityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRegionsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeRegionsResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeRegionsResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRegionsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRegionsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRegionsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceTypeResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeResourceTypeResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeResourceTypeResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceTypeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeResourceTypeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeResourceTypeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceTypesResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeResourceTypesResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeResourceTypesResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceTypesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeResourceTypesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeResourceTypesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRootDomainResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRootDomainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeRootDomainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeRootDomainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchemaDetailRequest extends $tea.Model {
  bizid?: string;
  schemaId?: number;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      schemaId: 'SchemaId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      schemaId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchemaDetailResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeSchemaDetailResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeSchemaDetailResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchemaDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSchemaDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSchemaDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractJobStatusRequest extends $tea.Model {
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractJobStatusResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractJobStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSmartContractJobStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSmartContractJobStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractJobsRequest extends $tea.Model {
  size?: number;
  start?: number;
  static names(): { [key: string]: string } {
    return {
      size: 'Size',
      start: 'Start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      size: 'number',
      start: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractJobsResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeSmartContractJobsResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeSmartContractJobsResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractJobsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSmartContractJobsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSmartContractJobsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractJobsByNameRequest extends $tea.Model {
  name?: string;
  size?: number;
  start?: number;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      size: 'Size',
      start: 'Start',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      size: 'number',
      start: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractJobsByNameResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeSmartContractJobsByNameResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeSmartContractJobsByNameResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractJobsByNameResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSmartContractJobsByNameResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSmartContractJobsByNameResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractResultRequest extends $tea.Model {
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractResultResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractResultResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSmartContractResultResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSmartContractResultResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractResultContentRequest extends $tea.Model {
  jobId?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractResultContentResponseBody extends $tea.Model {
  dynamicCode?: string;
  dynamicMessage?: string;
  errorCode?: number;
  requestId?: string;
  result?: DescribeSmartContractResultContentResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeSmartContractResultContentResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractResultContentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSmartContractResultContentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSmartContractResultContentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSubscribeCloudServiceIntegrationStateRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSubscribeCloudServiceIntegrationStateResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSubscribeCloudServiceIntegrationStateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeSubscribeCloudServiceIntegrationStateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeSubscribeCloudServiceIntegrationStateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTasksResponseBody extends $tea.Model {
  dynamicCode?: string;
  dynamicMessage?: string;
  errorCode?: number;
  requestId?: string;
  result?: DescribeTasksResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DescribeTasksResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTasksResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTasksResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTasksResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTemplatesResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeTemplatesResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeTemplatesResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionRequest extends $tea.Model {
  bizid?: string;
  hash?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      hash: 'Hash',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      hash: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeTransactionResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeTransactionResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTransactionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTransactionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionFor2CBrowserRequest extends $tea.Model {
  alipayAuthCode?: string;
  bizid?: string;
  hash?: string;
  static names(): { [key: string]: string } {
    return {
      alipayAuthCode: 'AlipayAuthCode',
      bizid: 'Bizid',
      hash: 'Hash',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alipayAuthCode: 'string',
      bizid: 'string',
      hash: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionFor2CBrowserResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeTransactionFor2CBrowserResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeTransactionFor2CBrowserResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionFor2CBrowserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTransactionFor2CBrowserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTransactionFor2CBrowserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionQRCodeRequest extends $tea.Model {
  bizid?: string;
  hash?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      hash: 'Hash',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      hash: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionQRCodeResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionQRCodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTransactionQRCodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTransactionQRCodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionReceiptFor2CBrowserRequest extends $tea.Model {
  alipayAuthCode?: string;
  bizid?: string;
  hash?: string;
  static names(): { [key: string]: string } {
    return {
      alipayAuthCode: 'AlipayAuthCode',
      bizid: 'Bizid',
      hash: 'Hash',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alipayAuthCode: 'string',
      bizid: 'string',
      hash: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionReceiptFor2CBrowserResponseBody extends $tea.Model {
  requestId?: string;
  result?: DescribeTransactionReceiptFor2CBrowserResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DescribeTransactionReceiptFor2CBrowserResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionReceiptFor2CBrowserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTransactionReceiptFor2CBrowserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTransactionReceiptFor2CBrowserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTriggerRequest extends $tea.Model {
  channelId?: string;
  name?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      name: 'Name',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      name: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTriggerResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DescribeTriggerResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DescribeTriggerResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTriggerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DescribeTriggerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DescribeTriggerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DestroyConsortiumRequest extends $tea.Model {
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DestroyConsortiumResponseBody extends $tea.Model {
  dynamicCode?: string;
  dynamicMessage?: string;
  errorCode?: number;
  requestId?: string;
  result?: DestroyConsortiumResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'number',
      requestId: 'string',
      result: DestroyConsortiumResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DestroyConsortiumResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DestroyConsortiumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DestroyConsortiumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DestroyEthereumRequest extends $tea.Model {
  ethereumId?: string;
  static names(): { [key: string]: string } {
    return {
      ethereumId: 'EthereumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ethereumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DestroyEthereumResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DestroyEthereumResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: DestroyEthereumResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DestroyEthereumResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DestroyEthereumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DestroyEthereumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DestroyOrganizationRequest extends $tea.Model {
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DestroyOrganizationResponseBody extends $tea.Model {
  dynamicCode?: string;
  dynamicMessage?: string;
  errorCode?: number;
  requestId?: string;
  result?: DestroyOrganizationResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      dynamicCode: 'DynamicCode',
      dynamicMessage: 'DynamicMessage',
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      dynamicCode: 'string',
      dynamicMessage: 'string',
      errorCode: 'number',
      requestId: 'string',
      result: DestroyOrganizationResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DestroyOrganizationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DestroyOrganizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DestroyOrganizationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadAllRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadAllResponseBody extends $tea.Model {
  requestId?: string;
  result?: DownloadAllResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DownloadAllResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadAllResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DownloadAllResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DownloadAllResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadBizviewRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadBizviewResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadBizviewResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DownloadBizviewResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DownloadBizviewResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadFabricChannelSDKRequest extends $tea.Model {
  channelId?: string;
  location?: string;
  organizationId?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      location: 'Location',
      organizationId: 'OrganizationId',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      location: 'string',
      organizationId: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadFabricChannelSDKResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DownloadFabricChannelSDKResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DownloadFabricChannelSDKResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadFabricChannelSDKResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DownloadFabricChannelSDKResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DownloadFabricChannelSDKResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadOrganizationSDKRequest extends $tea.Model {
  location?: string;
  organizationId?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      organizationId: 'OrganizationId',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      organizationId: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadOrganizationSDKResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: DownloadOrganizationSDKResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': DownloadOrganizationSDKResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadOrganizationSDKResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DownloadOrganizationSDKResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DownloadOrganizationSDKResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadSDK2Request extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadSDK2ResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadSDK2Response extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DownloadSDK2ResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DownloadSDK2ResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadSdkRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadSdkResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadSdkResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DownloadSdkResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DownloadSdkResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadSignedDataRequest extends $tea.Model {
  bizid?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadSignedDataResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadSignedDataResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DownloadSignedDataResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DownloadSignedDataResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DuplicateAntChainContractProjectRequest extends $tea.Model {
  description?: string;
  name?: string;
  projectId?: string;
  projectVersion?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      name: 'Name',
      projectId: 'ProjectId',
      projectVersion: 'ProjectVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      name: 'string',
      projectId: 'string',
      projectVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DuplicateAntChainContractProjectResponseBody extends $tea.Model {
  requestId?: string;
  result?: DuplicateAntChainContractProjectResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: DuplicateAntChainContractProjectResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DuplicateAntChainContractProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: DuplicateAntChainContractProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: DuplicateAntChainContractProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FreezeAccountRequest extends $tea.Model {
  account?: string;
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FreezeAccountResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FreezeAccountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: FreezeAccountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: FreezeAccountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FreezeAntChainAccountRequest extends $tea.Model {
  account?: string;
  antChainId?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      antChainId: 'AntChainId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      antChainId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FreezeAntChainAccountResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class FreezeAntChainAccountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: FreezeAntChainAccountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: FreezeAntChainAccountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppliesRequest extends $tea.Model {
  bizid?: string;
  current?: number;
  pageSize?: number;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      current: 'Current',
      pageSize: 'PageSize',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      current: 'number',
      pageSize: 'number',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppliesResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetAppliesResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: GetAppliesResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppliesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetAppliesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetAppliesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBcSchemaRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBcSchemaResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetBcSchemaResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: GetBcSchemaResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBcSchemaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetBcSchemaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetBcSchemaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlockchainCreateTaskRequest extends $tea.Model {
  current?: number;
  pageSize?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'Current',
      pageSize: 'PageSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      pageSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlockchainCreateTaskResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetBlockchainCreateTaskResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: GetBlockchainCreateTaskResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlockchainCreateTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetBlockchainCreateTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetBlockchainCreateTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlockchainInfoRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlockchainInfoResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetBlockchainInfoResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: GetBlockchainInfoResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlockchainInfoResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetBlockchainInfoResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetBlockchainInfoResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMyBlockchainsResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetMyBlockchainsResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': GetMyBlockchainsResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMyBlockchainsResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMyBlockchainsResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMyBlockchainsResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMySuccessAppliesResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetMySuccessAppliesResponseBodyResult[];
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: { 'type': 'array', 'itemType': GetMySuccessAppliesResponseBodyResult },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMySuccessAppliesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetMySuccessAppliesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetMySuccessAppliesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOssPropertiesRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOssPropertiesResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetOssPropertiesResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: GetOssPropertiesResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOssPropertiesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetOssPropertiesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetOssPropertiesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTemplatesResponseBody extends $tea.Model {
  requestId?: string;
  result?: GetTemplatesResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: GetTemplatesResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTemplatesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: GetTemplatesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: GetTemplatesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallChaincodeRequest extends $tea.Model {
  chaincodeId?: string;
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallChaincodeResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: InstallChaincodeResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: InstallChaincodeResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallChaincodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InstallChaincodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InstallChaincodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallFabricChaincodePackageRequest extends $tea.Model {
  chaincodePackageId?: string;
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodePackageId: 'ChaincodePackageId',
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodePackageId: 'string',
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallFabricChaincodePackageResponseBody extends $tea.Model {
  errorCode?: number;
  message?: string;
  requestId?: string;
  result?: InstallFabricChaincodePackageResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      message: 'Message',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      message: 'string',
      requestId: 'string',
      result: InstallFabricChaincodePackageResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallFabricChaincodePackageResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InstallFabricChaincodePackageResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InstallFabricChaincodePackageResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstantiateChaincodeRequest extends $tea.Model {
  chaincodeId?: string;
  collectionConfig?: string;
  endorsePolicy?: string;
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      collectionConfig: 'CollectionConfig',
      endorsePolicy: 'EndorsePolicy',
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      collectionConfig: 'string',
      endorsePolicy: 'string',
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstantiateChaincodeResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: InstantiateChaincodeResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: InstantiateChaincodeResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstantiateChaincodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InstantiateChaincodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InstantiateChaincodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUserRequest extends $tea.Model {
  bid?: string;
  bizid?: string;
  userEmail?: string;
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      bid: 'Bid',
      bizid: 'Bizid',
      userEmail: 'UserEmail',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bid: 'string',
      bizid: 'string',
      userEmail: 'string',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUserResponseBody extends $tea.Model {
  requestId?: string;
  result?: InviteUserResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: InviteUserResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: InviteUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: InviteUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinChannelRequest extends $tea.Model {
  channelId?: string;
  do?: string;
  location?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      do: 'Do',
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      do: 'string',
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinChannelResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: JoinChannelResponseBodyResult[];
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: { 'type': 'array', 'itemType': JoinChannelResponseBodyResult },
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinChannelResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: JoinChannelResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: JoinChannelResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequest extends $tea.Model {
  nextToken?: string;
  resourceId?: string[];
  resourceType?: string;
  tag?: ListTagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': ListTagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBody extends $tea.Model {
  nextToken?: string;
  requestId?: string;
  tagResources?: ListTagResourcesResponseBodyTagResources[];
  static names(): { [key: string]: string } {
    return {
      nextToken: 'NextToken',
      requestId: 'RequestId',
      tagResources: 'TagResources',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nextToken: 'string',
      requestId: 'string',
      tagResources: { 'type': 'array', 'itemType': ListTagResourcesResponseBodyTagResources },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ListTagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ListTagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTriggerRequest extends $tea.Model {
  channelId?: string;
  name?: string;
  options?: string;
  organizationId?: string;
  source?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      name: 'Name',
      options: 'Options',
      organizationId: 'OrganizationId',
      source: 'Source',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      name: 'string',
      options: 'string',
      organizationId: 'string',
      source: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTriggerResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: ModifyTriggerResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: ModifyTriggerResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTriggerResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ModifyTriggerResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ModifyTriggerResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateUserRequest extends $tea.Model {
  bid?: string;
  bizid?: string;
  operation?: number;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      bid: 'Bid',
      bizid: 'Bizid',
      operation: 'Operation',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bid: 'string',
      bizid: 'string',
      operation: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateUserResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class OperateUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: OperateUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: OperateUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ProcessCloudIDEContractTransactionRequest extends $tea.Model {
  antChainId?: string;
  transaction?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      transaction: 'Transaction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      transaction: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ProcessCloudIDEContractTransactionResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ProcessCloudIDEContractTransactionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ProcessCloudIDEContractTransactionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ProcessCloudIDEContractTransactionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ProcessPublicCloudIDEContractTransactionRequest extends $tea.Model {
  bizid?: string;
  transaction?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      transaction: 'Transaction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      transaction: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ProcessPublicCloudIDEContractTransactionResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ProcessPublicCloudIDEContractTransactionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ProcessPublicCloudIDEContractTransactionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ProcessPublicCloudIDEContractTransactionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBlockRequest extends $tea.Model {
  bizid?: string;
  height?: number;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      height: 'Height',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      height: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBlockResponseBody extends $tea.Model {
  requestId?: string;
  result?: QueryBlockResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: QueryBlockResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBlockResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryBlockResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryBlockResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsortiumDeletableRequest extends $tea.Model {
  consortiumId?: string;
  location?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      location: 'Location',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      location: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsortiumDeletableResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: QueryConsortiumDeletableResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: QueryConsortiumDeletableResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsortiumDeletableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryConsortiumDeletableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryConsortiumDeletableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEthereumDeletableRequest extends $tea.Model {
  ethereumId?: string;
  static names(): { [key: string]: string } {
    return {
      ethereumId: 'EthereumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      ethereumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEthereumDeletableResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: QueryEthereumDeletableResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: QueryEthereumDeletableResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEthereumDeletableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryEthereumDeletableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryEthereumDeletableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMetricRequest extends $tea.Model {
  bizid?: string;
  innerIp?: string;
  metric?: string;
  period?: string;
  port?: string;
  timeArea?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      innerIp: 'InnerIp',
      metric: 'Metric',
      period: 'Period',
      port: 'Port',
      timeArea: 'TimeArea',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      innerIp: 'string',
      metric: 'string',
      period: 'string',
      port: 'string',
      timeArea: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMetricResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryMetricResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryMetricResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryMetricResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrganizationDeletableRequest extends $tea.Model {
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrganizationDeletableResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: QueryOrganizationDeletableResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: QueryOrganizationDeletableResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrganizationDeletableResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryOrganizationDeletableResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryOrganizationDeletableResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTransactionRequest extends $tea.Model {
  bizid?: string;
  hash?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      hash: 'Hash',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      hash: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTransactionResponseBody extends $tea.Model {
  requestId?: string;
  result?: QueryTransactionResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: QueryTransactionResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTransactionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: QueryTransactionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: QueryTransactionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RejectUserRequest extends $tea.Model {
  bid?: string;
  bizid?: string;
  reason?: string;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      bid: 'Bid',
      bizid: 'Bizid',
      reason: 'Reason',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bid: 'string',
      bizid: 'string',
      reason: 'string',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RejectUserResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RejectUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RejectUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RejectUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenameBlockchainRequest extends $tea.Model {
  bizid?: string;
  newName?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      newName: 'NewName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      newName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenameBlockchainResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class RenameBlockchainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: RenameBlockchainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: RenameBlockchainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetAntChainCertificateRequest extends $tea.Model {
  antChainId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetAntChainCertificateResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetAntChainCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResetAntChainCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetAntChainCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetAntChainUserCertificateRequest extends $tea.Model {
  antChainId?: string;
  bid?: string;
  operation?: number;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      bid: 'Bid',
      operation: 'Operation',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      bid: 'string',
      operation: 'number',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetAntChainUserCertificateResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetAntChainUserCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResetAntChainUserCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetAntChainUserCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetCertificateRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetCertificateResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResetCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetOrganizationUserPasswordRequest extends $tea.Model {
  location?: string;
  organizationId?: string;
  password?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      organizationId: 'OrganizationId',
      password: 'Password',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: 'string',
      organizationId: 'string',
      password: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetOrganizationUserPasswordResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: ResetOrganizationUserPasswordResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: ResetOrganizationUserPasswordResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetOrganizationUserPasswordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResetOrganizationUserPasswordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetOrganizationUserPasswordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetPublicAntChainCertificateRequest extends $tea.Model {
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetPublicAntChainCertificateResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetPublicAntChainCertificateResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResetPublicAntChainCertificateResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetPublicAntChainCertificateResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetUserRequest extends $tea.Model {
  bid?: string;
  bizid?: string;
  operation?: number;
  userName?: string;
  static names(): { [key: string]: string } {
    return {
      bid: 'Bid',
      bizid: 'Bizid',
      operation: 'Operation',
      userName: 'UserName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bid: 'string',
      bizid: 'string',
      operation: 'number',
      userName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetUserResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetUserResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: ResetUserResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: ResetUserResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SchemaDetailRequest extends $tea.Model {
  bizid?: string;
  schemaId?: number;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      schemaId: 'SchemaId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      schemaId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SchemaDetailResponseBody extends $tea.Model {
  requestId?: string;
  result?: SchemaDetailResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: SchemaDetailResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SchemaDetailResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SchemaDetailResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SchemaDetailResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartSmartContractJobRequest extends $tea.Model {
  jobId?: string;
  jobName?: string;
  sourceOpt?: string;
  sourceType?: string;
  static names(): { [key: string]: string } {
    return {
      jobId: 'JobId',
      jobName: 'JobName',
      sourceOpt: 'SourceOpt',
      sourceType: 'SourceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      jobId: 'string',
      jobName: 'string',
      sourceOpt: 'string',
      sourceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartSmartContractJobResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class StartSmartContractJobResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: StartSmartContractJobResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: StartSmartContractJobResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFabricChaincodeDefinitionRequest extends $tea.Model {
  chaincodePackageId?: string;
  chaincodeVersion?: string;
  channelId?: string;
  collectionConfig?: string;
  endorsePolicy?: string;
  initRequired?: boolean;
  location?: string;
  name?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodePackageId: 'ChaincodePackageId',
      chaincodeVersion: 'ChaincodeVersion',
      channelId: 'ChannelId',
      collectionConfig: 'CollectionConfig',
      endorsePolicy: 'EndorsePolicy',
      initRequired: 'InitRequired',
      location: 'Location',
      name: 'Name',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodePackageId: 'string',
      chaincodeVersion: 'string',
      channelId: 'string',
      collectionConfig: 'string',
      endorsePolicy: 'string',
      initRequired: 'boolean',
      location: 'string',
      name: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFabricChaincodeDefinitionResponseBody extends $tea.Model {
  chaincodeDefinitionId?: string;
  chaincodePackageId?: string;
  errorCode?: number;
  initRequired?: boolean;
  requestId?: string;
  result?: SubmitFabricChaincodeDefinitionResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      chaincodeDefinitionId: 'ChaincodeDefinitionId',
      chaincodePackageId: 'ChaincodePackageId',
      errorCode: 'ErrorCode',
      initRequired: 'InitRequired',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeDefinitionId: 'string',
      chaincodePackageId: 'string',
      errorCode: 'number',
      initRequired: 'boolean',
      requestId: 'string',
      result: SubmitFabricChaincodeDefinitionResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFabricChaincodeDefinitionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SubmitFabricChaincodeDefinitionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SubmitFabricChaincodeDefinitionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncFabricChaincodeStatusRequest extends $tea.Model {
  chaincodeId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncFabricChaincodeStatusResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: SyncFabricChaincodeStatusResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: SyncFabricChaincodeStatusResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncFabricChaincodeStatusResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SyncFabricChaincodeStatusResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SyncFabricChaincodeStatusResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SynchronizeChaincodeRequest extends $tea.Model {
  chaincodeId?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SynchronizeChaincodeResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: SynchronizeChaincodeResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: SynchronizeChaincodeResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SynchronizeChaincodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: SynchronizeChaincodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: SynchronizeChaincodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequest extends $tea.Model {
  resourceId?: string[];
  resourceType?: string;
  tag?: TagResourcesRequestTag[];
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tag: 'Tag',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tag: { 'type': 'array', 'itemType': TagResourcesRequestTag },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: boolean;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: TagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: TagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnfreezeAccountRequest extends $tea.Model {
  account?: string;
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnfreezeAccountResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnfreezeAccountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UnfreezeAccountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UnfreezeAccountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnfreezeAntChainAccountRequest extends $tea.Model {
  account?: string;
  antChainId?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      antChainId: 'AntChainId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      antChainId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnfreezeAntChainAccountResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UnfreezeAntChainAccountResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UnfreezeAntChainAccountResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UnfreezeAntChainAccountResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesRequest extends $tea.Model {
  all?: boolean;
  resourceId?: string[];
  resourceType?: string;
  tagKey?: string[];
  static names(): { [key: string]: string } {
    return {
      all: 'All',
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      all: 'boolean',
      resourceId: { 'type': 'array', 'itemType': 'string' },
      resourceType: 'string',
      tagKey: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: boolean;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'boolean',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UntagResourcesResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UntagResourcesResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UntagResourcesResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainRequest extends $tea.Model {
  antChainId?: string;
  antChainName?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      antChainName: 'AntChainName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      antChainName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAntChainResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAntChainResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainConsortiumRequest extends $tea.Model {
  consortiumDescription?: string;
  consortiumId?: string;
  consortiumName?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumDescription: 'ConsortiumDescription',
      consortiumId: 'ConsortiumId',
      consortiumName: 'ConsortiumName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumDescription: 'string',
      consortiumId: 'string',
      consortiumName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainConsortiumResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainConsortiumResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAntChainConsortiumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAntChainConsortiumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainContractContentRequest extends $tea.Model {
  content?: string;
  contentId?: string;
  contentName?: string;
  parentContentId?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentId: 'ContentId',
      contentName: 'ContentName',
      parentContentId: 'ParentContentId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentId: 'string',
      contentName: 'string',
      parentContentId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainContractContentResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainContractContentResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAntChainContractContentResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAntChainContractContentResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainContractProjectRequest extends $tea.Model {
  projectDescription?: string;
  projectId?: string;
  projectName?: string;
  projectVersion?: string;
  static names(): { [key: string]: string } {
    return {
      projectDescription: 'ProjectDescription',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      projectVersion: 'ProjectVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      projectDescription: 'string',
      projectId: 'string',
      projectName: 'string',
      projectVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainContractProjectResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainContractProjectResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAntChainContractProjectResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAntChainContractProjectResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainMemberRequest extends $tea.Model {
  consortiumId?: string;
  memberId?: string;
  memberName?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      memberId: 'MemberId',
      memberName: 'MemberName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      memberId: 'string',
      memberName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainMemberResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainMemberResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAntChainMemberResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAntChainMemberResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainQRCodeAuthorizationRequest extends $tea.Model {
  antChainId?: string;
  authorizationType?: string;
  QRCodeType?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      authorizationType: 'AuthorizationType',
      QRCodeType: 'QRCodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      authorizationType: 'string',
      QRCodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainQRCodeAuthorizationResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateAntChainQRCodeAuthorizationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateAntChainQRCodeAuthorizationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateAntChainQRCodeAuthorizationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBlockchainSchemaRequest extends $tea.Model {
  bizid?: string;
  categoryConfigs?: string;
  description?: string;
  schemaId?: number;
  schemaName?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      categoryConfigs: 'CategoryConfigs',
      description: 'Description',
      schemaId: 'SchemaId',
      schemaName: 'SchemaName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      categoryConfigs: 'string',
      description: 'string',
      schemaId: 'number',
      schemaName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBlockchainSchemaResponseBody extends $tea.Model {
  requestId?: string;
  result?: UpdateBlockchainSchemaResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: UpdateBlockchainSchemaResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBlockchainSchemaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateBlockchainSchemaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateBlockchainSchemaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateChannelConfigRequest extends $tea.Model {
  batchTimeout?: number;
  channelId?: string;
  maxMessageCount?: number;
  organizationId?: string;
  preferredMaxBytes?: number;
  static names(): { [key: string]: string } {
    return {
      batchTimeout: 'BatchTimeout',
      channelId: 'ChannelId',
      maxMessageCount: 'MaxMessageCount',
      organizationId: 'OrganizationId',
      preferredMaxBytes: 'PreferredMaxBytes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchTimeout: 'number',
      channelId: 'string',
      maxMessageCount: 'number',
      organizationId: 'string',
      preferredMaxBytes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateChannelConfigResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: UpdateChannelConfigResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: UpdateChannelConfigResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateChannelConfigResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateChannelConfigResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateChannelConfigResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumRequest extends $tea.Model {
  description?: string;
  ethereumId?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      ethereumId: 'EthereumId',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      ethereumId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: UpdateEthereumResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: UpdateEthereumResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateEthereumResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateEthereumResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumClientUserPasswordRequest extends $tea.Model {
  nodeId?: string;
  password?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      password: 'Password',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      password: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumClientUserPasswordResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumClientUserPasswordResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateEthereumClientUserPasswordResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateEthereumClientUserPasswordResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumNodeRequest extends $tea.Model {
  description?: string;
  nodeId?: string;
  nodeName?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      nodeId: 'NodeId',
      nodeName: 'NodeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      nodeId: 'string',
      nodeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumNodeResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: UpdateEthereumNodeResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: UpdateEthereumNodeResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumNodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateEthereumNodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateEthereumNodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumNodeConfigurationRequest extends $tea.Model {
  IP?: string;
  nodeId?: string;
  nodePub?: string;
  p2pPort?: number;
  raftPort?: number;
  rpcPort?: number;
  TMPort?: number;
  TMPub?: string;
  WSPort?: number;
  static names(): { [key: string]: string } {
    return {
      IP: 'IP',
      nodeId: 'NodeId',
      nodePub: 'NodePub',
      p2pPort: 'P2pPort',
      raftPort: 'RaftPort',
      rpcPort: 'RpcPort',
      TMPort: 'TMPort',
      TMPub: 'TMPub',
      WSPort: 'WSPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      IP: 'string',
      nodeId: 'string',
      nodePub: 'string',
      p2pPort: 'number',
      raftPort: 'number',
      rpcPort: 'number',
      TMPort: 'number',
      TMPub: 'string',
      WSPort: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumNodeConfigurationResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: string;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: 'string',
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumNodeConfigurationResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateEthereumNodeConfigurationResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateEthereumNodeConfigurationResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskRequest extends $tea.Model {
  channelId?: string;
  organizationId?: string;
  taskAction?: string;
  taskId?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      organizationId: 'OrganizationId',
      taskAction: 'TaskAction',
      taskId: 'TaskId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      organizationId: 'string',
      taskAction: 'string',
      taskId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: UpdateGovernanceTaskResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: UpdateGovernanceTaskResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateGovernanceTaskResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateGovernanceTaskResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMemberRoleRequest extends $tea.Model {
  bid?: string;
  bizid?: string;
  role?: number;
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      bid: 'Bid',
      bizid: 'Bizid',
      role: 'Role',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bid: 'string',
      bizid: 'string',
      role: 'number',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMemberRoleResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateMemberRoleResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateMemberRoleResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateMemberRoleResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateQRCodeAuthorityRequest extends $tea.Model {
  authorized?: boolean;
  bizid?: string;
  static names(): { [key: string]: string } {
    return {
      authorized: 'Authorized',
      bizid: 'Bizid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      authorized: 'boolean',
      bizid: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateQRCodeAuthorityResponseBody extends $tea.Model {
  requestId?: string;
  result?: string;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateQRCodeAuthorityResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateQRCodeAuthorityResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateQRCodeAuthorityResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSchemaRequest extends $tea.Model {
  bizid?: string;
  categoryConfigs?: string;
  description?: string;
  schemaId?: number;
  schemaName?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      categoryConfigs: 'CategoryConfigs',
      description: 'Description',
      schemaId: 'SchemaId',
      schemaName: 'SchemaName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      categoryConfigs: 'string',
      description: 'string',
      schemaId: 'number',
      schemaName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSchemaResponseBody extends $tea.Model {
  requestId?: string;
  result?: UpdateSchemaResponseBodyResult;
  static names(): { [key: string]: string } {
    return {
      requestId: 'RequestId',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      requestId: 'string',
      result: UpdateSchemaResponseBodyResult,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSchemaResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpdateSchemaResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpdateSchemaResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeChaincodeRequest extends $tea.Model {
  chaincodeId?: string;
  collectionConfig?: string;
  endorsePolicy?: string;
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      collectionConfig: 'CollectionConfig',
      endorsePolicy: 'EndorsePolicy',
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      collectionConfig: 'string',
      endorsePolicy: 'string',
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeChaincodeResponseBody extends $tea.Model {
  errorCode?: number;
  requestId?: string;
  result?: UpgradeChaincodeResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      errorCode: 'ErrorCode',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCode: 'number',
      requestId: 'string',
      result: UpgradeChaincodeResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeChaincodeResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpgradeChaincodeResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpgradeChaincodeResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeFabricChaincodeDefinitionRequest extends $tea.Model {
  chaincodeId?: string;
  chaincodePackageId?: string;
  chaincodeVersion?: string;
  channelId?: string;
  collectionConfig?: string;
  endorsePolicy?: string;
  initRequired?: boolean;
  location?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      chaincodePackageId: 'ChaincodePackageId',
      chaincodeVersion: 'ChaincodeVersion',
      channelId: 'ChannelId',
      collectionConfig: 'CollectionConfig',
      endorsePolicy: 'EndorsePolicy',
      initRequired: 'InitRequired',
      location: 'Location',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      chaincodePackageId: 'string',
      chaincodeVersion: 'string',
      channelId: 'string',
      collectionConfig: 'string',
      endorsePolicy: 'string',
      initRequired: 'boolean',
      location: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeFabricChaincodeDefinitionResponseBody extends $tea.Model {
  chaincodeDefinitionId?: string;
  chaincodePackageId?: string;
  errorCode?: number;
  initRequired?: boolean;
  requestId?: string;
  result?: UpgradeFabricChaincodeDefinitionResponseBodyResult;
  success?: boolean;
  static names(): { [key: string]: string } {
    return {
      chaincodeDefinitionId: 'ChaincodeDefinitionId',
      chaincodePackageId: 'ChaincodePackageId',
      errorCode: 'ErrorCode',
      initRequired: 'InitRequired',
      requestId: 'RequestId',
      result: 'Result',
      success: 'Success',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeDefinitionId: 'string',
      chaincodePackageId: 'string',
      errorCode: 'number',
      initRequired: 'boolean',
      requestId: 'string',
      result: UpgradeFabricChaincodeDefinitionResponseBodyResult,
      success: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeFabricChaincodeDefinitionResponse extends $tea.Model {
  headers?: { [key: string]: string };
  statusCode?: number;
  body?: UpgradeFabricChaincodeDefinitionResponseBody;
  static names(): { [key: string]: string } {
    return {
      headers: 'headers',
      statusCode: 'statusCode',
      body: 'body',
    };
  }

  static types(): { [key: string]: any } {
    return {
      headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
      statusCode: 'number',
      body: UpgradeFabricChaincodeDefinitionResponseBody,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAntChainSubnetMemberCheckResponseBodyResultConsortiumMemberInfoList extends $tea.Model {
  memberId?: string;
  memberName?: string;
  static names(): { [key: string]: string } {
    return {
      memberId: 'MemberId',
      memberName: 'MemberName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberId: 'string',
      memberName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAntChainSubnetMemberCheckResponseBodyResult extends $tea.Model {
  consortiumMemberInfoList?: AddAntChainSubnetMemberCheckResponseBodyResultConsortiumMemberInfoList[];
  static names(): { [key: string]: string } {
    return {
      consortiumMemberInfoList: 'ConsortiumMemberInfoList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumMemberInfoList: { 'type': 'array', 'itemType': AddAntChainSubnetMemberCheckResponseBodyResultConsortiumMemberInfoList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddAntChainSubnetNodeCheckResponseBodyResult extends $tea.Model {
  nodeId?: string;
  nodeName?: string;
  static names(): { [key: string]: string } {
    return {
      nodeId: 'NodeId',
      nodeName: 'NodeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      nodeId: 'string',
      nodeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddEthereumNodeResponseBodyResult extends $tea.Model {
  createTime?: number;
  creator?: string;
  description?: string;
  ethereumId?: string;
  ethereumName?: string;
  id?: string;
  networkId?: string;
  nodeName?: string;
  publicIp?: string;
  regionId?: string;
  rpcPort?: number;
  state?: string;
  wsPort?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      creator: 'Creator',
      description: 'Description',
      ethereumId: 'EthereumId',
      ethereumName: 'EthereumName',
      id: 'Id',
      networkId: 'NetworkId',
      nodeName: 'NodeName',
      publicIp: 'PublicIp',
      regionId: 'RegionId',
      rpcPort: 'RpcPort',
      state: 'State',
      wsPort: 'WsPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creator: 'string',
      description: 'string',
      ethereumId: 'string',
      ethereumName: 'string',
      id: 'string',
      networkId: 'string',
      nodeName: 'string',
      publicIp: 'string',
      regionId: 'string',
      rpcPort: 'number',
      state: 'string',
      wsPort: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsAnchorPeers extends $tea.Model {
  host?: string;
  port?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsOrdererNodes extends $tea.Model {
  address?: string;
  certificate?: string;
  key?: string;
  tlsroot?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      certificate: 'Certificate',
      key: 'Key',
      tlsroot: 'Tlsroot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      certificate: 'string',
      key: 'string',
      tlsroot: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizations extends $tea.Model {
  anchorPeers?: AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsAnchorPeers[];
  crls?: string;
  mspId?: string;
  mspType?: string;
  orderer?: boolean;
  ordererNodes?: AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsOrdererNodes[];
  rootCertificates?: string;
  tlsRootCertificates?: string;
  static names(): { [key: string]: string } {
    return {
      anchorPeers: 'AnchorPeers',
      crls: 'Crls',
      mspId: 'MspId',
      mspType: 'MspType',
      orderer: 'Orderer',
      ordererNodes: 'OrdererNodes',
      rootCertificates: 'RootCertificates',
      tlsRootCertificates: 'TlsRootCertificates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorPeers: { 'type': 'array', 'itemType': AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsAnchorPeers },
      crls: 'string',
      mspId: 'string',
      mspType: 'string',
      orderer: 'boolean',
      ordererNodes: { 'type': 'array', 'itemType': AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsOrdererNodes },
      rootCertificates: 'string',
      tlsRootCertificates: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkgCs extends $tea.Model {
  input?: string;
  name?: string;
  path?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      input: 'Input',
      name: 'Name',
      path: 'Path',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      input: 'string',
      name: 'string',
      path: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkg extends $tea.Model {
  cs?: AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkgCs;
  policy?: string;
  sha256?: string;
  static names(): { [key: string]: string } {
    return {
      cs: 'Cs',
      policy: 'Policy',
      sha256: 'Sha256',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cs: AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkgCs,
      policy: 'string',
      sha256: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelResponseBodyResultContentOrdererConfig extends $tea.Model {
  batchTimeout?: string;
  maxMessageCount?: number;
  preferredMaxBytes?: number;
  static names(): { [key: string]: string } {
    return {
      batchTimeout: 'BatchTimeout',
      maxMessageCount: 'MaxMessageCount',
      preferredMaxBytes: 'PreferredMaxBytes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchTimeout: 'string',
      maxMessageCount: 'number',
      preferredMaxBytes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsAnchorPeers extends $tea.Model {
  host?: string;
  port?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsOrdererNodes extends $tea.Model {
  address?: string;
  certificate?: string;
  key?: string;
  tlsroot?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      certificate: 'Certificate',
      key: 'Key',
      tlsroot: 'Tlsroot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      certificate: 'string',
      key: 'string',
      tlsroot: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizations extends $tea.Model {
  anchorPeers?: AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsAnchorPeers[];
  crls?: string;
  mspId?: string;
  mspType?: string;
  orderer?: boolean;
  ordererNodes?: AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsOrdererNodes[];
  rootCertificates?: string;
  tlsRootCertificates?: string;
  static names(): { [key: string]: string } {
    return {
      anchorPeers: 'AnchorPeers',
      crls: 'Crls',
      mspId: 'MspId',
      mspType: 'MspType',
      orderer: 'Orderer',
      ordererNodes: 'OrdererNodes',
      rootCertificates: 'RootCertificates',
      tlsRootCertificates: 'TlsRootCertificates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorPeers: { 'type': 'array', 'itemType': AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsAnchorPeers },
      crls: 'string',
      mspId: 'string',
      mspType: 'string',
      orderer: 'boolean',
      ordererNodes: { 'type': 'array', 'itemType': AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsOrdererNodes },
      rootCertificates: 'string',
      tlsRootCertificates: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelResponseBodyResultContent extends $tea.Model {
  addedOrganizations?: AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizations[];
  chaincodeSpecPkg?: AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkg;
  ordererConfig?: AddFabricExternalOrganizationToChannelResponseBodyResultContentOrdererConfig;
  raw?: string;
  removedOrganizations?: AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizations[];
  rwSets?: string;
  static names(): { [key: string]: string } {
    return {
      addedOrganizations: 'AddedOrganizations',
      chaincodeSpecPkg: 'ChaincodeSpecPkg',
      ordererConfig: 'OrdererConfig',
      raw: 'Raw',
      removedOrganizations: 'RemovedOrganizations',
      rwSets: 'RwSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addedOrganizations: { 'type': 'array', 'itemType': AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizations },
      chaincodeSpecPkg: AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkg,
      ordererConfig: AddFabricExternalOrganizationToChannelResponseBodyResultContentOrdererConfig,
      raw: 'string',
      removedOrganizations: { 'type': 'array', 'itemType': AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizations },
      rwSets: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricExternalOrganizationToChannelResponseBodyResult extends $tea.Model {
  content?: AddFabricExternalOrganizationToChannelResponseBodyResultContent;
  createTime?: number;
  creator?: string;
  description?: string;
  status?: string;
  taskId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      createTime: 'CreateTime',
      creator: 'Creator',
      description: 'Description',
      status: 'Status',
      taskId: 'TaskId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: AddFabricExternalOrganizationToChannelResponseBodyResultContent,
      createTime: 'number',
      creator: 'string',
      description: 'string',
      status: 'string',
      taskId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class AddFabricOrganizationToExternalChannelResponseBodyResult extends $tea.Model {
  m?: number;
  n?: number;
  static names(): { [key: string]: string } {
    return {
      m: 'M',
      n: 'N',
    };
  }

  static types(): { [key: string]: any } {
    return {
      m: 'number',
      n: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath extends $tea.Model {
  caCrtUrl?: string;
  clientCrtUrl?: string;
  sdkUrl?: string;
  trustCaUrl?: string;
  static names(): { [key: string]: string } {
    return {
      caCrtUrl: 'CaCrtUrl',
      clientCrtUrl: 'ClientCrtUrl',
      sdkUrl: 'SdkUrl',
      trustCaUrl: 'TrustCaUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caCrtUrl: 'string',
      clientCrtUrl: 'string',
      sdkUrl: 'string',
      trustCaUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult extends $tea.Model {
  downloadPath?: ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath;
  privateKey?: string;
  static names(): { [key: string]: string } {
    return {
      downloadPath: 'DownloadPath',
      privateKey: 'PrivateKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadPath: ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath,
      privateKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainWithKeyAutoCreationResponseBodyResultDownloadPath extends $tea.Model {
  caCrtUrl?: string;
  clientCrtUrl?: string;
  sdkUrl?: string;
  trustCaUrl?: string;
  static names(): { [key: string]: string } {
    return {
      caCrtUrl: 'CaCrtUrl',
      clientCrtUrl: 'ClientCrtUrl',
      sdkUrl: 'SdkUrl',
      trustCaUrl: 'TrustCaUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caCrtUrl: 'string',
      clientCrtUrl: 'string',
      sdkUrl: 'string',
      trustCaUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyAntChainWithKeyAutoCreationResponseBodyResult extends $tea.Model {
  downloadPath?: ApplyAntChainWithKeyAutoCreationResponseBodyResultDownloadPath;
  privateKey?: string;
  static names(): { [key: string]: string } {
    return {
      downloadPath: 'DownloadPath',
      privateKey: 'PrivateKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadPath: ApplyAntChainWithKeyAutoCreationResponseBodyResultDownloadPath,
      privateKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyBlockchainWithKeyAutoCreationResponseBodyResultDownloadPath extends $tea.Model {
  bizviewUrl?: string;
  certUrl?: string;
  sdkUrl?: string;
  static names(): { [key: string]: string } {
    return {
      bizviewUrl: 'BizviewUrl',
      certUrl: 'CertUrl',
      sdkUrl: 'SdkUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizviewUrl: 'string',
      certUrl: 'string',
      sdkUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyBlockchainWithKeyAutoCreationResponseBodyResult extends $tea.Model {
  downloadPath?: ApplyBlockchainWithKeyAutoCreationResponseBodyResultDownloadPath;
  privateKey?: string;
  static names(): { [key: string]: string } {
    return {
      downloadPath: 'DownloadPath',
      privateKey: 'PrivateKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadPath: ApplyBlockchainWithKeyAutoCreationResponseBodyResultDownloadPath,
      privateKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyPublicAntChainWithKeyAutoCreationResponseBodyResultDownloadPath extends $tea.Model {
  caCrtUrl?: string;
  clientCrtUrl?: string;
  sdkUrl?: string;
  trustCaUrl?: string;
  static names(): { [key: string]: string } {
    return {
      caCrtUrl: 'CaCrtUrl',
      clientCrtUrl: 'ClientCrtUrl',
      sdkUrl: 'SdkUrl',
      trustCaUrl: 'TrustCaUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caCrtUrl: 'string',
      clientCrtUrl: 'string',
      sdkUrl: 'string',
      trustCaUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApplyPublicAntChainWithKeyAutoCreationResponseBodyResult extends $tea.Model {
  downloadPath?: ApplyPublicAntChainWithKeyAutoCreationResponseBodyResultDownloadPath;
  privateKey?: string;
  static names(): { [key: string]: string } {
    return {
      downloadPath: 'DownloadPath',
      privateKey: 'PrivateKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      downloadPath: ApplyPublicAntChainWithKeyAutoCreationResponseBodyResultDownloadPath,
      privateKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveEthereumInviteeRequestInvitee extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ApproveFabricChaincodeDefinitionResponseBodyResult extends $tea.Model {
  chaincodeId?: string;
  channelName?: string;
  consortiumId?: string;
  createTime?: string;
  deployTime?: string;
  endorsePolicy?: string;
  input?: string;
  install?: boolean;
  message?: string;
  name?: string;
  path?: string;
  providerId?: string;
  providerName?: string;
  state?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      channelName: 'ChannelName',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      deployTime: 'DeployTime',
      endorsePolicy: 'EndorsePolicy',
      input: 'Input',
      install: 'Install',
      message: 'Message',
      name: 'Name',
      path: 'Path',
      providerId: 'ProviderId',
      providerName: 'ProviderName',
      state: 'State',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      channelName: 'string',
      consortiumId: 'string',
      createTime: 'string',
      deployTime: 'string',
      endorsePolicy: 'string',
      input: 'string',
      install: 'boolean',
      message: 'string',
      name: 'string',
      path: 'string',
      providerId: 'string',
      providerName: 'string',
      state: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class BindFabricManagementChaincodeResponseBodyResult extends $tea.Model {
  input?: string;
  name?: string;
  path?: number;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      input: 'Input',
      name: 'Name',
      path: 'Path',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      input: 'string',
      name: 'string',
      path: 'number',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckConsortiumDomainResponseBodyResult extends $tea.Model {
  domain?: string;
  prompt?: string;
  valid?: boolean;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      prompt: 'Prompt',
      valid: 'Valid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      prompt: 'string',
      valid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CheckOrganizationDomainResponseBodyResult extends $tea.Model {
  domain?: string;
  prompt?: string;
  valid?: boolean;
  static names(): { [key: string]: string } {
    return {
      domain: 'Domain',
      prompt: 'Prompt',
      valid: 'Valid',
    };
  }

  static types(): { [key: string]: any } {
    return {
      domain: 'string',
      prompt: 'string',
      valid: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ConfirmConsortiumMemberRequestOrganization extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CopyAntChainContractProjectResponseBodyResult extends $tea.Model {
  consortiumId?: string;
  createTime?: number;
  projectDescription?: string;
  projectId?: string;
  projectName?: string;
  projectVersion?: string;
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      projectDescription: 'ProjectDescription',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      projectVersion: 'ProjectVersion',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      createTime: 'number',
      projectDescription: 'string',
      projectId: 'string',
      projectName: 'string',
      projectVersion: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccessTokenResponseBodyResult extends $tea.Model {
  accessToken?: string;
  expiresIn?: number;
  refreshToken?: string;
  tokenType?: string;
  static names(): { [key: string]: string } {
    return {
      accessToken: 'AccessToken',
      expiresIn: 'ExpiresIn',
      refreshToken: 'RefreshToken',
      tokenType: 'TokenType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessToken: 'string',
      expiresIn: 'number',
      refreshToken: 'string',
      tokenType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAccountWithKeyPairAutoCreationResponseBodyResult extends $tea.Model {
  accountPrivateKey?: string;
  accountPublicKey?: string;
  accountRecoverPrivateKey?: string;
  accountRecoverPublicKey?: string;
  static names(): { [key: string]: string } {
    return {
      accountPrivateKey: 'AccountPrivateKey',
      accountPublicKey: 'AccountPublicKey',
      accountRecoverPrivateKey: 'AccountRecoverPrivateKey',
      accountRecoverPublicKey: 'AccountRecoverPublicKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountPrivateKey: 'string',
      accountPublicKey: 'string',
      accountRecoverPrivateKey: 'string',
      accountRecoverPublicKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainResponseBodyResult extends $tea.Model {
  antChainId?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainAccountResponseBodyResult extends $tea.Model {
  account?: string;
  antChainId?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      antChainId: 'AntChainId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      antChainId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult extends $tea.Model {
  account?: string;
  accountPrivateKey?: string;
  accountPublicKey?: string;
  accountRecoverPrivateKey?: string;
  accountRecoverPublicKey?: string;
  antChainId?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      accountPrivateKey: 'AccountPrivateKey',
      accountPublicKey: 'AccountPublicKey',
      accountRecoverPrivateKey: 'AccountRecoverPrivateKey',
      accountRecoverPublicKey: 'AccountRecoverPublicKey',
      antChainId: 'AntChainId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      accountPrivateKey: 'string',
      accountPublicKey: 'string',
      accountRecoverPrivateKey: 'string',
      accountRecoverPublicKey: 'string',
      antChainId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainConsortiumResponseBodyResult extends $tea.Model {
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainContractContentResponseBodyResult extends $tea.Model {
  content?: string;
  contentId?: string;
  contentName?: string;
  createTime?: string;
  isDirectory?: boolean;
  parentContentId?: string;
  projectId?: string;
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      contentId: 'ContentId',
      contentName: 'ContentName',
      createTime: 'CreateTime',
      isDirectory: 'IsDirectory',
      parentContentId: 'ParentContentId',
      projectId: 'ProjectId',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      contentId: 'string',
      contentName: 'string',
      createTime: 'string',
      isDirectory: 'boolean',
      parentContentId: 'string',
      projectId: 'string',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateAntChainContractProjectResponseBodyResult extends $tea.Model {
  consortiumId?: string;
  createTime?: number;
  projectDescription?: string;
  projectId?: string;
  projectName?: string;
  projectVersion?: string;
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      projectDescription: 'ProjectDescription',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      projectVersion: 'ProjectVersion',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      createTime: 'number',
      projectDescription: 'string',
      projectId: 'string',
      projectName: 'string',
      projectVersion: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChaincodeResponseBodyResult extends $tea.Model {
  chaincodeId?: string;
  channelName?: string;
  consortiumId?: string;
  createTime?: string;
  deployTime?: string;
  endorsePolicy?: string;
  input?: string;
  install?: boolean;
  message?: string;
  name?: string;
  path?: string;
  providerId?: string;
  providerName?: string;
  state?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      channelName: 'ChannelName',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      deployTime: 'DeployTime',
      endorsePolicy: 'EndorsePolicy',
      input: 'Input',
      install: 'Install',
      message: 'Message',
      name: 'Name',
      path: 'Path',
      providerId: 'ProviderId',
      providerName: 'ProviderName',
      state: 'State',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      channelName: 'string',
      consortiumId: 'string',
      createTime: 'string',
      deployTime: 'string',
      endorsePolicy: 'string',
      input: 'string',
      install: 'boolean',
      message: 'string',
      name: 'string',
      path: 'string',
      providerId: 'string',
      providerName: 'string',
      state: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChannelRequestOrganization extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChannelResponseBodyResult extends $tea.Model {
  batchTimeout?: number;
  blockCount?: number;
  chaincodeCount?: number;
  channelId?: string;
  consortiumId?: string;
  consortiumName?: string;
  createTime?: string;
  maxMessageCount?: number;
  memberCount?: number;
  name?: string;
  ownerBid?: string;
  ownerName?: string;
  ownerUid?: number;
  preferredMaxBytes?: number;
  requestId?: string;
  state?: string;
  supportConfig?: boolean;
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      batchTimeout: 'BatchTimeout',
      blockCount: 'BlockCount',
      chaincodeCount: 'ChaincodeCount',
      channelId: 'ChannelId',
      consortiumId: 'ConsortiumId',
      consortiumName: 'ConsortiumName',
      createTime: 'CreateTime',
      maxMessageCount: 'MaxMessageCount',
      memberCount: 'MemberCount',
      name: 'Name',
      ownerBid: 'OwnerBid',
      ownerName: 'OwnerName',
      ownerUid: 'OwnerUid',
      preferredMaxBytes: 'PreferredMaxBytes',
      requestId: 'RequestId',
      state: 'State',
      supportConfig: 'SupportConfig',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchTimeout: 'number',
      blockCount: 'number',
      chaincodeCount: 'number',
      channelId: 'string',
      consortiumId: 'string',
      consortiumName: 'string',
      createTime: 'string',
      maxMessageCount: 'number',
      memberCount: 'number',
      name: 'string',
      ownerBid: 'string',
      ownerName: 'string',
      ownerUid: 'number',
      preferredMaxBytes: 'number',
      requestId: 'string',
      state: 'string',
      supportConfig: 'boolean',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateChannelMemberRequestOrganization extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsortiumRequestOrganization extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsortiumResponseBodyResult extends $tea.Model {
  channelCount?: number;
  channelPolicy?: string;
  clusterState?: string;
  codeName?: string;
  consortiumId?: string;
  createTime?: string;
  description?: string;
  domain?: string;
  memberCount?: number;
  name?: string;
  ordererCount?: number;
  ordererType?: string;
  ownerBid?: string;
  ownerUid?: number;
  regionId?: string;
  serviceState?: string;
  specName?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      channelCount: 'ChannelCount',
      channelPolicy: 'ChannelPolicy',
      clusterState: 'ClusterState',
      codeName: 'CodeName',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      description: 'Description',
      domain: 'Domain',
      memberCount: 'MemberCount',
      name: 'Name',
      ordererCount: 'OrdererCount',
      ordererType: 'OrdererType',
      ownerBid: 'OwnerBid',
      ownerUid: 'OwnerUid',
      regionId: 'RegionId',
      serviceState: 'ServiceState',
      specName: 'SpecName',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelCount: 'number',
      channelPolicy: 'string',
      clusterState: 'string',
      codeName: 'string',
      consortiumId: 'string',
      createTime: 'string',
      description: 'string',
      domain: 'string',
      memberCount: 'number',
      name: 'string',
      ordererCount: 'number',
      ordererType: 'string',
      ownerBid: 'string',
      ownerUid: 'number',
      regionId: 'string',
      serviceState: 'string',
      specName: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateConsortiumMemberRequestOrganization extends $tea.Model {
  id?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEcosphereRequestOrganization extends $tea.Model {
  description?: string;
  domain?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      description: 'Description',
      domain: 'Domain',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      description: 'string',
      domain: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEcosphereResponseBodyResultOrganizations extends $tea.Model {
  clusterState?: string;
  code?: string;
  createTime?: string;
  description?: string;
  domain?: string;
  name?: string;
  serviceState?: string;
  static names(): { [key: string]: string } {
    return {
      clusterState: 'ClusterState',
      code: 'Code',
      createTime: 'CreateTime',
      description: 'Description',
      domain: 'Domain',
      name: 'Name',
      serviceState: 'ServiceState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterState: 'string',
      code: 'string',
      createTime: 'string',
      description: 'string',
      domain: 'string',
      name: 'string',
      serviceState: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEcosphereResponseBodyResultSpecification extends $tea.Model {
  name?: string;
  numOfNodes?: number;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      numOfNodes: 'NumOfNodes',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      numOfNodes: 'number',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEcosphereResponseBodyResult extends $tea.Model {
  channelCount?: number;
  channelPolicy?: string;
  clusterState?: string;
  code?: string;
  consortiumId?: string;
  createTime?: string;
  description?: string;
  domain?: string;
  memberCount?: number;
  name?: string;
  ordererCount?: number;
  ordererType?: string;
  organizations?: CreateEcosphereResponseBodyResultOrganizations[];
  ownerBid?: string;
  ownerUid?: number;
  regionId?: string;
  serviceState?: string;
  specName?: string;
  specification?: CreateEcosphereResponseBodyResultSpecification;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      channelCount: 'ChannelCount',
      channelPolicy: 'ChannelPolicy',
      clusterState: 'ClusterState',
      code: 'Code',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      description: 'Description',
      domain: 'Domain',
      memberCount: 'MemberCount',
      name: 'Name',
      ordererCount: 'OrdererCount',
      ordererType: 'OrdererType',
      organizations: 'Organizations',
      ownerBid: 'OwnerBid',
      ownerUid: 'OwnerUid',
      regionId: 'RegionId',
      serviceState: 'ServiceState',
      specName: 'SpecName',
      specification: 'Specification',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelCount: 'number',
      channelPolicy: 'string',
      clusterState: 'string',
      code: 'string',
      consortiumId: 'string',
      createTime: 'string',
      description: 'string',
      domain: 'string',
      memberCount: 'number',
      name: 'string',
      ordererCount: 'number',
      ordererType: 'string',
      organizations: { 'type': 'array', 'itemType': CreateEcosphereResponseBodyResultOrganizations },
      ownerBid: 'string',
      ownerUid: 'number',
      regionId: 'string',
      serviceState: 'string',
      specName: 'string',
      specification: CreateEcosphereResponseBodyResultSpecification,
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEthereumRequestNode extends $tea.Model {
  name?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEthereumResponseBodyResult extends $tea.Model {
  consensus?: string;
  creator?: string;
  description?: string;
  id?: string;
  name?: string;
  networkId?: string;
  regionId?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      consensus: 'Consensus',
      creator: 'Creator',
      description: 'Description',
      id: 'Id',
      name: 'Name',
      networkId: 'NetworkId',
      regionId: 'RegionId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consensus: 'string',
      creator: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
      networkId: 'string',
      regionId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateEthereumInvitationResponseBodyResult extends $tea.Model {
  code?: string;
  createTime?: string;
  expireTime?: string;
  token?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      createTime: 'CreateTime',
      expireTime: 'ExpireTime',
      token: 'Token',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      createTime: 'string',
      expireTime: 'string',
      token: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateFabricChaincodePackageResponseBodyResult extends $tea.Model {
  chaincodePackageId?: number;
  checksum?: string;
  deleteTime?: number;
  deleted?: boolean;
  installTime?: number;
  label?: string;
  md5sum?: string;
  organizationId?: string;
  ossBucket?: string;
  ossURL?: string;
  providerBid?: string;
  providerUid?: number;
  state?: string;
  type?: string;
  typeString?: boolean;
  uploadTime?: number;
  static names(): { [key: string]: string } {
    return {
      chaincodePackageId: 'ChaincodePackageId',
      checksum: 'Checksum',
      deleteTime: 'DeleteTime',
      deleted: 'Deleted',
      installTime: 'InstallTime',
      label: 'Label',
      md5sum: 'Md5sum',
      organizationId: 'OrganizationId',
      ossBucket: 'OssBucket',
      ossURL: 'OssURL',
      providerBid: 'ProviderBid',
      providerUid: 'ProviderUid',
      state: 'State',
      type: 'Type',
      typeString: 'TypeString',
      uploadTime: 'UploadTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodePackageId: 'number',
      checksum: 'string',
      deleteTime: 'number',
      deleted: 'boolean',
      installTime: 'number',
      label: 'string',
      md5sum: 'string',
      organizationId: 'string',
      ossBucket: 'string',
      ossURL: 'string',
      providerBid: 'string',
      providerUid: 'number',
      state: 'string',
      type: 'string',
      typeString: 'boolean',
      uploadTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrganizationResponseBodyResult extends $tea.Model {
  clusterState?: string;
  codeName?: string;
  consortiumCount?: number;
  createTime?: string;
  description?: string;
  domain?: string;
  name?: string;
  organizationId?: string;
  ownerBid?: string;
  ownerName?: string;
  ownerUid?: number;
  peerCount?: number;
  regionId?: string;
  requestId?: string;
  serviceState?: string;
  specName?: string;
  userCount?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      clusterState: 'ClusterState',
      codeName: 'CodeName',
      consortiumCount: 'ConsortiumCount',
      createTime: 'CreateTime',
      description: 'Description',
      domain: 'Domain',
      name: 'Name',
      organizationId: 'OrganizationId',
      ownerBid: 'OwnerBid',
      ownerName: 'OwnerName',
      ownerUid: 'OwnerUid',
      peerCount: 'PeerCount',
      regionId: 'RegionId',
      requestId: 'RequestId',
      serviceState: 'ServiceState',
      specName: 'SpecName',
      userCount: 'UserCount',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterState: 'string',
      codeName: 'string',
      consortiumCount: 'number',
      createTime: 'string',
      description: 'string',
      domain: 'string',
      name: 'string',
      organizationId: 'string',
      ownerBid: 'string',
      ownerName: 'string',
      ownerUid: 'number',
      peerCount: 'number',
      regionId: 'string',
      requestId: 'string',
      serviceState: 'string',
      specName: 'string',
      userCount: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateOrganizationUserResponseBodyResult extends $tea.Model {
  createTime?: string;
  expireTime?: string;
  fullname?: string;
  organizationId?: string;
  password?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      expireTime: 'ExpireTime',
      fullname: 'Fullname',
      organizationId: 'OrganizationId',
      password: 'Password',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      expireTime: 'string',
      fullname: 'string',
      organizationId: 'string',
      password: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreatePublicAccountWithKeyPairAutoCreationResponseBodyResult extends $tea.Model {
  accountPrivateKey?: string;
  accountPublicKey?: string;
  accountRecoverPrivateKey?: string;
  accountRecoverPublicKey?: string;
  static names(): { [key: string]: string } {
    return {
      accountPrivateKey: 'AccountPrivateKey',
      accountPublicKey: 'AccountPublicKey',
      accountRecoverPrivateKey: 'AccountRecoverPrivateKey',
      accountRecoverPublicKey: 'AccountRecoverPublicKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accountPrivateKey: 'string',
      accountPublicKey: 'string',
      accountRecoverPrivateKey: 'string',
      accountRecoverPublicKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateSmartContractJobResponseBodyResult extends $tea.Model {
  accessId?: string;
  dir?: number;
  expire?: number;
  host?: string;
  jobID?: string;
  policy?: string;
  signature?: string;
  static names(): { [key: string]: string } {
    return {
      accessId: 'AccessId',
      dir: 'Dir',
      expire: 'Expire',
      host: 'Host',
      jobID: 'JobID',
      policy: 'Policy',
      signature: 'Signature',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessId: 'string',
      dir: 'number',
      expire: 'number',
      host: 'string',
      jobID: 'string',
      policy: 'string',
      signature: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class CreateTriggerResponseBodyResult extends $tea.Model {
  channelId?: string;
  channelName?: string;
  createTime?: number;
  errorMessage?: string;
  name?: string;
  options?: string;
  source?: string;
  status?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      createTime: 'CreateTime',
      errorMessage: 'ErrorMessage',
      name: 'Name',
      options: 'Options',
      source: 'Source',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      createTime: 'number',
      errorMessage: 'string',
      name: 'string',
      options: 'string',
      source: 'string',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers extends $tea.Model {
  host?: string;
  port?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes extends $tea.Model {
  address?: string;
  certificate?: string;
  key?: string;
  tlsroot?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      certificate: 'Certificate',
      key: 'Key',
      tlsroot: 'Tlsroot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      certificate: 'string',
      key: 'string',
      tlsroot: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskResponseBodyResultContentAddedOrganizations extends $tea.Model {
  anchorPeers?: DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers[];
  crls?: string;
  mspId?: string;
  mspType?: string;
  orderer?: boolean;
  ordererNodes?: DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes[];
  rootCertificates?: string;
  tlsRootCertificates?: string;
  static names(): { [key: string]: string } {
    return {
      anchorPeers: 'AnchorPeers',
      crls: 'Crls',
      mspId: 'MspId',
      mspType: 'MspType',
      orderer: 'Orderer',
      ordererNodes: 'OrdererNodes',
      rootCertificates: 'RootCertificates',
      tlsRootCertificates: 'TlsRootCertificates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorPeers: { 'type': 'array', 'itemType': DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers },
      crls: 'string',
      mspId: 'string',
      mspType: 'string',
      orderer: 'boolean',
      ordererNodes: { 'type': 'array', 'itemType': DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes },
      rootCertificates: 'string',
      tlsRootCertificates: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs extends $tea.Model {
  input?: string;
  name?: string;
  path?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      input: 'Input',
      name: 'Name',
      path: 'Path',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      input: 'string',
      name: 'string',
      path: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkg extends $tea.Model {
  cs?: DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs;
  policy?: string;
  sha256?: string;
  static names(): { [key: string]: string } {
    return {
      cs: 'Cs',
      policy: 'Policy',
      sha256: 'Sha256',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cs: DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs,
      policy: 'string',
      sha256: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskResponseBodyResultContentOrdererConfig extends $tea.Model {
  batchTimeout?: string;
  maxMessageCount?: number;
  preferredMaxBytes?: number;
  static names(): { [key: string]: string } {
    return {
      batchTimeout: 'BatchTimeout',
      maxMessageCount: 'MaxMessageCount',
      preferredMaxBytes: 'PreferredMaxBytes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchTimeout: 'string',
      maxMessageCount: 'number',
      preferredMaxBytes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers extends $tea.Model {
  host?: string;
  port?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes extends $tea.Model {
  address?: string;
  certificate?: string;
  key?: string;
  tlsroot?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      certificate: 'Certificate',
      key: 'Key',
      tlsroot: 'Tlsroot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      certificate: 'string',
      key: 'string',
      tlsroot: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizations extends $tea.Model {
  anchorPeers?: DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers[];
  crls?: string;
  mspId?: string;
  mspType?: string;
  orderer?: boolean;
  ordererNodes?: DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes[];
  rootCertificates?: string;
  tlsRootCertificates?: string;
  static names(): { [key: string]: string } {
    return {
      anchorPeers: 'AnchorPeers',
      crls: 'Crls',
      mspId: 'MspId',
      mspType: 'MspType',
      orderer: 'Orderer',
      ordererNodes: 'OrdererNodes',
      rootCertificates: 'RootCertificates',
      tlsRootCertificates: 'TlsRootCertificates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorPeers: { 'type': 'array', 'itemType': DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers },
      crls: 'string',
      mspId: 'string',
      mspType: 'string',
      orderer: 'boolean',
      ordererNodes: { 'type': 'array', 'itemType': DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes },
      rootCertificates: 'string',
      tlsRootCertificates: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskResponseBodyResultContent extends $tea.Model {
  addedOrganizations?: DeleteGovernanceTaskResponseBodyResultContentAddedOrganizations[];
  chaincodeSpecPkg?: DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkg;
  ordererConfig?: DeleteGovernanceTaskResponseBodyResultContentOrdererConfig;
  raw?: string;
  removedOrganizations?: DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizations[];
  rwSets?: string;
  static names(): { [key: string]: string } {
    return {
      addedOrganizations: 'AddedOrganizations',
      chaincodeSpecPkg: 'ChaincodeSpecPkg',
      ordererConfig: 'OrdererConfig',
      raw: 'Raw',
      removedOrganizations: 'RemovedOrganizations',
      rwSets: 'RwSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addedOrganizations: { 'type': 'array', 'itemType': DeleteGovernanceTaskResponseBodyResultContentAddedOrganizations },
      chaincodeSpecPkg: DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkg,
      ordererConfig: DeleteGovernanceTaskResponseBodyResultContentOrdererConfig,
      raw: 'string',
      removedOrganizations: { 'type': 'array', 'itemType': DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizations },
      rwSets: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteGovernanceTaskResponseBodyResult extends $tea.Model {
  channelName?: string;
  content?: DeleteGovernanceTaskResponseBodyResultContent;
  createTime?: number;
  creator?: string;
  description?: string;
  status?: string;
  taskId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      channelName: 'ChannelName',
      content: 'Content',
      createTime: 'CreateTime',
      creator: 'Creator',
      description: 'Description',
      status: 'Status',
      taskId: 'TaskId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelName: 'string',
      content: DeleteGovernanceTaskResponseBodyResultContent,
      createTime: 'number',
      creator: 'string',
      description: 'string',
      status: 'string',
      taskId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTriggerResponseBodyResultCheckpoint extends $tea.Model {
  errorCount?: number;
  height?: number;
  index?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      errorCount: 'ErrorCount',
      height: 'Height',
      index: 'Index',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCount: 'number',
      height: 'number',
      index: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DeleteTriggerResponseBodyResult extends $tea.Model {
  channelId?: string;
  channelName?: string;
  checkpoint?: DeleteTriggerResponseBodyResultCheckpoint;
  createTime?: number;
  errorMessage?: string;
  name?: string;
  options?: string;
  source?: string;
  status?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      checkpoint: 'Checkpoint',
      createTime: 'CreateTime',
      errorMessage: 'ErrorMessage',
      name: 'Name',
      options: 'Options',
      source: 'Source',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      checkpoint: DeleteTriggerResponseBodyResultCheckpoint,
      createTime: 'number',
      errorMessage: 'string',
      name: 'string',
      options: 'string',
      source: 'string',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainAccountsResponseBodyResultAccounts extends $tea.Model {
  account?: string;
  accountPublicKey?: string;
  accountRecoveryKey?: string;
  accountStatus?: string;
  antChainId?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      accountPublicKey: 'AccountPublicKey',
      accountRecoveryKey: 'AccountRecoveryKey',
      accountStatus: 'AccountStatus',
      antChainId: 'AntChainId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      accountPublicKey: 'string',
      accountRecoveryKey: 'string',
      accountStatus: 'string',
      antChainId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainAccountsResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainAccountsResponseBodyResult extends $tea.Model {
  accounts?: DescribeAntChainAccountsResponseBodyResultAccounts[];
  pagination?: DescribeAntChainAccountsResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      accounts: 'Accounts',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accounts: { 'type': 'array', 'itemType': DescribeAntChainAccountsResponseBodyResultAccounts },
      pagination: DescribeAntChainAccountsResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainAccountsNewResponseBodyResultAccounts extends $tea.Model {
  account?: string;
  accountPublicKey?: string;
  accountRecoveryKey?: string;
  accountStatus?: string;
  antChainId?: string;
  createTime?: number;
  memberName?: string;
  static names(): { [key: string]: string } {
    return {
      account: 'Account',
      accountPublicKey: 'AccountPublicKey',
      accountRecoveryKey: 'AccountRecoveryKey',
      accountStatus: 'AccountStatus',
      antChainId: 'AntChainId',
      createTime: 'CreateTime',
      memberName: 'MemberName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      account: 'string',
      accountPublicKey: 'string',
      accountRecoveryKey: 'string',
      accountStatus: 'string',
      antChainId: 'string',
      createTime: 'number',
      memberName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainAccountsNewResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainAccountsNewResponseBodyResult extends $tea.Model {
  accounts?: DescribeAntChainAccountsNewResponseBodyResultAccounts[];
  consortiumAdmin?: boolean;
  pagination?: DescribeAntChainAccountsNewResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      accounts: 'Accounts',
      consortiumAdmin: 'ConsortiumAdmin',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accounts: { 'type': 'array', 'itemType': DescribeAntChainAccountsNewResponseBodyResultAccounts },
      consortiumAdmin: 'boolean',
      pagination: DescribeAntChainAccountsNewResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainApplicationsResponseBodyResultApplyHistoryList extends $tea.Model {
  bizid?: string;
  createtime?: number;
  id?: number;
  rejectReason?: string;
  reqAddr?: string;
  signedAddr?: string;
  status?: number;
  updatetime?: number;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      createtime: 'Createtime',
      id: 'Id',
      rejectReason: 'RejectReason',
      reqAddr: 'ReqAddr',
      signedAddr: 'SignedAddr',
      status: 'Status',
      updatetime: 'Updatetime',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      createtime: 'number',
      id: 'number',
      rejectReason: 'string',
      reqAddr: 'string',
      signedAddr: 'string',
      status: 'number',
      updatetime: 'number',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainApplicationsResponseBodyResultPagination extends $tea.Model {
  current?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'Current',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainApplicationsResponseBodyResult extends $tea.Model {
  applyHistoryList?: DescribeAntChainApplicationsResponseBodyResultApplyHistoryList[];
  pagination?: DescribeAntChainApplicationsResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      applyHistoryList: 'ApplyHistoryList',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyHistoryList: { 'type': 'array', 'itemType': DescribeAntChainApplicationsResponseBodyResultApplyHistoryList },
      pagination: DescribeAntChainApplicationsResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainBlockResponseBodyResult extends $tea.Model {
  antChainId?: string;
  blockHash?: string;
  createTime?: number;
  height?: number;
  previousHash?: string;
  rootTxHash?: string;
  transSummaryList?: string;
  transactionSize?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      blockHash: 'BlockHash',
      createTime: 'CreateTime',
      height: 'Height',
      previousHash: 'PreviousHash',
      rootTxHash: 'RootTxHash',
      transSummaryList: 'TransSummaryList',
      transactionSize: 'TransactionSize',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      blockHash: 'string',
      createTime: 'number',
      height: 'number',
      previousHash: 'string',
      rootTxHash: 'string',
      transSummaryList: 'string',
      transactionSize: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainBlockNewResponseBodyResultTransSummaryList extends $tea.Model {
  alias?: string;
  blockHash?: string;
  category?: number;
  createTime?: number;
  from?: string;
  gasUsed?: number;
  hash?: string;
  height?: number;
  referenceCount?: number;
  to?: string;
  transTypeV10?: string;
  transTypeV6?: string;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      blockHash: 'BlockHash',
      category: 'Category',
      createTime: 'CreateTime',
      from: 'From',
      gasUsed: 'GasUsed',
      hash: 'Hash',
      height: 'Height',
      referenceCount: 'ReferenceCount',
      to: 'To',
      transTypeV10: 'TransTypeV10',
      transTypeV6: 'TransTypeV6',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      blockHash: 'string',
      category: 'number',
      createTime: 'number',
      from: 'string',
      gasUsed: 'number',
      hash: 'string',
      height: 'number',
      referenceCount: 'number',
      to: 'string',
      transTypeV10: 'string',
      transTypeV6: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainBlockNewResponseBodyResult extends $tea.Model {
  antChainId?: string;
  blockHash?: string;
  createTime?: number;
  height?: number;
  previousHash?: string;
  rootTxHash?: string;
  transSummaryList?: DescribeAntChainBlockNewResponseBodyResultTransSummaryList[];
  transactionSize?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      blockHash: 'BlockHash',
      createTime: 'CreateTime',
      height: 'Height',
      previousHash: 'PreviousHash',
      rootTxHash: 'RootTxHash',
      transSummaryList: 'TransSummaryList',
      transactionSize: 'TransactionSize',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      blockHash: 'string',
      createTime: 'number',
      height: 'number',
      previousHash: 'string',
      rootTxHash: 'string',
      transSummaryList: { 'type': 'array', 'itemType': DescribeAntChainBlockNewResponseBodyResultTransSummaryList },
      transactionSize: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications extends $tea.Model {
  antChainId?: string;
  bid?: string;
  createtime?: number;
  status?: string;
  updatetime?: number;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      bid: 'Bid',
      createtime: 'Createtime',
      status: 'Status',
      updatetime: 'Updatetime',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      bid: 'string',
      createtime: 'number',
      status: 'string',
      updatetime: 'number',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainCertificateApplicationsResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainCertificateApplicationsResponseBodyResult extends $tea.Model {
  certificateApplications?: DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications[];
  pagination?: DescribeAntChainCertificateApplicationsResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      certificateApplications: 'CertificateApplications',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certificateApplications: { 'type': 'array', 'itemType': DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications },
      pagination: DescribeAntChainCertificateApplicationsResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainCertificateApplicationsNewResponseBodyResultCertificateApplications extends $tea.Model {
  antChainId?: string;
  bid?: string;
  createtime?: number;
  status?: string;
  updatetime?: number;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      bid: 'Bid',
      createtime: 'Createtime',
      status: 'Status',
      updatetime: 'Updatetime',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      bid: 'string',
      createtime: 'number',
      status: 'string',
      updatetime: 'number',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainCertificateApplicationsNewResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainCertificateApplicationsNewResponseBodyResult extends $tea.Model {
  certificateApplications?: DescribeAntChainCertificateApplicationsNewResponseBodyResultCertificateApplications[];
  pagination?: DescribeAntChainCertificateApplicationsNewResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      certificateApplications: 'CertificateApplications',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certificateApplications: { 'type': 'array', 'itemType': DescribeAntChainCertificateApplicationsNewResponseBodyResultCertificateApplications },
      pagination: DescribeAntChainCertificateApplicationsNewResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConsortiumsResponseBodyResultAntConsortiums extends $tea.Model {
  chainNum?: number;
  consortiumDescription?: string;
  consortiumId?: string;
  consortiumName?: string;
  createTime?: number;
  isEmptyConsortium?: boolean;
  memberNum?: number;
  role?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      chainNum: 'ChainNum',
      consortiumDescription: 'ConsortiumDescription',
      consortiumId: 'ConsortiumId',
      consortiumName: 'ConsortiumName',
      createTime: 'CreateTime',
      isEmptyConsortium: 'IsEmptyConsortium',
      memberNum: 'MemberNum',
      role: 'Role',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chainNum: 'number',
      consortiumDescription: 'string',
      consortiumId: 'string',
      consortiumName: 'string',
      createTime: 'number',
      isEmptyConsortium: 'boolean',
      memberNum: 'number',
      role: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConsortiumsResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConsortiumsResponseBodyResult extends $tea.Model {
  antConsortiums?: DescribeAntChainConsortiumsResponseBodyResultAntConsortiums[];
  pagination?: DescribeAntChainConsortiumsResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      antConsortiums: 'AntConsortiums',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antConsortiums: { 'type': 'array', 'itemType': DescribeAntChainConsortiumsResponseBodyResultAntConsortiums },
      pagination: DescribeAntChainConsortiumsResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConsortiumsNewResponseBodyResultAntConsortiums extends $tea.Model {
  chainNum?: number;
  consortiumDescription?: string;
  consortiumId?: string;
  consortiumName?: string;
  createTime?: number;
  isEmptyConsortium?: boolean;
  memberNum?: number;
  role?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      chainNum: 'ChainNum',
      consortiumDescription: 'ConsortiumDescription',
      consortiumId: 'ConsortiumId',
      consortiumName: 'ConsortiumName',
      createTime: 'CreateTime',
      isEmptyConsortium: 'IsEmptyConsortium',
      memberNum: 'MemberNum',
      role: 'Role',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chainNum: 'number',
      consortiumDescription: 'string',
      consortiumId: 'string',
      consortiumName: 'string',
      createTime: 'number',
      isEmptyConsortium: 'boolean',
      memberNum: 'number',
      role: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConsortiumsNewResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainConsortiumsNewResponseBodyResult extends $tea.Model {
  antConsortiums?: DescribeAntChainConsortiumsNewResponseBodyResultAntConsortiums[];
  pagination?: DescribeAntChainConsortiumsNewResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      antConsortiums: 'AntConsortiums',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antConsortiums: { 'type': 'array', 'itemType': DescribeAntChainConsortiumsNewResponseBodyResultAntConsortiums },
      pagination: DescribeAntChainConsortiumsNewResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectContentTreeResponseBodyResult extends $tea.Model {
  children?: { [key: string]: any }[];
  projectDescription?: string;
  projectId?: string;
  projectName?: string;
  projectVersion?: string;
  static names(): { [key: string]: string } {
    return {
      children: 'Children',
      projectDescription: 'ProjectDescription',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      projectVersion: 'ProjectVersion',
    };
  }

  static types(): { [key: string]: any } {
    return {
      children: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
      projectDescription: 'string',
      projectId: 'string',
      projectName: 'string',
      projectVersion: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectsResponseBodyResultContractProjects extends $tea.Model {
  consortiumId?: string;
  createTime?: number;
  projectDescription?: string;
  projectId?: string;
  projectName?: string;
  projectVersion?: string;
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      projectDescription: 'ProjectDescription',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      projectVersion: 'ProjectVersion',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      createTime: 'number',
      projectDescription: 'string',
      projectId: 'string',
      projectName: 'string',
      projectVersion: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectsResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectsResponseBodyResult extends $tea.Model {
  contractProjects?: DescribeAntChainContractProjectsResponseBodyResultContractProjects[];
  pagination?: DescribeAntChainContractProjectsResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      contractProjects: 'ContractProjects',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contractProjects: { 'type': 'array', 'itemType': DescribeAntChainContractProjectsResponseBodyResultContractProjects },
      pagination: DescribeAntChainContractProjectsResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectsNewResponseBodyResultContractProjects extends $tea.Model {
  consortiumId?: string;
  createTime?: number;
  projectDescription?: string;
  projectId?: string;
  projectName?: string;
  projectVersion?: string;
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      projectDescription: 'ProjectDescription',
      projectId: 'ProjectId',
      projectName: 'ProjectName',
      projectVersion: 'ProjectVersion',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      createTime: 'number',
      projectDescription: 'string',
      projectId: 'string',
      projectName: 'string',
      projectVersion: 'string',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectsNewResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainContractProjectsNewResponseBodyResult extends $tea.Model {
  contractProjects?: DescribeAntChainContractProjectsNewResponseBodyResultContractProjects[];
  pagination?: DescribeAntChainContractProjectsNewResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      contractProjects: 'ContractProjects',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      contractProjects: { 'type': 'array', 'itemType': DescribeAntChainContractProjectsNewResponseBodyResultContractProjects },
      pagination: DescribeAntChainContractProjectsNewResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainDownloadPathsResponseBodyResult extends $tea.Model {
  caCrtUrl?: string;
  clientCrtUrl?: string;
  sdkUrl?: string;
  trustCaUrl?: string;
  static names(): { [key: string]: string } {
    return {
      caCrtUrl: 'CaCrtUrl',
      clientCrtUrl: 'ClientCrtUrl',
      sdkUrl: 'SdkUrl',
      trustCaUrl: 'TrustCaUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caCrtUrl: 'string',
      clientCrtUrl: 'string',
      sdkUrl: 'string',
      trustCaUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainDownloadPathsNewResponseBodyResult extends $tea.Model {
  caCrtUrl?: string;
  clientCrtUrl?: string;
  sdkUrl?: string;
  trustCaUrl?: string;
  static names(): { [key: string]: string } {
    return {
      caCrtUrl: 'CaCrtUrl',
      clientCrtUrl: 'ClientCrtUrl',
      sdkUrl: 'SdkUrl',
      trustCaUrl: 'TrustCaUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caCrtUrl: 'string',
      clientCrtUrl: 'string',
      sdkUrl: 'string',
      trustCaUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainInformationResponseBodyResultNodeInfos extends $tea.Model {
  blockHeight?: number;
  nodeName?: string;
  status?: boolean;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      blockHeight: 'BlockHeight',
      nodeName: 'NodeName',
      status: 'Status',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockHeight: 'number',
      nodeName: 'string',
      status: 'boolean',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainInformationResponseBodyResult extends $tea.Model {
  abnormalNodes?: number;
  antChainId?: string;
  blockHeight?: number;
  createTime?: number;
  isRole?: boolean;
  nodeInfos?: DescribeAntChainInformationResponseBodyResultNodeInfos[];
  nodeNumber?: number;
  normal?: boolean;
  transactionSum?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      abnormalNodes: 'AbnormalNodes',
      antChainId: 'AntChainId',
      blockHeight: 'BlockHeight',
      createTime: 'CreateTime',
      isRole: 'IsRole',
      nodeInfos: 'NodeInfos',
      nodeNumber: 'NodeNumber',
      normal: 'Normal',
      transactionSum: 'TransactionSum',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abnormalNodes: 'number',
      antChainId: 'string',
      blockHeight: 'number',
      createTime: 'number',
      isRole: 'boolean',
      nodeInfos: { 'type': 'array', 'itemType': DescribeAntChainInformationResponseBodyResultNodeInfos },
      nodeNumber: 'number',
      normal: 'boolean',
      transactionSum: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainInformationNewResponseBodyResultNodeInfos extends $tea.Model {
  blockHeight?: number;
  nodeName?: string;
  status?: boolean;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      blockHeight: 'BlockHeight',
      nodeName: 'NodeName',
      status: 'Status',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockHeight: 'number',
      nodeName: 'string',
      status: 'boolean',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainInformationNewResponseBodyResult extends $tea.Model {
  abnormalNodes?: number;
  antChainId?: string;
  blockHeight?: number;
  createTime?: number;
  isRole?: boolean;
  nodeInfos?: DescribeAntChainInformationNewResponseBodyResultNodeInfos[];
  nodeNumber?: number;
  normal?: boolean;
  transactionSum?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      abnormalNodes: 'AbnormalNodes',
      antChainId: 'AntChainId',
      blockHeight: 'BlockHeight',
      createTime: 'CreateTime',
      isRole: 'IsRole',
      nodeInfos: 'NodeInfos',
      nodeNumber: 'NodeNumber',
      normal: 'Normal',
      transactionSum: 'TransactionSum',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abnormalNodes: 'number',
      antChainId: 'string',
      blockHeight: 'number',
      createTime: 'number',
      isRole: 'boolean',
      nodeInfos: { 'type': 'array', 'itemType': DescribeAntChainInformationNewResponseBodyResultNodeInfos },
      nodeNumber: 'number',
      normal: 'boolean',
      transactionSum: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainLatestBlocksNewResponseBodyResult extends $tea.Model {
  alias?: string;
  bizData?: string;
  blockHash?: string;
  createTime?: number;
  height?: number;
  previousHash?: string;
  rootTxHash?: string;
  size?: number;
  transactionSize?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      bizData: 'BizData',
      blockHash: 'BlockHash',
      createTime: 'CreateTime',
      height: 'Height',
      previousHash: 'PreviousHash',
      rootTxHash: 'RootTxHash',
      size: 'Size',
      transactionSize: 'TransactionSize',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      bizData: 'string',
      blockHash: 'string',
      createTime: 'number',
      height: 'number',
      previousHash: 'string',
      rootTxHash: 'string',
      size: 'number',
      transactionSize: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMembersResponseBodyResultMembers extends $tea.Model {
  joinTime?: number;
  memberId?: string;
  memberName?: string;
  role?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      joinTime: 'JoinTime',
      memberId: 'MemberId',
      memberName: 'MemberName',
      role: 'Role',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      joinTime: 'number',
      memberId: 'string',
      memberName: 'string',
      role: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMembersResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMembersResponseBodyResult extends $tea.Model {
  members?: DescribeAntChainMembersResponseBodyResultMembers[];
  pagination?: DescribeAntChainMembersResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      members: 'Members',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      members: { 'type': 'array', 'itemType': DescribeAntChainMembersResponseBodyResultMembers },
      pagination: DescribeAntChainMembersResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMembersNewResponseBodyResultMembers extends $tea.Model {
  joinTime?: number;
  memberId?: string;
  memberName?: string;
  role?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      joinTime: 'JoinTime',
      memberId: 'MemberId',
      memberName: 'MemberName',
      role: 'Role',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      joinTime: 'number',
      memberId: 'string',
      memberName: 'string',
      role: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMembersNewResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMembersNewResponseBodyResult extends $tea.Model {
  members?: DescribeAntChainMembersNewResponseBodyResultMembers[];
  pagination?: DescribeAntChainMembersNewResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      members: 'Members',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      members: { 'type': 'array', 'itemType': DescribeAntChainMembersNewResponseBodyResultMembers },
      pagination: DescribeAntChainMembersNewResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult extends $tea.Model {
  accessAlipayAccountCount?: number;
  accessCount?: number;
  static names(): { [key: string]: string } {
    return {
      accessAlipayAccountCount: 'AccessAlipayAccountCount',
      accessCount: 'AccessCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessAlipayAccountCount: 'number',
      accessCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBodyResult extends $tea.Model {
  accessAlipayAccountCount?: number;
  accessCount?: number;
  static names(): { [key: string]: string } {
    return {
      accessAlipayAccountCount: 'AccessAlipayAccountCount',
      accessCount: 'AccessCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessAlipayAccountCount: 'number',
      accessCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList extends $tea.Model {
  gmtAuthorized?: string;
  phone?: string;
  static names(): { [key: string]: string } {
    return {
      gmtAuthorized: 'GmtAuthorized',
      phone: 'Phone',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtAuthorized: 'string',
      phone: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult extends $tea.Model {
  antChainId?: string;
  authorizationType?: string;
  authorizedUserList?: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList[];
  pagination?: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination;
  QRCodeType?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      authorizationType: 'AuthorizationType',
      authorizedUserList: 'AuthorizedUserList',
      pagination: 'Pagination',
      QRCodeType: 'QRCodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      authorizationType: 'string',
      authorizedUserList: { 'type': 'array', 'itemType': DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList },
      pagination: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination,
      QRCodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultAuthorizedUserList extends $tea.Model {
  gmtAuthorized?: string;
  phone?: string;
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      gmtAuthorized: 'GmtAuthorized',
      phone: 'Phone',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      gmtAuthorized: 'string',
      phone: 'string',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResult extends $tea.Model {
  antChainId?: string;
  authorizationType?: string;
  authorizedUserList?: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultAuthorizedUserList[];
  pagination?: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultPagination;
  QRCodeType?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      authorizationType: 'AuthorizationType',
      authorizedUserList: 'AuthorizedUserList',
      pagination: 'Pagination',
      QRCodeType: 'QRCodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      authorizationType: 'string',
      authorizedUserList: { 'type': 'array', 'itemType': DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultAuthorizedUserList },
      pagination: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultPagination,
      QRCodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult extends $tea.Model {
  antChainId?: string;
  base64QRCodePNG?: string;
  QRCodeContent?: string;
  transactionHash?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      base64QRCodePNG: 'Base64QRCodePNG',
      QRCodeContent: 'QRCodeContent',
      transactionHash: 'TransactionHash',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      base64QRCodePNG: 'string',
      QRCodeContent: 'string',
      transactionHash: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult extends $tea.Model {
  antChainId?: string;
  base64QRCodePNG?: string;
  QRCodeContent?: string;
  transactionHash?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      base64QRCodePNG: 'Base64QRCodePNG',
      QRCodeContent: 'QRCodeContent',
      transactionHash: 'TransactionHash',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      base64QRCodePNG: 'string',
      QRCodeContent: 'string',
      transactionHash: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainQRCodeAuthorizationResponseBodyResult extends $tea.Model {
  antChainId?: string;
  authorizationType?: string;
  QRCodeType?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      authorizationType: 'AuthorizationType',
      QRCodeType: 'QRCodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      authorizationType: 'string',
      QRCodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainQRCodeAuthorizationNewResponseBodyResult extends $tea.Model {
  antChainId?: string;
  authorizationType?: string;
  QRCodeType?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      authorizationType: 'AuthorizationType',
      QRCodeType: 'QRCodeType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      authorizationType: 'string',
      QRCodeType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainRegionNamesResponseBodyResult extends $tea.Model {
  regionId?: string;
  regionName?: string;
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      regionName: 'RegionName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      regionName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainRegionsForSaleResponseBodyResult extends $tea.Model {
  regionId?: string;
  typeList?: string[];
  static names(): { [key: string]: string } {
    return {
      regionId: 'RegionId',
      typeList: 'TypeList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      regionId: 'string',
      typeList: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainResourceTypesResponseBodyResult extends $tea.Model {
  cpu?: number;
  disk?: number;
  memory?: number;
  typeId?: number;
  static names(): { [key: string]: string } {
    return {
      cpu: 'Cpu',
      disk: 'Disk',
      memory: 'Memory',
      typeId: 'TypeId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpu: 'number',
      disk: 'number',
      memory: 'number',
      typeId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainRestResponseBodyResult extends $tea.Model {
  accessId?: string;
  createTime?: number;
  updateTime?: number;
  static names(): { [key: string]: string } {
    return {
      accessId: 'AccessId',
      createTime: 'CreateTime',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessId: 'string',
      createTime: 'number',
      updateTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetListResponseBodyResultBlockchainSubnetList extends $tea.Model {
  antChainId?: string;
  blockHeight?: number;
  consortiumMember?: boolean;
  createTime?: number;
  groupId?: string;
  monitor?: boolean;
  name?: string;
  nodeSum?: number;
  rest?: string;
  status?: string;
  transactionSum?: number;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      blockHeight: 'BlockHeight',
      consortiumMember: 'ConsortiumMember',
      createTime: 'CreateTime',
      groupId: 'GroupId',
      monitor: 'Monitor',
      name: 'Name',
      nodeSum: 'NodeSum',
      rest: 'Rest',
      status: 'Status',
      transactionSum: 'TransactionSum',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      blockHeight: 'number',
      consortiumMember: 'boolean',
      createTime: 'number',
      groupId: 'string',
      monitor: 'boolean',
      name: 'string',
      nodeSum: 'number',
      rest: 'string',
      status: 'string',
      transactionSum: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetListResponseBodyResult extends $tea.Model {
  antChainId?: string;
  blockchainName?: string;
  blockchainSubnetList?: DescribeAntChainSubnetListResponseBodyResultBlockchainSubnetList[];
  consortiumAdmin?: boolean;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      blockchainName: 'BlockchainName',
      blockchainSubnetList: 'BlockchainSubnetList',
      consortiumAdmin: 'ConsortiumAdmin',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      blockchainName: 'string',
      blockchainSubnetList: { 'type': 'array', 'itemType': DescribeAntChainSubnetListResponseBodyResultBlockchainSubnetList },
      consortiumAdmin: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetMemberListResponseBodyResultConsortiumMemberInfoList extends $tea.Model {
  joinTime?: number;
  memberId?: string;
  memberName?: string;
  role?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      joinTime: 'JoinTime',
      memberId: 'MemberId',
      memberName: 'MemberName',
      role: 'Role',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      joinTime: 'number',
      memberId: 'string',
      memberName: 'string',
      role: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetMemberListResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetMemberListResponseBodyResult extends $tea.Model {
  consortiumAdmin?: boolean;
  consortiumMemberInfoList?: DescribeAntChainSubnetMemberListResponseBodyResultConsortiumMemberInfoList[];
  pagination?: DescribeAntChainSubnetMemberListResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      consortiumAdmin: 'ConsortiumAdmin',
      consortiumMemberInfoList: 'ConsortiumMemberInfoList',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumAdmin: 'boolean',
      consortiumMemberInfoList: { 'type': 'array', 'itemType': DescribeAntChainSubnetMemberListResponseBodyResultConsortiumMemberInfoList },
      pagination: DescribeAntChainSubnetMemberListResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetNodeListResponseBodyResultChainNodeInfoList extends $tea.Model {
  diskTotal?: string;
  diskUse?: string;
  nodeId?: string;
  nodeIp?: string;
  nodeName?: string;
  nodePort?: string;
  nodeSource?: string;
  nodeState?: string;
  nodeType?: string;
  publicKey?: string;
  static names(): { [key: string]: string } {
    return {
      diskTotal: 'DiskTotal',
      diskUse: 'DiskUse',
      nodeId: 'NodeId',
      nodeIp: 'NodeIp',
      nodeName: 'NodeName',
      nodePort: 'NodePort',
      nodeSource: 'NodeSource',
      nodeState: 'NodeState',
      nodeType: 'NodeType',
      publicKey: 'PublicKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diskTotal: 'string',
      diskUse: 'string',
      nodeId: 'string',
      nodeIp: 'string',
      nodeName: 'string',
      nodePort: 'string',
      nodeSource: 'string',
      nodeState: 'string',
      nodeType: 'string',
      publicKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainSubnetNodeListResponseBodyResult extends $tea.Model {
  chainNodeInfoList?: DescribeAntChainSubnetNodeListResponseBodyResultChainNodeInfoList[];
  consortiumAdmin?: boolean;
  static names(): { [key: string]: string } {
    return {
      chainNodeInfoList: 'ChainNodeInfoList',
      consortiumAdmin: 'ConsortiumAdmin',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chainNodeInfoList: { 'type': 'array', 'itemType': DescribeAntChainSubnetNodeListResponseBodyResultChainNodeInfoList },
      consortiumAdmin: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionResponseBodyResultTransaction extends $tea.Model {
  data?: string;
  extentions?: string[];
  from?: string;
  gas?: string;
  hash?: string;
  nonce?: string;
  period?: number;
  signatures?: string[];
  timestamp?: number;
  to?: string;
  txType?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      extentions: 'Extentions',
      from: 'From',
      gas: 'Gas',
      hash: 'Hash',
      nonce: 'Nonce',
      period: 'Period',
      signatures: 'Signatures',
      timestamp: 'Timestamp',
      to: 'To',
      txType: 'TxType',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      extentions: { 'type': 'array', 'itemType': 'string' },
      from: 'string',
      gas: 'string',
      hash: 'string',
      nonce: 'string',
      period: 'number',
      signatures: { 'type': 'array', 'itemType': 'string' },
      timestamp: 'number',
      to: 'string',
      txType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionResponseBodyResult extends $tea.Model {
  blockHash?: string;
  blockHeight?: number;
  blockVersion?: string;
  createTime?: number;
  hash?: string;
  transaction?: DescribeAntChainTransactionResponseBodyResultTransaction;
  static names(): { [key: string]: string } {
    return {
      blockHash: 'BlockHash',
      blockHeight: 'BlockHeight',
      blockVersion: 'BlockVersion',
      createTime: 'CreateTime',
      hash: 'Hash',
      transaction: 'Transaction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockHash: 'string',
      blockHeight: 'number',
      blockVersion: 'string',
      createTime: 'number',
      hash: 'string',
      transaction: DescribeAntChainTransactionResponseBodyResultTransaction,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionNewResponseBodyResultTransaction extends $tea.Model {
  data?: string;
  extentions?: string[];
  from?: string;
  gas?: string;
  hash?: string;
  nonce?: string;
  period?: number;
  signatures?: string[];
  timestamp?: number;
  to?: string;
  txType?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      extentions: 'Extentions',
      from: 'From',
      gas: 'Gas',
      hash: 'Hash',
      nonce: 'Nonce',
      period: 'Period',
      signatures: 'Signatures',
      timestamp: 'Timestamp',
      to: 'To',
      txType: 'TxType',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      extentions: { 'type': 'array', 'itemType': 'string' },
      from: 'string',
      gas: 'string',
      hash: 'string',
      nonce: 'string',
      period: 'number',
      signatures: { 'type': 'array', 'itemType': 'string' },
      timestamp: 'number',
      to: 'string',
      txType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionNewResponseBodyResult extends $tea.Model {
  blockHash?: string;
  blockHeight?: number;
  blockVersion?: string;
  createTime?: number;
  hash?: string;
  transaction?: DescribeAntChainTransactionNewResponseBodyResultTransaction;
  static names(): { [key: string]: string } {
    return {
      blockHash: 'BlockHash',
      blockHeight: 'BlockHeight',
      blockVersion: 'BlockVersion',
      createTime: 'CreateTime',
      hash: 'Hash',
      transaction: 'Transaction',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockHash: 'string',
      blockHeight: 'number',
      blockVersion: 'string',
      createTime: 'number',
      hash: 'string',
      transaction: DescribeAntChainTransactionNewResponseBodyResultTransaction,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionReceiptNewResponseBodyResult extends $tea.Model {
  data?: string;
  gasUsed?: string;
  logs?: string[];
  result?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      gasUsed: 'GasUsed',
      logs: 'Logs',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      gasUsed: 'string',
      logs: { 'type': 'array', 'itemType': 'string' },
      result: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionStatisticsResponseBodyResult extends $tea.Model {
  antChainId?: string;
  creatTime?: number;
  dt?: number;
  lastSumBlockHeight?: number;
  transCount?: number;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      creatTime: 'CreatTime',
      dt: 'Dt',
      lastSumBlockHeight: 'LastSumBlockHeight',
      transCount: 'TransCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      creatTime: 'number',
      dt: 'number',
      lastSumBlockHeight: 'number',
      transCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainTransactionStatisticsNewResponseBodyResult extends $tea.Model {
  antChainId?: string;
  creatTime?: number;
  dt?: number;
  lastSumBlockHeight?: number;
  transCount?: number;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      creatTime: 'CreatTime',
      dt: 'Dt',
      lastSumBlockHeight: 'LastSumBlockHeight',
      transCount: 'TransCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      creatTime: 'number',
      dt: 'number',
      lastSumBlockHeight: 'number',
      transCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainsResponseBodyResultAntChains extends $tea.Model {
  antChainId?: string;
  antChainName?: string;
  chainType?: string;
  cipherSuit?: string;
  createTime?: number;
  expireTime?: number;
  isAdmin?: boolean;
  memberStatus?: string;
  merkleTreeSuit?: string;
  network?: string;
  nodeNum?: number;
  regionId?: string;
  resourceSize?: string;
  tlsAlgo?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      antChainName: 'AntChainName',
      chainType: 'ChainType',
      cipherSuit: 'CipherSuit',
      createTime: 'CreateTime',
      expireTime: 'ExpireTime',
      isAdmin: 'IsAdmin',
      memberStatus: 'MemberStatus',
      merkleTreeSuit: 'MerkleTreeSuit',
      network: 'Network',
      nodeNum: 'NodeNum',
      regionId: 'RegionId',
      resourceSize: 'ResourceSize',
      tlsAlgo: 'TlsAlgo',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      antChainName: 'string',
      chainType: 'string',
      cipherSuit: 'string',
      createTime: 'number',
      expireTime: 'number',
      isAdmin: 'boolean',
      memberStatus: 'string',
      merkleTreeSuit: 'string',
      network: 'string',
      nodeNum: 'number',
      regionId: 'string',
      resourceSize: 'string',
      tlsAlgo: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainsResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainsResponseBodyResult extends $tea.Model {
  antChains?: DescribeAntChainsResponseBodyResultAntChains[];
  isExist?: boolean;
  pagination?: DescribeAntChainsResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      antChains: 'AntChains',
      isExist: 'IsExist',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChains: { 'type': 'array', 'itemType': DescribeAntChainsResponseBodyResultAntChains },
      isExist: 'boolean',
      pagination: DescribeAntChainsResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainsNewResponseBodyResultAntChains extends $tea.Model {
  antChainId?: string;
  antChainName?: string;
  chainType?: string;
  cipherSuit?: string;
  createTime?: number;
  expireTime?: number;
  instanceId?: string;
  isAdmin?: boolean;
  memberStatus?: string;
  merkleTreeSuit?: string;
  monitorStatus?: boolean;
  network?: string;
  nodeNum?: number;
  regionId?: string;
  resourceSize?: string;
  restStatus?: string;
  tlsAlgo?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      antChainId: 'AntChainId',
      antChainName: 'AntChainName',
      chainType: 'ChainType',
      cipherSuit: 'CipherSuit',
      createTime: 'CreateTime',
      expireTime: 'ExpireTime',
      instanceId: 'InstanceId',
      isAdmin: 'IsAdmin',
      memberStatus: 'MemberStatus',
      merkleTreeSuit: 'MerkleTreeSuit',
      monitorStatus: 'MonitorStatus',
      network: 'Network',
      nodeNum: 'NodeNum',
      regionId: 'RegionId',
      resourceSize: 'ResourceSize',
      restStatus: 'RestStatus',
      tlsAlgo: 'TlsAlgo',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChainId: 'string',
      antChainName: 'string',
      chainType: 'string',
      cipherSuit: 'string',
      createTime: 'number',
      expireTime: 'number',
      instanceId: 'string',
      isAdmin: 'boolean',
      memberStatus: 'string',
      merkleTreeSuit: 'string',
      monitorStatus: 'boolean',
      network: 'string',
      nodeNum: 'number',
      regionId: 'string',
      resourceSize: 'string',
      restStatus: 'string',
      tlsAlgo: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainsNewResponseBodyResultPagination extends $tea.Model {
  pageNumber?: number;
  pageSize?: number;
  totalCount?: number;
  static names(): { [key: string]: string } {
    return {
      pageNumber: 'PageNumber',
      pageSize: 'PageSize',
      totalCount: 'TotalCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      pageNumber: 'number',
      pageSize: 'number',
      totalCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntChainsNewResponseBodyResult extends $tea.Model {
  antChains?: DescribeAntChainsNewResponseBodyResultAntChains[];
  isExist?: boolean;
  pagination?: DescribeAntChainsNewResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      antChains: 'AntChains',
      isExist: 'IsExist',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      antChains: { 'type': 'array', 'itemType': DescribeAntChainsNewResponseBodyResultAntChains },
      isExist: 'boolean',
      pagination: DescribeAntChainsNewResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAntRegionsResponseBodyResult extends $tea.Model {
  localName?: string;
  regionId?: string;
  static names(): { [key: string]: string } {
    return {
      localName: 'LocalName',
      regionId: 'RegionId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      localName: 'string',
      regionId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppliesResponseBodyResultApplyHistoryList extends $tea.Model {
  bizid?: string;
  createtime?: number;
  id?: number;
  rejectReason?: string;
  reqAddr?: string;
  signedAddr?: string;
  status?: number;
  updatetime?: number;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      createtime: 'Createtime',
      id: 'Id',
      rejectReason: 'RejectReason',
      reqAddr: 'ReqAddr',
      signedAddr: 'SignedAddr',
      status: 'Status',
      updatetime: 'Updatetime',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      createtime: 'number',
      id: 'number',
      rejectReason: 'string',
      reqAddr: 'string',
      signedAddr: 'string',
      status: 'number',
      updatetime: 'number',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppliesResponseBodyResultPagination extends $tea.Model {
  current?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'Current',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeAppliesResponseBodyResult extends $tea.Model {
  applyHistoryList?: DescribeAppliesResponseBodyResultApplyHistoryList[];
  pagination?: DescribeAppliesResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      applyHistoryList: 'ApplyHistoryList',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyHistoryList: { 'type': 'array', 'itemType': DescribeAppliesResponseBodyResultApplyHistoryList },
      pagination: DescribeAppliesResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBcSchemaResponseBodyResultResponsesPropertiesDataSource extends $tea.Model {
  allowNull?: number;
  annotation?: string;
  field?: string;
  indexes?: number;
  key?: number;
  length?: number;
  reg?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      allowNull: 'AllowNull',
      annotation: 'Annotation',
      field: 'Field',
      indexes: 'Indexes',
      key: 'Key',
      length: 'Length',
      reg: 'Reg',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowNull: 'number',
      annotation: 'string',
      field: 'string',
      indexes: 'number',
      key: 'number',
      length: 'number',
      reg: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBcSchemaResponseBodyResultResponsesProperties extends $tea.Model {
  count?: number;
  dataSource?: DescribeBcSchemaResponseBodyResultResponsesPropertiesDataSource[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      dataSource: 'DataSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      dataSource: { 'type': 'array', 'itemType': DescribeBcSchemaResponseBodyResultResponsesPropertiesDataSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBcSchemaResponseBodyResultResponses extends $tea.Model {
  category?: string;
  categoryName?: string;
  description?: string;
  properties?: DescribeBcSchemaResponseBodyResultResponsesProperties;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      categoryName: 'CategoryName',
      description: 'Description',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      categoryName: 'string',
      description: 'string',
      properties: DescribeBcSchemaResponseBodyResultResponsesProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBcSchemaResponseBodyResultSchema extends $tea.Model {
  createTime?: number;
  description?: string;
  id?: number;
  isTemplate?: boolean;
  name?: string;
  updateTime?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      id: 'Id',
      isTemplate: 'IsTemplate',
      name: 'Name',
      updateTime: 'UpdateTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      id: 'number',
      isTemplate: 'boolean',
      name: 'string',
      updateTime: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBcSchemaResponseBodyResult extends $tea.Model {
  responses?: DescribeBcSchemaResponseBodyResultResponses[];
  schema?: DescribeBcSchemaResponseBodyResultSchema;
  static names(): { [key: string]: string } {
    return {
      responses: 'Responses',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responses: { 'type': 'array', 'itemType': DescribeBcSchemaResponseBodyResultResponses },
      schema: DescribeBcSchemaResponseBodyResultSchema,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockResponseBodyResult extends $tea.Model {
  alias?: string;
  blockHash?: string;
  createTime?: number;
  height?: number;
  previousHash?: string;
  rootTxHash?: string;
  transSummaryList?: string;
  transactionSize?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      blockHash: 'BlockHash',
      createTime: 'CreateTime',
      height: 'Height',
      previousHash: 'PreviousHash',
      rootTxHash: 'RootTxHash',
      transSummaryList: 'TransSummaryList',
      transactionSize: 'TransactionSize',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      blockHash: 'string',
      createTime: 'number',
      height: 'number',
      previousHash: 'string',
      rootTxHash: 'string',
      transSummaryList: 'string',
      transactionSize: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainApplicationResponseBodyResultApplyHistoryList extends $tea.Model {
  bizid?: string;
  createtime?: number;
  id?: number;
  rejectReason?: string;
  reqAddr?: string;
  signedAddr?: string;
  status?: number;
  updatetime?: number;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      createtime: 'Createtime',
      id: 'Id',
      rejectReason: 'RejectReason',
      reqAddr: 'ReqAddr',
      signedAddr: 'SignedAddr',
      status: 'Status',
      updatetime: 'Updatetime',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      createtime: 'number',
      id: 'number',
      rejectReason: 'string',
      reqAddr: 'string',
      signedAddr: 'string',
      status: 'number',
      updatetime: 'number',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainApplicationResponseBodyResultPagination extends $tea.Model {
  current?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'Current',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainApplicationResponseBodyResult extends $tea.Model {
  applyHistoryList?: DescribeBlockchainApplicationResponseBodyResultApplyHistoryList[];
  pagination?: DescribeBlockchainApplicationResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      applyHistoryList: 'ApplyHistoryList',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyHistoryList: { 'type': 'array', 'itemType': DescribeBlockchainApplicationResponseBodyResultApplyHistoryList },
      pagination: DescribeBlockchainApplicationResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks extends $tea.Model {
  bizid?: string;
  createTime?: number;
  memo?: string;
  name?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      createTime: 'CreateTime',
      memo: 'Memo',
      name: 'Name',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      createTime: 'number',
      memo: 'string',
      name: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainCreateTaskResponseBodyResultPagination extends $tea.Model {
  current?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'Current',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainCreateTaskResponseBodyResult extends $tea.Model {
  blockchainCreateTasks?: DescribeBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks[];
  pagination?: DescribeBlockchainCreateTaskResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      blockchainCreateTasks: 'BlockchainCreateTasks',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockchainCreateTasks: { 'type': 'array', 'itemType': DescribeBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks },
      pagination: DescribeBlockchainCreateTaskResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainInfoResponseBodyResultNodeInfoList extends $tea.Model {
  blockHeight?: number;
  nodeName?: string;
  status?: boolean;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      blockHeight: 'BlockHeight',
      nodeName: 'NodeName',
      status: 'Status',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockHeight: 'number',
      nodeName: 'string',
      status: 'boolean',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainInfoResponseBodyResult extends $tea.Model {
  abnormalNodes?: number;
  bizid?: string;
  blockHeight?: number;
  createTime?: number;
  isRole?: boolean;
  nodeInfoList?: DescribeBlockchainInfoResponseBodyResultNodeInfoList[];
  nodeNumber?: number;
  normal?: boolean;
  transactionSum?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      abnormalNodes: 'AbnormalNodes',
      bizid: 'Bizid',
      blockHeight: 'BlockHeight',
      createTime: 'CreateTime',
      isRole: 'IsRole',
      nodeInfoList: 'NodeInfoList',
      nodeNumber: 'NodeNumber',
      normal: 'Normal',
      transactionSum: 'TransactionSum',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abnormalNodes: 'number',
      bizid: 'string',
      blockHeight: 'number',
      createTime: 'number',
      isRole: 'boolean',
      nodeInfoList: { 'type': 'array', 'itemType': DescribeBlockchainInfoResponseBodyResultNodeInfoList },
      nodeNumber: 'number',
      normal: 'boolean',
      transactionSum: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource extends $tea.Model {
  allowNull?: number;
  annotation?: string;
  field?: string;
  indexes?: number;
  key?: number;
  length?: number;
  reg?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      allowNull: 'AllowNull',
      annotation: 'Annotation',
      field: 'Field',
      indexes: 'Indexes',
      key: 'Key',
      length: 'Length',
      reg: 'Reg',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowNull: 'number',
      annotation: 'string',
      field: 'string',
      indexes: 'number',
      key: 'number',
      length: 'number',
      reg: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaResponseBodyResultResponsesProperties extends $tea.Model {
  count?: number;
  dataSource?: DescribeBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      dataSource: 'DataSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      dataSource: { 'type': 'array', 'itemType': DescribeBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaResponseBodyResultResponses extends $tea.Model {
  category?: string;
  categoryName?: string;
  description?: string;
  properties?: DescribeBlockchainSchemaResponseBodyResultResponsesProperties;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      categoryName: 'CategoryName',
      description: 'Description',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      categoryName: 'string',
      description: 'string',
      properties: DescribeBlockchainSchemaResponseBodyResultResponsesProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaResponseBodyResultSchema extends $tea.Model {
  createTime?: number;
  description?: string;
  id?: number;
  isTemplate?: boolean;
  name?: string;
  updateTime?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      id: 'Id',
      isTemplate: 'IsTemplate',
      name: 'Name',
      updateTime: 'UpdateTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      id: 'number',
      isTemplate: 'boolean',
      name: 'string',
      updateTime: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaResponseBodyResult extends $tea.Model {
  responses?: DescribeBlockchainSchemaResponseBodyResultResponses[];
  schema?: DescribeBlockchainSchemaResponseBodyResultSchema;
  static names(): { [key: string]: string } {
    return {
      responses: 'Responses',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responses: { 'type': 'array', 'itemType': DescribeBlockchainSchemaResponseBodyResultResponses },
      schema: DescribeBlockchainSchemaResponseBodyResultSchema,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaDetailResponseBodyResultResponsesPropertiesDataSource extends $tea.Model {
  allowNull?: number;
  annotation?: string;
  field?: string;
  indexes?: number;
  key?: number;
  length?: number;
  reg?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      allowNull: 'AllowNull',
      annotation: 'Annotation',
      field: 'Field',
      indexes: 'Indexes',
      key: 'Key',
      length: 'Length',
      reg: 'Reg',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowNull: 'number',
      annotation: 'string',
      field: 'string',
      indexes: 'number',
      key: 'number',
      length: 'number',
      reg: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaDetailResponseBodyResultResponsesProperties extends $tea.Model {
  count?: number;
  dataSource?: DescribeBlockchainSchemaDetailResponseBodyResultResponsesPropertiesDataSource[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      dataSource: 'DataSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      dataSource: { 'type': 'array', 'itemType': DescribeBlockchainSchemaDetailResponseBodyResultResponsesPropertiesDataSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaDetailResponseBodyResultResponses extends $tea.Model {
  category?: string;
  categoryName?: string;
  description?: string;
  properties?: DescribeBlockchainSchemaDetailResponseBodyResultResponsesProperties;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      categoryName: 'CategoryName',
      description: 'Description',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      categoryName: 'string',
      description: 'string',
      properties: DescribeBlockchainSchemaDetailResponseBodyResultResponsesProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaDetailResponseBodyResultSchema extends $tea.Model {
  createTime?: number;
  description?: string;
  id?: number;
  isTemplate?: boolean;
  name?: string;
  updateTime?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      id: 'Id',
      isTemplate: 'IsTemplate',
      name: 'Name',
      updateTime: 'UpdateTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      id: 'number',
      isTemplate: 'boolean',
      name: 'string',
      updateTime: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaDetailResponseBodyResult extends $tea.Model {
  responses?: DescribeBlockchainSchemaDetailResponseBodyResultResponses[];
  schema?: DescribeBlockchainSchemaDetailResponseBodyResultSchema;
  static names(): { [key: string]: string } {
    return {
      responses: 'Responses',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responses: { 'type': 'array', 'itemType': DescribeBlockchainSchemaDetailResponseBodyResultResponses },
      schema: DescribeBlockchainSchemaDetailResponseBodyResultSchema,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaFileOSSPropertiesResponseBodyResult extends $tea.Model {
  accessKeyId?: string;
  accessKeySecret?: string;
  bucketName?: string;
  endpoint?: string;
  folderName?: string;
  static names(): { [key: string]: string } {
    return {
      accessKeyId: 'AccessKeyId',
      accessKeySecret: 'AccessKeySecret',
      bucketName: 'BucketName',
      endpoint: 'Endpoint',
      folderName: 'FolderName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKeyId: 'string',
      accessKeySecret: 'string',
      bucketName: 'string',
      endpoint: 'string',
      folderName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaTemplatesResponseBodyResultSchemaList extends $tea.Model {
  createTime?: number;
  description?: string;
  id?: number;
  isTemplate?: number;
  name?: string;
  updateTime?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      id: 'Id',
      isTemplate: 'IsTemplate',
      name: 'Name',
      updateTime: 'UpdateTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      id: 'number',
      isTemplate: 'number',
      name: 'string',
      updateTime: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeBlockchainSchemaTemplatesResponseBodyResult extends $tea.Model {
  schemaList?: DescribeBlockchainSchemaTemplatesResponseBodyResultSchemaList[];
  static names(): { [key: string]: string } {
    return {
      schemaList: 'SchemaList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      schemaList: { 'type': 'array', 'itemType': DescribeBlockchainSchemaTemplatesResponseBodyResultSchemaList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCandidateOrganizationsResponseBodyResult extends $tea.Model {
  clusterState?: string;
  organizationId?: string;
  organizationName?: string;
  serviceState?: string;
  static names(): { [key: string]: string } {
    return {
      clusterState: 'ClusterState',
      organizationId: 'OrganizationId',
      organizationName: 'OrganizationName',
      serviceState: 'ServiceState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      clusterState: 'string',
      organizationId: 'string',
      organizationName: 'string',
      serviceState: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition extends $tea.Model {
  chaincodePackageId?: string;
  collectionConfig?: string;
  endorsementPolicy?: string;
  initRequired?: boolean;
  name?: string;
  sequence?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodePackageId: 'ChaincodePackageId',
      collectionConfig: 'CollectionConfig',
      endorsementPolicy: 'EndorsementPolicy',
      initRequired: 'InitRequired',
      name: 'Name',
      sequence: 'Sequence',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodePackageId: 'string',
      collectionConfig: 'string',
      endorsementPolicy: 'string',
      initRequired: 'boolean',
      name: 'string',
      sequence: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChaincodeDefinitionTaskResponseBodyResultContent extends $tea.Model {
  chaincodeDefinition?: DescribeChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition;
  static names(): { [key: string]: string } {
    return {
      chaincodeDefinition: 'ChaincodeDefinition',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeDefinition: DescribeChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChaincodeDefinitionTaskResponseBodyResult extends $tea.Model {
  approvers?: string[];
  channelName?: string;
  content?: DescribeChaincodeDefinitionTaskResponseBodyResultContent;
  createTime?: number;
  creator?: string;
  description?: string;
  status?: string;
  taskId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      approvers: 'Approvers',
      channelName: 'ChannelName',
      content: 'Content',
      createTime: 'CreateTime',
      creator: 'Creator',
      description: 'Description',
      status: 'Status',
      taskId: 'TaskId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      approvers: { 'type': 'array', 'itemType': 'string' },
      channelName: 'string',
      content: DescribeChaincodeDefinitionTaskResponseBodyResultContent,
      createTime: 'number',
      creator: 'string',
      description: 'string',
      status: 'string',
      taskId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChaincodeUploadPolicyResponseBodyResult extends $tea.Model {
  accessId?: string;
  dir?: string;
  expire?: number;
  host?: string;
  policy?: string;
  signature?: string;
  static names(): { [key: string]: string } {
    return {
      accessId: 'AccessId',
      dir: 'Dir',
      expire: 'Expire',
      host: 'Host',
      policy: 'Policy',
      signature: 'Signature',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessId: 'string',
      dir: 'string',
      expire: 'number',
      host: 'string',
      policy: 'string',
      signature: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChannelChaincodesResponseBodyResult extends $tea.Model {
  binding?: boolean;
  chaincodeId?: string;
  channelId?: string;
  channelName?: string;
  consortiumId?: string;
  createTime?: string;
  creator?: string;
  deployTime?: string;
  endorsePolicy?: string;
  installed?: string;
  management?: boolean;
  message?: string;
  name?: string;
  state?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      binding: 'Binding',
      chaincodeId: 'ChaincodeId',
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      creator: 'Creator',
      deployTime: 'DeployTime',
      endorsePolicy: 'EndorsePolicy',
      installed: 'Installed',
      management: 'Management',
      message: 'Message',
      name: 'Name',
      state: 'State',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      binding: 'boolean',
      chaincodeId: 'string',
      channelId: 'string',
      channelName: 'string',
      consortiumId: 'string',
      createTime: 'string',
      creator: 'string',
      deployTime: 'string',
      endorsePolicy: 'string',
      installed: 'string',
      management: 'boolean',
      message: 'string',
      name: 'string',
      state: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChannelMembersResponseBodyResult extends $tea.Model {
  acceptTime?: string;
  channelId?: string;
  description?: string;
  domain?: string;
  inviteTime?: string;
  name?: string;
  organizationId?: string;
  state?: string;
  withPeer?: boolean;
  static names(): { [key: string]: string } {
    return {
      acceptTime: 'AcceptTime',
      channelId: 'ChannelId',
      description: 'Description',
      domain: 'Domain',
      inviteTime: 'InviteTime',
      name: 'Name',
      organizationId: 'OrganizationId',
      state: 'State',
      withPeer: 'WithPeer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptTime: 'string',
      channelId: 'string',
      description: 'string',
      domain: 'string',
      inviteTime: 'string',
      name: 'string',
      organizationId: 'string',
      state: 'string',
      withPeer: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChannelTriggersResponseBodyResultCheckpoint extends $tea.Model {
  errorCount?: number;
  height?: number;
  index?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      errorCount: 'ErrorCount',
      height: 'Height',
      index: 'Index',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCount: 'number',
      height: 'number',
      index: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeChannelTriggersResponseBodyResult extends $tea.Model {
  channelId?: string;
  channelName?: string;
  checkpoint?: DescribeChannelTriggersResponseBodyResultCheckpoint;
  createTime?: number;
  errorMessage?: string;
  name?: string;
  options?: string;
  source?: string;
  status?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      checkpoint: 'Checkpoint',
      createTime: 'CreateTime',
      errorMessage: 'ErrorMessage',
      name: 'Name',
      options: 'Options',
      source: 'Source',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      checkpoint: DescribeChannelTriggersResponseBodyResultCheckpoint,
      createTime: 'number',
      errorMessage: 'string',
      name: 'string',
      options: 'string',
      source: 'string',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudIntegrationServiceTokenResponseBodyResultHistory extends $tea.Model {
  service?: string;
  token?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      service: 'Service',
      token: 'Token',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      service: 'string',
      token: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudIntegrationServiceTokenResponseBodyResult extends $tea.Model {
  history?: DescribeCloudIntegrationServiceTokenResponseBodyResultHistory[];
  service?: string;
  token?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      history: 'History',
      service: 'Service',
      token: 'Token',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      history: { 'type': 'array', 'itemType': DescribeCloudIntegrationServiceTokenResponseBodyResultHistory },
      service: 'string',
      token: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudServiceOrganizationStatusResponseBodyResult extends $tea.Model {
  grantPrivilegeUrl?: string;
  organizationId?: string;
  serviceOpenStatus?: boolean;
  serviceOpenUrl?: string;
  servicePrivilegeStatus?: boolean;
  serviceType?: string;
  static names(): { [key: string]: string } {
    return {
      grantPrivilegeUrl: 'GrantPrivilegeUrl',
      organizationId: 'OrganizationId',
      serviceOpenStatus: 'ServiceOpenStatus',
      serviceOpenUrl: 'ServiceOpenUrl',
      servicePrivilegeStatus: 'ServicePrivilegeStatus',
      serviceType: 'ServiceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      grantPrivilegeUrl: 'string',
      organizationId: 'string',
      serviceOpenStatus: 'boolean',
      serviceOpenUrl: 'string',
      servicePrivilegeStatus: 'boolean',
      serviceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeCloudServiceTypeStatusResponseBodyResult extends $tea.Model {
  grantPrivilegeUrl?: string;
  organizationId?: string;
  serviceOpenStatus?: boolean;
  serviceOpenUrl?: string;
  servicePrivilegeStatus?: boolean;
  serviceType?: string;
  static names(): { [key: string]: string } {
    return {
      grantPrivilegeUrl: 'GrantPrivilegeUrl',
      organizationId: 'OrganizationId',
      serviceOpenStatus: 'ServiceOpenStatus',
      serviceOpenUrl: 'ServiceOpenUrl',
      servicePrivilegeStatus: 'ServicePrivilegeStatus',
      serviceType: 'ServiceType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      grantPrivilegeUrl: 'string',
      organizationId: 'string',
      serviceOpenStatus: 'boolean',
      serviceOpenUrl: 'string',
      servicePrivilegeStatus: 'boolean',
      serviceType: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumAdminStatusResponseBodyResult extends $tea.Model {
  consortiumAdministrator?: boolean;
  consortiumId?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumAdministrator: 'ConsortiumAdministrator',
      consortiumId: 'ConsortiumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumAdministrator: 'boolean',
      consortiumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumChaincodesResponseBodyResult extends $tea.Model {
  chaincodeId?: string;
  channelId?: string;
  channelName?: string;
  consortiumId?: string;
  createTime?: string;
  deployTime?: string;
  endorsePolicy?: string;
  input?: string;
  install?: boolean;
  management?: boolean;
  message?: string;
  name?: string;
  path?: string;
  providerId?: string;
  providerName?: string;
  state?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      deployTime: 'DeployTime',
      endorsePolicy: 'EndorsePolicy',
      input: 'Input',
      install: 'Install',
      management: 'Management',
      message: 'Message',
      name: 'Name',
      path: 'Path',
      providerId: 'ProviderId',
      providerName: 'ProviderName',
      state: 'State',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      channelId: 'string',
      channelName: 'string',
      consortiumId: 'string',
      createTime: 'string',
      deployTime: 'string',
      endorsePolicy: 'string',
      input: 'string',
      install: 'boolean',
      management: 'boolean',
      message: 'string',
      name: 'string',
      path: 'string',
      providerId: 'string',
      providerName: 'string',
      state: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumChannelsResponseBodyResult extends $tea.Model {
  batchTimeout?: number;
  blockCount?: number;
  chaincodeCount?: number;
  channelId?: string;
  consortiumId?: string;
  consortiumName?: string;
  createTime?: string;
  deleteTime?: string;
  deleted?: boolean;
  hybird?: boolean;
  id?: number;
  maxMessageCount?: number;
  memberCount?: number;
  memberJoinedCount?: string;
  name?: string;
  needJoined?: boolean;
  ownerBid?: string;
  ownerName?: string;
  ownerUid?: number;
  preferredMaxBytes?: number;
  requestId?: string;
  state?: string;
  supportChannelConfig?: boolean;
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      batchTimeout: 'BatchTimeout',
      blockCount: 'BlockCount',
      chaincodeCount: 'ChaincodeCount',
      channelId: 'ChannelId',
      consortiumId: 'ConsortiumId',
      consortiumName: 'ConsortiumName',
      createTime: 'CreateTime',
      deleteTime: 'DeleteTime',
      deleted: 'Deleted',
      hybird: 'Hybird',
      id: 'Id',
      maxMessageCount: 'MaxMessageCount',
      memberCount: 'MemberCount',
      memberJoinedCount: 'MemberJoinedCount',
      name: 'Name',
      needJoined: 'NeedJoined',
      ownerBid: 'OwnerBid',
      ownerName: 'OwnerName',
      ownerUid: 'OwnerUid',
      preferredMaxBytes: 'PreferredMaxBytes',
      requestId: 'RequestId',
      state: 'State',
      supportChannelConfig: 'SupportChannelConfig',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchTimeout: 'number',
      blockCount: 'number',
      chaincodeCount: 'number',
      channelId: 'string',
      consortiumId: 'string',
      consortiumName: 'string',
      createTime: 'string',
      deleteTime: 'string',
      deleted: 'boolean',
      hybird: 'boolean',
      id: 'number',
      maxMessageCount: 'number',
      memberCount: 'number',
      memberJoinedCount: 'string',
      name: 'string',
      needJoined: 'boolean',
      ownerBid: 'string',
      ownerName: 'string',
      ownerUid: 'number',
      preferredMaxBytes: 'number',
      requestId: 'string',
      state: 'string',
      supportChannelConfig: 'boolean',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumConfigResponseBodyResult extends $tea.Model {
  channelPolicy?: string[];
  ordererType?: string[];
  static names(): { [key: string]: string } {
    return {
      channelPolicy: 'ChannelPolicy',
      ordererType: 'OrdererType',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelPolicy: { 'type': 'array', 'itemType': 'string' },
      ordererType: { 'type': 'array', 'itemType': 'string' },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumDeletableResponseBodyResult extends $tea.Model {
  codeName?: string;
  consortiumId?: string;
  deletable?: boolean;
  description?: string;
  domain?: string;
  name?: string;
  regionId?: string;
  state?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      codeName: 'CodeName',
      consortiumId: 'ConsortiumId',
      deletable: 'Deletable',
      description: 'Description',
      domain: 'Domain',
      name: 'Name',
      regionId: 'RegionId',
      state: 'State',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeName: 'string',
      consortiumId: 'string',
      deletable: 'boolean',
      description: 'string',
      domain: 'string',
      name: 'string',
      regionId: 'string',
      state: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumMemberApprovalResponseBodyResult extends $tea.Model {
  channelCreatePolicy?: string;
  confirmTime?: string;
  consortiumId?: string;
  consortiumName?: string;
  domainName?: string;
  organizationId?: string;
  organizationName?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      channelCreatePolicy: 'ChannelCreatePolicy',
      confirmTime: 'ConfirmTime',
      consortiumId: 'ConsortiumId',
      consortiumName: 'ConsortiumName',
      domainName: 'DomainName',
      organizationId: 'OrganizationId',
      organizationName: 'OrganizationName',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelCreatePolicy: 'string',
      confirmTime: 'string',
      consortiumId: 'string',
      consortiumName: 'string',
      domainName: 'string',
      organizationId: 'string',
      organizationName: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumMembersResponseBodyResult extends $tea.Model {
  consortiumId?: string;
  description?: string;
  domain?: string;
  joinedTime?: string;
  name?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      description: 'Description',
      domain: 'Domain',
      joinedTime: 'JoinedTime',
      name: 'Name',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      description: 'string',
      domain: 'string',
      joinedTime: 'string',
      name: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumOrderersResponseBodyResult extends $tea.Model {
  createTime?: string;
  domain?: string;
  instanceType?: string;
  name?: string;
  port?: number;
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      domain: 'Domain',
      instanceType: 'InstanceType',
      name: 'Name',
      port: 'Port',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      domain: 'string',
      instanceType: 'string',
      name: 'string',
      port: 'number',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumSpecsResponseBodyResult extends $tea.Model {
  enable?: boolean;
  name?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      name: 'Name',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      name: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumsResponseBodyResultTags extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeConsortiumsResponseBodyResult extends $tea.Model {
  CAName?: string;
  CAUrl?: string;
  channelCount?: number;
  channelPolicy?: string;
  codeName?: string;
  consortiumId?: string;
  createTime?: string;
  domain?: string;
  expireState?: string;
  expiredTime?: string;
  hybrid?: boolean;
  MSP?: string;
  majorVersion?: string;
  name?: string;
  ordererCount?: number;
  organizationCount?: number;
  ownerBid?: string;
  ownerName?: string;
  ownerUid?: number;
  regionId?: string;
  requestId?: string;
  specName?: string;
  state?: string;
  supportChannelConfig?: boolean;
  tags?: DescribeConsortiumsResponseBodyResultTags[];
  static names(): { [key: string]: string } {
    return {
      CAName: 'CAName',
      CAUrl: 'CAUrl',
      channelCount: 'ChannelCount',
      channelPolicy: 'ChannelPolicy',
      codeName: 'CodeName',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      domain: 'Domain',
      expireState: 'ExpireState',
      expiredTime: 'ExpiredTime',
      hybrid: 'Hybrid',
      MSP: 'MSP',
      majorVersion: 'MajorVersion',
      name: 'Name',
      ordererCount: 'OrdererCount',
      organizationCount: 'OrganizationCount',
      ownerBid: 'OwnerBid',
      ownerName: 'OwnerName',
      ownerUid: 'OwnerUid',
      regionId: 'RegionId',
      requestId: 'RequestId',
      specName: 'SpecName',
      state: 'State',
      supportChannelConfig: 'SupportChannelConfig',
      tags: 'Tags',
    };
  }

  static types(): { [key: string]: any } {
    return {
      CAName: 'string',
      CAUrl: 'string',
      channelCount: 'number',
      channelPolicy: 'string',
      codeName: 'string',
      consortiumId: 'string',
      createTime: 'string',
      domain: 'string',
      expireState: 'string',
      expiredTime: 'string',
      hybrid: 'boolean',
      MSP: 'string',
      majorVersion: 'string',
      name: 'string',
      ordererCount: 'number',
      organizationCount: 'number',
      ownerBid: 'string',
      ownerName: 'string',
      ownerUid: 'number',
      regionId: 'string',
      requestId: 'string',
      specName: 'string',
      state: 'string',
      supportChannelConfig: 'boolean',
      tags: { 'type': 'array', 'itemType': DescribeConsortiumsResponseBodyResultTags },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDownloadPathsResponseBodyResult extends $tea.Model {
  bizviewUrl?: string;
  certUrl?: string;
  sdkUrl?: string;
  static names(): { [key: string]: string } {
    return {
      bizviewUrl: 'BizviewUrl',
      certUrl: 'CertUrl',
      sdkUrl: 'SdkUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizviewUrl: 'string',
      certUrl: 'string',
      sdkUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDownloadPathsOfContractChainResponseBodyResult extends $tea.Model {
  caUrl?: string;
  certUrl?: string;
  trustCaUrl?: string;
  static names(): { [key: string]: string } {
    return {
      caUrl: 'CaUrl',
      certUrl: 'CertUrl',
      trustCaUrl: 'TrustCaUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caUrl: 'string',
      certUrl: 'string',
      trustCaUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeDownloadPathsOfNotaryChainResponseBodyResult extends $tea.Model {
  bizviewUrl?: string;
  certUrl?: string;
  sdkUrl?: string;
  static names(): { [key: string]: string } {
    return {
      bizviewUrl: 'BizviewUrl',
      certUrl: 'CertUrl',
      sdkUrl: 'SdkUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizviewUrl: 'string',
      certUrl: 'string',
      sdkUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEcosphereSpecsResponseBodyResult extends $tea.Model {
  enable?: boolean;
  name?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      name: 'Name',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      name: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumResponseBodyResult extends $tea.Model {
  consensus?: string;
  creator?: string;
  description?: string;
  id?: string;
  name?: string;
  networkId?: string;
  regionId?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      consensus: 'Consensus',
      creator: 'Creator',
      description: 'Description',
      id: 'Id',
      name: 'Name',
      networkId: 'NetworkId',
      regionId: 'RegionId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consensus: 'string',
      creator: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
      networkId: 'string',
      regionId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumClientUsersResponseBodyResult extends $tea.Model {
  username?: string;
  static names(): { [key: string]: string } {
    return {
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumDeletableResponseBodyResult extends $tea.Model {
  deletable?: boolean;
  ethereumId?: string;
  static names(): { [key: string]: string } {
    return {
      deletable: 'Deletable',
      ethereumId: 'EthereumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deletable: 'boolean',
      ethereumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumInvitaionResponseBodyResult extends $tea.Model {
  consensus?: string;
  createTime?: string;
  creator?: string;
  description?: string;
  id?: string;
  name?: string;
  networkId?: string;
  regionId?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      consensus: 'Consensus',
      createTime: 'CreateTime',
      creator: 'Creator',
      description: 'Description',
      id: 'Id',
      name: 'Name',
      networkId: 'NetworkId',
      regionId: 'RegionId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consensus: 'string',
      createTime: 'string',
      creator: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
      networkId: 'string',
      regionId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumInviteeResponseBodyResult extends $tea.Model {
  createTime?: string;
  creator?: string;
  description?: string;
  ethereumId?: string;
  ethereumName?: string;
  id?: string;
  networkId?: number;
  nodeName?: string;
  publicIp?: string;
  regionId?: string;
  rpcPort?: string;
  state?: string;
  wsPort?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      creator: 'Creator',
      description: 'Description',
      ethereumId: 'EthereumId',
      ethereumName: 'EthereumName',
      id: 'Id',
      networkId: 'NetworkId',
      nodeName: 'NodeName',
      publicIp: 'PublicIp',
      regionId: 'RegionId',
      rpcPort: 'RpcPort',
      state: 'State',
      wsPort: 'WsPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      creator: 'string',
      description: 'string',
      ethereumId: 'string',
      ethereumName: 'string',
      id: 'string',
      networkId: 'number',
      nodeName: 'string',
      publicIp: 'string',
      regionId: 'string',
      rpcPort: 'string',
      state: 'string',
      wsPort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeResponseBodyResult extends $tea.Model {
  createTime?: number;
  creator?: string;
  description?: string;
  ethereumId?: string;
  ethereumName?: string;
  id?: string;
  networkId?: string;
  nodeName?: string;
  publicIp?: string;
  regionId?: string;
  rpcPort?: number;
  state?: string;
  wsPort?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      creator: 'Creator',
      description: 'Description',
      ethereumId: 'EthereumId',
      ethereumName: 'EthereumName',
      id: 'Id',
      networkId: 'NetworkId',
      nodeName: 'NodeName',
      publicIp: 'PublicIp',
      regionId: 'RegionId',
      rpcPort: 'RpcPort',
      state: 'State',
      wsPort: 'WsPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creator: 'string',
      description: 'string',
      ethereumId: 'string',
      ethereumName: 'string',
      id: 'string',
      networkId: 'string',
      nodeName: 'string',
      publicIp: 'string',
      regionId: 'string',
      rpcPort: 'number',
      state: 'string',
      wsPort: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodeConfigurationResponseBodyResult extends $tea.Model {
  genesisJson?: string;
  IP?: string;
  nodePub?: string;
  p2pPort?: number;
  permissionedNodesJson?: string;
  raftPort?: number;
  rpcPort?: number;
  staticNodesJson?: string;
  TMJson?: string;
  TMPort?: number;
  TMPub?: string;
  WSPort?: number;
  static names(): { [key: string]: string } {
    return {
      genesisJson: 'GenesisJson',
      IP: 'IP',
      nodePub: 'NodePub',
      p2pPort: 'P2pPort',
      permissionedNodesJson: 'PermissionedNodesJson',
      raftPort: 'RaftPort',
      rpcPort: 'RpcPort',
      staticNodesJson: 'StaticNodesJson',
      TMJson: 'TMJson',
      TMPort: 'TMPort',
      TMPub: 'TMPub',
      WSPort: 'WSPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      genesisJson: 'string',
      IP: 'string',
      nodePub: 'string',
      p2pPort: 'number',
      permissionedNodesJson: 'string',
      raftPort: 'number',
      rpcPort: 'number',
      staticNodesJson: 'string',
      TMJson: 'string',
      TMPort: 'number',
      TMPub: 'string',
      WSPort: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumNodesResponseBodyResult extends $tea.Model {
  consensus?: string;
  createTime?: string;
  creator?: string;
  description?: string;
  ethereumId?: string;
  ethereumName?: string;
  external?: boolean;
  id?: string;
  networkId?: number;
  nodeName?: string;
  publicIp?: string;
  regionId?: string;
  rpcPort?: string;
  state?: string;
  validator?: boolean;
  wsPort?: string;
  static names(): { [key: string]: string } {
    return {
      consensus: 'Consensus',
      createTime: 'CreateTime',
      creator: 'Creator',
      description: 'Description',
      ethereumId: 'EthereumId',
      ethereumName: 'EthereumName',
      external: 'External',
      id: 'Id',
      networkId: 'NetworkId',
      nodeName: 'NodeName',
      publicIp: 'PublicIp',
      regionId: 'RegionId',
      rpcPort: 'RpcPort',
      state: 'State',
      validator: 'Validator',
      wsPort: 'WsPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consensus: 'string',
      createTime: 'string',
      creator: 'string',
      description: 'string',
      ethereumId: 'string',
      ethereumName: 'string',
      external: 'boolean',
      id: 'string',
      networkId: 'number',
      nodeName: 'string',
      publicIp: 'string',
      regionId: 'string',
      rpcPort: 'string',
      state: 'string',
      validator: 'boolean',
      wsPort: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeEthereumsResponseBodyResult extends $tea.Model {
  consensus?: string;
  createTime?: number;
  creator?: string;
  deletable?: boolean;
  description?: string;
  id?: string;
  name?: string;
  networkId?: string;
  nodeNumber?: number;
  regionId?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      consensus: 'Consensus',
      createTime: 'CreateTime',
      creator: 'Creator',
      deletable: 'Deletable',
      description: 'Description',
      id: 'Id',
      name: 'Name',
      networkId: 'NetworkId',
      nodeNumber: 'NodeNumber',
      regionId: 'RegionId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consensus: 'string',
      createTime: 'number',
      creator: 'string',
      deletable: 'boolean',
      description: 'string',
      id: 'string',
      name: 'string',
      networkId: 'string',
      nodeNumber: 'number',
      regionId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelConfigResponseBodyResult extends $tea.Model {
  absoluteMaxBytes?: number;
  batchTimeout?: string;
  maxMessageCount?: number;
  preferredMaxBytes?: number;
  static names(): { [key: string]: string } {
    return {
      absoluteMaxBytes: 'AbsoluteMaxBytes',
      batchTimeout: 'BatchTimeout',
      maxMessageCount: 'MaxMessageCount',
      preferredMaxBytes: 'PreferredMaxBytes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      absoluteMaxBytes: 'number',
      batchTimeout: 'string',
      maxMessageCount: 'number',
      preferredMaxBytes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelOrdererResponseBodyResult extends $tea.Model {
  address?: string;
  certificate?: string;
  key?: string;
  tlsroot?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      certificate: 'Certificate',
      key: 'Key',
      tlsroot: 'Tlsroot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      certificate: 'string',
      key: 'string',
      tlsroot: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelOrganizationsResponseBodyResultAnchorPeers extends $tea.Model {
  host?: string;
  port?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelOrganizationsResponseBodyResultOrdererNodes extends $tea.Model {
  address?: string;
  certificate?: string;
  key?: string;
  tlsroot?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      certificate: 'Certificate',
      key: 'Key',
      tlsroot: 'Tlsroot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      certificate: 'string',
      key: 'string',
      tlsroot: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricChannelOrganizationsResponseBodyResult extends $tea.Model {
  anchorPeers?: DescribeFabricChannelOrganizationsResponseBodyResultAnchorPeers[];
  crls?: string;
  mspId?: string;
  mspType?: string;
  orderer?: boolean;
  ordererNodes?: DescribeFabricChannelOrganizationsResponseBodyResultOrdererNodes[];
  rootCertificates?: string;
  tlsRootCertificates?: string;
  static names(): { [key: string]: string } {
    return {
      anchorPeers: 'AnchorPeers',
      crls: 'Crls',
      mspId: 'MspId',
      mspType: 'MspType',
      orderer: 'Orderer',
      ordererNodes: 'OrdererNodes',
      rootCertificates: 'RootCertificates',
      tlsRootCertificates: 'TlsRootCertificates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorPeers: { 'type': 'array', 'itemType': DescribeFabricChannelOrganizationsResponseBodyResultAnchorPeers },
      crls: 'string',
      mspId: 'string',
      mspType: 'string',
      orderer: 'boolean',
      ordererNodes: { 'type': 'array', 'itemType': DescribeFabricChannelOrganizationsResponseBodyResultOrdererNodes },
      rootCertificates: 'string',
      tlsRootCertificates: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeFabricManagementChaincodesResponseBodyResult extends $tea.Model {
  input?: string;
  name?: string;
  path?: number;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      input: 'Input',
      name: 'Name',
      path: 'Path',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      input: 'string',
      name: 'string',
      path: 'number',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers extends $tea.Model {
  host?: string;
  port?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes extends $tea.Model {
  address?: string;
  certificate?: string;
  key?: string;
  tlsroot?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      certificate: 'Certificate',
      key: 'Key',
      tlsroot: 'Tlsroot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      certificate: 'string',
      key: 'string',
      tlsroot: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskResponseBodyResultContentAddedOrganizations extends $tea.Model {
  anchorPeers?: DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers[];
  crls?: string;
  mspId?: string;
  mspType?: string;
  orderer?: boolean;
  ordererNodes?: DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes[];
  rootCertificates?: string;
  tlsRootCertificates?: string;
  static names(): { [key: string]: string } {
    return {
      anchorPeers: 'AnchorPeers',
      crls: 'Crls',
      mspId: 'MspId',
      mspType: 'MspType',
      orderer: 'Orderer',
      ordererNodes: 'OrdererNodes',
      rootCertificates: 'RootCertificates',
      tlsRootCertificates: 'TlsRootCertificates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorPeers: { 'type': 'array', 'itemType': DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers },
      crls: 'string',
      mspId: 'string',
      mspType: 'string',
      orderer: 'boolean',
      ordererNodes: { 'type': 'array', 'itemType': DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes },
      rootCertificates: 'string',
      tlsRootCertificates: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs extends $tea.Model {
  input?: string;
  name?: string;
  path?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      input: 'Input',
      name: 'Name',
      path: 'Path',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      input: 'string',
      name: 'string',
      path: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkg extends $tea.Model {
  cs?: DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs;
  policy?: string;
  sha256?: string;
  static names(): { [key: string]: string } {
    return {
      cs: 'Cs',
      policy: 'Policy',
      sha256: 'Sha256',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cs: DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs,
      policy: 'string',
      sha256: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskResponseBodyResultContentOrdererConfig extends $tea.Model {
  batchTimeout?: string;
  maxMessageCount?: number;
  preferredMaxBytes?: number;
  static names(): { [key: string]: string } {
    return {
      batchTimeout: 'BatchTimeout',
      maxMessageCount: 'MaxMessageCount',
      preferredMaxBytes: 'PreferredMaxBytes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchTimeout: 'string',
      maxMessageCount: 'number',
      preferredMaxBytes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers extends $tea.Model {
  host?: string;
  port?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes extends $tea.Model {
  address?: string;
  certificate?: string;
  key?: string;
  tlsroot?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      certificate: 'Certificate',
      key: 'Key',
      tlsroot: 'Tlsroot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      certificate: 'string',
      key: 'string',
      tlsroot: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizations extends $tea.Model {
  anchorPeers?: DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers[];
  crls?: string;
  mspId?: string;
  mspType?: string;
  orderer?: boolean;
  ordererNodes?: DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes[];
  rootCertificates?: string;
  tlsRootCertificates?: string;
  static names(): { [key: string]: string } {
    return {
      anchorPeers: 'AnchorPeers',
      crls: 'Crls',
      mspId: 'MspId',
      mspType: 'MspType',
      orderer: 'Orderer',
      ordererNodes: 'OrdererNodes',
      rootCertificates: 'RootCertificates',
      tlsRootCertificates: 'TlsRootCertificates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorPeers: { 'type': 'array', 'itemType': DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers },
      crls: 'string',
      mspId: 'string',
      mspType: 'string',
      orderer: 'boolean',
      ordererNodes: { 'type': 'array', 'itemType': DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes },
      rootCertificates: 'string',
      tlsRootCertificates: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskResponseBodyResultContent extends $tea.Model {
  addedOrganizations?: DescribeGovernanceTaskResponseBodyResultContentAddedOrganizations[];
  chaincodeSpecPkg?: DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkg;
  ordererConfig?: DescribeGovernanceTaskResponseBodyResultContentOrdererConfig;
  raw?: string;
  removedOrganizations?: DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizations[];
  rwSets?: string;
  static names(): { [key: string]: string } {
    return {
      addedOrganizations: 'AddedOrganizations',
      chaincodeSpecPkg: 'ChaincodeSpecPkg',
      ordererConfig: 'OrdererConfig',
      raw: 'Raw',
      removedOrganizations: 'RemovedOrganizations',
      rwSets: 'RwSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addedOrganizations: { 'type': 'array', 'itemType': DescribeGovernanceTaskResponseBodyResultContentAddedOrganizations },
      chaincodeSpecPkg: DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkg,
      ordererConfig: DescribeGovernanceTaskResponseBodyResultContentOrdererConfig,
      raw: 'string',
      removedOrganizations: { 'type': 'array', 'itemType': DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizations },
      rwSets: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTaskResponseBodyResult extends $tea.Model {
  channelName?: string;
  content?: DescribeGovernanceTaskResponseBodyResultContent;
  createTime?: number;
  creator?: string;
  description?: string;
  status?: string;
  taskId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      channelName: 'ChannelName',
      content: 'Content',
      createTime: 'CreateTime',
      creator: 'Creator',
      description: 'Description',
      status: 'Status',
      taskId: 'TaskId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelName: 'string',
      content: DescribeGovernanceTaskResponseBodyResultContent,
      createTime: 'number',
      creator: 'string',
      description: 'string',
      status: 'string',
      taskId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsAnchorPeers extends $tea.Model {
  host?: string;
  port?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsOrdererNodes extends $tea.Model {
  address?: string;
  certificate?: string;
  key?: string;
  tlsroot?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      certificate: 'Certificate',
      key: 'Key',
      tlsroot: 'Tlsroot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      certificate: 'string',
      key: 'string',
      tlsroot: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksResponseBodyResultContentAddedOrganizations extends $tea.Model {
  anchorPeers?: DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsAnchorPeers[];
  crls?: string;
  mspId?: string;
  mspType?: string;
  orderer?: boolean;
  ordererNodes?: DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsOrdererNodes[];
  rootCertificates?: string;
  tlsRootCertificates?: string;
  static names(): { [key: string]: string } {
    return {
      anchorPeers: 'AnchorPeers',
      crls: 'Crls',
      mspId: 'MspId',
      mspType: 'MspType',
      orderer: 'Orderer',
      ordererNodes: 'OrdererNodes',
      rootCertificates: 'RootCertificates',
      tlsRootCertificates: 'TlsRootCertificates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorPeers: { 'type': 'array', 'itemType': DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsAnchorPeers },
      crls: 'string',
      mspId: 'string',
      mspType: 'string',
      orderer: 'boolean',
      ordererNodes: { 'type': 'array', 'itemType': DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsOrdererNodes },
      rootCertificates: 'string',
      tlsRootCertificates: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkgCs extends $tea.Model {
  input?: string;
  name?: string;
  path?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      input: 'Input',
      name: 'Name',
      path: 'Path',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      input: 'string',
      name: 'string',
      path: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkg extends $tea.Model {
  cs?: DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkgCs;
  policy?: string;
  sha256?: string;
  static names(): { [key: string]: string } {
    return {
      cs: 'Cs',
      policy: 'Policy',
      sha256: 'Sha256',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cs: DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkgCs,
      policy: 'string',
      sha256: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksResponseBodyResultContentOrdererConfig extends $tea.Model {
  batchTimeout?: string;
  maxMessageCount?: number;
  preferredMaxBytes?: number;
  static names(): { [key: string]: string } {
    return {
      batchTimeout: 'BatchTimeout',
      maxMessageCount: 'MaxMessageCount',
      preferredMaxBytes: 'PreferredMaxBytes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchTimeout: 'string',
      maxMessageCount: 'number',
      preferredMaxBytes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsAnchorPeers extends $tea.Model {
  host?: string;
  port?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsOrdererNodes extends $tea.Model {
  address?: string;
  certificate?: string;
  key?: string;
  tlsroot?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      certificate: 'Certificate',
      key: 'Key',
      tlsroot: 'Tlsroot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      certificate: 'string',
      key: 'string',
      tlsroot: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizations extends $tea.Model {
  anchorPeers?: DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsAnchorPeers[];
  crls?: string;
  mspId?: string;
  mspType?: string;
  orderer?: boolean;
  ordererNodes?: DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsOrdererNodes[];
  rootCertificates?: string;
  tlsRootCertificates?: string;
  static names(): { [key: string]: string } {
    return {
      anchorPeers: 'AnchorPeers',
      crls: 'Crls',
      mspId: 'MspId',
      mspType: 'MspType',
      orderer: 'Orderer',
      ordererNodes: 'OrdererNodes',
      rootCertificates: 'RootCertificates',
      tlsRootCertificates: 'TlsRootCertificates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorPeers: { 'type': 'array', 'itemType': DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsAnchorPeers },
      crls: 'string',
      mspId: 'string',
      mspType: 'string',
      orderer: 'boolean',
      ordererNodes: { 'type': 'array', 'itemType': DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsOrdererNodes },
      rootCertificates: 'string',
      tlsRootCertificates: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksResponseBodyResultContent extends $tea.Model {
  addedOrganizations?: DescribeGovernanceTasksResponseBodyResultContentAddedOrganizations[];
  chaincodeSpecPkg?: DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkg;
  ordererConfig?: DescribeGovernanceTasksResponseBodyResultContentOrdererConfig;
  raw?: string;
  removedOrganizations?: DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizations[];
  rwSets?: string;
  static names(): { [key: string]: string } {
    return {
      addedOrganizations: 'AddedOrganizations',
      chaincodeSpecPkg: 'ChaincodeSpecPkg',
      ordererConfig: 'OrdererConfig',
      raw: 'Raw',
      removedOrganizations: 'RemovedOrganizations',
      rwSets: 'RwSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addedOrganizations: { 'type': 'array', 'itemType': DescribeGovernanceTasksResponseBodyResultContentAddedOrganizations },
      chaincodeSpecPkg: DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkg,
      ordererConfig: DescribeGovernanceTasksResponseBodyResultContentOrdererConfig,
      raw: 'string',
      removedOrganizations: { 'type': 'array', 'itemType': DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizations },
      rwSets: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeGovernanceTasksResponseBodyResult extends $tea.Model {
  channelName?: string;
  content?: DescribeGovernanceTasksResponseBodyResultContent;
  createTime?: number;
  creator?: string;
  description?: string;
  status?: string;
  taskId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      channelName: 'ChannelName',
      content: 'Content',
      createTime: 'CreateTime',
      creator: 'Creator',
      description: 'Description',
      status: 'Status',
      taskId: 'TaskId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelName: 'string',
      content: DescribeGovernanceTasksResponseBodyResultContent,
      createTime: 'number',
      creator: 'string',
      description: 'string',
      status: 'string',
      taskId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvitationCodeResponseBodyResult extends $tea.Model {
  accepted?: boolean;
  code?: string;
  consortiumId?: string;
  email?: string;
  expireTime?: string;
  id?: number;
  sendTime?: string;
  senderBid?: string;
  senderId?: number;
  senderName?: string;
  url?: string;
  static names(): { [key: string]: string } {
    return {
      accepted: 'Accepted',
      code: 'Code',
      consortiumId: 'ConsortiumId',
      email: 'Email',
      expireTime: 'ExpireTime',
      id: 'Id',
      sendTime: 'SendTime',
      senderBid: 'SenderBid',
      senderId: 'SenderId',
      senderName: 'SenderName',
      url: 'Url',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accepted: 'boolean',
      code: 'string',
      consortiumId: 'string',
      email: 'string',
      expireTime: 'string',
      id: 'number',
      sendTime: 'string',
      senderBid: 'string',
      senderId: 'number',
      senderName: 'string',
      url: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInvitationListResponseBodyResult extends $tea.Model {
  code?: string;
  consortiumId?: string;
  email?: string;
  expireTime?: string;
  sendTime?: string;
  static names(): { [key: string]: string } {
    return {
      code: 'Code',
      consortiumId: 'ConsortiumId',
      email: 'Email',
      expireTime: 'ExpireTime',
      sendTime: 'SendTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      code: 'string',
      consortiumId: 'string',
      email: 'string',
      expireTime: 'string',
      sendTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeInviterResponseBodyResult extends $tea.Model {
  consortiumId?: string;
  consortiumName?: string;
  expireTime?: string;
  inviterId?: number;
  inviterName?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      consortiumName: 'ConsortiumName',
      expireTime: 'ExpireTime',
      inviterId: 'InviterId',
      inviterName: 'InviterName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      consortiumName: 'string',
      expireTime: 'string',
      inviterId: 'number',
      inviterName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMemberRoleResponseBodyResult extends $tea.Model {
  role?: number;
  static names(): { [key: string]: string } {
    return {
      role: 'Role',
    };
  }

  static types(): { [key: string]: any } {
    return {
      role: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMembersResponseBodyResultPagination extends $tea.Model {
  current?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'Current',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMembersResponseBodyResult extends $tea.Model {
  memberList?: string[];
  pagination?: DescribeMembersResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      memberList: 'MemberList',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      memberList: { 'type': 'array', 'itemType': 'string' },
      pagination: DescribeMembersResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMyBlockchainsResponseBodyResult extends $tea.Model {
  bizid?: string;
  createtime?: number;
  id?: number;
  rejectReason?: string;
  reqAddr?: string;
  signedAddr?: string;
  status?: number;
  updatetime?: number;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      createtime: 'Createtime',
      id: 'Id',
      rejectReason: 'RejectReason',
      reqAddr: 'ReqAddr',
      signedAddr: 'SignedAddr',
      status: 'Status',
      updatetime: 'Updatetime',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      createtime: 'number',
      id: 'number',
      rejectReason: 'string',
      reqAddr: 'string',
      signedAddr: 'string',
      status: 'number',
      updatetime: 'number',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMyBlockchanInfosResponseBodyResultNodeInfoList extends $tea.Model {
  blockHeight?: number;
  nodeName?: string;
  status?: boolean;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      blockHeight: 'BlockHeight',
      nodeName: 'NodeName',
      status: 'Status',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockHeight: 'number',
      nodeName: 'string',
      status: 'boolean',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMyBlockchanInfosResponseBodyResult extends $tea.Model {
  abnormalNodes?: number;
  bizid?: string;
  blockHeight?: number;
  createTime?: number;
  isRole?: boolean;
  name?: string;
  nodeInfoList?: DescribeMyBlockchanInfosResponseBodyResultNodeInfoList[];
  nodeNumber?: number;
  normal?: boolean;
  transactionSum?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      abnormalNodes: 'AbnormalNodes',
      bizid: 'Bizid',
      blockHeight: 'BlockHeight',
      createTime: 'CreateTime',
      isRole: 'IsRole',
      name: 'Name',
      nodeInfoList: 'NodeInfoList',
      nodeNumber: 'NodeNumber',
      normal: 'Normal',
      transactionSum: 'TransactionSum',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abnormalNodes: 'number',
      bizid: 'string',
      blockHeight: 'number',
      createTime: 'number',
      isRole: 'boolean',
      name: 'string',
      nodeInfoList: { 'type': 'array', 'itemType': DescribeMyBlockchanInfosResponseBodyResultNodeInfoList },
      nodeNumber: 'number',
      normal: 'boolean',
      transactionSum: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMySuccessAppliesResponseBodyResultNodeInfoList extends $tea.Model {
  blockHeight?: number;
  nodeName?: string;
  status?: boolean;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      blockHeight: 'BlockHeight',
      nodeName: 'NodeName',
      status: 'Status',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockHeight: 'number',
      nodeName: 'string',
      status: 'boolean',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMySuccessAppliesResponseBodyResult extends $tea.Model {
  abnormalNodes?: number;
  bizid?: string;
  blockHeight?: number;
  createTime?: number;
  isRole?: boolean;
  name?: string;
  nodeInfoList?: DescribeMySuccessAppliesResponseBodyResultNodeInfoList[];
  nodeNumber?: number;
  normal?: boolean;
  transactionSum?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      abnormalNodes: 'AbnormalNodes',
      bizid: 'Bizid',
      blockHeight: 'BlockHeight',
      createTime: 'CreateTime',
      isRole: 'IsRole',
      name: 'Name',
      nodeInfoList: 'NodeInfoList',
      nodeNumber: 'NodeNumber',
      normal: 'Normal',
      transactionSum: 'TransactionSum',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abnormalNodes: 'number',
      bizid: 'string',
      blockHeight: 'number',
      createTime: 'number',
      isRole: 'boolean',
      name: 'string',
      nodeInfoList: { 'type': 'array', 'itemType': DescribeMySuccessAppliesResponseBodyResultNodeInfoList },
      nodeNumber: 'number',
      normal: 'boolean',
      transactionSum: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMySuccessfulApplicationResponseBodyResultNodeInfoList extends $tea.Model {
  blockHeight?: number;
  nodeName?: string;
  status?: boolean;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      blockHeight: 'BlockHeight',
      nodeName: 'NodeName',
      status: 'Status',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockHeight: 'number',
      nodeName: 'string',
      status: 'boolean',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeMySuccessfulApplicationResponseBodyResult extends $tea.Model {
  abnormalNodes?: number;
  bizid?: string;
  blockHeight?: number;
  createTime?: number;
  isRole?: boolean;
  name?: string;
  nodeInfoList?: DescribeMySuccessfulApplicationResponseBodyResultNodeInfoList[];
  nodeNumber?: number;
  normal?: boolean;
  transactionSum?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      abnormalNodes: 'AbnormalNodes',
      bizid: 'Bizid',
      blockHeight: 'BlockHeight',
      createTime: 'CreateTime',
      isRole: 'IsRole',
      name: 'Name',
      nodeInfoList: 'NodeInfoList',
      nodeNumber: 'NodeNumber',
      normal: 'Normal',
      transactionSum: 'TransactionSum',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abnormalNodes: 'number',
      bizid: 'string',
      blockHeight: 'number',
      createTime: 'number',
      isRole: 'boolean',
      name: 'string',
      nodeInfoList: { 'type': 'array', 'itemType': DescribeMySuccessfulApplicationResponseBodyResultNodeInfoList },
      nodeNumber: 'number',
      normal: 'boolean',
      transactionSum: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationResponseBodyResultTags extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationResponseBodyResult extends $tea.Model {
  CAName?: string;
  CAUrl?: string;
  codeName?: string;
  consortiumCount?: number;
  createTime?: string;
  description?: string;
  domain?: string;
  expiredTime?: string;
  MSP?: string;
  name?: string;
  organizationId?: string;
  ownerBid?: string;
  ownerName?: string;
  ownerUid?: number;
  peerCount?: number;
  regionId?: string;
  requestId?: string;
  specName?: string;
  state?: string;
  tags?: DescribeOrganizationResponseBodyResultTags[];
  userCount?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      CAName: 'CAName',
      CAUrl: 'CAUrl',
      codeName: 'CodeName',
      consortiumCount: 'ConsortiumCount',
      createTime: 'CreateTime',
      description: 'Description',
      domain: 'Domain',
      expiredTime: 'ExpiredTime',
      MSP: 'MSP',
      name: 'Name',
      organizationId: 'OrganizationId',
      ownerBid: 'OwnerBid',
      ownerName: 'OwnerName',
      ownerUid: 'OwnerUid',
      peerCount: 'PeerCount',
      regionId: 'RegionId',
      requestId: 'RequestId',
      specName: 'SpecName',
      state: 'State',
      tags: 'Tags',
      userCount: 'UserCount',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      CAName: 'string',
      CAUrl: 'string',
      codeName: 'string',
      consortiumCount: 'number',
      createTime: 'string',
      description: 'string',
      domain: 'string',
      expiredTime: 'string',
      MSP: 'string',
      name: 'string',
      organizationId: 'string',
      ownerBid: 'string',
      ownerName: 'string',
      ownerUid: 'number',
      peerCount: 'number',
      regionId: 'string',
      requestId: 'string',
      specName: 'string',
      state: 'string',
      tags: { 'type': 'array', 'itemType': DescribeOrganizationResponseBodyResultTags },
      userCount: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationChaincodesResponseBodyResult extends $tea.Model {
  binding?: boolean;
  chaincodeId?: string;
  chaincodePackageId?: string;
  channelId?: string;
  channelName?: string;
  consortiumId?: string;
  createTime?: string;
  creator?: string;
  deployTime?: string;
  endorsePolicy?: string;
  installed?: string;
  management?: boolean;
  message?: string;
  name?: string;
  state?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      binding: 'Binding',
      chaincodeId: 'ChaincodeId',
      chaincodePackageId: 'ChaincodePackageId',
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      creator: 'Creator',
      deployTime: 'DeployTime',
      endorsePolicy: 'EndorsePolicy',
      installed: 'Installed',
      management: 'Management',
      message: 'Message',
      name: 'Name',
      state: 'State',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      binding: 'boolean',
      chaincodeId: 'string',
      chaincodePackageId: 'string',
      channelId: 'string',
      channelName: 'string',
      consortiumId: 'string',
      createTime: 'string',
      creator: 'string',
      deployTime: 'string',
      endorsePolicy: 'string',
      installed: 'string',
      management: 'boolean',
      message: 'string',
      name: 'string',
      state: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationChannelsResponseBodyResult extends $tea.Model {
  batchTimeout?: number;
  blockCount?: number;
  chaincodeCount?: number;
  channelId?: string;
  consortiumId?: string;
  consortiumName?: string;
  createTime?: string;
  deleteTime?: string;
  deleted?: boolean;
  hybird?: boolean;
  maxMessageCount?: number;
  memberCount?: number;
  name?: string;
  ownerBid?: string;
  ownerName?: string;
  ownerUid?: number;
  preferredMaxBytes?: number;
  requestId?: string;
  state?: string;
  supportChannelConfig?: boolean;
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      batchTimeout: 'BatchTimeout',
      blockCount: 'BlockCount',
      chaincodeCount: 'ChaincodeCount',
      channelId: 'ChannelId',
      consortiumId: 'ConsortiumId',
      consortiumName: 'ConsortiumName',
      createTime: 'CreateTime',
      deleteTime: 'DeleteTime',
      deleted: 'Deleted',
      hybird: 'Hybird',
      maxMessageCount: 'MaxMessageCount',
      memberCount: 'MemberCount',
      name: 'Name',
      ownerBid: 'OwnerBid',
      ownerName: 'OwnerName',
      ownerUid: 'OwnerUid',
      preferredMaxBytes: 'PreferredMaxBytes',
      requestId: 'RequestId',
      state: 'State',
      supportChannelConfig: 'SupportChannelConfig',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchTimeout: 'number',
      blockCount: 'number',
      chaincodeCount: 'number',
      channelId: 'string',
      consortiumId: 'string',
      consortiumName: 'string',
      createTime: 'string',
      deleteTime: 'string',
      deleted: 'boolean',
      hybird: 'boolean',
      maxMessageCount: 'number',
      memberCount: 'number',
      name: 'string',
      ownerBid: 'string',
      ownerName: 'string',
      ownerUid: 'number',
      preferredMaxBytes: 'number',
      requestId: 'string',
      state: 'string',
      supportChannelConfig: 'boolean',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationDeletableResponseBodyResult extends $tea.Model {
  codeName?: string;
  deletable?: boolean;
  description?: string;
  domain?: string;
  name?: string;
  organizationId?: string;
  regionId?: string;
  state?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      codeName: 'CodeName',
      deletable: 'Deletable',
      description: 'Description',
      domain: 'Domain',
      name: 'Name',
      organizationId: 'OrganizationId',
      regionId: 'RegionId',
      state: 'State',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeName: 'string',
      deletable: 'boolean',
      description: 'string',
      domain: 'string',
      name: 'string',
      organizationId: 'string',
      regionId: 'string',
      state: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationMembersResponseBodyResult extends $tea.Model {
  consortiumId?: string;
  consortiumName?: string;
  description?: string;
  domain?: string;
  id?: string;
  joinedTime?: string;
  name?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      consortiumName: 'ConsortiumName',
      description: 'Description',
      domain: 'Domain',
      id: 'Id',
      joinedTime: 'JoinedTime',
      name: 'Name',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      consortiumName: 'string',
      description: 'string',
      domain: 'string',
      id: 'string',
      joinedTime: 'string',
      name: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationPeersResponseBodyResult extends $tea.Model {
  createTime?: string;
  domain?: string;
  instanceType?: string;
  internetIp?: string;
  intranetIp?: string;
  isAnchor?: boolean;
  name?: string;
  port?: number;
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      domain: 'Domain',
      instanceType: 'InstanceType',
      internetIp: 'InternetIp',
      intranetIp: 'IntranetIp',
      isAnchor: 'IsAnchor',
      name: 'Name',
      port: 'Port',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      domain: 'string',
      instanceType: 'string',
      internetIp: 'string',
      intranetIp: 'string',
      isAnchor: 'boolean',
      name: 'string',
      port: 'number',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationSpecsResponseBodyResult extends $tea.Model {
  enable?: boolean;
  name?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      enable: 'Enable',
      name: 'Name',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      enable: 'boolean',
      name: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationTriggersResponseBodyResultCheckpoint extends $tea.Model {
  errorCount?: number;
  height?: number;
  index?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      errorCount: 'ErrorCount',
      height: 'Height',
      index: 'Index',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCount: 'number',
      height: 'number',
      index: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationTriggersResponseBodyResult extends $tea.Model {
  channelId?: string;
  channelName?: string;
  checkpoint?: DescribeOrganizationTriggersResponseBodyResultCheckpoint;
  createTime?: number;
  errorMessage?: string;
  name?: string;
  options?: string;
  source?: string;
  status?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      checkpoint: 'Checkpoint',
      createTime: 'CreateTime',
      errorMessage: 'ErrorMessage',
      name: 'Name',
      options: 'Options',
      source: 'Source',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      checkpoint: DescribeOrganizationTriggersResponseBodyResultCheckpoint,
      createTime: 'number',
      errorMessage: 'string',
      name: 'string',
      options: 'string',
      source: 'string',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationUserCertsResponseBodyResultCertificates extends $tea.Model {
  certData?: string;
  issuer?: string;
  name?: string;
  scope?: string;
  subject?: string;
  validFrom?: string;
  validTo?: string;
  static names(): { [key: string]: string } {
    return {
      certData: 'CertData',
      issuer: 'Issuer',
      name: 'Name',
      scope: 'Scope',
      subject: 'Subject',
      validFrom: 'ValidFrom',
      validTo: 'ValidTo',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certData: 'string',
      issuer: 'string',
      name: 'string',
      scope: 'string',
      subject: 'string',
      validFrom: 'string',
      validTo: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationUserCertsResponseBodyResultKeyPair extends $tea.Model {
  privateKey?: string;
  publicKey?: string;
  static names(): { [key: string]: string } {
    return {
      privateKey: 'PrivateKey',
      publicKey: 'PublicKey',
    };
  }

  static types(): { [key: string]: any } {
    return {
      privateKey: 'string',
      publicKey: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationUserCertsResponseBodyResult extends $tea.Model {
  certificates?: DescribeOrganizationUserCertsResponseBodyResultCertificates[];
  keyPair?: DescribeOrganizationUserCertsResponseBodyResultKeyPair;
  static names(): { [key: string]: string } {
    return {
      certificates: 'Certificates',
      keyPair: 'KeyPair',
    };
  }

  static types(): { [key: string]: any } {
    return {
      certificates: { 'type': 'array', 'itemType': DescribeOrganizationUserCertsResponseBodyResultCertificates },
      keyPair: DescribeOrganizationUserCertsResponseBodyResultKeyPair,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationUsersResponseBodyResult extends $tea.Model {
  attrs?: string;
  callerBid?: string;
  callerUid?: number;
  createTime?: string;
  expireTime?: string;
  fullName?: string;
  organizationId?: string;
  regionId?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      attrs: 'Attrs',
      callerBid: 'CallerBid',
      callerUid: 'CallerUid',
      createTime: 'CreateTime',
      expireTime: 'ExpireTime',
      fullName: 'FullName',
      organizationId: 'OrganizationId',
      regionId: 'RegionId',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      attrs: 'string',
      callerBid: 'string',
      callerUid: 'number',
      createTime: 'string',
      expireTime: 'string',
      fullName: 'string',
      organizationId: 'string',
      regionId: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationsRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationsResponseBodyResultTags extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrganizationsResponseBodyResult extends $tea.Model {
  codeName?: string;
  consortiumCount?: number;
  createTime?: string;
  description?: string;
  domain?: string;
  expireState?: string;
  expiredTime?: string;
  hybrid?: boolean;
  majorVersion?: string;
  name?: string;
  organizationId?: string;
  ownerBid?: string;
  ownerName?: string;
  ownerUid?: number;
  peerCount?: number;
  regionId?: string;
  requestId?: string;
  specName?: string;
  state?: string;
  tags?: DescribeOrganizationsResponseBodyResultTags[];
  userCount?: number;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      codeName: 'CodeName',
      consortiumCount: 'ConsortiumCount',
      createTime: 'CreateTime',
      description: 'Description',
      domain: 'Domain',
      expireState: 'ExpireState',
      expiredTime: 'ExpiredTime',
      hybrid: 'Hybrid',
      majorVersion: 'MajorVersion',
      name: 'Name',
      organizationId: 'OrganizationId',
      ownerBid: 'OwnerBid',
      ownerName: 'OwnerName',
      ownerUid: 'OwnerUid',
      peerCount: 'PeerCount',
      regionId: 'RegionId',
      requestId: 'RequestId',
      specName: 'SpecName',
      state: 'State',
      tags: 'Tags',
      userCount: 'UserCount',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeName: 'string',
      consortiumCount: 'number',
      createTime: 'string',
      description: 'string',
      domain: 'string',
      expireState: 'string',
      expiredTime: 'string',
      hybrid: 'boolean',
      majorVersion: 'string',
      name: 'string',
      organizationId: 'string',
      ownerBid: 'string',
      ownerName: 'string',
      ownerUid: 'number',
      peerCount: 'number',
      regionId: 'string',
      requestId: 'string',
      specName: 'string',
      state: 'string',
      tags: { 'type': 'array', 'itemType': DescribeOrganizationsResponseBodyResultTags },
      userCount: 'number',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOrgnaizationChaincodesResponseBodyResult extends $tea.Model {
  chaincodeId?: string;
  channelId?: string;
  channelName?: string;
  createTime?: string;
  creator?: string;
  deployTime?: string;
  endorsePolicy?: string;
  installed?: string;
  message?: string;
  name?: string;
  state?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      createTime: 'CreateTime',
      creator: 'Creator',
      deployTime: 'DeployTime',
      endorsePolicy: 'EndorsePolicy',
      installed: 'Installed',
      message: 'Message',
      name: 'Name',
      state: 'State',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      channelId: 'string',
      channelName: 'string',
      createTime: 'string',
      creator: 'string',
      deployTime: 'string',
      endorsePolicy: 'string',
      installed: 'string',
      message: 'string',
      name: 'string',
      state: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeOssPropertiesResponseBodyResult extends $tea.Model {
  accessKeyId?: string;
  accessKeySecret?: string;
  bucketName?: string;
  endpoint?: string;
  folderName?: string;
  static names(): { [key: string]: string } {
    return {
      accessKeyId: 'AccessKeyId',
      accessKeySecret: 'AccessKeySecret',
      bucketName: 'BucketName',
      endpoint: 'Endpoint',
      folderName: 'FolderName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKeyId: 'string',
      accessKeySecret: 'string',
      bucketName: 'string',
      endpoint: 'string',
      folderName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePublicAntChainContractProjectContentTreeResponseBodyResult extends $tea.Model {
  children?: { [key: string]: any }[];
  static names(): { [key: string]: string } {
    return {
      children: 'Children',
    };
  }

  static types(): { [key: string]: any } {
    return {
      children: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'any' } },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePublicAntChainDownloadPathsResponseBodyResult extends $tea.Model {
  caCrtUrl?: string;
  clientCrtUrl?: string;
  sdkUrl?: string;
  trustCaUrl?: string;
  static names(): { [key: string]: string } {
    return {
      caCrtUrl: 'CaCrtUrl',
      clientCrtUrl: 'ClientCrtUrl',
      sdkUrl: 'SdkUrl',
      trustCaUrl: 'TrustCaUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      caCrtUrl: 'string',
      clientCrtUrl: 'string',
      sdkUrl: 'string',
      trustCaUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribePublicCloudIDEEnvConfigsResponseBodyResult extends $tea.Model {
  bizid?: string;
  name?: string;
  trialAccount?: string;
  trialAccountPrivateKey?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      name: 'Name',
      trialAccount: 'TrialAccount',
      trialAccountPrivateKey: 'TrialAccountPrivateKey',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      name: 'string',
      trialAccount: 'string',
      trialAccountPrivateKey: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeQRCodeAccessLogResponseBodyResult extends $tea.Model {
  accessAlipayAccountCount?: number;
  accessCount?: number;
  static names(): { [key: string]: string } {
    return {
      accessAlipayAccountCount: 'AccessAlipayAccountCount',
      accessCount: 'AccessCount',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessAlipayAccountCount: 'number',
      accessCount: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeRegionsResponseBodyResult extends $tea.Model {
  id?: number;
  online?: boolean;
  regionId?: string;
  title?: string;
  static names(): { [key: string]: string } {
    return {
      id: 'Id',
      online: 'Online',
      regionId: 'RegionId',
      title: 'Title',
    };
  }

  static types(): { [key: string]: any } {
    return {
      id: 'number',
      online: 'boolean',
      regionId: 'string',
      title: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceTypeResponseBodyResult extends $tea.Model {
  cpu?: number;
  disk?: number;
  memory?: number;
  typeId?: number;
  typeName?: string;
  static names(): { [key: string]: string } {
    return {
      cpu: 'Cpu',
      disk: 'Disk',
      memory: 'Memory',
      typeId: 'TypeId',
      typeName: 'TypeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpu: 'number',
      disk: 'number',
      memory: 'number',
      typeId: 'number',
      typeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeResourceTypesResponseBodyResult extends $tea.Model {
  cpu?: number;
  disk?: number;
  memory?: number;
  typeId?: number;
  typeName?: string;
  static names(): { [key: string]: string } {
    return {
      cpu: 'Cpu',
      disk: 'Disk',
      memory: 'Memory',
      typeId: 'TypeId',
      typeName: 'TypeName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cpu: 'number',
      disk: 'number',
      memory: 'number',
      typeId: 'number',
      typeName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchemaDetailResponseBodyResultResponsesPropertiesDataSource extends $tea.Model {
  allowNull?: number;
  annotation?: string;
  field?: string;
  indexes?: number;
  key?: number;
  length?: number;
  reg?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      allowNull: 'AllowNull',
      annotation: 'Annotation',
      field: 'Field',
      indexes: 'Indexes',
      key: 'Key',
      length: 'Length',
      reg: 'Reg',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowNull: 'number',
      annotation: 'string',
      field: 'string',
      indexes: 'number',
      key: 'number',
      length: 'number',
      reg: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchemaDetailResponseBodyResultResponsesProperties extends $tea.Model {
  count?: number;
  dataSource?: DescribeSchemaDetailResponseBodyResultResponsesPropertiesDataSource[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      dataSource: 'DataSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      dataSource: { 'type': 'array', 'itemType': DescribeSchemaDetailResponseBodyResultResponsesPropertiesDataSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchemaDetailResponseBodyResultResponses extends $tea.Model {
  category?: string;
  categoryName?: string;
  description?: string;
  properties?: DescribeSchemaDetailResponseBodyResultResponsesProperties;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      categoryName: 'CategoryName',
      description: 'Description',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      categoryName: 'string',
      description: 'string',
      properties: DescribeSchemaDetailResponseBodyResultResponsesProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchemaDetailResponseBodyResultSchema extends $tea.Model {
  createTime?: number;
  description?: string;
  id?: number;
  isTemplate?: boolean;
  name?: string;
  updateTime?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      id: 'Id',
      isTemplate: 'IsTemplate',
      name: 'Name',
      updateTime: 'UpdateTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      id: 'number',
      isTemplate: 'boolean',
      name: 'string',
      updateTime: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSchemaDetailResponseBodyResult extends $tea.Model {
  responses?: DescribeSchemaDetailResponseBodyResultResponses[];
  schema?: DescribeSchemaDetailResponseBodyResultSchema;
  static names(): { [key: string]: string } {
    return {
      responses: 'Responses',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responses: { 'type': 'array', 'itemType': DescribeSchemaDetailResponseBodyResultResponses },
      schema: DescribeSchemaDetailResponseBodyResultSchema,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractJobsResponseBodyResultContent extends $tea.Model {
  createTime?: number;
  finishedTime?: number;
  jobId?: string;
  name?: string;
  sourceType?: string;
  status?: string;
  userBid?: string;
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      finishedTime: 'FinishedTime',
      jobId: 'JobId',
      name: 'Name',
      sourceType: 'SourceType',
      status: 'Status',
      userBid: 'UserBid',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      finishedTime: 'number',
      jobId: 'string',
      name: 'string',
      sourceType: 'string',
      status: 'string',
      userBid: 'string',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractJobsResponseBodyResult extends $tea.Model {
  content?: DescribeSmartContractJobsResponseBodyResultContent[];
  first?: boolean;
  last?: boolean;
  numberOfElements?: number;
  size?: number;
  totalElements?: number;
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      first: 'First',
      last: 'Last',
      numberOfElements: 'NumberOfElements',
      size: 'Size',
      totalElements: 'TotalElements',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': DescribeSmartContractJobsResponseBodyResultContent },
      first: 'boolean',
      last: 'boolean',
      numberOfElements: 'number',
      size: 'number',
      totalElements: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractJobsByNameResponseBodyResultContent extends $tea.Model {
  createTime?: number;
  finishedTime?: number;
  jobId?: string;
  name?: string;
  sourceType?: string;
  status?: string;
  userBid?: string;
  userId?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      finishedTime: 'FinishedTime',
      jobId: 'JobId',
      name: 'Name',
      sourceType: 'SourceType',
      status: 'Status',
      userBid: 'UserBid',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      finishedTime: 'number',
      jobId: 'string',
      name: 'string',
      sourceType: 'string',
      status: 'string',
      userBid: 'string',
      userId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractJobsByNameResponseBodyResult extends $tea.Model {
  content?: DescribeSmartContractJobsByNameResponseBodyResultContent[];
  first?: boolean;
  last?: boolean;
  numberOfElements?: number;
  size?: number;
  totalElements?: number;
  totalPages?: number;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      first: 'First',
      last: 'Last',
      numberOfElements: 'NumberOfElements',
      size: 'Size',
      totalElements: 'TotalElements',
      totalPages: 'TotalPages',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: { 'type': 'array', 'itemType': DescribeSmartContractJobsByNameResponseBodyResultContent },
      first: 'boolean',
      last: 'boolean',
      numberOfElements: 'number',
      size: 'number',
      totalElements: 'number',
      totalPages: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractResultContentResponseBodyResultDiagnosticsRange extends $tea.Model {
  character?: number;
  line?: number;
  static names(): { [key: string]: string } {
    return {
      character: 'Character',
      line: 'Line',
    };
  }

  static types(): { [key: string]: any } {
    return {
      character: 'number',
      line: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocationRange extends $tea.Model {
  character?: number;
  line?: number;
  static names(): { [key: string]: string } {
    return {
      character: 'Character',
      line: 'Line',
    };
  }

  static types(): { [key: string]: any } {
    return {
      character: 'number',
      line: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocation extends $tea.Model {
  range?: DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocationRange[];
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      range: 'Range',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      range: { 'type': 'array', 'itemType': DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocationRange },
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractResultContentResponseBodyResultDiagnosticsTrace extends $tea.Model {
  location?: DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocation;
  message?: string;
  static names(): { [key: string]: string } {
    return {
      location: 'Location',
      message: 'Message',
    };
  }

  static types(): { [key: string]: any } {
    return {
      location: DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocation,
      message: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractResultContentResponseBodyResultDiagnostics extends $tea.Model {
  advice?: string;
  code?: string;
  detail?: string;
  message?: string;
  range?: DescribeSmartContractResultContentResponseBodyResultDiagnosticsRange[];
  severity?: number;
  source?: string;
  trace?: DescribeSmartContractResultContentResponseBodyResultDiagnosticsTrace[];
  static names(): { [key: string]: string } {
    return {
      advice: 'Advice',
      code: 'Code',
      detail: 'Detail',
      message: 'Message',
      range: 'Range',
      severity: 'Severity',
      source: 'Source',
      trace: 'Trace',
    };
  }

  static types(): { [key: string]: any } {
    return {
      advice: 'string',
      code: 'string',
      detail: 'string',
      message: 'string',
      range: { 'type': 'array', 'itemType': DescribeSmartContractResultContentResponseBodyResultDiagnosticsRange },
      severity: 'number',
      source: 'string',
      trace: { 'type': 'array', 'itemType': DescribeSmartContractResultContentResponseBodyResultDiagnosticsTrace },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeSmartContractResultContentResponseBodyResult extends $tea.Model {
  diagnostics?: DescribeSmartContractResultContentResponseBodyResultDiagnostics[];
  uri?: string;
  static names(): { [key: string]: string } {
    return {
      diagnostics: 'Diagnostics',
      uri: 'Uri',
    };
  }

  static types(): { [key: string]: any } {
    return {
      diagnostics: { 'type': 'array', 'itemType': DescribeSmartContractResultContentResponseBodyResultDiagnostics },
      uri: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTasksResponseBodyResult extends $tea.Model {
  action?: string;
  assignee?: string;
  handled?: boolean;
  operationType?: string;
  requestTime?: number;
  responseTime?: string;
  result?: string;
  sender?: string;
  target?: string;
  taskId?: number;
  taskState?: string;
  static names(): { [key: string]: string } {
    return {
      action: 'Action',
      assignee: 'Assignee',
      handled: 'Handled',
      operationType: 'OperationType',
      requestTime: 'RequestTime',
      responseTime: 'ResponseTime',
      result: 'Result',
      sender: 'Sender',
      target: 'Target',
      taskId: 'TaskId',
      taskState: 'TaskState',
    };
  }

  static types(): { [key: string]: any } {
    return {
      action: 'string',
      assignee: 'string',
      handled: 'boolean',
      operationType: 'string',
      requestTime: 'number',
      responseTime: 'string',
      result: 'string',
      sender: 'string',
      target: 'string',
      taskId: 'number',
      taskState: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTemplatesResponseBodyResultSchemaList extends $tea.Model {
  createTime?: number;
  description?: string;
  id?: number;
  isTemplate?: number;
  name?: string;
  updateTime?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      id: 'Id',
      isTemplate: 'IsTemplate',
      name: 'Name',
      updateTime: 'UpdateTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      id: 'number',
      isTemplate: 'number',
      name: 'string',
      updateTime: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTemplatesResponseBodyResult extends $tea.Model {
  schemaList?: DescribeTemplatesResponseBodyResultSchemaList[];
  static names(): { [key: string]: string } {
    return {
      schemaList: 'SchemaList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      schemaList: { 'type': 'array', 'itemType': DescribeTemplatesResponseBodyResultSchemaList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionResponseBodyResultTransactionV10 extends $tea.Model {
  data?: string;
  extentions?: string[];
  from?: string;
  gas?: string;
  hash?: string;
  nonce?: string;
  period?: number;
  signatureList?: string[];
  timestamp?: number;
  to?: string;
  txType?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      extentions: 'Extentions',
      from: 'From',
      gas: 'Gas',
      hash: 'Hash',
      nonce: 'Nonce',
      period: 'Period',
      signatureList: 'SignatureList',
      timestamp: 'Timestamp',
      to: 'To',
      txType: 'TxType',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      extentions: { 'type': 'array', 'itemType': 'string' },
      from: 'string',
      gas: 'string',
      hash: 'string',
      nonce: 'string',
      period: 'number',
      signatureList: { 'type': 'array', 'itemType': 'string' },
      timestamp: 'number',
      to: 'string',
      txType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionResponseBodyResult extends $tea.Model {
  blockHash?: string;
  blockHeight?: number;
  blockVersion?: number;
  category?: number;
  content?: string;
  contentHash?: string;
  createTime?: number;
  hash?: string;
  keyName?: string;
  keyWrap?: string;
  nonce?: string;
  referenceCount?: number;
  referenceList?: string[];
  transTypeV6?: string;
  transactionV10?: DescribeTransactionResponseBodyResultTransactionV10;
  static names(): { [key: string]: string } {
    return {
      blockHash: 'BlockHash',
      blockHeight: 'BlockHeight',
      blockVersion: 'BlockVersion',
      category: 'Category',
      content: 'Content',
      contentHash: 'ContentHash',
      createTime: 'CreateTime',
      hash: 'Hash',
      keyName: 'KeyName',
      keyWrap: 'KeyWrap',
      nonce: 'Nonce',
      referenceCount: 'ReferenceCount',
      referenceList: 'ReferenceList',
      transTypeV6: 'TransTypeV6',
      transactionV10: 'TransactionV10',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockHash: 'string',
      blockHeight: 'number',
      blockVersion: 'number',
      category: 'number',
      content: 'string',
      contentHash: 'string',
      createTime: 'number',
      hash: 'string',
      keyName: 'string',
      keyWrap: 'string',
      nonce: 'string',
      referenceCount: 'number',
      referenceList: { 'type': 'array', 'itemType': 'string' },
      transTypeV6: 'string',
      transactionV10: DescribeTransactionResponseBodyResultTransactionV10,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionFor2CBrowserResponseBodyResultTransactionV10 extends $tea.Model {
  data?: string;
  extentions?: string[];
  from?: string;
  gas?: string;
  hash?: string;
  nonce?: string;
  period?: number;
  signatureList?: string[];
  timestamp?: number;
  to?: string;
  txType?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      extentions: 'Extentions',
      from: 'From',
      gas: 'Gas',
      hash: 'Hash',
      nonce: 'Nonce',
      period: 'Period',
      signatureList: 'SignatureList',
      timestamp: 'Timestamp',
      to: 'To',
      txType: 'TxType',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      extentions: { 'type': 'array', 'itemType': 'string' },
      from: 'string',
      gas: 'string',
      hash: 'string',
      nonce: 'string',
      period: 'number',
      signatureList: { 'type': 'array', 'itemType': 'string' },
      timestamp: 'number',
      to: 'string',
      txType: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionFor2CBrowserResponseBodyResult extends $tea.Model {
  blockHash?: string;
  blockHeight?: number;
  blockVersion?: number;
  category?: number;
  content?: string;
  contentHash?: string;
  createTime?: number;
  hash?: string;
  keyName?: string;
  keyWrap?: string;
  nonce?: string;
  referenceCount?: number;
  referenceList?: string[];
  transTypeV6?: string;
  transactionV10?: DescribeTransactionFor2CBrowserResponseBodyResultTransactionV10;
  static names(): { [key: string]: string } {
    return {
      blockHash: 'BlockHash',
      blockHeight: 'BlockHeight',
      blockVersion: 'BlockVersion',
      category: 'Category',
      content: 'Content',
      contentHash: 'ContentHash',
      createTime: 'CreateTime',
      hash: 'Hash',
      keyName: 'KeyName',
      keyWrap: 'KeyWrap',
      nonce: 'Nonce',
      referenceCount: 'ReferenceCount',
      referenceList: 'ReferenceList',
      transTypeV6: 'TransTypeV6',
      transactionV10: 'TransactionV10',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockHash: 'string',
      blockHeight: 'number',
      blockVersion: 'number',
      category: 'number',
      content: 'string',
      contentHash: 'string',
      createTime: 'number',
      hash: 'string',
      keyName: 'string',
      keyWrap: 'string',
      nonce: 'string',
      referenceCount: 'number',
      referenceList: { 'type': 'array', 'itemType': 'string' },
      transTypeV6: 'string',
      transactionV10: DescribeTransactionFor2CBrowserResponseBodyResultTransactionV10,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTransactionReceiptFor2CBrowserResponseBodyResult extends $tea.Model {
  data?: string;
  gasUsed?: string;
  logs?: string[];
  result?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      gasUsed: 'GasUsed',
      logs: 'Logs',
      result: 'Result',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      gasUsed: 'string',
      logs: { 'type': 'array', 'itemType': 'string' },
      result: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTriggerResponseBodyResultCheckpoint extends $tea.Model {
  errorCount?: number;
  height?: number;
  index?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      errorCount: 'ErrorCount',
      height: 'Height',
      index: 'Index',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCount: 'number',
      height: 'number',
      index: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DescribeTriggerResponseBodyResult extends $tea.Model {
  channelId?: string;
  channelName?: string;
  checkpoint?: DescribeTriggerResponseBodyResultCheckpoint;
  createTime?: number;
  errorMessage?: string;
  name?: string;
  options?: string;
  source?: string;
  status?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      checkpoint: 'Checkpoint',
      createTime: 'CreateTime',
      errorMessage: 'ErrorMessage',
      name: 'Name',
      options: 'Options',
      source: 'Source',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      checkpoint: DescribeTriggerResponseBodyResultCheckpoint,
      createTime: 'number',
      errorMessage: 'string',
      name: 'string',
      options: 'string',
      source: 'string',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DestroyConsortiumResponseBodyResult extends $tea.Model {
  consortiumId?: string;
  name?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      name: 'Name',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      name: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DestroyEthereumResponseBodyResult extends $tea.Model {
  consensus?: string;
  creator?: string;
  description?: string;
  id?: string;
  name?: string;
  networkId?: string;
  regionId?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      consensus: 'Consensus',
      creator: 'Creator',
      description: 'Description',
      id: 'Id',
      name: 'Name',
      networkId: 'NetworkId',
      regionId: 'RegionId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consensus: 'string',
      creator: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
      networkId: 'string',
      regionId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DestroyOrganizationResponseBodyResult extends $tea.Model {
  name?: string;
  organizationId?: string;
  static names(): { [key: string]: string } {
    return {
      name: 'Name',
      organizationId: 'OrganizationId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      name: 'string',
      organizationId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadAllResponseBodyResult extends $tea.Model {
  bizviewUrl?: string;
  certUrl?: string;
  sdkUrl?: string;
  static names(): { [key: string]: string } {
    return {
      bizviewUrl: 'BizviewUrl',
      certUrl: 'CertUrl',
      sdkUrl: 'SdkUrl',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizviewUrl: 'string',
      certUrl: 'string',
      sdkUrl: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadFabricChannelSDKResponseBodyResult extends $tea.Model {
  content?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DownloadOrganizationSDKResponseBodyResult extends $tea.Model {
  content?: string;
  path?: string;
  static names(): { [key: string]: string } {
    return {
      content: 'Content',
      path: 'Path',
    };
  }

  static types(): { [key: string]: any } {
    return {
      content: 'string',
      path: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class DuplicateAntChainContractProjectResponseBodyResult extends $tea.Model {
  consortiumId?: string;
  description?: string;
  gmtCreate?: number;
  gmtModified?: number;
  id?: string;
  name?: string;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      consortiumId: 'ConsortiumId',
      description: 'Description',
      gmtCreate: 'GmtCreate',
      gmtModified: 'GmtModified',
      id: 'Id',
      name: 'Name',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consortiumId: 'string',
      description: 'string',
      gmtCreate: 'number',
      gmtModified: 'number',
      id: 'string',
      name: 'string',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppliesResponseBodyResultApplyHistoryList extends $tea.Model {
  bizid?: string;
  createtime?: number;
  id?: number;
  rejectReason?: string;
  reqAddr?: string;
  signedAddr?: string;
  status?: number;
  updatetime?: number;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      createtime: 'Createtime',
      id: 'Id',
      rejectReason: 'RejectReason',
      reqAddr: 'ReqAddr',
      signedAddr: 'SignedAddr',
      status: 'Status',
      updatetime: 'Updatetime',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      createtime: 'number',
      id: 'number',
      rejectReason: 'string',
      reqAddr: 'string',
      signedAddr: 'string',
      status: 'number',
      updatetime: 'number',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppliesResponseBodyResultPagination extends $tea.Model {
  current?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'Current',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetAppliesResponseBodyResult extends $tea.Model {
  applyHistoryList?: GetAppliesResponseBodyResultApplyHistoryList[];
  pagination?: GetAppliesResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      applyHistoryList: 'ApplyHistoryList',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      applyHistoryList: { 'type': 'array', 'itemType': GetAppliesResponseBodyResultApplyHistoryList },
      pagination: GetAppliesResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBcSchemaResponseBodyResultResponsesPropertiesDataSource extends $tea.Model {
  allowNull?: number;
  annotation?: string;
  field?: string;
  indexes?: number;
  key?: number;
  length?: number;
  reg?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      allowNull: 'AllowNull',
      annotation: 'Annotation',
      field: 'Field',
      indexes: 'Indexes',
      key: 'Key',
      length: 'Length',
      reg: 'Reg',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowNull: 'number',
      annotation: 'string',
      field: 'string',
      indexes: 'number',
      key: 'number',
      length: 'number',
      reg: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBcSchemaResponseBodyResultResponsesProperties extends $tea.Model {
  count?: number;
  dataSource?: GetBcSchemaResponseBodyResultResponsesPropertiesDataSource[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      dataSource: 'DataSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      dataSource: { 'type': 'array', 'itemType': GetBcSchemaResponseBodyResultResponsesPropertiesDataSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBcSchemaResponseBodyResultResponses extends $tea.Model {
  category?: string;
  categoryName?: string;
  description?: string;
  properties?: GetBcSchemaResponseBodyResultResponsesProperties;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      categoryName: 'CategoryName',
      description: 'Description',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      categoryName: 'string',
      description: 'string',
      properties: GetBcSchemaResponseBodyResultResponsesProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBcSchemaResponseBodyResultSchema extends $tea.Model {
  createTime?: number;
  description?: string;
  id?: number;
  isTemplate?: boolean;
  name?: string;
  updateTime?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      id: 'Id',
      isTemplate: 'IsTemplate',
      name: 'Name',
      updateTime: 'UpdateTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      id: 'number',
      isTemplate: 'boolean',
      name: 'string',
      updateTime: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBcSchemaResponseBodyResult extends $tea.Model {
  responses?: GetBcSchemaResponseBodyResultResponses[];
  schema?: GetBcSchemaResponseBodyResultSchema;
  static names(): { [key: string]: string } {
    return {
      responses: 'Responses',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responses: { 'type': 'array', 'itemType': GetBcSchemaResponseBodyResultResponses },
      schema: GetBcSchemaResponseBodyResultSchema,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasksBlockchainCreateTasks extends $tea.Model {
  bizid?: string;
  createTime?: number;
  memo?: string;
  name?: string;
  status?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      createTime: 'CreateTime',
      memo: 'Memo',
      name: 'Name',
      status: 'Status',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      createTime: 'number',
      memo: 'string',
      name: 'string',
      status: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks extends $tea.Model {
  blockchainCreateTasks?: GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasksBlockchainCreateTasks[];
  static names(): { [key: string]: string } {
    return {
      blockchainCreateTasks: 'BlockchainCreateTasks',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockchainCreateTasks: { 'type': 'array', 'itemType': GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasksBlockchainCreateTasks },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlockchainCreateTaskResponseBodyResultPagination extends $tea.Model {
  current?: number;
  pageSize?: number;
  total?: number;
  static names(): { [key: string]: string } {
    return {
      current: 'Current',
      pageSize: 'PageSize',
      total: 'Total',
    };
  }

  static types(): { [key: string]: any } {
    return {
      current: 'number',
      pageSize: 'number',
      total: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlockchainCreateTaskResponseBodyResult extends $tea.Model {
  blockchainCreateTasks?: GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks;
  pagination?: GetBlockchainCreateTaskResponseBodyResultPagination;
  static names(): { [key: string]: string } {
    return {
      blockchainCreateTasks: 'BlockchainCreateTasks',
      pagination: 'Pagination',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockchainCreateTasks: GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks,
      pagination: GetBlockchainCreateTaskResponseBodyResultPagination,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlockchainInfoResponseBodyResultNodeInfoList extends $tea.Model {
  blockHeight?: number;
  nodeName?: string;
  status?: boolean;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      blockHeight: 'BlockHeight',
      nodeName: 'NodeName',
      status: 'Status',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockHeight: 'number',
      nodeName: 'string',
      status: 'boolean',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetBlockchainInfoResponseBodyResult extends $tea.Model {
  abnormalNodes?: number;
  bizid?: string;
  blockHeight?: number;
  createTime?: number;
  isRole?: boolean;
  nodeInfoList?: GetBlockchainInfoResponseBodyResultNodeInfoList[];
  nodeNumber?: number;
  normal?: boolean;
  transactionSum?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      abnormalNodes: 'AbnormalNodes',
      bizid: 'Bizid',
      blockHeight: 'BlockHeight',
      createTime: 'CreateTime',
      isRole: 'IsRole',
      nodeInfoList: 'NodeInfoList',
      nodeNumber: 'NodeNumber',
      normal: 'Normal',
      transactionSum: 'TransactionSum',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abnormalNodes: 'number',
      bizid: 'string',
      blockHeight: 'number',
      createTime: 'number',
      isRole: 'boolean',
      nodeInfoList: { 'type': 'array', 'itemType': GetBlockchainInfoResponseBodyResultNodeInfoList },
      nodeNumber: 'number',
      normal: 'boolean',
      transactionSum: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMyBlockchainsResponseBodyResult extends $tea.Model {
  bizid?: string;
  createtime?: number;
  id?: number;
  rejectReason?: string;
  reqAddr?: string;
  signedAddr?: string;
  status?: number;
  updatetime?: number;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      bizid: 'Bizid',
      createtime: 'Createtime',
      id: 'Id',
      rejectReason: 'RejectReason',
      reqAddr: 'ReqAddr',
      signedAddr: 'SignedAddr',
      status: 'Status',
      updatetime: 'Updatetime',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bizid: 'string',
      createtime: 'number',
      id: 'number',
      rejectReason: 'string',
      reqAddr: 'string',
      signedAddr: 'string',
      status: 'number',
      updatetime: 'number',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMySuccessAppliesResponseBodyResultNodeInfoList extends $tea.Model {
  blockHeight?: number;
  nodeName?: string;
  status?: boolean;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      blockHeight: 'BlockHeight',
      nodeName: 'NodeName',
      status: 'Status',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockHeight: 'number',
      nodeName: 'string',
      status: 'boolean',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetMySuccessAppliesResponseBodyResult extends $tea.Model {
  abnormalNodes?: number;
  bizid?: string;
  blockHeight?: number;
  createTime?: number;
  isRole?: boolean;
  name?: string;
  nodeInfoList?: GetMySuccessAppliesResponseBodyResultNodeInfoList[];
  nodeNumber?: number;
  normal?: boolean;
  transactionSum?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      abnormalNodes: 'AbnormalNodes',
      bizid: 'Bizid',
      blockHeight: 'BlockHeight',
      createTime: 'CreateTime',
      isRole: 'IsRole',
      name: 'Name',
      nodeInfoList: 'NodeInfoList',
      nodeNumber: 'NodeNumber',
      normal: 'Normal',
      transactionSum: 'TransactionSum',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      abnormalNodes: 'number',
      bizid: 'string',
      blockHeight: 'number',
      createTime: 'number',
      isRole: 'boolean',
      name: 'string',
      nodeInfoList: { 'type': 'array', 'itemType': GetMySuccessAppliesResponseBodyResultNodeInfoList },
      nodeNumber: 'number',
      normal: 'boolean',
      transactionSum: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetOssPropertiesResponseBodyResult extends $tea.Model {
  accessKeyId?: string;
  accessKeySecret?: string;
  bucketName?: string;
  endpoint?: string;
  folderName?: string;
  static names(): { [key: string]: string } {
    return {
      accessKeyId: 'AccessKeyId',
      accessKeySecret: 'AccessKeySecret',
      bucketName: 'BucketName',
      endpoint: 'Endpoint',
      folderName: 'FolderName',
    };
  }

  static types(): { [key: string]: any } {
    return {
      accessKeyId: 'string',
      accessKeySecret: 'string',
      bucketName: 'string',
      endpoint: 'string',
      folderName: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTemplatesResponseBodyResultSchemaList extends $tea.Model {
  createTime?: number;
  description?: string;
  id?: number;
  isTemplate?: number;
  name?: string;
  updateTime?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      id: 'Id',
      isTemplate: 'IsTemplate',
      name: 'Name',
      updateTime: 'UpdateTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      id: 'number',
      isTemplate: 'number',
      name: 'string',
      updateTime: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class GetTemplatesResponseBodyResult extends $tea.Model {
  schemaList?: GetTemplatesResponseBodyResultSchemaList[];
  static names(): { [key: string]: string } {
    return {
      schemaList: 'SchemaList',
    };
  }

  static types(): { [key: string]: any } {
    return {
      schemaList: { 'type': 'array', 'itemType': GetTemplatesResponseBodyResultSchemaList },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallChaincodeResponseBodyResult extends $tea.Model {
  chaincodeId?: string;
  channelName?: string;
  consortiumId?: string;
  createTime?: string;
  deployTime?: string;
  endorsePolicy?: string;
  input?: string;
  install?: boolean;
  message?: string;
  name?: string;
  path?: string;
  providerId?: string;
  providerName?: string;
  state?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      channelName: 'ChannelName',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      deployTime: 'DeployTime',
      endorsePolicy: 'EndorsePolicy',
      input: 'Input',
      install: 'Install',
      message: 'Message',
      name: 'Name',
      path: 'Path',
      providerId: 'ProviderId',
      providerName: 'ProviderName',
      state: 'State',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      channelName: 'string',
      consortiumId: 'string',
      createTime: 'string',
      deployTime: 'string',
      endorsePolicy: 'string',
      input: 'string',
      install: 'boolean',
      message: 'string',
      name: 'string',
      path: 'string',
      providerId: 'string',
      providerName: 'string',
      state: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstallFabricChaincodePackageResponseBodyResult extends $tea.Model {
  chaincodePackageId?: string;
  checksum?: string;
  deleteTime?: number;
  deleted?: boolean;
  installTime?: number;
  label?: string;
  md5sum?: string;
  organizationId?: string;
  ossBucket?: string;
  ossURL?: string;
  providerBid?: string;
  providerUid?: number;
  state?: string;
  type?: number;
  typeName?: string;
  uploadTime?: number;
  static names(): { [key: string]: string } {
    return {
      chaincodePackageId: 'ChaincodePackageId',
      checksum: 'Checksum',
      deleteTime: 'DeleteTime',
      deleted: 'Deleted',
      installTime: 'InstallTime',
      label: 'Label',
      md5sum: 'Md5sum',
      organizationId: 'OrganizationId',
      ossBucket: 'OssBucket',
      ossURL: 'OssURL',
      providerBid: 'ProviderBid',
      providerUid: 'ProviderUid',
      state: 'State',
      type: 'Type',
      typeName: 'TypeName',
      uploadTime: 'UploadTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodePackageId: 'string',
      checksum: 'string',
      deleteTime: 'number',
      deleted: 'boolean',
      installTime: 'number',
      label: 'string',
      md5sum: 'string',
      organizationId: 'string',
      ossBucket: 'string',
      ossURL: 'string',
      providerBid: 'string',
      providerUid: 'number',
      state: 'string',
      type: 'number',
      typeName: 'string',
      uploadTime: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InstantiateChaincodeResponseBodyResult extends $tea.Model {
  chaincodeId?: string;
  channelName?: string;
  consortiumId?: string;
  createTime?: string;
  deployTime?: string;
  endorsePolicy?: string;
  input?: string;
  install?: boolean;
  message?: string;
  name?: string;
  path?: string;
  providerId?: string;
  providerName?: string;
  state?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      channelName: 'ChannelName',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      deployTime: 'DeployTime',
      endorsePolicy: 'EndorsePolicy',
      input: 'Input',
      install: 'Install',
      message: 'Message',
      name: 'Name',
      path: 'Path',
      providerId: 'ProviderId',
      providerName: 'ProviderName',
      state: 'State',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      channelName: 'string',
      consortiumId: 'string',
      createTime: 'string',
      deployTime: 'string',
      endorsePolicy: 'string',
      input: 'string',
      install: 'boolean',
      message: 'string',
      name: 'string',
      path: 'string',
      providerId: 'string',
      providerName: 'string',
      state: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class InviteUserResponseBodyResult extends $tea.Model {
  bid?: string;
  bizid?: string;
  code?: string;
  createTime?: number;
  email?: string;
  fromBid?: string;
  fromUserId?: number;
  status?: number;
  updateTime?: number;
  userId?: number;
  static names(): { [key: string]: string } {
    return {
      bid: 'Bid',
      bizid: 'Bizid',
      code: 'Code',
      createTime: 'CreateTime',
      email: 'Email',
      fromBid: 'FromBid',
      fromUserId: 'FromUserId',
      status: 'Status',
      updateTime: 'UpdateTime',
      userId: 'UserId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      bid: 'string',
      bizid: 'string',
      code: 'string',
      createTime: 'number',
      email: 'string',
      fromBid: 'string',
      fromUserId: 'number',
      status: 'number',
      updateTime: 'number',
      userId: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class JoinChannelResponseBodyResult extends $tea.Model {
  acceptTime?: string;
  approveTime?: string;
  channelId?: string;
  confirmTime?: string;
  destroyTime?: string;
  inviteTime?: string;
  organizationId?: string;
  state?: string;
  withPeer?: boolean;
  static names(): { [key: string]: string } {
    return {
      acceptTime: 'AcceptTime',
      approveTime: 'ApproveTime',
      channelId: 'ChannelId',
      confirmTime: 'ConfirmTime',
      destroyTime: 'DestroyTime',
      inviteTime: 'InviteTime',
      organizationId: 'OrganizationId',
      state: 'State',
      withPeer: 'WithPeer',
    };
  }

  static types(): { [key: string]: any } {
    return {
      acceptTime: 'string',
      approveTime: 'string',
      channelId: 'string',
      confirmTime: 'string',
      destroyTime: 'string',
      inviteTime: 'string',
      organizationId: 'string',
      state: 'string',
      withPeer: 'boolean',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ListTagResourcesResponseBodyTagResources extends $tea.Model {
  resourceId?: string;
  resourceType?: string;
  tagKey?: string;
  tagValue?: string;
  static names(): { [key: string]: string } {
    return {
      resourceId: 'ResourceId',
      resourceType: 'ResourceType',
      tagKey: 'TagKey',
      tagValue: 'TagValue',
    };
  }

  static types(): { [key: string]: any } {
    return {
      resourceId: 'string',
      resourceType: 'string',
      tagKey: 'string',
      tagValue: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTriggerResponseBodyResultCheckpoint extends $tea.Model {
  errorCount?: number;
  height?: number;
  index?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      errorCount: 'ErrorCount',
      height: 'Height',
      index: 'Index',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      errorCount: 'number',
      height: 'number',
      index: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ModifyTriggerResponseBodyResult extends $tea.Model {
  channelId?: string;
  channelName?: string;
  checkpoint?: ModifyTriggerResponseBodyResultCheckpoint;
  createTime?: number;
  errorMessage?: string;
  name?: string;
  options?: string;
  source?: string;
  status?: number;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      channelId: 'ChannelId',
      channelName: 'ChannelName',
      checkpoint: 'Checkpoint',
      createTime: 'CreateTime',
      errorMessage: 'ErrorMessage',
      name: 'Name',
      options: 'Options',
      source: 'Source',
      status: 'Status',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelId: 'string',
      channelName: 'string',
      checkpoint: ModifyTriggerResponseBodyResultCheckpoint,
      createTime: 'number',
      errorMessage: 'string',
      name: 'string',
      options: 'string',
      source: 'string',
      status: 'number',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryBlockResponseBodyResult extends $tea.Model {
  alias?: string;
  blockHash?: string;
  createTime?: number;
  height?: number;
  previousHash?: string;
  rootTxHash?: string;
  transSummaryList?: string;
  transactionSize?: number;
  static names(): { [key: string]: string } {
    return {
      alias: 'Alias',
      blockHash: 'BlockHash',
      createTime: 'CreateTime',
      height: 'Height',
      previousHash: 'PreviousHash',
      rootTxHash: 'RootTxHash',
      transSummaryList: 'TransSummaryList',
      transactionSize: 'TransactionSize',
    };
  }

  static types(): { [key: string]: any } {
    return {
      alias: 'string',
      blockHash: 'string',
      createTime: 'number',
      height: 'number',
      previousHash: 'string',
      rootTxHash: 'string',
      transSummaryList: 'string',
      transactionSize: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryConsortiumDeletableResponseBodyResult extends $tea.Model {
  codeName?: string;
  consortiumId?: string;
  deletable?: boolean;
  description?: string;
  domain?: string;
  name?: string;
  regionId?: string;
  state?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      codeName: 'CodeName',
      consortiumId: 'ConsortiumId',
      deletable: 'Deletable',
      description: 'Description',
      domain: 'Domain',
      name: 'Name',
      regionId: 'RegionId',
      state: 'State',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeName: 'string',
      consortiumId: 'string',
      deletable: 'boolean',
      description: 'string',
      domain: 'string',
      name: 'string',
      regionId: 'string',
      state: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryEthereumDeletableResponseBodyResult extends $tea.Model {
  deletable?: boolean;
  ethereumId?: string;
  static names(): { [key: string]: string } {
    return {
      deletable: 'Deletable',
      ethereumId: 'EthereumId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      deletable: 'boolean',
      ethereumId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryOrganizationDeletableResponseBodyResult extends $tea.Model {
  codeName?: string;
  deletable?: boolean;
  description?: string;
  domain?: string;
  name?: string;
  organizationId?: string;
  regionId?: string;
  state?: string;
  zoneId?: string;
  static names(): { [key: string]: string } {
    return {
      codeName: 'CodeName',
      deletable: 'Deletable',
      description: 'Description',
      domain: 'Domain',
      name: 'Name',
      organizationId: 'OrganizationId',
      regionId: 'RegionId',
      state: 'State',
      zoneId: 'ZoneId',
    };
  }

  static types(): { [key: string]: any } {
    return {
      codeName: 'string',
      deletable: 'boolean',
      description: 'string',
      domain: 'string',
      name: 'string',
      organizationId: 'string',
      regionId: 'string',
      state: 'string',
      zoneId: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTransactionResponseBodyResultReferenceList extends $tea.Model {
  data?: string;
  length?: number;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      data: 'Data',
      length: 'Length',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      data: 'string',
      length: 'number',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class QueryTransactionResponseBodyResult extends $tea.Model {
  blockHeight?: number;
  blockVersion?: number;
  category?: number;
  content?: string;
  contentHash?: string;
  createTime?: number;
  hash?: string;
  keyName?: string;
  keyWrap?: string;
  nonce?: string;
  referenceCount?: number;
  referenceList?: QueryTransactionResponseBodyResultReferenceList;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      blockHeight: 'BlockHeight',
      blockVersion: 'BlockVersion',
      category: 'Category',
      content: 'Content',
      contentHash: 'ContentHash',
      createTime: 'CreateTime',
      hash: 'Hash',
      keyName: 'KeyName',
      keyWrap: 'KeyWrap',
      nonce: 'Nonce',
      referenceCount: 'ReferenceCount',
      referenceList: 'ReferenceList',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      blockHeight: 'number',
      blockVersion: 'number',
      category: 'number',
      content: 'string',
      contentHash: 'string',
      createTime: 'number',
      hash: 'string',
      keyName: 'string',
      keyWrap: 'string',
      nonce: 'string',
      referenceCount: 'number',
      referenceList: QueryTransactionResponseBodyResultReferenceList,
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class ResetOrganizationUserPasswordResponseBodyResult extends $tea.Model {
  createTime?: string;
  expireTime?: string;
  fullname?: string;
  organizationId?: string;
  password?: string;
  username?: string;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      expireTime: 'ExpireTime',
      fullname: 'Fullname',
      organizationId: 'OrganizationId',
      password: 'Password',
      username: 'Username',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'string',
      expireTime: 'string',
      fullname: 'string',
      organizationId: 'string',
      password: 'string',
      username: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SchemaDetailResponseBodyResultResponsesPropertiesDataSource extends $tea.Model {
  allowNull?: number;
  annotation?: string;
  field?: string;
  indexes?: number;
  key?: number;
  length?: number;
  reg?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      allowNull: 'AllowNull',
      annotation: 'Annotation',
      field: 'Field',
      indexes: 'Indexes',
      key: 'Key',
      length: 'Length',
      reg: 'Reg',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowNull: 'number',
      annotation: 'string',
      field: 'string',
      indexes: 'number',
      key: 'number',
      length: 'number',
      reg: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SchemaDetailResponseBodyResultResponsesProperties extends $tea.Model {
  count?: number;
  dataSource?: SchemaDetailResponseBodyResultResponsesPropertiesDataSource[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      dataSource: 'DataSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      dataSource: { 'type': 'array', 'itemType': SchemaDetailResponseBodyResultResponsesPropertiesDataSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SchemaDetailResponseBodyResultResponses extends $tea.Model {
  category?: string;
  categoryName?: string;
  description?: string;
  properties?: SchemaDetailResponseBodyResultResponsesProperties;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      categoryName: 'CategoryName',
      description: 'Description',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      categoryName: 'string',
      description: 'string',
      properties: SchemaDetailResponseBodyResultResponsesProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SchemaDetailResponseBodyResultSchema extends $tea.Model {
  createTime?: number;
  description?: string;
  id?: number;
  isTemplate?: boolean;
  name?: string;
  updateTime?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      id: 'Id',
      isTemplate: 'IsTemplate',
      name: 'Name',
      updateTime: 'UpdateTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      id: 'number',
      isTemplate: 'boolean',
      name: 'string',
      updateTime: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SchemaDetailResponseBodyResult extends $tea.Model {
  responses?: SchemaDetailResponseBodyResultResponses[];
  schema?: SchemaDetailResponseBodyResultSchema;
  static names(): { [key: string]: string } {
    return {
      responses: 'Responses',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responses: { 'type': 'array', 'itemType': SchemaDetailResponseBodyResultResponses },
      schema: SchemaDetailResponseBodyResultSchema,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SubmitFabricChaincodeDefinitionResponseBodyResult extends $tea.Model {
  chaincodeId?: string;
  channelName?: string;
  consortiumId?: string;
  createTime?: string;
  deployTime?: string;
  endorsePolicy?: string;
  input?: string;
  install?: boolean;
  message?: string;
  name?: string;
  path?: string;
  providerId?: string;
  providerName?: string;
  state?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      channelName: 'ChannelName',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      deployTime: 'DeployTime',
      endorsePolicy: 'EndorsePolicy',
      input: 'Input',
      install: 'Install',
      message: 'Message',
      name: 'Name',
      path: 'Path',
      providerId: 'ProviderId',
      providerName: 'ProviderName',
      state: 'State',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      channelName: 'string',
      consortiumId: 'string',
      createTime: 'string',
      deployTime: 'string',
      endorsePolicy: 'string',
      input: 'string',
      install: 'boolean',
      message: 'string',
      name: 'string',
      path: 'string',
      providerId: 'string',
      providerName: 'string',
      state: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SyncFabricChaincodeStatusResponseBodyResult extends $tea.Model {
  chaincodeId?: string;
  input?: string;
  name?: string;
  path?: number;
  state?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      input: 'Input',
      name: 'Name',
      path: 'Path',
      state: 'State',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      input: 'string',
      name: 'string',
      path: 'number',
      state: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class SynchronizeChaincodeResponseBodyResult extends $tea.Model {
  chaincodeId?: string;
  channelName?: string;
  consortiumId?: string;
  createTime?: string;
  deployTime?: string;
  endorsePolicy?: string;
  input?: string;
  install?: boolean;
  message?: string;
  name?: string;
  path?: string;
  providerId?: string;
  providerName?: string;
  state?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      channelName: 'ChannelName',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      deployTime: 'DeployTime',
      endorsePolicy: 'EndorsePolicy',
      input: 'Input',
      install: 'Install',
      message: 'Message',
      name: 'Name',
      path: 'Path',
      providerId: 'ProviderId',
      providerName: 'ProviderName',
      state: 'State',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      channelName: 'string',
      consortiumId: 'string',
      createTime: 'string',
      deployTime: 'string',
      endorsePolicy: 'string',
      input: 'string',
      install: 'boolean',
      message: 'string',
      name: 'string',
      path: 'string',
      providerId: 'string',
      providerName: 'string',
      state: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class TagResourcesRequestTag extends $tea.Model {
  key?: string;
  value?: string;
  static names(): { [key: string]: string } {
    return {
      key: 'Key',
      value: 'Value',
    };
  }

  static types(): { [key: string]: any } {
    return {
      key: 'string',
      value: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource extends $tea.Model {
  allowNull?: number;
  annotation?: string;
  field?: string;
  indexes?: number;
  key?: number;
  length?: number;
  reg?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      allowNull: 'AllowNull',
      annotation: 'Annotation',
      field: 'Field',
      indexes: 'Indexes',
      key: 'Key',
      length: 'Length',
      reg: 'Reg',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowNull: 'number',
      annotation: 'string',
      field: 'string',
      indexes: 'number',
      key: 'number',
      length: 'number',
      reg: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBlockchainSchemaResponseBodyResultResponsesProperties extends $tea.Model {
  count?: number;
  dataSource?: UpdateBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      dataSource: 'DataSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      dataSource: { 'type': 'array', 'itemType': UpdateBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBlockchainSchemaResponseBodyResultResponses extends $tea.Model {
  category?: string;
  categoryName?: string;
  description?: string;
  properties?: UpdateBlockchainSchemaResponseBodyResultResponsesProperties;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      categoryName: 'CategoryName',
      description: 'Description',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      categoryName: 'string',
      description: 'string',
      properties: UpdateBlockchainSchemaResponseBodyResultResponsesProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBlockchainSchemaResponseBodyResultSchema extends $tea.Model {
  createTime?: number;
  description?: string;
  id?: number;
  isTemplate?: boolean;
  name?: string;
  updateTime?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      id: 'Id',
      isTemplate: 'IsTemplate',
      name: 'Name',
      updateTime: 'UpdateTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      id: 'number',
      isTemplate: 'boolean',
      name: 'string',
      updateTime: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateBlockchainSchemaResponseBodyResult extends $tea.Model {
  responses?: UpdateBlockchainSchemaResponseBodyResultResponses[];
  schema?: UpdateBlockchainSchemaResponseBodyResultSchema;
  static names(): { [key: string]: string } {
    return {
      responses: 'Responses',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responses: { 'type': 'array', 'itemType': UpdateBlockchainSchemaResponseBodyResultResponses },
      schema: UpdateBlockchainSchemaResponseBodyResultSchema,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateChannelConfigResponseBodyResult extends $tea.Model {
  batchTimeout?: number;
  blockCount?: number;
  chaincodeCount?: number;
  channelId?: string;
  consortiumId?: string;
  consortiumName?: string;
  createTime?: string;
  maxMessageCount?: number;
  memberCount?: number;
  name?: string;
  ownerBid?: string;
  ownerName?: string;
  ownerUid?: number;
  preferredMaxBytes?: number;
  requestId?: string;
  state?: string;
  supportConfig?: boolean;
  updateTime?: string;
  static names(): { [key: string]: string } {
    return {
      batchTimeout: 'BatchTimeout',
      blockCount: 'BlockCount',
      chaincodeCount: 'ChaincodeCount',
      channelId: 'ChannelId',
      consortiumId: 'ConsortiumId',
      consortiumName: 'ConsortiumName',
      createTime: 'CreateTime',
      maxMessageCount: 'MaxMessageCount',
      memberCount: 'MemberCount',
      name: 'Name',
      ownerBid: 'OwnerBid',
      ownerName: 'OwnerName',
      ownerUid: 'OwnerUid',
      preferredMaxBytes: 'PreferredMaxBytes',
      requestId: 'RequestId',
      state: 'State',
      supportConfig: 'SupportConfig',
      updateTime: 'UpdateTime',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchTimeout: 'number',
      blockCount: 'number',
      chaincodeCount: 'number',
      channelId: 'string',
      consortiumId: 'string',
      consortiumName: 'string',
      createTime: 'string',
      maxMessageCount: 'number',
      memberCount: 'number',
      name: 'string',
      ownerBid: 'string',
      ownerName: 'string',
      ownerUid: 'number',
      preferredMaxBytes: 'number',
      requestId: 'string',
      state: 'string',
      supportConfig: 'boolean',
      updateTime: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumResponseBodyResult extends $tea.Model {
  consensus?: string;
  creator?: string;
  description?: string;
  id?: string;
  name?: string;
  networkId?: string;
  regionId?: string;
  state?: string;
  static names(): { [key: string]: string } {
    return {
      consensus: 'Consensus',
      creator: 'Creator',
      description: 'Description',
      id: 'Id',
      name: 'Name',
      networkId: 'NetworkId',
      regionId: 'RegionId',
      state: 'State',
    };
  }

  static types(): { [key: string]: any } {
    return {
      consensus: 'string',
      creator: 'string',
      description: 'string',
      id: 'string',
      name: 'string',
      networkId: 'string',
      regionId: 'string',
      state: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateEthereumNodeResponseBodyResult extends $tea.Model {
  createTime?: number;
  creator?: string;
  description?: string;
  ethereumId?: string;
  ethereumName?: string;
  id?: string;
  networkId?: string;
  nodeName?: string;
  publicIp?: string;
  regionId?: string;
  rpcPort?: number;
  state?: string;
  wsPort?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      creator: 'Creator',
      description: 'Description',
      ethereumId: 'EthereumId',
      ethereumName: 'EthereumName',
      id: 'Id',
      networkId: 'NetworkId',
      nodeName: 'NodeName',
      publicIp: 'PublicIp',
      regionId: 'RegionId',
      rpcPort: 'RpcPort',
      state: 'State',
      wsPort: 'WsPort',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      creator: 'string',
      description: 'string',
      ethereumId: 'string',
      ethereumName: 'string',
      id: 'string',
      networkId: 'string',
      nodeName: 'string',
      publicIp: 'string',
      regionId: 'string',
      rpcPort: 'number',
      state: 'string',
      wsPort: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers extends $tea.Model {
  host?: string;
  port?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes extends $tea.Model {
  address?: string;
  certificate?: string;
  key?: string;
  tlsroot?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      certificate: 'Certificate',
      key: 'Key',
      tlsroot: 'Tlsroot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      certificate: 'string',
      key: 'string',
      tlsroot: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskResponseBodyResultContentAddedOrganizations extends $tea.Model {
  anchorPeers?: UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers[];
  crls?: string;
  mspId?: string;
  mspType?: string;
  orderer?: boolean;
  ordererNodes?: UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes[];
  rootCertificates?: string;
  tlsRootCertificates?: string;
  static names(): { [key: string]: string } {
    return {
      anchorPeers: 'AnchorPeers',
      crls: 'Crls',
      mspId: 'MspId',
      mspType: 'MspType',
      orderer: 'Orderer',
      ordererNodes: 'OrdererNodes',
      rootCertificates: 'RootCertificates',
      tlsRootCertificates: 'TlsRootCertificates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorPeers: { 'type': 'array', 'itemType': UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers },
      crls: 'string',
      mspId: 'string',
      mspType: 'string',
      orderer: 'boolean',
      ordererNodes: { 'type': 'array', 'itemType': UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes },
      rootCertificates: 'string',
      tlsRootCertificates: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs extends $tea.Model {
  input?: string;
  name?: string;
  path?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      input: 'Input',
      name: 'Name',
      path: 'Path',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      input: 'string',
      name: 'string',
      path: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkg extends $tea.Model {
  cs?: UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs;
  policy?: string;
  sha256?: string;
  static names(): { [key: string]: string } {
    return {
      cs: 'Cs',
      policy: 'Policy',
      sha256: 'Sha256',
    };
  }

  static types(): { [key: string]: any } {
    return {
      cs: UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs,
      policy: 'string',
      sha256: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskResponseBodyResultContentOrdererConfig extends $tea.Model {
  batchTimeout?: string;
  maxMessageCount?: number;
  preferredMaxBytes?: number;
  static names(): { [key: string]: string } {
    return {
      batchTimeout: 'BatchTimeout',
      maxMessageCount: 'MaxMessageCount',
      preferredMaxBytes: 'PreferredMaxBytes',
    };
  }

  static types(): { [key: string]: any } {
    return {
      batchTimeout: 'string',
      maxMessageCount: 'number',
      preferredMaxBytes: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers extends $tea.Model {
  host?: string;
  port?: number;
  static names(): { [key: string]: string } {
    return {
      host: 'Host',
      port: 'Port',
    };
  }

  static types(): { [key: string]: any } {
    return {
      host: 'string',
      port: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes extends $tea.Model {
  address?: string;
  certificate?: string;
  key?: string;
  tlsroot?: string;
  static names(): { [key: string]: string } {
    return {
      address: 'Address',
      certificate: 'Certificate',
      key: 'Key',
      tlsroot: 'Tlsroot',
    };
  }

  static types(): { [key: string]: any } {
    return {
      address: 'string',
      certificate: 'string',
      key: 'string',
      tlsroot: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizations extends $tea.Model {
  anchorPeers?: UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers[];
  crls?: string;
  mspId?: string;
  mspType?: string;
  orderer?: boolean;
  ordererNodes?: UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes[];
  rootCertificates?: string;
  tlsRootCertificates?: string;
  static names(): { [key: string]: string } {
    return {
      anchorPeers: 'AnchorPeers',
      crls: 'Crls',
      mspId: 'MspId',
      mspType: 'MspType',
      orderer: 'Orderer',
      ordererNodes: 'OrdererNodes',
      rootCertificates: 'RootCertificates',
      tlsRootCertificates: 'TlsRootCertificates',
    };
  }

  static types(): { [key: string]: any } {
    return {
      anchorPeers: { 'type': 'array', 'itemType': UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers },
      crls: 'string',
      mspId: 'string',
      mspType: 'string',
      orderer: 'boolean',
      ordererNodes: { 'type': 'array', 'itemType': UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes },
      rootCertificates: 'string',
      tlsRootCertificates: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskResponseBodyResultContent extends $tea.Model {
  addedOrganizations?: UpdateGovernanceTaskResponseBodyResultContentAddedOrganizations[];
  chaincodeSpecPkg?: UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkg;
  ordererConfig?: UpdateGovernanceTaskResponseBodyResultContentOrdererConfig;
  raw?: string;
  removedOrganizations?: UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizations[];
  rwSets?: string;
  static names(): { [key: string]: string } {
    return {
      addedOrganizations: 'AddedOrganizations',
      chaincodeSpecPkg: 'ChaincodeSpecPkg',
      ordererConfig: 'OrdererConfig',
      raw: 'Raw',
      removedOrganizations: 'RemovedOrganizations',
      rwSets: 'RwSets',
    };
  }

  static types(): { [key: string]: any } {
    return {
      addedOrganizations: { 'type': 'array', 'itemType': UpdateGovernanceTaskResponseBodyResultContentAddedOrganizations },
      chaincodeSpecPkg: UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkg,
      ordererConfig: UpdateGovernanceTaskResponseBodyResultContentOrdererConfig,
      raw: 'string',
      removedOrganizations: { 'type': 'array', 'itemType': UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizations },
      rwSets: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateGovernanceTaskResponseBodyResult extends $tea.Model {
  channelName?: string;
  content?: UpdateGovernanceTaskResponseBodyResultContent;
  createTime?: number;
  creator?: string;
  description?: string;
  status?: string;
  taskId?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      channelName: 'ChannelName',
      content: 'Content',
      createTime: 'CreateTime',
      creator: 'Creator',
      description: 'Description',
      status: 'Status',
      taskId: 'TaskId',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      channelName: 'string',
      content: UpdateGovernanceTaskResponseBodyResultContent,
      createTime: 'number',
      creator: 'string',
      description: 'string',
      status: 'string',
      taskId: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSchemaResponseBodyResultResponsesPropertiesDataSource extends $tea.Model {
  allowNull?: number;
  annotation?: string;
  field?: string;
  indexes?: number;
  key?: number;
  length?: number;
  reg?: string;
  type?: string;
  static names(): { [key: string]: string } {
    return {
      allowNull: 'AllowNull',
      annotation: 'Annotation',
      field: 'Field',
      indexes: 'Indexes',
      key: 'Key',
      length: 'Length',
      reg: 'Reg',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      allowNull: 'number',
      annotation: 'string',
      field: 'string',
      indexes: 'number',
      key: 'number',
      length: 'number',
      reg: 'string',
      type: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSchemaResponseBodyResultResponsesProperties extends $tea.Model {
  count?: number;
  dataSource?: UpdateSchemaResponseBodyResultResponsesPropertiesDataSource[];
  static names(): { [key: string]: string } {
    return {
      count: 'Count',
      dataSource: 'DataSource',
    };
  }

  static types(): { [key: string]: any } {
    return {
      count: 'number',
      dataSource: { 'type': 'array', 'itemType': UpdateSchemaResponseBodyResultResponsesPropertiesDataSource },
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSchemaResponseBodyResultResponses extends $tea.Model {
  category?: string;
  categoryName?: string;
  description?: string;
  properties?: UpdateSchemaResponseBodyResultResponsesProperties;
  static names(): { [key: string]: string } {
    return {
      category: 'Category',
      categoryName: 'CategoryName',
      description: 'Description',
      properties: 'Properties',
    };
  }

  static types(): { [key: string]: any } {
    return {
      category: 'string',
      categoryName: 'string',
      description: 'string',
      properties: UpdateSchemaResponseBodyResultResponsesProperties,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSchemaResponseBodyResultSchema extends $tea.Model {
  createTime?: number;
  description?: string;
  id?: number;
  isTemplate?: boolean;
  name?: string;
  updateTime?: number;
  version?: number;
  static names(): { [key: string]: string } {
    return {
      createTime: 'CreateTime',
      description: 'Description',
      id: 'Id',
      isTemplate: 'IsTemplate',
      name: 'Name',
      updateTime: 'UpdateTime',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      createTime: 'number',
      description: 'string',
      id: 'number',
      isTemplate: 'boolean',
      name: 'string',
      updateTime: 'number',
      version: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpdateSchemaResponseBodyResult extends $tea.Model {
  responses?: UpdateSchemaResponseBodyResultResponses[];
  schema?: UpdateSchemaResponseBodyResultSchema;
  static names(): { [key: string]: string } {
    return {
      responses: 'Responses',
      schema: 'Schema',
    };
  }

  static types(): { [key: string]: any } {
    return {
      responses: { 'type': 'array', 'itemType': UpdateSchemaResponseBodyResultResponses },
      schema: UpdateSchemaResponseBodyResultSchema,
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeChaincodeResponseBodyResult extends $tea.Model {
  chaincodeId?: string;
  channelName?: string;
  consortiumId?: string;
  createTime?: string;
  deployTime?: string;
  endorsePolicy?: string;
  input?: string;
  install?: boolean;
  message?: string;
  name?: string;
  path?: string;
  providerId?: string;
  providerName?: string;
  state?: string;
  type?: number;
  version?: string;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      channelName: 'ChannelName',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      deployTime: 'DeployTime',
      endorsePolicy: 'EndorsePolicy',
      input: 'Input',
      install: 'Install',
      message: 'Message',
      name: 'Name',
      path: 'Path',
      providerId: 'ProviderId',
      providerName: 'ProviderName',
      state: 'State',
      type: 'Type',
      version: 'Version',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      channelName: 'string',
      consortiumId: 'string',
      createTime: 'string',
      deployTime: 'string',
      endorsePolicy: 'string',
      input: 'string',
      install: 'boolean',
      message: 'string',
      name: 'string',
      path: 'string',
      providerId: 'string',
      providerName: 'string',
      state: 'string',
      type: 'number',
      version: 'string',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}

export class UpgradeFabricChaincodeDefinitionResponseBodyResult extends $tea.Model {
  chaincodeId?: string;
  chaincodeVersion?: string;
  channelName?: string;
  consortiumId?: string;
  createTime?: string;
  deployTime?: string;
  endorsePolicy?: string;
  input?: string;
  install?: boolean;
  message?: string;
  name?: string;
  path?: string;
  providerId?: string;
  providerName?: string;
  state?: string;
  type?: number;
  static names(): { [key: string]: string } {
    return {
      chaincodeId: 'ChaincodeId',
      chaincodeVersion: 'ChaincodeVersion',
      channelName: 'ChannelName',
      consortiumId: 'ConsortiumId',
      createTime: 'CreateTime',
      deployTime: 'DeployTime',
      endorsePolicy: 'EndorsePolicy',
      input: 'Input',
      install: 'Install',
      message: 'Message',
      name: 'Name',
      path: 'Path',
      providerId: 'ProviderId',
      providerName: 'ProviderName',
      state: 'State',
      type: 'Type',
    };
  }

  static types(): { [key: string]: any } {
    return {
      chaincodeId: 'string',
      chaincodeVersion: 'string',
      channelName: 'string',
      consortiumId: 'string',
      createTime: 'string',
      deployTime: 'string',
      endorsePolicy: 'string',
      input: 'string',
      install: 'boolean',
      message: 'string',
      name: 'string',
      path: 'string',
      providerId: 'string',
      providerName: 'string',
      state: 'string',
      type: 'number',
    };
  }

  constructor(map?: { [key: string]: any }) {
    super(map);
  }
}


export default class Client extends OpenApi {

  constructor(config: $OpenApi.Config) {
    super(config);
    this._signatureAlgorithm = "v2";
    this._endpointRule = "regional";
    this._endpointMap = {
      'cn-qingdao': "baas.aliyuncs.com",
      'cn-beijing': "baas.aliyuncs.com",
      'cn-zhangjiakou': "baas.aliyuncs.com",
      'cn-huhehaote': "baas.aliyuncs.com",
      'cn-shanghai': "baas.aliyuncs.com",
      'cn-shenzhen': "baas.aliyuncs.com",
      'cn-hongkong': "baas.ap-southeast-1.aliyuncs.com",
      'ap-southeast-2': "baas.ap-southeast-1.aliyuncs.com",
      'ap-northeast-1': "baas.ap-southeast-1.aliyuncs.com",
      'eu-west-1': "baas.ap-southeast-1.aliyuncs.com",
      'us-west-1': "baas.ap-southeast-1.aliyuncs.com",
      'us-east-1': "baas.ap-southeast-1.aliyuncs.com",
      'eu-central-1': "baas.ap-southeast-1.aliyuncs.com",
      'ap-south-1': "baas.ap-southeast-1.aliyuncs.com",
    };
    this.checkConfig(config);
    this._endpoint = this.getEndpoint("baas", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
  }


  getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: {[key: string ]: string}, endpoint: string): string {
    if (!Util.empty(endpoint)) {
      return endpoint;
    }

    if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
      return endpointMap[regionId];
    }

    return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
  }

  /**
   * @param request AcceptEthereumInvitationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return AcceptEthereumInvitationResponse
   */
  async acceptEthereumInvitationWithOptions(request: AcceptEthereumInvitationRequest, runtime: $Util.RuntimeOptions): Promise<AcceptEthereumInvitationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.code)) {
      body["Code"] = request.code;
    }

    if (!Util.isUnset(request.token)) {
      body["Token"] = request.token;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AcceptEthereumInvitation",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AcceptEthereumInvitationResponse>(await this.callApi(params, req, runtime), new AcceptEthereumInvitationResponse({}));
  }

  /**
   * @param request AcceptEthereumInvitationRequest
   * @return AcceptEthereumInvitationResponse
   */
  async acceptEthereumInvitation(request: AcceptEthereumInvitationRequest): Promise<AcceptEthereumInvitationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.acceptEthereumInvitationWithOptions(request, runtime);
  }

  /**
   * @param request AcceptInvitationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return AcceptInvitationResponse
   */
  async acceptInvitationWithOptions(request: AcceptInvitationRequest, runtime: $Util.RuntimeOptions): Promise<AcceptInvitationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.code)) {
      body["Code"] = request.code;
    }

    if (!Util.isUnset(request.isAccepted)) {
      body["IsAccepted"] = request.isAccepted;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AcceptInvitation",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AcceptInvitationResponse>(await this.callApi(params, req, runtime), new AcceptInvitationResponse({}));
  }

  /**
   * @param request AcceptInvitationRequest
   * @return AcceptInvitationResponse
   */
  async acceptInvitation(request: AcceptInvitationRequest): Promise<AcceptInvitationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.acceptInvitationWithOptions(request, runtime);
  }

  /**
   * @param request AddAntChainSubnetMemberCheckRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return AddAntChainSubnetMemberCheckResponse
   */
  async addAntChainSubnetMemberCheckWithOptions(request: AddAntChainSubnetMemberCheckRequest, runtime: $Util.RuntimeOptions): Promise<AddAntChainSubnetMemberCheckResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddAntChainSubnetMemberCheck",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddAntChainSubnetMemberCheckResponse>(await this.callApi(params, req, runtime), new AddAntChainSubnetMemberCheckResponse({}));
  }

  /**
   * @param request AddAntChainSubnetMemberCheckRequest
   * @return AddAntChainSubnetMemberCheckResponse
   */
  async addAntChainSubnetMemberCheck(request: AddAntChainSubnetMemberCheckRequest): Promise<AddAntChainSubnetMemberCheckResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addAntChainSubnetMemberCheckWithOptions(request, runtime);
  }

  /**
   * @param request AddAntChainSubnetNodeCheckRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return AddAntChainSubnetNodeCheckResponse
   */
  async addAntChainSubnetNodeCheckWithOptions(request: AddAntChainSubnetNodeCheckRequest, runtime: $Util.RuntimeOptions): Promise<AddAntChainSubnetNodeCheckResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddAntChainSubnetNodeCheck",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddAntChainSubnetNodeCheckResponse>(await this.callApi(params, req, runtime), new AddAntChainSubnetNodeCheckResponse({}));
  }

  /**
   * @param request AddAntChainSubnetNodeCheckRequest
   * @return AddAntChainSubnetNodeCheckResponse
   */
  async addAntChainSubnetNodeCheck(request: AddAntChainSubnetNodeCheckRequest): Promise<AddAntChainSubnetNodeCheckResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addAntChainSubnetNodeCheckWithOptions(request, runtime);
  }

  /**
   * @param request AddEthereumNodeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return AddEthereumNodeResponse
   */
  async addEthereumNodeWithOptions(request: AddEthereumNodeRequest, runtime: $Util.RuntimeOptions): Promise<AddEthereumNodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.ethereumId)) {
      body["EthereumId"] = request.ethereumId;
    }

    if (!Util.isUnset(request.externalNode)) {
      body["ExternalNode"] = request.externalNode;
    }

    if (!Util.isUnset(request.nodeName)) {
      body["NodeName"] = request.nodeName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddEthereumNode",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddEthereumNodeResponse>(await this.callApi(params, req, runtime), new AddEthereumNodeResponse({}));
  }

  /**
   * @param request AddEthereumNodeRequest
   * @return AddEthereumNodeResponse
   */
  async addEthereumNode(request: AddEthereumNodeRequest): Promise<AddEthereumNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addEthereumNodeWithOptions(request, runtime);
  }

  /**
   * @param request AddFabricExternalOrganizationToChannelRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return AddFabricExternalOrganizationToChannelResponse
   */
  async addFabricExternalOrganizationToChannelWithOptions(request: AddFabricExternalOrganizationToChannelRequest, runtime: $Util.RuntimeOptions): Promise<AddFabricExternalOrganizationToChannelResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.joinRequest)) {
      body["JoinRequest"] = request.joinRequest;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddFabricExternalOrganizationToChannel",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddFabricExternalOrganizationToChannelResponse>(await this.callApi(params, req, runtime), new AddFabricExternalOrganizationToChannelResponse({}));
  }

  /**
   * @param request AddFabricExternalOrganizationToChannelRequest
   * @return AddFabricExternalOrganizationToChannelResponse
   */
  async addFabricExternalOrganizationToChannel(request: AddFabricExternalOrganizationToChannelRequest): Promise<AddFabricExternalOrganizationToChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addFabricExternalOrganizationToChannelWithOptions(request, runtime);
  }

  /**
   * @param request AddFabricOrganizationToExternalChannelRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return AddFabricOrganizationToExternalChannelResponse
   */
  async addFabricOrganizationToExternalChannelWithOptions(request: AddFabricOrganizationToExternalChannelRequest, runtime: $Util.RuntimeOptions): Promise<AddFabricOrganizationToExternalChannelResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.joinResponse)) {
      body["JoinResponse"] = request.joinResponse;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "AddFabricOrganizationToExternalChannel",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<AddFabricOrganizationToExternalChannelResponse>(await this.callApi(params, req, runtime), new AddFabricOrganizationToExternalChannelResponse({}));
  }

  /**
   * @param request AddFabricOrganizationToExternalChannelRequest
   * @return AddFabricOrganizationToExternalChannelResponse
   */
  async addFabricOrganizationToExternalChannel(request: AddFabricOrganizationToExternalChannelRequest): Promise<AddFabricOrganizationToExternalChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.addFabricOrganizationToExternalChannelWithOptions(request, runtime);
  }

  /**
   * @param request ApplyAntChainRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ApplyAntChainResponse
   */
  async applyAntChainWithOptions(request: ApplyAntChainRequest, runtime: $Util.RuntimeOptions): Promise<ApplyAntChainResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.uploadReq)) {
      body["UploadReq"] = request.uploadReq;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ApplyAntChain",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApplyAntChainResponse>(await this.callApi(params, req, runtime), new ApplyAntChainResponse({}));
  }

  /**
   * @param request ApplyAntChainRequest
   * @return ApplyAntChainResponse
   */
  async applyAntChain(request: ApplyAntChainRequest): Promise<ApplyAntChainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.applyAntChainWithOptions(request, runtime);
  }

  /**
   * @param request ApplyAntChainCertificateRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ApplyAntChainCertificateResponse
   */
  async applyAntChainCertificateWithOptions(request: ApplyAntChainCertificateRequest, runtime: $Util.RuntimeOptions): Promise<ApplyAntChainCertificateResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.uploadReq)) {
      body["UploadReq"] = request.uploadReq;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ApplyAntChainCertificate",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApplyAntChainCertificateResponse>(await this.callApi(params, req, runtime), new ApplyAntChainCertificateResponse({}));
  }

  /**
   * @param request ApplyAntChainCertificateRequest
   * @return ApplyAntChainCertificateResponse
   */
  async applyAntChainCertificate(request: ApplyAntChainCertificateRequest): Promise<ApplyAntChainCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.applyAntChainCertificateWithOptions(request, runtime);
  }

  /**
   * @param request ApplyAntChainCertificateWithKeyAutoCreationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ApplyAntChainCertificateWithKeyAutoCreationResponse
   */
  async applyAntChainCertificateWithKeyAutoCreationWithOptions(request: ApplyAntChainCertificateWithKeyAutoCreationRequest, runtime: $Util.RuntimeOptions): Promise<ApplyAntChainCertificateWithKeyAutoCreationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.commonName)) {
      body["CommonName"] = request.commonName;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.countryName)) {
      body["CountryName"] = request.countryName;
    }

    if (!Util.isUnset(request.localityName)) {
      body["LocalityName"] = request.localityName;
    }

    if (!Util.isUnset(request.organizationName)) {
      body["OrganizationName"] = request.organizationName;
    }

    if (!Util.isUnset(request.organizationUnitName)) {
      body["OrganizationUnitName"] = request.organizationUnitName;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.stateOrProvinceName)) {
      body["StateOrProvinceName"] = request.stateOrProvinceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ApplyAntChainCertificateWithKeyAutoCreation",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApplyAntChainCertificateWithKeyAutoCreationResponse>(await this.callApi(params, req, runtime), new ApplyAntChainCertificateWithKeyAutoCreationResponse({}));
  }

  /**
   * @param request ApplyAntChainCertificateWithKeyAutoCreationRequest
   * @return ApplyAntChainCertificateWithKeyAutoCreationResponse
   */
  async applyAntChainCertificateWithKeyAutoCreation(request: ApplyAntChainCertificateWithKeyAutoCreationRequest): Promise<ApplyAntChainCertificateWithKeyAutoCreationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.applyAntChainCertificateWithKeyAutoCreationWithOptions(request, runtime);
  }

  /**
   * @param request ApplyAntChainWithKeyAutoCreationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ApplyAntChainWithKeyAutoCreationResponse
   */
  async applyAntChainWithKeyAutoCreationWithOptions(request: ApplyAntChainWithKeyAutoCreationRequest, runtime: $Util.RuntimeOptions): Promise<ApplyAntChainWithKeyAutoCreationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.commonName)) {
      body["CommonName"] = request.commonName;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.countryName)) {
      body["CountryName"] = request.countryName;
    }

    if (!Util.isUnset(request.localityName)) {
      body["LocalityName"] = request.localityName;
    }

    if (!Util.isUnset(request.organizationName)) {
      body["OrganizationName"] = request.organizationName;
    }

    if (!Util.isUnset(request.organizationUnitName)) {
      body["OrganizationUnitName"] = request.organizationUnitName;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.stateOrProvinceName)) {
      body["StateOrProvinceName"] = request.stateOrProvinceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ApplyAntChainWithKeyAutoCreation",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApplyAntChainWithKeyAutoCreationResponse>(await this.callApi(params, req, runtime), new ApplyAntChainWithKeyAutoCreationResponse({}));
  }

  /**
   * @param request ApplyAntChainWithKeyAutoCreationRequest
   * @return ApplyAntChainWithKeyAutoCreationResponse
   */
  async applyAntChainWithKeyAutoCreation(request: ApplyAntChainWithKeyAutoCreationRequest): Promise<ApplyAntChainWithKeyAutoCreationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.applyAntChainWithKeyAutoCreationWithOptions(request, runtime);
  }

  /**
   * @param request ApplyBlockchainRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ApplyBlockchainResponse
   */
  async applyBlockchainWithOptions(request: ApplyBlockchainRequest, runtime: $Util.RuntimeOptions): Promise<ApplyBlockchainResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.account)) {
      body["Account"] = request.account;
    }

    if (!Util.isUnset(request.accountPubKey)) {
      body["AccountPubKey"] = request.accountPubKey;
    }

    if (!Util.isUnset(request.accountRecoverPubKey)) {
      body["AccountRecoverPubKey"] = request.accountRecoverPubKey;
    }

    if (!Util.isUnset(request.blockchain)) {
      body["Blockchain"] = request.blockchain;
    }

    if (!Util.isUnset(request.uploadReq)) {
      body["UploadReq"] = request.uploadReq;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ApplyBlockchain",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApplyBlockchainResponse>(await this.callApi(params, req, runtime), new ApplyBlockchainResponse({}));
  }

  /**
   * @param request ApplyBlockchainRequest
   * @return ApplyBlockchainResponse
   */
  async applyBlockchain(request: ApplyBlockchainRequest): Promise<ApplyBlockchainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.applyBlockchainWithOptions(request, runtime);
  }

  /**
   * @param request ApplyBlockchainWithKeyAutoCreationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ApplyBlockchainWithKeyAutoCreationResponse
   */
  async applyBlockchainWithKeyAutoCreationWithOptions(request: ApplyBlockchainWithKeyAutoCreationRequest, runtime: $Util.RuntimeOptions): Promise<ApplyBlockchainWithKeyAutoCreationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.commonName)) {
      body["CommonName"] = request.commonName;
    }

    if (!Util.isUnset(request.countryName)) {
      body["CountryName"] = request.countryName;
    }

    if (!Util.isUnset(request.localityName)) {
      body["LocalityName"] = request.localityName;
    }

    if (!Util.isUnset(request.organizationName)) {
      body["OrganizationName"] = request.organizationName;
    }

    if (!Util.isUnset(request.organizationUnitName)) {
      body["OrganizationUnitName"] = request.organizationUnitName;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.stateOrProvinceName)) {
      body["StateOrProvinceName"] = request.stateOrProvinceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ApplyBlockchainWithKeyAutoCreation",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApplyBlockchainWithKeyAutoCreationResponse>(await this.callApi(params, req, runtime), new ApplyBlockchainWithKeyAutoCreationResponse({}));
  }

  /**
   * @param request ApplyBlockchainWithKeyAutoCreationRequest
   * @return ApplyBlockchainWithKeyAutoCreationResponse
   */
  async applyBlockchainWithKeyAutoCreation(request: ApplyBlockchainWithKeyAutoCreationRequest): Promise<ApplyBlockchainWithKeyAutoCreationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.applyBlockchainWithKeyAutoCreationWithOptions(request, runtime);
  }

  /**
   * @param request ApplyPublicAntChainRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ApplyPublicAntChainResponse
   */
  async applyPublicAntChainWithOptions(request: ApplyPublicAntChainRequest, runtime: $Util.RuntimeOptions): Promise<ApplyPublicAntChainResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.uploadReq)) {
      body["UploadReq"] = request.uploadReq;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ApplyPublicAntChain",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApplyPublicAntChainResponse>(await this.callApi(params, req, runtime), new ApplyPublicAntChainResponse({}));
  }

  /**
   * @param request ApplyPublicAntChainRequest
   * @return ApplyPublicAntChainResponse
   */
  async applyPublicAntChain(request: ApplyPublicAntChainRequest): Promise<ApplyPublicAntChainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.applyPublicAntChainWithOptions(request, runtime);
  }

  /**
   * @param request ApplyPublicAntChainWithKeyAutoCreationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ApplyPublicAntChainWithKeyAutoCreationResponse
   */
  async applyPublicAntChainWithKeyAutoCreationWithOptions(request: ApplyPublicAntChainWithKeyAutoCreationRequest, runtime: $Util.RuntimeOptions): Promise<ApplyPublicAntChainWithKeyAutoCreationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.commonName)) {
      body["CommonName"] = request.commonName;
    }

    if (!Util.isUnset(request.countryName)) {
      body["CountryName"] = request.countryName;
    }

    if (!Util.isUnset(request.localityName)) {
      body["LocalityName"] = request.localityName;
    }

    if (!Util.isUnset(request.organizationName)) {
      body["OrganizationName"] = request.organizationName;
    }

    if (!Util.isUnset(request.organizationUnitName)) {
      body["OrganizationUnitName"] = request.organizationUnitName;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.stateOrProvinceName)) {
      body["StateOrProvinceName"] = request.stateOrProvinceName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ApplyPublicAntChainWithKeyAutoCreation",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApplyPublicAntChainWithKeyAutoCreationResponse>(await this.callApi(params, req, runtime), new ApplyPublicAntChainWithKeyAutoCreationResponse({}));
  }

  /**
   * @param request ApplyPublicAntChainWithKeyAutoCreationRequest
   * @return ApplyPublicAntChainWithKeyAutoCreationResponse
   */
  async applyPublicAntChainWithKeyAutoCreation(request: ApplyPublicAntChainWithKeyAutoCreationRequest): Promise<ApplyPublicAntChainWithKeyAutoCreationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.applyPublicAntChainWithKeyAutoCreationWithOptions(request, runtime);
  }

  /**
   * @param request ApproveEthereumInviteeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ApproveEthereumInviteeResponse
   */
  async approveEthereumInviteeWithOptions(request: ApproveEthereumInviteeRequest, runtime: $Util.RuntimeOptions): Promise<ApproveEthereumInviteeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    if (!Util.isUnset(request.invitee)) {
      body["Invitee"] = request.invitee;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ApproveEthereumInvitee",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApproveEthereumInviteeResponse>(await this.callApi(params, req, runtime), new ApproveEthereumInviteeResponse({}));
  }

  /**
   * @param request ApproveEthereumInviteeRequest
   * @return ApproveEthereumInviteeResponse
   */
  async approveEthereumInvitee(request: ApproveEthereumInviteeRequest): Promise<ApproveEthereumInviteeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.approveEthereumInviteeWithOptions(request, runtime);
  }

  /**
   * @param request ApproveFabricChaincodeDefinitionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ApproveFabricChaincodeDefinitionResponse
   */
  async approveFabricChaincodeDefinitionWithOptions(request: ApproveFabricChaincodeDefinitionRequest, runtime: $Util.RuntimeOptions): Promise<ApproveFabricChaincodeDefinitionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodeId)) {
      body["ChaincodeId"] = request.chaincodeId;
    }

    if (!Util.isUnset(request.chaincodePackageId)) {
      body["ChaincodePackageId"] = request.chaincodePackageId;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ApproveFabricChaincodeDefinition",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ApproveFabricChaincodeDefinitionResponse>(await this.callApi(params, req, runtime), new ApproveFabricChaincodeDefinitionResponse({}));
  }

  /**
   * @param request ApproveFabricChaincodeDefinitionRequest
   * @return ApproveFabricChaincodeDefinitionResponse
   */
  async approveFabricChaincodeDefinition(request: ApproveFabricChaincodeDefinitionRequest): Promise<ApproveFabricChaincodeDefinitionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.approveFabricChaincodeDefinitionWithOptions(request, runtime);
  }

  /**
   * @param tmpReq BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse
   */
  async batchAddAntChainMiniAppQRCodeAuthorizedUsersWithOptions(tmpReq: BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest, runtime: $Util.RuntimeOptions): Promise<BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse> {
    Util.validateModel(tmpReq);
    let request = new BatchAddAntChainMiniAppQRCodeAuthorizedUsersShrinkRequest({ });
    OpenApiUtil.convert(tmpReq, request);
    if (!Util.isUnset(tmpReq.phoneList)) {
      request.phoneListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.phoneList, "PhoneList", "json");
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.phoneListShrink)) {
      body["PhoneList"] = request.phoneListShrink;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BatchAddAntChainMiniAppQRCodeAuthorizedUsers",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse>(await this.callApi(params, req, runtime), new BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse({}));
  }

  /**
   * @param request BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest
   * @return BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse
   */
  async batchAddAntChainMiniAppQRCodeAuthorizedUsers(request: BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest): Promise<BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.batchAddAntChainMiniAppQRCodeAuthorizedUsersWithOptions(request, runtime);
  }

  /**
   * @param request BindFabricManagementChaincodeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return BindFabricManagementChaincodeResponse
   */
  async bindFabricManagementChaincodeWithOptions(request: BindFabricManagementChaincodeRequest, runtime: $Util.RuntimeOptions): Promise<BindFabricManagementChaincodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodeId)) {
      body["ChaincodeId"] = request.chaincodeId;
    }

    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "BindFabricManagementChaincode",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<BindFabricManagementChaincodeResponse>(await this.callApi(params, req, runtime), new BindFabricManagementChaincodeResponse({}));
  }

  /**
   * @param request BindFabricManagementChaincodeRequest
   * @return BindFabricManagementChaincodeResponse
   */
  async bindFabricManagementChaincode(request: BindFabricManagementChaincodeRequest): Promise<BindFabricManagementChaincodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.bindFabricManagementChaincodeWithOptions(request, runtime);
  }

  /**
   * @param request CheckConsortiumDomainRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CheckConsortiumDomainResponse
   */
  async checkConsortiumDomainWithOptions(request: CheckConsortiumDomainRequest, runtime: $Util.RuntimeOptions): Promise<CheckConsortiumDomainResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.domainCode)) {
      body["DomainCode"] = request.domainCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CheckConsortiumDomain",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckConsortiumDomainResponse>(await this.callApi(params, req, runtime), new CheckConsortiumDomainResponse({}));
  }

  /**
   * @param request CheckConsortiumDomainRequest
   * @return CheckConsortiumDomainResponse
   */
  async checkConsortiumDomain(request: CheckConsortiumDomainRequest): Promise<CheckConsortiumDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkConsortiumDomainWithOptions(request, runtime);
  }

  /**
   * @param request CheckOrganizationDomainRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CheckOrganizationDomainResponse
   */
  async checkOrganizationDomainWithOptions(request: CheckOrganizationDomainRequest, runtime: $Util.RuntimeOptions): Promise<CheckOrganizationDomainResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.domain)) {
      body["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.domainCode)) {
      body["DomainCode"] = request.domainCode;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CheckOrganizationDomain",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CheckOrganizationDomainResponse>(await this.callApi(params, req, runtime), new CheckOrganizationDomainResponse({}));
  }

  /**
   * @param request CheckOrganizationDomainRequest
   * @return CheckOrganizationDomainResponse
   */
  async checkOrganizationDomain(request: CheckOrganizationDomainRequest): Promise<CheckOrganizationDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.checkOrganizationDomainWithOptions(request, runtime);
  }

  /**
   * @param request ConfirmConsortiumMemberRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ConfirmConsortiumMemberResponse
   */
  async confirmConsortiumMemberWithOptions(request: ConfirmConsortiumMemberRequest, runtime: $Util.RuntimeOptions): Promise<ConfirmConsortiumMemberResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consortiumId)) {
      query["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.organization)) {
      query["Organization"] = request.organization;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ConfirmConsortiumMember",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ConfirmConsortiumMemberResponse>(await this.callApi(params, req, runtime), new ConfirmConsortiumMemberResponse({}));
  }

  /**
   * @param request ConfirmConsortiumMemberRequest
   * @return ConfirmConsortiumMemberResponse
   */
  async confirmConsortiumMember(request: ConfirmConsortiumMemberRequest): Promise<ConfirmConsortiumMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.confirmConsortiumMemberWithOptions(request, runtime);
  }

  /**
   * @param request CopyAntChainContractProjectRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CopyAntChainContractProjectResponse
   */
  async copyAntChainContractProjectWithOptions(request: CopyAntChainContractProjectRequest, runtime: $Util.RuntimeOptions): Promise<CopyAntChainContractProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectDescription)) {
      body["ProjectDescription"] = request.projectDescription;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.projectVersion)) {
      body["ProjectVersion"] = request.projectVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CopyAntChainContractProject",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CopyAntChainContractProjectResponse>(await this.callApi(params, req, runtime), new CopyAntChainContractProjectResponse({}));
  }

  /**
   * @param request CopyAntChainContractProjectRequest
   * @return CopyAntChainContractProjectResponse
   */
  async copyAntChainContractProject(request: CopyAntChainContractProjectRequest): Promise<CopyAntChainContractProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.copyAntChainContractProjectWithOptions(request, runtime);
  }

  /**
   * @param request CreateAccessTokenRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateAccessTokenResponse
   */
  async createAccessTokenWithOptions(request: CreateAccessTokenRequest, runtime: $Util.RuntimeOptions): Promise<CreateAccessTokenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.accessTokenLifetime)) {
      body["AccessTokenLifetime"] = request.accessTokenLifetime;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.refreshTokenLifetime)) {
      body["RefreshTokenLifetime"] = request.refreshTokenLifetime;
    }

    if (!Util.isUnset(request.scope)) {
      body["Scope"] = request.scope;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateAccessToken",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAccessTokenResponse>(await this.callApi(params, req, runtime), new CreateAccessTokenResponse({}));
  }

  /**
   * @param request CreateAccessTokenRequest
   * @return CreateAccessTokenResponse
   */
  async createAccessToken(request: CreateAccessTokenRequest): Promise<CreateAccessTokenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAccessTokenWithOptions(request, runtime);
  }

  /**
   * @param request CreateAccountRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateAccountResponse
   */
  async createAccountWithOptions(request: CreateAccountRequest, runtime: $Util.RuntimeOptions): Promise<CreateAccountResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.account)) {
      body["Account"] = request.account;
    }

    if (!Util.isUnset(request.accountPubKey)) {
      body["AccountPubKey"] = request.accountPubKey;
    }

    if (!Util.isUnset(request.accountRecoverPubKey)) {
      body["AccountRecoverPubKey"] = request.accountRecoverPubKey;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateAccount",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAccountResponse>(await this.callApi(params, req, runtime), new CreateAccountResponse({}));
  }

  /**
   * @param request CreateAccountRequest
   * @return CreateAccountResponse
   */
  async createAccount(request: CreateAccountRequest): Promise<CreateAccountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAccountWithOptions(request, runtime);
  }

  /**
   * @param request CreateAccountWithKeyPairAutoCreationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateAccountWithKeyPairAutoCreationResponse
   */
  async createAccountWithKeyPairAutoCreationWithOptions(request: CreateAccountWithKeyPairAutoCreationRequest, runtime: $Util.RuntimeOptions): Promise<CreateAccountWithKeyPairAutoCreationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.account)) {
      body["Account"] = request.account;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateAccountWithKeyPairAutoCreation",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAccountWithKeyPairAutoCreationResponse>(await this.callApi(params, req, runtime), new CreateAccountWithKeyPairAutoCreationResponse({}));
  }

  /**
   * @param request CreateAccountWithKeyPairAutoCreationRequest
   * @return CreateAccountWithKeyPairAutoCreationResponse
   */
  async createAccountWithKeyPairAutoCreation(request: CreateAccountWithKeyPairAutoCreationRequest): Promise<CreateAccountWithKeyPairAutoCreationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAccountWithKeyPairAutoCreationWithOptions(request, runtime);
  }

  /**
   * @param request CreateAntChainRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateAntChainResponse
   */
  async createAntChainWithOptions(request: CreateAntChainRequest, runtime: $Util.RuntimeOptions): Promise<CreateAntChainResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainName)) {
      body["AntChainName"] = request.antChainName;
    }

    if (!Util.isUnset(request.blockchainRegionId)) {
      body["BlockchainRegionId"] = request.blockchainRegionId;
    }

    if (!Util.isUnset(request.cipherSuit)) {
      body["CipherSuit"] = request.cipherSuit;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.liveTime)) {
      body["LiveTime"] = request.liveTime;
    }

    if (!Util.isUnset(request.merkleTreeSuit)) {
      body["MerkleTreeSuit"] = request.merkleTreeSuit;
    }

    if (!Util.isUnset(request.nodeNum)) {
      body["NodeNum"] = request.nodeNum;
    }

    if (!Util.isUnset(request.resourceSize)) {
      body["ResourceSize"] = request.resourceSize;
    }

    if (!Util.isUnset(request.tlsAlgo)) {
      body["TlsAlgo"] = request.tlsAlgo;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateAntChain",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAntChainResponse>(await this.callApi(params, req, runtime), new CreateAntChainResponse({}));
  }

  /**
   * @param request CreateAntChainRequest
   * @return CreateAntChainResponse
   */
  async createAntChain(request: CreateAntChainRequest): Promise<CreateAntChainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAntChainWithOptions(request, runtime);
  }

  /**
   * @param request CreateAntChainAccountRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateAntChainAccountResponse
   */
  async createAntChainAccountWithOptions(request: CreateAntChainAccountRequest, runtime: $Util.RuntimeOptions): Promise<CreateAntChainAccountResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.account)) {
      body["Account"] = request.account;
    }

    if (!Util.isUnset(request.accountPubKey)) {
      body["AccountPubKey"] = request.accountPubKey;
    }

    if (!Util.isUnset(request.accountRecoverPubKey)) {
      body["AccountRecoverPubKey"] = request.accountRecoverPubKey;
    }

    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateAntChainAccount",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAntChainAccountResponse>(await this.callApi(params, req, runtime), new CreateAntChainAccountResponse({}));
  }

  /**
   * @param request CreateAntChainAccountRequest
   * @return CreateAntChainAccountResponse
   */
  async createAntChainAccount(request: CreateAntChainAccountRequest): Promise<CreateAntChainAccountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAntChainAccountWithOptions(request, runtime);
  }

  /**
   * @param request CreateAntChainAccountWithKeyPairAutoCreationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateAntChainAccountWithKeyPairAutoCreationResponse
   */
  async createAntChainAccountWithKeyPairAutoCreationWithOptions(request: CreateAntChainAccountWithKeyPairAutoCreationRequest, runtime: $Util.RuntimeOptions): Promise<CreateAntChainAccountWithKeyPairAutoCreationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.account)) {
      body["Account"] = request.account;
    }

    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.recoverPassword)) {
      body["RecoverPassword"] = request.recoverPassword;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateAntChainAccountWithKeyPairAutoCreation",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAntChainAccountWithKeyPairAutoCreationResponse>(await this.callApi(params, req, runtime), new CreateAntChainAccountWithKeyPairAutoCreationResponse({}));
  }

  /**
   * @param request CreateAntChainAccountWithKeyPairAutoCreationRequest
   * @return CreateAntChainAccountWithKeyPairAutoCreationResponse
   */
  async createAntChainAccountWithKeyPairAutoCreation(request: CreateAntChainAccountWithKeyPairAutoCreationRequest): Promise<CreateAntChainAccountWithKeyPairAutoCreationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAntChainAccountWithKeyPairAutoCreationWithOptions(request, runtime);
  }

  /**
   * @param request CreateAntChainConsortiumRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateAntChainConsortiumResponse
   */
  async createAntChainConsortiumWithOptions(request: CreateAntChainConsortiumRequest, runtime: $Util.RuntimeOptions): Promise<CreateAntChainConsortiumResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumDescription)) {
      body["ConsortiumDescription"] = request.consortiumDescription;
    }

    if (!Util.isUnset(request.consortiumName)) {
      body["ConsortiumName"] = request.consortiumName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateAntChainConsortium",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAntChainConsortiumResponse>(await this.callApi(params, req, runtime), new CreateAntChainConsortiumResponse({}));
  }

  /**
   * @param request CreateAntChainConsortiumRequest
   * @return CreateAntChainConsortiumResponse
   */
  async createAntChainConsortium(request: CreateAntChainConsortiumRequest): Promise<CreateAntChainConsortiumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAntChainConsortiumWithOptions(request, runtime);
  }

  /**
   * @param request CreateAntChainContractContentRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateAntChainContractContentResponse
   */
  async createAntChainContractContentWithOptions(request: CreateAntChainContractContentRequest, runtime: $Util.RuntimeOptions): Promise<CreateAntChainContractContentResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["Content"] = request.content;
    }

    if (!Util.isUnset(request.contentName)) {
      body["ContentName"] = request.contentName;
    }

    if (!Util.isUnset(request.isDirectory)) {
      body["IsDirectory"] = request.isDirectory;
    }

    if (!Util.isUnset(request.parentContentId)) {
      body["ParentContentId"] = request.parentContentId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateAntChainContractContent",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAntChainContractContentResponse>(await this.callApi(params, req, runtime), new CreateAntChainContractContentResponse({}));
  }

  /**
   * @param request CreateAntChainContractContentRequest
   * @return CreateAntChainContractContentResponse
   */
  async createAntChainContractContent(request: CreateAntChainContractContentRequest): Promise<CreateAntChainContractContentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAntChainContractContentWithOptions(request, runtime);
  }

  /**
   * @param request CreateAntChainContractProjectRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateAntChainContractProjectResponse
   */
  async createAntChainContractProjectWithOptions(request: CreateAntChainContractProjectRequest, runtime: $Util.RuntimeOptions): Promise<CreateAntChainContractProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.projectDescription)) {
      body["ProjectDescription"] = request.projectDescription;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.projectVersion)) {
      body["ProjectVersion"] = request.projectVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateAntChainContractProject",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateAntChainContractProjectResponse>(await this.callApi(params, req, runtime), new CreateAntChainContractProjectResponse({}));
  }

  /**
   * @param request CreateAntChainContractProjectRequest
   * @return CreateAntChainContractProjectResponse
   */
  async createAntChainContractProject(request: CreateAntChainContractProjectRequest): Promise<CreateAntChainContractProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createAntChainContractProjectWithOptions(request, runtime);
  }

  /**
   * @param request CreateBlockchainRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateBlockchainResponse
   */
  async createBlockchainWithOptions(request: CreateBlockchainRequest, runtime: $Util.RuntimeOptions): Promise<CreateBlockchainResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.blockchainRegionId)) {
      body["BlockchainRegionId"] = request.blockchainRegionId;
    }

    if (!Util.isUnset(request.blockchainType)) {
      body["BlockchainType"] = request.blockchainType;
    }

    if (!Util.isUnset(request.cipherSuit)) {
      body["CipherSuit"] = request.cipherSuit;
    }

    if (!Util.isUnset(request.liveTime)) {
      body["LiveTime"] = request.liveTime;
    }

    if (!Util.isUnset(request.machineNum)) {
      body["MachineNum"] = request.machineNum;
    }

    if (!Util.isUnset(request.merkleTreeSuit)) {
      body["MerkleTreeSuit"] = request.merkleTreeSuit;
    }

    if (!Util.isUnset(request.size)) {
      body["Size"] = request.size;
    }

    if (!Util.isUnset(request.tlsAlgo)) {
      body["TlsAlgo"] = request.tlsAlgo;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateBlockchain",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateBlockchainResponse>(await this.callApi(params, req, runtime), new CreateBlockchainResponse({}));
  }

  /**
   * @param request CreateBlockchainRequest
   * @return CreateBlockchainResponse
   */
  async createBlockchain(request: CreateBlockchainRequest): Promise<CreateBlockchainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createBlockchainWithOptions(request, runtime);
  }

  /**
   * @param request CreateBlockchainApplicationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateBlockchainApplicationResponse
   */
  async createBlockchainApplicationWithOptions(request: CreateBlockchainApplicationRequest, runtime: $Util.RuntimeOptions): Promise<CreateBlockchainApplicationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.blockchainRegionId)) {
      body["BlockchainRegionId"] = request.blockchainRegionId;
    }

    if (!Util.isUnset(request.blockchainType)) {
      body["BlockchainType"] = request.blockchainType;
    }

    if (!Util.isUnset(request.cipherSuit)) {
      body["CipherSuit"] = request.cipherSuit;
    }

    if (!Util.isUnset(request.liveTime)) {
      body["LiveTime"] = request.liveTime;
    }

    if (!Util.isUnset(request.machineNum)) {
      body["MachineNum"] = request.machineNum;
    }

    if (!Util.isUnset(request.merkleTreeSuit)) {
      body["MerkleTreeSuit"] = request.merkleTreeSuit;
    }

    if (!Util.isUnset(request.size)) {
      body["Size"] = request.size;
    }

    if (!Util.isUnset(request.tlsAlgo)) {
      body["TlsAlgo"] = request.tlsAlgo;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateBlockchainApplication",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateBlockchainApplicationResponse>(await this.callApi(params, req, runtime), new CreateBlockchainApplicationResponse({}));
  }

  /**
   * @param request CreateBlockchainApplicationRequest
   * @return CreateBlockchainApplicationResponse
   */
  async createBlockchainApplication(request: CreateBlockchainApplicationRequest): Promise<CreateBlockchainApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createBlockchainApplicationWithOptions(request, runtime);
  }

  /**
   * @param request CreateBlockchainApplyRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateBlockchainApplyResponse
   */
  async createBlockchainApplyWithOptions(request: CreateBlockchainApplyRequest, runtime: $Util.RuntimeOptions): Promise<CreateBlockchainApplyResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.liveTime)) {
      body["LiveTime"] = request.liveTime;
    }

    if (!Util.isUnset(request.machineNum)) {
      body["MachineNum"] = request.machineNum;
    }

    if (!Util.isUnset(request.size)) {
      body["Size"] = request.size;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateBlockchainApply",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateBlockchainApplyResponse>(await this.callApi(params, req, runtime), new CreateBlockchainApplyResponse({}));
  }

  /**
   * @param request CreateBlockchainApplyRequest
   * @return CreateBlockchainApplyResponse
   */
  async createBlockchainApply(request: CreateBlockchainApplyRequest): Promise<CreateBlockchainApplyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createBlockchainApplyWithOptions(request, runtime);
  }

  /**
   * @param request CreateChaincodeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateChaincodeResponse
   */
  async createChaincodeWithOptions(request: CreateChaincodeRequest, runtime: $Util.RuntimeOptions): Promise<CreateChaincodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.endorsePolicy)) {
      body["EndorsePolicy"] = request.endorsePolicy;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.ossBucket)) {
      body["OssBucket"] = request.ossBucket;
    }

    if (!Util.isUnset(request.ossUrl)) {
      body["OssUrl"] = request.ossUrl;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateChaincode",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateChaincodeResponse>(await this.callApi(params, req, runtime), new CreateChaincodeResponse({}));
  }

  /**
   * @param request CreateChaincodeRequest
   * @return CreateChaincodeResponse
   */
  async createChaincode(request: CreateChaincodeRequest): Promise<CreateChaincodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createChaincodeWithOptions(request, runtime);
  }

  /**
   * @param request CreateChannelRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateChannelResponse
   */
  async createChannelWithOptions(request: CreateChannelRequest, runtime: $Util.RuntimeOptions): Promise<CreateChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelName)) {
      query["ChannelName"] = request.channelName;
    }

    if (!Util.isUnset(request.consortiumId)) {
      query["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.organization)) {
      query["Organization"] = request.organization;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.batchTimeout)) {
      body["BatchTimeout"] = request.batchTimeout;
    }

    if (!Util.isUnset(request.maxMessageCount)) {
      body["MaxMessageCount"] = request.maxMessageCount;
    }

    if (!Util.isUnset(request.preferredMaxBytes)) {
      body["PreferredMaxBytes"] = request.preferredMaxBytes;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateChannel",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateChannelResponse>(await this.callApi(params, req, runtime), new CreateChannelResponse({}));
  }

  /**
   * @param request CreateChannelRequest
   * @return CreateChannelResponse
   */
  async createChannel(request: CreateChannelRequest): Promise<CreateChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createChannelWithOptions(request, runtime);
  }

  /**
   * @param request CreateChannelMemberRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateChannelMemberResponse
   */
  async createChannelMemberWithOptions(request: CreateChannelMemberRequest, runtime: $Util.RuntimeOptions): Promise<CreateChannelMemberResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelId)) {
      query["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organization)) {
      query["Organization"] = request.organization;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateChannelMember",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateChannelMemberResponse>(await this.callApi(params, req, runtime), new CreateChannelMemberResponse({}));
  }

  /**
   * @param request CreateChannelMemberRequest
   * @return CreateChannelMemberResponse
   */
  async createChannelMember(request: CreateChannelMemberRequest): Promise<CreateChannelMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createChannelMemberWithOptions(request, runtime);
  }

  /**
   * @param request CreateCloudIntegrationServiceTokenRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateCloudIntegrationServiceTokenResponse
   */
  async createCloudIntegrationServiceTokenWithOptions(request: CreateCloudIntegrationServiceTokenRequest, runtime: $Util.RuntimeOptions): Promise<CreateCloudIntegrationServiceTokenResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.service)) {
      query["Service"] = request.service;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCloudIntegrationServiceToken",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCloudIntegrationServiceTokenResponse>(await this.callApi(params, req, runtime), new CreateCloudIntegrationServiceTokenResponse({}));
  }

  /**
   * @param request CreateCloudIntegrationServiceTokenRequest
   * @return CreateCloudIntegrationServiceTokenResponse
   */
  async createCloudIntegrationServiceToken(request: CreateCloudIntegrationServiceTokenRequest): Promise<CreateCloudIntegrationServiceTokenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCloudIntegrationServiceTokenWithOptions(request, runtime);
  }

  /**
   * @param request CreateCloudServiceIntegrationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateCloudServiceIntegrationResponse
   */
  async createCloudServiceIntegrationWithOptions(request: CreateCloudServiceIntegrationRequest, runtime: $Util.RuntimeOptions): Promise<CreateCloudServiceIntegrationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCloudServiceIntegration",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCloudServiceIntegrationResponse>(await this.callApi(params, req, runtime), new CreateCloudServiceIntegrationResponse({}));
  }

  /**
   * @param request CreateCloudServiceIntegrationRequest
   * @return CreateCloudServiceIntegrationResponse
   */
  async createCloudServiceIntegration(request: CreateCloudServiceIntegrationRequest): Promise<CreateCloudServiceIntegrationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCloudServiceIntegrationWithOptions(request, runtime);
  }

  /**
   * @param request CreateCloudServiceSessionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateCloudServiceSessionResponse
   */
  async createCloudServiceSessionWithOptions(request: CreateCloudServiceSessionRequest, runtime: $Util.RuntimeOptions): Promise<CreateCloudServiceSessionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateCloudServiceSession",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateCloudServiceSessionResponse>(await this.callApi(params, req, runtime), new CreateCloudServiceSessionResponse({}));
  }

  /**
   * @param request CreateCloudServiceSessionRequest
   * @return CreateCloudServiceSessionResponse
   */
  async createCloudServiceSession(request: CreateCloudServiceSessionRequest): Promise<CreateCloudServiceSessionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createCloudServiceSessionWithOptions(request, runtime);
  }

  /**
   * @param request CreateConsortiumRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateConsortiumResponse
   */
  async createConsortiumWithOptions(request: CreateConsortiumRequest, runtime: $Util.RuntimeOptions): Promise<CreateConsortiumResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelPolicy)) {
      body["ChannelPolicy"] = request.channelPolicy;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.domain)) {
      body["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.duration)) {
      body["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.majorVersion)) {
      body["MajorVersion"] = request.majorVersion;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.ordererType)) {
      body["OrdererType"] = request.ordererType;
    }

    if (!Util.isUnset(request.orderersCount)) {
      body["OrderersCount"] = request.orderersCount;
    }

    if (!Util.isUnset(request.organization)) {
      body["Organization"] = request.organization;
    }

    if (!Util.isUnset(request.peersCount)) {
      body["PeersCount"] = request.peersCount;
    }

    if (!Util.isUnset(request.pricingCycle)) {
      body["PricingCycle"] = request.pricingCycle;
    }

    if (!Util.isUnset(request.specName)) {
      body["SpecName"] = request.specName;
    }

    if (!Util.isUnset(request.zoneId)) {
      body["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateConsortium",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateConsortiumResponse>(await this.callApi(params, req, runtime), new CreateConsortiumResponse({}));
  }

  /**
   * @param request CreateConsortiumRequest
   * @return CreateConsortiumResponse
   */
  async createConsortium(request: CreateConsortiumRequest): Promise<CreateConsortiumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createConsortiumWithOptions(request, runtime);
  }

  /**
   * @param request CreateConsortiumMemberRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateConsortiumMemberResponse
   */
  async createConsortiumMemberWithOptions(request: CreateConsortiumMemberRequest, runtime: $Util.RuntimeOptions): Promise<CreateConsortiumMemberResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.code)) {
      query["Code"] = request.code;
    }

    if (!Util.isUnset(request.consortiumId)) {
      query["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.organization)) {
      query["Organization"] = request.organization;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "CreateConsortiumMember",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateConsortiumMemberResponse>(await this.callApi(params, req, runtime), new CreateConsortiumMemberResponse({}));
  }

  /**
   * @param request CreateConsortiumMemberRequest
   * @return CreateConsortiumMemberResponse
   */
  async createConsortiumMember(request: CreateConsortiumMemberRequest): Promise<CreateConsortiumMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createConsortiumMemberWithOptions(request, runtime);
  }

  /**
   * @param request CreateEcosphereRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateEcosphereResponse
   */
  async createEcosphereWithOptions(request: CreateEcosphereRequest, runtime: $Util.RuntimeOptions): Promise<CreateEcosphereResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelPolicy)) {
      body["ChannelPolicy"] = request.channelPolicy;
    }

    if (!Util.isUnset(request.consortiumName)) {
      body["ConsortiumName"] = request.consortiumName;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.duration)) {
      body["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.majorVersion)) {
      body["MajorVersion"] = request.majorVersion;
    }

    if (!Util.isUnset(request.ordererDomain)) {
      body["OrdererDomain"] = request.ordererDomain;
    }

    if (!Util.isUnset(request.ordererType)) {
      body["OrdererType"] = request.ordererType;
    }

    if (!Util.isUnset(request.orderersCount)) {
      body["OrderersCount"] = request.orderersCount;
    }

    if (!Util.isUnset(request.organization)) {
      body["Organization"] = request.organization;
    }

    if (!Util.isUnset(request.peersCount)) {
      body["PeersCount"] = request.peersCount;
    }

    if (!Util.isUnset(request.pricingCycle)) {
      body["PricingCycle"] = request.pricingCycle;
    }

    if (!Util.isUnset(request.specName)) {
      body["SpecName"] = request.specName;
    }

    if (!Util.isUnset(request.zoneId)) {
      body["ZoneId"] = request.zoneId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateEcosphere",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEcosphereResponse>(await this.callApi(params, req, runtime), new CreateEcosphereResponse({}));
  }

  /**
   * @param request CreateEcosphereRequest
   * @return CreateEcosphereResponse
   */
  async createEcosphere(request: CreateEcosphereRequest): Promise<CreateEcosphereResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEcosphereWithOptions(request, runtime);
  }

  /**
   * @param request CreateEthereumRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateEthereumResponse
   */
  async createEthereumWithOptions(request: CreateEthereumRequest, runtime: $Util.RuntimeOptions): Promise<CreateEthereumResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consensus)) {
      body["Consensus"] = request.consensus;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.difficulty)) {
      body["Difficulty"] = request.difficulty;
    }

    if (!Util.isUnset(request.gas)) {
      body["Gas"] = request.gas;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.networkId)) {
      body["NetworkId"] = request.networkId;
    }

    if (!Util.isUnset(request.node)) {
      body["Node"] = request.node;
    }

    if (!Util.isUnset(request.region)) {
      body["Region"] = request.region;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateEthereum",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEthereumResponse>(await this.callApi(params, req, runtime), new CreateEthereumResponse({}));
  }

  /**
   * @param request CreateEthereumRequest
   * @return CreateEthereumResponse
   */
  async createEthereum(request: CreateEthereumRequest): Promise<CreateEthereumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEthereumWithOptions(request, runtime);
  }

  /**
   * @param request CreateEthereumInvitationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateEthereumInvitationResponse
   */
  async createEthereumInvitationWithOptions(request: CreateEthereumInvitationRequest, runtime: $Util.RuntimeOptions): Promise<CreateEthereumInvitationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ethereumId)) {
      body["EthereumId"] = request.ethereumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateEthereumInvitation",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateEthereumInvitationResponse>(await this.callApi(params, req, runtime), new CreateEthereumInvitationResponse({}));
  }

  /**
   * @param request CreateEthereumInvitationRequest
   * @return CreateEthereumInvitationResponse
   */
  async createEthereumInvitation(request: CreateEthereumInvitationRequest): Promise<CreateEthereumInvitationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createEthereumInvitationWithOptions(request, runtime);
  }

  /**
   * @param request CreateFabricChaincodePackageRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateFabricChaincodePackageResponse
   */
  async createFabricChaincodePackageWithOptions(request: CreateFabricChaincodePackageRequest, runtime: $Util.RuntimeOptions): Promise<CreateFabricChaincodePackageResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.ossBucket)) {
      body["OssBucket"] = request.ossBucket;
    }

    if (!Util.isUnset(request.ossUrl)) {
      body["OssUrl"] = request.ossUrl;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateFabricChaincodePackage",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateFabricChaincodePackageResponse>(await this.callApi(params, req, runtime), new CreateFabricChaincodePackageResponse({}));
  }

  /**
   * @param request CreateFabricChaincodePackageRequest
   * @return CreateFabricChaincodePackageResponse
   */
  async createFabricChaincodePackage(request: CreateFabricChaincodePackageRequest): Promise<CreateFabricChaincodePackageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createFabricChaincodePackageWithOptions(request, runtime);
  }

  /**
   * @param request CreateOrganizationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateOrganizationResponse
   */
  async createOrganizationWithOptions(request: CreateOrganizationRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrganizationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.description)) {
      query["Description"] = request.description;
    }

    if (!Util.isUnset(request.domain)) {
      query["Domain"] = request.domain;
    }

    if (!Util.isUnset(request.duration)) {
      query["Duration"] = request.duration;
    }

    if (!Util.isUnset(request.location)) {
      query["Location"] = request.location;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.peersCount)) {
      query["PeersCount"] = request.peersCount;
    }

    if (!Util.isUnset(request.pricingCycle)) {
      query["PricingCycle"] = request.pricingCycle;
    }

    if (!Util.isUnset(request.specName)) {
      query["SpecName"] = request.specName;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.majorVersion)) {
      body["MajorVersion"] = request.majorVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrganization",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOrganizationResponse>(await this.callApi(params, req, runtime), new CreateOrganizationResponse({}));
  }

  /**
   * @param request CreateOrganizationRequest
   * @return CreateOrganizationResponse
   */
  async createOrganization(request: CreateOrganizationRequest): Promise<CreateOrganizationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrganizationWithOptions(request, runtime);
  }

  /**
   * @param request CreateOrganizationUserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateOrganizationUserResponse
   */
  async createOrganizationUserWithOptions(request: CreateOrganizationUserRequest, runtime: $Util.RuntimeOptions): Promise<CreateOrganizationUserResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.attrs)) {
      body["Attrs"] = request.attrs;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.username)) {
      body["Username"] = request.username;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOrganizationUser",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOrganizationUserResponse>(await this.callApi(params, req, runtime), new CreateOrganizationUserResponse({}));
  }

  /**
   * @param request CreateOrganizationUserRequest
   * @return CreateOrganizationUserResponse
   */
  async createOrganizationUser(request: CreateOrganizationUserRequest): Promise<CreateOrganizationUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOrganizationUserWithOptions(request, runtime);
  }

  /**
   * @param request CreateOwnAccountRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateOwnAccountResponse
   */
  async createOwnAccountWithOptions(request: CreateOwnAccountRequest, runtime: $Util.RuntimeOptions): Promise<CreateOwnAccountResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.identity)) {
      body["Identity"] = request.identity;
    }

    if (!Util.isUnset(request.publicKey)) {
      body["PublicKey"] = request.publicKey;
    }

    if (!Util.isUnset(request.recoveryKey)) {
      body["RecoveryKey"] = request.recoveryKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateOwnAccount",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateOwnAccountResponse>(await this.callApi(params, req, runtime), new CreateOwnAccountResponse({}));
  }

  /**
   * @param request CreateOwnAccountRequest
   * @return CreateOwnAccountResponse
   */
  async createOwnAccount(request: CreateOwnAccountRequest): Promise<CreateOwnAccountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createOwnAccountWithOptions(request, runtime);
  }

  /**
   * @param request CreatePublicAccountWithKeyPairAutoCreationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreatePublicAccountWithKeyPairAutoCreationResponse
   */
  async createPublicAccountWithKeyPairAutoCreationWithOptions(request: CreatePublicAccountWithKeyPairAutoCreationRequest, runtime: $Util.RuntimeOptions): Promise<CreatePublicAccountWithKeyPairAutoCreationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.account)) {
      body["Account"] = request.account;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.recoverPassword)) {
      body["RecoverPassword"] = request.recoverPassword;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreatePublicAccountWithKeyPairAutoCreation",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePublicAccountWithKeyPairAutoCreationResponse>(await this.callApi(params, req, runtime), new CreatePublicAccountWithKeyPairAutoCreationResponse({}));
  }

  /**
   * @param request CreatePublicAccountWithKeyPairAutoCreationRequest
   * @return CreatePublicAccountWithKeyPairAutoCreationResponse
   */
  async createPublicAccountWithKeyPairAutoCreation(request: CreatePublicAccountWithKeyPairAutoCreationRequest): Promise<CreatePublicAccountWithKeyPairAutoCreationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPublicAccountWithKeyPairAutoCreationWithOptions(request, runtime);
  }

  /**
   * @param request CreatePublicAntChainAccountRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreatePublicAntChainAccountResponse
   */
  async createPublicAntChainAccountWithOptions(request: CreatePublicAntChainAccountRequest, runtime: $Util.RuntimeOptions): Promise<CreatePublicAntChainAccountResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.account)) {
      body["Account"] = request.account;
    }

    if (!Util.isUnset(request.accountPubKey)) {
      body["AccountPubKey"] = request.accountPubKey;
    }

    if (!Util.isUnset(request.accountRecoverPubKey)) {
      body["AccountRecoverPubKey"] = request.accountRecoverPubKey;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreatePublicAntChainAccount",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreatePublicAntChainAccountResponse>(await this.callApi(params, req, runtime), new CreatePublicAntChainAccountResponse({}));
  }

  /**
   * @param request CreatePublicAntChainAccountRequest
   * @return CreatePublicAntChainAccountResponse
   */
  async createPublicAntChainAccount(request: CreatePublicAntChainAccountRequest): Promise<CreatePublicAntChainAccountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createPublicAntChainAccountWithOptions(request, runtime);
  }

  /**
   * @param request CreateSmartContractJobRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateSmartContractJobResponse
   */
  async createSmartContractJobWithOptions(runtime: $Util.RuntimeOptions): Promise<CreateSmartContractJobResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "CreateSmartContractJob",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateSmartContractJobResponse>(await this.callApi(params, req, runtime), new CreateSmartContractJobResponse({}));
  }

  /**
   * @return CreateSmartContractJobResponse
   */
  async createSmartContractJob(): Promise<CreateSmartContractJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createSmartContractJobWithOptions(runtime);
  }

  /**
   * @param request CreateTriggerRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return CreateTriggerResponse
   */
  async createTriggerWithOptions(request: CreateTriggerRequest, runtime: $Util.RuntimeOptions): Promise<CreateTriggerResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.options)) {
      body["Options"] = request.options;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.source)) {
      body["Source"] = request.source;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    if (!Util.isUnset(request.type)) {
      body["Type"] = request.type;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "CreateTrigger",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<CreateTriggerResponse>(await this.callApi(params, req, runtime), new CreateTriggerResponse({}));
  }

  /**
   * @param request CreateTriggerRequest
   * @return CreateTriggerResponse
   */
  async createTrigger(request: CreateTriggerRequest): Promise<CreateTriggerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.createTriggerWithOptions(request, runtime);
  }

  /**
   * @param request DeleteAntChainConsortiumRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteAntChainConsortiumResponse
   */
  async deleteAntChainConsortiumWithOptions(request: DeleteAntChainConsortiumRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAntChainConsortiumResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAntChainConsortium",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAntChainConsortiumResponse>(await this.callApi(params, req, runtime), new DeleteAntChainConsortiumResponse({}));
  }

  /**
   * @param request DeleteAntChainConsortiumRequest
   * @return DeleteAntChainConsortiumResponse
   */
  async deleteAntChainConsortium(request: DeleteAntChainConsortiumRequest): Promise<DeleteAntChainConsortiumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAntChainConsortiumWithOptions(request, runtime);
  }

  /**
   * @param request DeleteAntChainContractContentRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteAntChainContractContentResponse
   */
  async deleteAntChainContractContentWithOptions(request: DeleteAntChainContractContentRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAntChainContractContentResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.contentId)) {
      body["ContentId"] = request.contentId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAntChainContractContent",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAntChainContractContentResponse>(await this.callApi(params, req, runtime), new DeleteAntChainContractContentResponse({}));
  }

  /**
   * @param request DeleteAntChainContractContentRequest
   * @return DeleteAntChainContractContentResponse
   */
  async deleteAntChainContractContent(request: DeleteAntChainContractContentRequest): Promise<DeleteAntChainContractContentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAntChainContractContentWithOptions(request, runtime);
  }

  /**
   * @param request DeleteAntChainContractProjectRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteAntChainContractProjectResponse
   */
  async deleteAntChainContractProjectWithOptions(request: DeleteAntChainContractProjectRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAntChainContractProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAntChainContractProject",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAntChainContractProjectResponse>(await this.callApi(params, req, runtime), new DeleteAntChainContractProjectResponse({}));
  }

  /**
   * @param request DeleteAntChainContractProjectRequest
   * @return DeleteAntChainContractProjectResponse
   */
  async deleteAntChainContractProject(request: DeleteAntChainContractProjectRequest): Promise<DeleteAntChainContractProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAntChainContractProjectWithOptions(request, runtime);
  }

  /**
   * @param request DeleteAntChainMiniAppQRCodeAuthorizedUserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteAntChainMiniAppQRCodeAuthorizedUserResponse
   */
  async deleteAntChainMiniAppQRCodeAuthorizedUserWithOptions(request: DeleteAntChainMiniAppQRCodeAuthorizedUserRequest, runtime: $Util.RuntimeOptions): Promise<DeleteAntChainMiniAppQRCodeAuthorizedUserResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.phone)) {
      body["Phone"] = request.phone;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteAntChainMiniAppQRCodeAuthorizedUser",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteAntChainMiniAppQRCodeAuthorizedUserResponse>(await this.callApi(params, req, runtime), new DeleteAntChainMiniAppQRCodeAuthorizedUserResponse({}));
  }

  /**
   * @param request DeleteAntChainMiniAppQRCodeAuthorizedUserRequest
   * @return DeleteAntChainMiniAppQRCodeAuthorizedUserResponse
   */
  async deleteAntChainMiniAppQRCodeAuthorizedUser(request: DeleteAntChainMiniAppQRCodeAuthorizedUserRequest): Promise<DeleteAntChainMiniAppQRCodeAuthorizedUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteAntChainMiniAppQRCodeAuthorizedUserWithOptions(request, runtime);
  }

  /**
   * @param request DeleteChaincodeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteChaincodeResponse
   */
  async deleteChaincodeWithOptions(request: DeleteChaincodeRequest, runtime: $Util.RuntimeOptions): Promise<DeleteChaincodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodeId)) {
      body["ChaincodeId"] = request.chaincodeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteChaincode",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteChaincodeResponse>(await this.callApi(params, req, runtime), new DeleteChaincodeResponse({}));
  }

  /**
   * @param request DeleteChaincodeRequest
   * @return DeleteChaincodeResponse
   */
  async deleteChaincode(request: DeleteChaincodeRequest): Promise<DeleteChaincodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteChaincodeWithOptions(request, runtime);
  }

  /**
   * @param request DeleteGovernanceTaskRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteGovernanceTaskResponse
   */
  async deleteGovernanceTaskWithOptions(request: DeleteGovernanceTaskRequest, runtime: $Util.RuntimeOptions): Promise<DeleteGovernanceTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.taskId)) {
      body["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DeleteGovernanceTask",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteGovernanceTaskResponse>(await this.callApi(params, req, runtime), new DeleteGovernanceTaskResponse({}));
  }

  /**
   * @param request DeleteGovernanceTaskRequest
   * @return DeleteGovernanceTaskResponse
   */
  async deleteGovernanceTask(request: DeleteGovernanceTaskRequest): Promise<DeleteGovernanceTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteGovernanceTaskWithOptions(request, runtime);
  }

  /**
   * @param request DeleteTriggerRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DeleteTriggerResponse
   */
  async deleteTriggerWithOptions(request: DeleteTriggerRequest, runtime: $Util.RuntimeOptions): Promise<DeleteTriggerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelId)) {
      query["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DeleteTrigger",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DeleteTriggerResponse>(await this.callApi(params, req, runtime), new DeleteTriggerResponse({}));
  }

  /**
   * @param request DeleteTriggerRequest
   * @return DeleteTriggerResponse
   */
  async deleteTrigger(request: DeleteTriggerRequest): Promise<DeleteTriggerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.deleteTriggerWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainAccountsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainAccountsResponse
   */
  async describeAntChainAccountsWithOptions(request: DescribeAntChainAccountsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainAccountsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainAccounts",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainAccountsResponse>(await this.callApi(params, req, runtime), new DescribeAntChainAccountsResponse({}));
  }

  /**
   * @param request DescribeAntChainAccountsRequest
   * @return DescribeAntChainAccountsResponse
   */
  async describeAntChainAccounts(request: DescribeAntChainAccountsRequest): Promise<DescribeAntChainAccountsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainAccountsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainAccountsNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainAccountsNewResponse
   */
  async describeAntChainAccountsNewWithOptions(request: DescribeAntChainAccountsNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainAccountsNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainAccountsNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainAccountsNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainAccountsNewResponse({}));
  }

  /**
   * @param request DescribeAntChainAccountsNewRequest
   * @return DescribeAntChainAccountsNewResponse
   */
  async describeAntChainAccountsNew(request: DescribeAntChainAccountsNewRequest): Promise<DescribeAntChainAccountsNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainAccountsNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainApplicationsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainApplicationsResponse
   */
  async describeAntChainApplicationsWithOptions(request: DescribeAntChainApplicationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainApplicationsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.current)) {
      body["Current"] = request.current;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainApplications",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainApplicationsResponse>(await this.callApi(params, req, runtime), new DescribeAntChainApplicationsResponse({}));
  }

  /**
   * @param request DescribeAntChainApplicationsRequest
   * @return DescribeAntChainApplicationsResponse
   */
  async describeAntChainApplications(request: DescribeAntChainApplicationsRequest): Promise<DescribeAntChainApplicationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainApplicationsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainBlockRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainBlockResponse
   */
  async describeAntChainBlockWithOptions(request: DescribeAntChainBlockRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainBlockResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.height)) {
      body["Height"] = request.height;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainBlock",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainBlockResponse>(await this.callApi(params, req, runtime), new DescribeAntChainBlockResponse({}));
  }

  /**
   * @param request DescribeAntChainBlockRequest
   * @return DescribeAntChainBlockResponse
   */
  async describeAntChainBlock(request: DescribeAntChainBlockRequest): Promise<DescribeAntChainBlockResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainBlockWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainBlockNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainBlockNewResponse
   */
  async describeAntChainBlockNewWithOptions(request: DescribeAntChainBlockNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainBlockNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.height)) {
      body["Height"] = request.height;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainBlockNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainBlockNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainBlockNewResponse({}));
  }

  /**
   * @param request DescribeAntChainBlockNewRequest
   * @return DescribeAntChainBlockNewResponse
   */
  async describeAntChainBlockNew(request: DescribeAntChainBlockNewRequest): Promise<DescribeAntChainBlockNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainBlockNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainCertificateApplicationsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainCertificateApplicationsResponse
   */
  async describeAntChainCertificateApplicationsWithOptions(request: DescribeAntChainCertificateApplicationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainCertificateApplicationsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainCertificateApplications",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainCertificateApplicationsResponse>(await this.callApi(params, req, runtime), new DescribeAntChainCertificateApplicationsResponse({}));
  }

  /**
   * @param request DescribeAntChainCertificateApplicationsRequest
   * @return DescribeAntChainCertificateApplicationsResponse
   */
  async describeAntChainCertificateApplications(request: DescribeAntChainCertificateApplicationsRequest): Promise<DescribeAntChainCertificateApplicationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainCertificateApplicationsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainCertificateApplicationsNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainCertificateApplicationsNewResponse
   */
  async describeAntChainCertificateApplicationsNewWithOptions(request: DescribeAntChainCertificateApplicationsNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainCertificateApplicationsNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainCertificateApplicationsNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainCertificateApplicationsNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainCertificateApplicationsNewResponse({}));
  }

  /**
   * @param request DescribeAntChainCertificateApplicationsNewRequest
   * @return DescribeAntChainCertificateApplicationsNewResponse
   */
  async describeAntChainCertificateApplicationsNew(request: DescribeAntChainCertificateApplicationsNewRequest): Promise<DescribeAntChainCertificateApplicationsNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainCertificateApplicationsNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainConfigOptionsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainConfigOptionsResponse
   */
  async describeAntChainConfigOptionsWithOptions(request: DescribeAntChainConfigOptionsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainConfigOptionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.purpose)) {
      query["Purpose"] = request.purpose;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainConfigOptions",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainConfigOptionsResponse>(await this.callApi(params, req, runtime), new DescribeAntChainConfigOptionsResponse({}));
  }

  /**
   * @param request DescribeAntChainConfigOptionsRequest
   * @return DescribeAntChainConfigOptionsResponse
   */
  async describeAntChainConfigOptions(request: DescribeAntChainConfigOptionsRequest): Promise<DescribeAntChainConfigOptionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainConfigOptionsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainConsortiumsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainConsortiumsResponse
   */
  async describeAntChainConsortiumsWithOptions(request: DescribeAntChainConsortiumsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainConsortiumsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainConsortiums",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainConsortiumsResponse>(await this.callApi(params, req, runtime), new DescribeAntChainConsortiumsResponse({}));
  }

  /**
   * @param request DescribeAntChainConsortiumsRequest
   * @return DescribeAntChainConsortiumsResponse
   */
  async describeAntChainConsortiums(request: DescribeAntChainConsortiumsRequest): Promise<DescribeAntChainConsortiumsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainConsortiumsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainConsortiumsNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainConsortiumsNewResponse
   */
  async describeAntChainConsortiumsNewWithOptions(request: DescribeAntChainConsortiumsNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainConsortiumsNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainConsortiumsNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainConsortiumsNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainConsortiumsNewResponse({}));
  }

  /**
   * @param request DescribeAntChainConsortiumsNewRequest
   * @return DescribeAntChainConsortiumsNewResponse
   */
  async describeAntChainConsortiumsNew(request: DescribeAntChainConsortiumsNewRequest): Promise<DescribeAntChainConsortiumsNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainConsortiumsNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainContractProjectContentTreeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainContractProjectContentTreeResponse
   */
  async describeAntChainContractProjectContentTreeWithOptions(request: DescribeAntChainContractProjectContentTreeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainContractProjectContentTreeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainContractProjectContentTree",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainContractProjectContentTreeResponse>(await this.callApi(params, req, runtime), new DescribeAntChainContractProjectContentTreeResponse({}));
  }

  /**
   * @param request DescribeAntChainContractProjectContentTreeRequest
   * @return DescribeAntChainContractProjectContentTreeResponse
   */
  async describeAntChainContractProjectContentTree(request: DescribeAntChainContractProjectContentTreeRequest): Promise<DescribeAntChainContractProjectContentTreeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainContractProjectContentTreeWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainContractProjectContentTreeNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainContractProjectContentTreeNewResponse
   */
  async describeAntChainContractProjectContentTreeNewWithOptions(request: DescribeAntChainContractProjectContentTreeNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainContractProjectContentTreeNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainContractProjectContentTreeNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainContractProjectContentTreeNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainContractProjectContentTreeNewResponse({}));
  }

  /**
   * @param request DescribeAntChainContractProjectContentTreeNewRequest
   * @return DescribeAntChainContractProjectContentTreeNewResponse
   */
  async describeAntChainContractProjectContentTreeNew(request: DescribeAntChainContractProjectContentTreeNewRequest): Promise<DescribeAntChainContractProjectContentTreeNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainContractProjectContentTreeNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainContractProjectsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainContractProjectsResponse
   */
  async describeAntChainContractProjectsWithOptions(request: DescribeAntChainContractProjectsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainContractProjectsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainContractProjects",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainContractProjectsResponse>(await this.callApi(params, req, runtime), new DescribeAntChainContractProjectsResponse({}));
  }

  /**
   * @param request DescribeAntChainContractProjectsRequest
   * @return DescribeAntChainContractProjectsResponse
   */
  async describeAntChainContractProjects(request: DescribeAntChainContractProjectsRequest): Promise<DescribeAntChainContractProjectsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainContractProjectsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainContractProjectsNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainContractProjectsNewResponse
   */
  async describeAntChainContractProjectsNewWithOptions(request: DescribeAntChainContractProjectsNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainContractProjectsNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainContractProjectsNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainContractProjectsNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainContractProjectsNewResponse({}));
  }

  /**
   * @param request DescribeAntChainContractProjectsNewRequest
   * @return DescribeAntChainContractProjectsNewResponse
   */
  async describeAntChainContractProjectsNew(request: DescribeAntChainContractProjectsNewRequest): Promise<DescribeAntChainContractProjectsNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainContractProjectsNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainDownloadPathsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainDownloadPathsResponse
   */
  async describeAntChainDownloadPathsWithOptions(request: DescribeAntChainDownloadPathsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainDownloadPathsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainDownloadPaths",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainDownloadPathsResponse>(await this.callApi(params, req, runtime), new DescribeAntChainDownloadPathsResponse({}));
  }

  /**
   * @param request DescribeAntChainDownloadPathsRequest
   * @return DescribeAntChainDownloadPathsResponse
   */
  async describeAntChainDownloadPaths(request: DescribeAntChainDownloadPathsRequest): Promise<DescribeAntChainDownloadPathsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainDownloadPathsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainDownloadPathsNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainDownloadPathsNewResponse
   */
  async describeAntChainDownloadPathsNewWithOptions(request: DescribeAntChainDownloadPathsNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainDownloadPathsNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainDownloadPathsNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainDownloadPathsNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainDownloadPathsNewResponse({}));
  }

  /**
   * @param request DescribeAntChainDownloadPathsNewRequest
   * @return DescribeAntChainDownloadPathsNewResponse
   */
  async describeAntChainDownloadPathsNew(request: DescribeAntChainDownloadPathsNewRequest): Promise<DescribeAntChainDownloadPathsNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainDownloadPathsNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainInformationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainInformationResponse
   */
  async describeAntChainInformationWithOptions(request: DescribeAntChainInformationRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainInformationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainInformation",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainInformationResponse>(await this.callApi(params, req, runtime), new DescribeAntChainInformationResponse({}));
  }

  /**
   * @param request DescribeAntChainInformationRequest
   * @return DescribeAntChainInformationResponse
   */
  async describeAntChainInformation(request: DescribeAntChainInformationRequest): Promise<DescribeAntChainInformationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainInformationWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainInformationNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainInformationNewResponse
   */
  async describeAntChainInformationNewWithOptions(request: DescribeAntChainInformationNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainInformationNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainInformationNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainInformationNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainInformationNewResponse({}));
  }

  /**
   * @param request DescribeAntChainInformationNewRequest
   * @return DescribeAntChainInformationNewResponse
   */
  async describeAntChainInformationNew(request: DescribeAntChainInformationNewRequest): Promise<DescribeAntChainInformationNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainInformationNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainLatestBlocksRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainLatestBlocksResponse
   */
  async describeAntChainLatestBlocksWithOptions(request: DescribeAntChainLatestBlocksRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainLatestBlocksResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainLatestBlocks",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainLatestBlocksResponse>(await this.callApi(params, req, runtime), new DescribeAntChainLatestBlocksResponse({}));
  }

  /**
   * @param request DescribeAntChainLatestBlocksRequest
   * @return DescribeAntChainLatestBlocksResponse
   */
  async describeAntChainLatestBlocks(request: DescribeAntChainLatestBlocksRequest): Promise<DescribeAntChainLatestBlocksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainLatestBlocksWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainLatestBlocksNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainLatestBlocksNewResponse
   */
  async describeAntChainLatestBlocksNewWithOptions(request: DescribeAntChainLatestBlocksNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainLatestBlocksNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainLatestBlocksNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainLatestBlocksNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainLatestBlocksNewResponse({}));
  }

  /**
   * @param request DescribeAntChainLatestBlocksNewRequest
   * @return DescribeAntChainLatestBlocksNewResponse
   */
  async describeAntChainLatestBlocksNew(request: DescribeAntChainLatestBlocksNewRequest): Promise<DescribeAntChainLatestBlocksNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainLatestBlocksNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainLatestTransactionDigestsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainLatestTransactionDigestsResponse
   */
  async describeAntChainLatestTransactionDigestsWithOptions(request: DescribeAntChainLatestTransactionDigestsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainLatestTransactionDigestsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainLatestTransactionDigests",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainLatestTransactionDigestsResponse>(await this.callApi(params, req, runtime), new DescribeAntChainLatestTransactionDigestsResponse({}));
  }

  /**
   * @param request DescribeAntChainLatestTransactionDigestsRequest
   * @return DescribeAntChainLatestTransactionDigestsResponse
   */
  async describeAntChainLatestTransactionDigests(request: DescribeAntChainLatestTransactionDigestsRequest): Promise<DescribeAntChainLatestTransactionDigestsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainLatestTransactionDigestsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainLatestTransactionDigestsNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainLatestTransactionDigestsNewResponse
   */
  async describeAntChainLatestTransactionDigestsNewWithOptions(request: DescribeAntChainLatestTransactionDigestsNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainLatestTransactionDigestsNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainLatestTransactionDigestsNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainLatestTransactionDigestsNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainLatestTransactionDigestsNewResponse({}));
  }

  /**
   * @param request DescribeAntChainLatestTransactionDigestsNewRequest
   * @return DescribeAntChainLatestTransactionDigestsNewResponse
   */
  async describeAntChainLatestTransactionDigestsNew(request: DescribeAntChainLatestTransactionDigestsNewRequest): Promise<DescribeAntChainLatestTransactionDigestsNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainLatestTransactionDigestsNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainMembersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainMembersResponse
   */
  async describeAntChainMembersWithOptions(request: DescribeAntChainMembersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainMembersResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainMembers",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainMembersResponse>(await this.callApi(params, req, runtime), new DescribeAntChainMembersResponse({}));
  }

  /**
   * @param request DescribeAntChainMembersRequest
   * @return DescribeAntChainMembersResponse
   */
  async describeAntChainMembers(request: DescribeAntChainMembersRequest): Promise<DescribeAntChainMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainMembersWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainMembersNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainMembersNewResponse
   */
  async describeAntChainMembersNewWithOptions(request: DescribeAntChainMembersNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainMembersNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainMembersNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainMembersNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainMembersNewResponse({}));
  }

  /**
   * @param request DescribeAntChainMembersNewRequest
   * @return DescribeAntChainMembersNewResponse
   */
  async describeAntChainMembersNew(request: DescribeAntChainMembersNewRequest): Promise<DescribeAntChainMembersNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainMembersNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse
   */
  async describeAntChainMiniAppBrowserQRCodeAccessLogWithOptions(request: DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.QRCodeType)) {
      body["QRCodeType"] = request.QRCodeType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainMiniAppBrowserQRCodeAccessLog",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse>(await this.callApi(params, req, runtime), new DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse({}));
  }

  /**
   * @param request DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest
   * @return DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse
   */
  async describeAntChainMiniAppBrowserQRCodeAccessLog(request: DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest): Promise<DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainMiniAppBrowserQRCodeAccessLogWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse
   */
  async describeAntChainMiniAppBrowserQRCodeAccessLogNewWithOptions(request: DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.QRCodeType)) {
      body["QRCodeType"] = request.QRCodeType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainMiniAppBrowserQRCodeAccessLogNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse({}));
  }

  /**
   * @param request DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest
   * @return DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse
   */
  async describeAntChainMiniAppBrowserQRCodeAccessLogNew(request: DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest): Promise<DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainMiniAppBrowserQRCodeAccessLogNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse
   */
  async describeAntChainMiniAppBrowserQRCodeAuthorizedUsersWithOptions(request: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.QRCodeType)) {
      body["QRCodeType"] = request.QRCodeType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsers",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse>(await this.callApi(params, req, runtime), new DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse({}));
  }

  /**
   * @param request DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest
   * @return DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse
   */
  async describeAntChainMiniAppBrowserQRCodeAuthorizedUsers(request: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest): Promise<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainMiniAppBrowserQRCodeAuthorizedUsersWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse
   */
  async describeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewWithOptions(request: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.QRCodeType)) {
      body["QRCodeType"] = request.QRCodeType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse({}));
  }

  /**
   * @param request DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest
   * @return DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse
   */
  async describeAntChainMiniAppBrowserQRCodeAuthorizedUsersNew(request: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest): Promise<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainMiniAppBrowserTransactionQRCodeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainMiniAppBrowserTransactionQRCodeResponse
   */
  async describeAntChainMiniAppBrowserTransactionQRCodeWithOptions(request: DescribeAntChainMiniAppBrowserTransactionQRCodeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainMiniAppBrowserTransactionQRCodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.transactionHash)) {
      body["TransactionHash"] = request.transactionHash;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainMiniAppBrowserTransactionQRCode",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainMiniAppBrowserTransactionQRCodeResponse>(await this.callApi(params, req, runtime), new DescribeAntChainMiniAppBrowserTransactionQRCodeResponse({}));
  }

  /**
   * @param request DescribeAntChainMiniAppBrowserTransactionQRCodeRequest
   * @return DescribeAntChainMiniAppBrowserTransactionQRCodeResponse
   */
  async describeAntChainMiniAppBrowserTransactionQRCode(request: DescribeAntChainMiniAppBrowserTransactionQRCodeRequest): Promise<DescribeAntChainMiniAppBrowserTransactionQRCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainMiniAppBrowserTransactionQRCodeWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse
   */
  async describeAntChainMiniAppBrowserTransactionQRCodeNewWithOptions(request: DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.contractId)) {
      body["ContractId"] = request.contractId;
    }

    if (!Util.isUnset(request.transactionHash)) {
      body["TransactionHash"] = request.transactionHash;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainMiniAppBrowserTransactionQRCodeNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse({}));
  }

  /**
   * @param request DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest
   * @return DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse
   */
  async describeAntChainMiniAppBrowserTransactionQRCodeNew(request: DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest): Promise<DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainMiniAppBrowserTransactionQRCodeNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainNodesNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainNodesNewResponse
   */
  async describeAntChainNodesNewWithOptions(request: DescribeAntChainNodesNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainNodesNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainNodesNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainNodesNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainNodesNewResponse({}));
  }

  /**
   * @param request DescribeAntChainNodesNewRequest
   * @return DescribeAntChainNodesNewResponse
   */
  async describeAntChainNodesNew(request: DescribeAntChainNodesNewRequest): Promise<DescribeAntChainNodesNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainNodesNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainQRCodeAuthorizationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainQRCodeAuthorizationResponse
   */
  async describeAntChainQRCodeAuthorizationWithOptions(request: DescribeAntChainQRCodeAuthorizationRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainQRCodeAuthorizationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.QRCodeType)) {
      body["QRCodeType"] = request.QRCodeType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainQRCodeAuthorization",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainQRCodeAuthorizationResponse>(await this.callApi(params, req, runtime), new DescribeAntChainQRCodeAuthorizationResponse({}));
  }

  /**
   * @param request DescribeAntChainQRCodeAuthorizationRequest
   * @return DescribeAntChainQRCodeAuthorizationResponse
   */
  async describeAntChainQRCodeAuthorization(request: DescribeAntChainQRCodeAuthorizationRequest): Promise<DescribeAntChainQRCodeAuthorizationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainQRCodeAuthorizationWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainQRCodeAuthorizationNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainQRCodeAuthorizationNewResponse
   */
  async describeAntChainQRCodeAuthorizationNewWithOptions(request: DescribeAntChainQRCodeAuthorizationNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainQRCodeAuthorizationNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.QRCodeType)) {
      body["QRCodeType"] = request.QRCodeType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainQRCodeAuthorizationNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainQRCodeAuthorizationNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainQRCodeAuthorizationNewResponse({}));
  }

  /**
   * @param request DescribeAntChainQRCodeAuthorizationNewRequest
   * @return DescribeAntChainQRCodeAuthorizationNewResponse
   */
  async describeAntChainQRCodeAuthorizationNew(request: DescribeAntChainQRCodeAuthorizationNewRequest): Promise<DescribeAntChainQRCodeAuthorizationNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainQRCodeAuthorizationNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainRegionNamesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainRegionNamesResponse
   */
  async describeAntChainRegionNamesWithOptions(request: DescribeAntChainRegionNamesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainRegionNamesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.locale)) {
      body["Locale"] = request.locale;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainRegionNames",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainRegionNamesResponse>(await this.callApi(params, req, runtime), new DescribeAntChainRegionNamesResponse({}));
  }

  /**
   * @param request DescribeAntChainRegionNamesRequest
   * @return DescribeAntChainRegionNamesResponse
   */
  async describeAntChainRegionNames(request: DescribeAntChainRegionNamesRequest): Promise<DescribeAntChainRegionNamesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainRegionNamesWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainRegionsForSaleRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainRegionsForSaleResponse
   */
  async describeAntChainRegionsForSaleWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeAntChainRegionsForSaleResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainRegionsForSale",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainRegionsForSaleResponse>(await this.callApi(params, req, runtime), new DescribeAntChainRegionsForSaleResponse({}));
  }

  /**
   * @return DescribeAntChainRegionsForSaleResponse
   */
  async describeAntChainRegionsForSale(): Promise<DescribeAntChainRegionsForSaleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainRegionsForSaleWithOptions(runtime);
  }

  /**
   * @param request DescribeAntChainResourceTypesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainResourceTypesResponse
   */
  async describeAntChainResourceTypesWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeAntChainResourceTypesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainResourceTypes",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainResourceTypesResponse>(await this.callApi(params, req, runtime), new DescribeAntChainResourceTypesResponse({}));
  }

  /**
   * @return DescribeAntChainResourceTypesResponse
   */
  async describeAntChainResourceTypes(): Promise<DescribeAntChainResourceTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainResourceTypesWithOptions(runtime);
  }

  /**
   * @param request DescribeAntChainRestRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainRestResponse
   */
  async describeAntChainRestWithOptions(request: DescribeAntChainRestRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainRestResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainRest",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainRestResponse>(await this.callApi(params, req, runtime), new DescribeAntChainRestResponse({}));
  }

  /**
   * @param request DescribeAntChainRestRequest
   * @return DescribeAntChainRestResponse
   */
  async describeAntChainRest(request: DescribeAntChainRestRequest): Promise<DescribeAntChainRestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainRestWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainSubnetListRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainSubnetListResponse
   */
  async describeAntChainSubnetListWithOptions(request: DescribeAntChainSubnetListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainSubnetListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainSubnetList",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainSubnetListResponse>(await this.callApi(params, req, runtime), new DescribeAntChainSubnetListResponse({}));
  }

  /**
   * @param request DescribeAntChainSubnetListRequest
   * @return DescribeAntChainSubnetListResponse
   */
  async describeAntChainSubnetList(request: DescribeAntChainSubnetListRequest): Promise<DescribeAntChainSubnetListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainSubnetListWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainSubnetMemberListRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainSubnetMemberListResponse
   */
  async describeAntChainSubnetMemberListWithOptions(request: DescribeAntChainSubnetMemberListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainSubnetMemberListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainSubnetMemberList",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainSubnetMemberListResponse>(await this.callApi(params, req, runtime), new DescribeAntChainSubnetMemberListResponse({}));
  }

  /**
   * @param request DescribeAntChainSubnetMemberListRequest
   * @return DescribeAntChainSubnetMemberListResponse
   */
  async describeAntChainSubnetMemberList(request: DescribeAntChainSubnetMemberListRequest): Promise<DescribeAntChainSubnetMemberListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainSubnetMemberListWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainSubnetNodeListRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainSubnetNodeListResponse
   */
  async describeAntChainSubnetNodeListWithOptions(request: DescribeAntChainSubnetNodeListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainSubnetNodeListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainSubnetNodeList",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainSubnetNodeListResponse>(await this.callApi(params, req, runtime), new DescribeAntChainSubnetNodeListResponse({}));
  }

  /**
   * @param request DescribeAntChainSubnetNodeListRequest
   * @return DescribeAntChainSubnetNodeListResponse
   */
  async describeAntChainSubnetNodeList(request: DescribeAntChainSubnetNodeListRequest): Promise<DescribeAntChainSubnetNodeListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainSubnetNodeListWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainTransactionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainTransactionResponse
   */
  async describeAntChainTransactionWithOptions(request: DescribeAntChainTransactionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainTransactionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.hash)) {
      body["Hash"] = request.hash;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainTransaction",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainTransactionResponse>(await this.callApi(params, req, runtime), new DescribeAntChainTransactionResponse({}));
  }

  /**
   * @param request DescribeAntChainTransactionRequest
   * @return DescribeAntChainTransactionResponse
   */
  async describeAntChainTransaction(request: DescribeAntChainTransactionRequest): Promise<DescribeAntChainTransactionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainTransactionWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainTransactionNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainTransactionNewResponse
   */
  async describeAntChainTransactionNewWithOptions(request: DescribeAntChainTransactionNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainTransactionNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.hash)) {
      body["Hash"] = request.hash;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainTransactionNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainTransactionNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainTransactionNewResponse({}));
  }

  /**
   * @param request DescribeAntChainTransactionNewRequest
   * @return DescribeAntChainTransactionNewResponse
   */
  async describeAntChainTransactionNew(request: DescribeAntChainTransactionNewRequest): Promise<DescribeAntChainTransactionNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainTransactionNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainTransactionReceiptNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainTransactionReceiptNewResponse
   */
  async describeAntChainTransactionReceiptNewWithOptions(request: DescribeAntChainTransactionReceiptNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainTransactionReceiptNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.hash)) {
      body["Hash"] = request.hash;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainTransactionReceiptNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainTransactionReceiptNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainTransactionReceiptNewResponse({}));
  }

  /**
   * @param request DescribeAntChainTransactionReceiptNewRequest
   * @return DescribeAntChainTransactionReceiptNewResponse
   */
  async describeAntChainTransactionReceiptNew(request: DescribeAntChainTransactionReceiptNewRequest): Promise<DescribeAntChainTransactionReceiptNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainTransactionReceiptNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainTransactionStatisticsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainTransactionStatisticsResponse
   */
  async describeAntChainTransactionStatisticsWithOptions(request: DescribeAntChainTransactionStatisticsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainTransactionStatisticsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.end)) {
      body["End"] = request.end;
    }

    if (!Util.isUnset(request.start)) {
      body["Start"] = request.start;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainTransactionStatistics",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainTransactionStatisticsResponse>(await this.callApi(params, req, runtime), new DescribeAntChainTransactionStatisticsResponse({}));
  }

  /**
   * @param request DescribeAntChainTransactionStatisticsRequest
   * @return DescribeAntChainTransactionStatisticsResponse
   */
  async describeAntChainTransactionStatistics(request: DescribeAntChainTransactionStatisticsRequest): Promise<DescribeAntChainTransactionStatisticsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainTransactionStatisticsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainTransactionStatisticsNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainTransactionStatisticsNewResponse
   */
  async describeAntChainTransactionStatisticsNewWithOptions(request: DescribeAntChainTransactionStatisticsNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainTransactionStatisticsNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.end)) {
      body["End"] = request.end;
    }

    if (!Util.isUnset(request.start)) {
      body["Start"] = request.start;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainTransactionStatisticsNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainTransactionStatisticsNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainTransactionStatisticsNewResponse({}));
  }

  /**
   * @param request DescribeAntChainTransactionStatisticsNewRequest
   * @return DescribeAntChainTransactionStatisticsNewResponse
   */
  async describeAntChainTransactionStatisticsNew(request: DescribeAntChainTransactionStatisticsNewRequest): Promise<DescribeAntChainTransactionStatisticsNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainTransactionStatisticsNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainsResponse
   */
  async describeAntChainsWithOptions(request: DescribeAntChainsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChains",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainsResponse>(await this.callApi(params, req, runtime), new DescribeAntChainsResponse({}));
  }

  /**
   * @param request DescribeAntChainsRequest
   * @return DescribeAntChainsResponse
   */
  async describeAntChains(request: DescribeAntChainsRequest): Promise<DescribeAntChainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntChainsNewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntChainsNewResponse
   */
  async describeAntChainsNewWithOptions(request: DescribeAntChainsNewRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntChainsNewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.pageNumber)) {
      body["PageNumber"] = request.pageNumber;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntChainsNew",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntChainsNewResponse>(await this.callApi(params, req, runtime), new DescribeAntChainsNewResponse({}));
  }

  /**
   * @param request DescribeAntChainsNewRequest
   * @return DescribeAntChainsNewResponse
   */
  async describeAntChainsNew(request: DescribeAntChainsNewRequest): Promise<DescribeAntChainsNewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntChainsNewWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAntRegionsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAntRegionsResponse
   */
  async describeAntRegionsWithOptions(request: DescribeAntRegionsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAntRegionsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.locale)) {
      body["Locale"] = request.locale;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeAntRegions",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAntRegionsResponse>(await this.callApi(params, req, runtime), new DescribeAntRegionsResponse({}));
  }

  /**
   * @param request DescribeAntRegionsRequest
   * @return DescribeAntRegionsResponse
   */
  async describeAntRegions(request: DescribeAntRegionsRequest): Promise<DescribeAntRegionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAntRegionsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeAppliesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeAppliesResponse
   */
  async describeAppliesWithOptions(request: DescribeAppliesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeAppliesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.current)) {
      body["Current"] = request.current;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeApplies",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeAppliesResponse>(await this.callApi(params, req, runtime), new DescribeAppliesResponse({}));
  }

  /**
   * @param request DescribeAppliesRequest
   * @return DescribeAppliesResponse
   */
  async describeApplies(request: DescribeAppliesRequest): Promise<DescribeAppliesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeAppliesWithOptions(request, runtime);
  }

  /**
   * @param request DescribeBcSchemaRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeBcSchemaResponse
   */
  async describeBcSchemaWithOptions(request: DescribeBcSchemaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBcSchemaResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBcSchema",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBcSchemaResponse>(await this.callApi(params, req, runtime), new DescribeBcSchemaResponse({}));
  }

  /**
   * @param request DescribeBcSchemaRequest
   * @return DescribeBcSchemaResponse
   */
  async describeBcSchema(request: DescribeBcSchemaRequest): Promise<DescribeBcSchemaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBcSchemaWithOptions(request, runtime);
  }

  /**
   * @param request DescribeBlockRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeBlockResponse
   */
  async describeBlockWithOptions(request: DescribeBlockRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBlockResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.height)) {
      body["Height"] = request.height;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBlock",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBlockResponse>(await this.callApi(params, req, runtime), new DescribeBlockResponse({}));
  }

  /**
   * @param request DescribeBlockRequest
   * @return DescribeBlockResponse
   */
  async describeBlock(request: DescribeBlockRequest): Promise<DescribeBlockResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBlockWithOptions(request, runtime);
  }

  /**
   * @param request DescribeBlockchainApplicationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeBlockchainApplicationResponse
   */
  async describeBlockchainApplicationWithOptions(request: DescribeBlockchainApplicationRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBlockchainApplicationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.current)) {
      body["Current"] = request.current;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBlockchainApplication",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBlockchainApplicationResponse>(await this.callApi(params, req, runtime), new DescribeBlockchainApplicationResponse({}));
  }

  /**
   * @param request DescribeBlockchainApplicationRequest
   * @return DescribeBlockchainApplicationResponse
   */
  async describeBlockchainApplication(request: DescribeBlockchainApplicationRequest): Promise<DescribeBlockchainApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBlockchainApplicationWithOptions(request, runtime);
  }

  /**
   * @param request DescribeBlockchainConfigOptionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeBlockchainConfigOptionResponse
   */
  async describeBlockchainConfigOptionWithOptions(request: DescribeBlockchainConfigOptionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBlockchainConfigOptionResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.purpose)) {
      query["Purpose"] = request.purpose;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBlockchainConfigOption",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBlockchainConfigOptionResponse>(await this.callApi(params, req, runtime), new DescribeBlockchainConfigOptionResponse({}));
  }

  /**
   * @param request DescribeBlockchainConfigOptionRequest
   * @return DescribeBlockchainConfigOptionResponse
   */
  async describeBlockchainConfigOption(request: DescribeBlockchainConfigOptionRequest): Promise<DescribeBlockchainConfigOptionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBlockchainConfigOptionWithOptions(request, runtime);
  }

  /**
   * @param request DescribeBlockchainCreateTaskRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeBlockchainCreateTaskResponse
   */
  async describeBlockchainCreateTaskWithOptions(request: DescribeBlockchainCreateTaskRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBlockchainCreateTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.current)) {
      body["Current"] = request.current;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBlockchainCreateTask",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBlockchainCreateTaskResponse>(await this.callApi(params, req, runtime), new DescribeBlockchainCreateTaskResponse({}));
  }

  /**
   * @param request DescribeBlockchainCreateTaskRequest
   * @return DescribeBlockchainCreateTaskResponse
   */
  async describeBlockchainCreateTask(request: DescribeBlockchainCreateTaskRequest): Promise<DescribeBlockchainCreateTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBlockchainCreateTaskWithOptions(request, runtime);
  }

  /**
   * @param request DescribeBlockchainCreationConfigOptionsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeBlockchainCreationConfigOptionsResponse
   */
  async describeBlockchainCreationConfigOptionsWithOptions(request: DescribeBlockchainCreationConfigOptionsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBlockchainCreationConfigOptionsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.purpose)) {
      query["Purpose"] = request.purpose;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBlockchainCreationConfigOptions",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBlockchainCreationConfigOptionsResponse>(await this.callApi(params, req, runtime), new DescribeBlockchainCreationConfigOptionsResponse({}));
  }

  /**
   * @param request DescribeBlockchainCreationConfigOptionsRequest
   * @return DescribeBlockchainCreationConfigOptionsResponse
   */
  async describeBlockchainCreationConfigOptions(request: DescribeBlockchainCreationConfigOptionsRequest): Promise<DescribeBlockchainCreationConfigOptionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBlockchainCreationConfigOptionsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeBlockchainInfoRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeBlockchainInfoResponse
   */
  async describeBlockchainInfoWithOptions(request: DescribeBlockchainInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBlockchainInfoResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBlockchainInfo",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBlockchainInfoResponse>(await this.callApi(params, req, runtime), new DescribeBlockchainInfoResponse({}));
  }

  /**
   * @param request DescribeBlockchainInfoRequest
   * @return DescribeBlockchainInfoResponse
   */
  async describeBlockchainInfo(request: DescribeBlockchainInfoRequest): Promise<DescribeBlockchainInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBlockchainInfoWithOptions(request, runtime);
  }

  /**
   * @param request DescribeBlockchainSchemaRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeBlockchainSchemaResponse
   */
  async describeBlockchainSchemaWithOptions(request: DescribeBlockchainSchemaRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBlockchainSchemaResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBlockchainSchema",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBlockchainSchemaResponse>(await this.callApi(params, req, runtime), new DescribeBlockchainSchemaResponse({}));
  }

  /**
   * @param request DescribeBlockchainSchemaRequest
   * @return DescribeBlockchainSchemaResponse
   */
  async describeBlockchainSchema(request: DescribeBlockchainSchemaRequest): Promise<DescribeBlockchainSchemaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBlockchainSchemaWithOptions(request, runtime);
  }

  /**
   * @param request DescribeBlockchainSchemaDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeBlockchainSchemaDetailResponse
   */
  async describeBlockchainSchemaDetailWithOptions(request: DescribeBlockchainSchemaDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBlockchainSchemaDetailResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.schemaId)) {
      body["SchemaId"] = request.schemaId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBlockchainSchemaDetail",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBlockchainSchemaDetailResponse>(await this.callApi(params, req, runtime), new DescribeBlockchainSchemaDetailResponse({}));
  }

  /**
   * @param request DescribeBlockchainSchemaDetailRequest
   * @return DescribeBlockchainSchemaDetailResponse
   */
  async describeBlockchainSchemaDetail(request: DescribeBlockchainSchemaDetailRequest): Promise<DescribeBlockchainSchemaDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBlockchainSchemaDetailWithOptions(request, runtime);
  }

  /**
   * @param request DescribeBlockchainSchemaFileOSSPropertiesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeBlockchainSchemaFileOSSPropertiesResponse
   */
  async describeBlockchainSchemaFileOSSPropertiesWithOptions(request: DescribeBlockchainSchemaFileOSSPropertiesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeBlockchainSchemaFileOSSPropertiesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeBlockchainSchemaFileOSSProperties",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBlockchainSchemaFileOSSPropertiesResponse>(await this.callApi(params, req, runtime), new DescribeBlockchainSchemaFileOSSPropertiesResponse({}));
  }

  /**
   * @param request DescribeBlockchainSchemaFileOSSPropertiesRequest
   * @return DescribeBlockchainSchemaFileOSSPropertiesResponse
   */
  async describeBlockchainSchemaFileOSSProperties(request: DescribeBlockchainSchemaFileOSSPropertiesRequest): Promise<DescribeBlockchainSchemaFileOSSPropertiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBlockchainSchemaFileOSSPropertiesWithOptions(request, runtime);
  }

  /**
   * @param request DescribeBlockchainSchemaTemplatesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeBlockchainSchemaTemplatesResponse
   */
  async describeBlockchainSchemaTemplatesWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeBlockchainSchemaTemplatesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeBlockchainSchemaTemplates",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeBlockchainSchemaTemplatesResponse>(await this.callApi(params, req, runtime), new DescribeBlockchainSchemaTemplatesResponse({}));
  }

  /**
   * @return DescribeBlockchainSchemaTemplatesResponse
   */
  async describeBlockchainSchemaTemplates(): Promise<DescribeBlockchainSchemaTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeBlockchainSchemaTemplatesWithOptions(runtime);
  }

  /**
   * @param request DescribeCSIGatewayEndpointRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeCSIGatewayEndpointResponse
   */
  async describeCSIGatewayEndpointWithOptions(request: DescribeCSIGatewayEndpointRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCSIGatewayEndpointResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCSIGatewayEndpoint",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCSIGatewayEndpointResponse>(await this.callApi(params, req, runtime), new DescribeCSIGatewayEndpointResponse({}));
  }

  /**
   * @param request DescribeCSIGatewayEndpointRequest
   * @return DescribeCSIGatewayEndpointResponse
   */
  async describeCSIGatewayEndpoint(request: DescribeCSIGatewayEndpointRequest): Promise<DescribeCSIGatewayEndpointResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCSIGatewayEndpointWithOptions(request, runtime);
  }

  /**
   * @param request DescribeCandidateOrganizationsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeCandidateOrganizationsResponse
   */
  async describeCandidateOrganizationsWithOptions(request: DescribeCandidateOrganizationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCandidateOrganizationsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCandidateOrganizations",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCandidateOrganizationsResponse>(await this.callApi(params, req, runtime), new DescribeCandidateOrganizationsResponse({}));
  }

  /**
   * @param request DescribeCandidateOrganizationsRequest
   * @return DescribeCandidateOrganizationsResponse
   */
  async describeCandidateOrganizations(request: DescribeCandidateOrganizationsRequest): Promise<DescribeCandidateOrganizationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCandidateOrganizationsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeChaincodeCollectionConfigRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeChaincodeCollectionConfigResponse
   */
  async describeChaincodeCollectionConfigWithOptions(request: DescribeChaincodeCollectionConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeChaincodeCollectionConfigResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodeId)) {
      body["ChaincodeId"] = request.chaincodeId;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeChaincodeCollectionConfig",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeChaincodeCollectionConfigResponse>(await this.callApi(params, req, runtime), new DescribeChaincodeCollectionConfigResponse({}));
  }

  /**
   * @param request DescribeChaincodeCollectionConfigRequest
   * @return DescribeChaincodeCollectionConfigResponse
   */
  async describeChaincodeCollectionConfig(request: DescribeChaincodeCollectionConfigRequest): Promise<DescribeChaincodeCollectionConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeChaincodeCollectionConfigWithOptions(request, runtime);
  }

  /**
   * @param request DescribeChaincodeDefinitionTaskRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeChaincodeDefinitionTaskResponse
   */
  async describeChaincodeDefinitionTaskWithOptions(request: DescribeChaincodeDefinitionTaskRequest, runtime: $Util.RuntimeOptions): Promise<DescribeChaincodeDefinitionTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodeId)) {
      body["ChaincodeId"] = request.chaincodeId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeChaincodeDefinitionTask",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeChaincodeDefinitionTaskResponse>(await this.callApi(params, req, runtime), new DescribeChaincodeDefinitionTaskResponse({}));
  }

  /**
   * @param request DescribeChaincodeDefinitionTaskRequest
   * @return DescribeChaincodeDefinitionTaskResponse
   */
  async describeChaincodeDefinitionTask(request: DescribeChaincodeDefinitionTaskRequest): Promise<DescribeChaincodeDefinitionTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeChaincodeDefinitionTaskWithOptions(request, runtime);
  }

  /**
   * @param request DescribeChaincodeUploadPolicyRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeChaincodeUploadPolicyResponse
   */
  async describeChaincodeUploadPolicyWithOptions(request: DescribeChaincodeUploadPolicyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeChaincodeUploadPolicyResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeChaincodeUploadPolicy",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeChaincodeUploadPolicyResponse>(await this.callApi(params, req, runtime), new DescribeChaincodeUploadPolicyResponse({}));
  }

  /**
   * @param request DescribeChaincodeUploadPolicyRequest
   * @return DescribeChaincodeUploadPolicyResponse
   */
  async describeChaincodeUploadPolicy(request: DescribeChaincodeUploadPolicyRequest): Promise<DescribeChaincodeUploadPolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeChaincodeUploadPolicyWithOptions(request, runtime);
  }

  /**
   * @param request DescribeChannelChaincodesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeChannelChaincodesResponse
   */
  async describeChannelChaincodesWithOptions(request: DescribeChannelChaincodesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeChannelChaincodesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeChannelChaincodes",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeChannelChaincodesResponse>(await this.callApi(params, req, runtime), new DescribeChannelChaincodesResponse({}));
  }

  /**
   * @param request DescribeChannelChaincodesRequest
   * @return DescribeChannelChaincodesResponse
   */
  async describeChannelChaincodes(request: DescribeChannelChaincodesRequest): Promise<DescribeChannelChaincodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeChannelChaincodesWithOptions(request, runtime);
  }

  /**
   * @param request DescribeChannelMembersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeChannelMembersResponse
   */
  async describeChannelMembersWithOptions(request: DescribeChannelMembersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeChannelMembersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelId)) {
      query["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeChannelMembers",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeChannelMembersResponse>(await this.callApi(params, req, runtime), new DescribeChannelMembersResponse({}));
  }

  /**
   * @param request DescribeChannelMembersRequest
   * @return DescribeChannelMembersResponse
   */
  async describeChannelMembers(request: DescribeChannelMembersRequest): Promise<DescribeChannelMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeChannelMembersWithOptions(request, runtime);
  }

  /**
   * @param request DescribeChannelTriggersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeChannelTriggersResponse
   */
  async describeChannelTriggersWithOptions(request: DescribeChannelTriggersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeChannelTriggersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelId)) {
      query["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeChannelTriggers",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeChannelTriggersResponse>(await this.callApi(params, req, runtime), new DescribeChannelTriggersResponse({}));
  }

  /**
   * @param request DescribeChannelTriggersRequest
   * @return DescribeChannelTriggersResponse
   */
  async describeChannelTriggers(request: DescribeChannelTriggersRequest): Promise<DescribeChannelTriggersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeChannelTriggersWithOptions(request, runtime);
  }

  /**
   * @param request DescribeCloudIntegrationServiceTokenRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeCloudIntegrationServiceTokenResponse
   */
  async describeCloudIntegrationServiceTokenWithOptions(request: DescribeCloudIntegrationServiceTokenRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudIntegrationServiceTokenResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.service)) {
      body["Service"] = request.service;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCloudIntegrationServiceToken",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudIntegrationServiceTokenResponse>(await this.callApi(params, req, runtime), new DescribeCloudIntegrationServiceTokenResponse({}));
  }

  /**
   * @param request DescribeCloudIntegrationServiceTokenRequest
   * @return DescribeCloudIntegrationServiceTokenResponse
   */
  async describeCloudIntegrationServiceToken(request: DescribeCloudIntegrationServiceTokenRequest): Promise<DescribeCloudIntegrationServiceTokenResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudIntegrationServiceTokenWithOptions(request, runtime);
  }

  /**
   * @param request DescribeCloudServiceOrganizationStatusRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeCloudServiceOrganizationStatusResponse
   */
  async describeCloudServiceOrganizationStatusWithOptions(request: DescribeCloudServiceOrganizationStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudServiceOrganizationStatusResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCloudServiceOrganizationStatus",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudServiceOrganizationStatusResponse>(await this.callApi(params, req, runtime), new DescribeCloudServiceOrganizationStatusResponse({}));
  }

  /**
   * @param request DescribeCloudServiceOrganizationStatusRequest
   * @return DescribeCloudServiceOrganizationStatusResponse
   */
  async describeCloudServiceOrganizationStatus(request: DescribeCloudServiceOrganizationStatusRequest): Promise<DescribeCloudServiceOrganizationStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudServiceOrganizationStatusWithOptions(request, runtime);
  }

  /**
   * @param request DescribeCloudServiceTypeStatusRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeCloudServiceTypeStatusResponse
   */
  async describeCloudServiceTypeStatusWithOptions(request: DescribeCloudServiceTypeStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeCloudServiceTypeStatusResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.serviceType)) {
      body["ServiceType"] = request.serviceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeCloudServiceTypeStatus",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeCloudServiceTypeStatusResponse>(await this.callApi(params, req, runtime), new DescribeCloudServiceTypeStatusResponse({}));
  }

  /**
   * @param request DescribeCloudServiceTypeStatusRequest
   * @return DescribeCloudServiceTypeStatusResponse
   */
  async describeCloudServiceTypeStatus(request: DescribeCloudServiceTypeStatusRequest): Promise<DescribeCloudServiceTypeStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeCloudServiceTypeStatusWithOptions(request, runtime);
  }

  /**
   * @param request DescribeConsortiumAdminStatusRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeConsortiumAdminStatusResponse
   */
  async describeConsortiumAdminStatusWithOptions(request: DescribeConsortiumAdminStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeConsortiumAdminStatusResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeConsortiumAdminStatus",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeConsortiumAdminStatusResponse>(await this.callApi(params, req, runtime), new DescribeConsortiumAdminStatusResponse({}));
  }

  /**
   * @param request DescribeConsortiumAdminStatusRequest
   * @return DescribeConsortiumAdminStatusResponse
   */
  async describeConsortiumAdminStatus(request: DescribeConsortiumAdminStatusRequest): Promise<DescribeConsortiumAdminStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeConsortiumAdminStatusWithOptions(request, runtime);
  }

  /**
   * @param request DescribeConsortiumChaincodesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeConsortiumChaincodesResponse
   */
  async describeConsortiumChaincodesWithOptions(request: DescribeConsortiumChaincodesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeConsortiumChaincodesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeConsortiumChaincodes",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeConsortiumChaincodesResponse>(await this.callApi(params, req, runtime), new DescribeConsortiumChaincodesResponse({}));
  }

  /**
   * @param request DescribeConsortiumChaincodesRequest
   * @return DescribeConsortiumChaincodesResponse
   */
  async describeConsortiumChaincodes(request: DescribeConsortiumChaincodesRequest): Promise<DescribeConsortiumChaincodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeConsortiumChaincodesWithOptions(request, runtime);
  }

  /**
   * @param request DescribeConsortiumChannelsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeConsortiumChannelsResponse
   */
  async describeConsortiumChannelsWithOptions(request: DescribeConsortiumChannelsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeConsortiumChannelsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consortiumId)) {
      query["ConsortiumId"] = request.consortiumId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeConsortiumChannels",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeConsortiumChannelsResponse>(await this.callApi(params, req, runtime), new DescribeConsortiumChannelsResponse({}));
  }

  /**
   * @param request DescribeConsortiumChannelsRequest
   * @return DescribeConsortiumChannelsResponse
   */
  async describeConsortiumChannels(request: DescribeConsortiumChannelsRequest): Promise<DescribeConsortiumChannelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeConsortiumChannelsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeConsortiumConfigRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeConsortiumConfigResponse
   */
  async describeConsortiumConfigWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeConsortiumConfigResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeConsortiumConfig",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeConsortiumConfigResponse>(await this.callApi(params, req, runtime), new DescribeConsortiumConfigResponse({}));
  }

  /**
   * @return DescribeConsortiumConfigResponse
   */
  async describeConsortiumConfig(): Promise<DescribeConsortiumConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeConsortiumConfigWithOptions(runtime);
  }

  /**
   * @param request DescribeConsortiumDeletableRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeConsortiumDeletableResponse
   */
  async describeConsortiumDeletableWithOptions(request: DescribeConsortiumDeletableRequest, runtime: $Util.RuntimeOptions): Promise<DescribeConsortiumDeletableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consortiumId)) {
      query["ConsortiumId"] = request.consortiumId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeConsortiumDeletable",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeConsortiumDeletableResponse>(await this.callApi(params, req, runtime), new DescribeConsortiumDeletableResponse({}));
  }

  /**
   * @param request DescribeConsortiumDeletableRequest
   * @return DescribeConsortiumDeletableResponse
   */
  async describeConsortiumDeletable(request: DescribeConsortiumDeletableRequest): Promise<DescribeConsortiumDeletableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeConsortiumDeletableWithOptions(request, runtime);
  }

  /**
   * @param request DescribeConsortiumMemberApprovalRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeConsortiumMemberApprovalResponse
   */
  async describeConsortiumMemberApprovalWithOptions(request: DescribeConsortiumMemberApprovalRequest, runtime: $Util.RuntimeOptions): Promise<DescribeConsortiumMemberApprovalResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consortiumId)) {
      query["ConsortiumId"] = request.consortiumId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeConsortiumMemberApproval",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeConsortiumMemberApprovalResponse>(await this.callApi(params, req, runtime), new DescribeConsortiumMemberApprovalResponse({}));
  }

  /**
   * @param request DescribeConsortiumMemberApprovalRequest
   * @return DescribeConsortiumMemberApprovalResponse
   */
  async describeConsortiumMemberApproval(request: DescribeConsortiumMemberApprovalRequest): Promise<DescribeConsortiumMemberApprovalResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeConsortiumMemberApprovalWithOptions(request, runtime);
  }

  /**
   * @param request DescribeConsortiumMembersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeConsortiumMembersResponse
   */
  async describeConsortiumMembersWithOptions(request: DescribeConsortiumMembersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeConsortiumMembersResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeConsortiumMembers",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeConsortiumMembersResponse>(await this.callApi(params, req, runtime), new DescribeConsortiumMembersResponse({}));
  }

  /**
   * @param request DescribeConsortiumMembersRequest
   * @return DescribeConsortiumMembersResponse
   */
  async describeConsortiumMembers(request: DescribeConsortiumMembersRequest): Promise<DescribeConsortiumMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeConsortiumMembersWithOptions(request, runtime);
  }

  /**
   * @param request DescribeConsortiumOrderersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeConsortiumOrderersResponse
   */
  async describeConsortiumOrderersWithOptions(request: DescribeConsortiumOrderersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeConsortiumOrderersResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeConsortiumOrderers",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeConsortiumOrderersResponse>(await this.callApi(params, req, runtime), new DescribeConsortiumOrderersResponse({}));
  }

  /**
   * @param request DescribeConsortiumOrderersRequest
   * @return DescribeConsortiumOrderersResponse
   */
  async describeConsortiumOrderers(request: DescribeConsortiumOrderersRequest): Promise<DescribeConsortiumOrderersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeConsortiumOrderersWithOptions(request, runtime);
  }

  /**
   * @param request DescribeConsortiumSpecsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeConsortiumSpecsResponse
   */
  async describeConsortiumSpecsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeConsortiumSpecsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeConsortiumSpecs",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeConsortiumSpecsResponse>(await this.callApi(params, req, runtime), new DescribeConsortiumSpecsResponse({}));
  }

  /**
   * @return DescribeConsortiumSpecsResponse
   */
  async describeConsortiumSpecs(): Promise<DescribeConsortiumSpecsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeConsortiumSpecsWithOptions(runtime);
  }

  /**
   * @param request DescribeConsortiumsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeConsortiumsResponse
   */
  async describeConsortiumsWithOptions(request: DescribeConsortiumsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeConsortiumsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consortiumId)) {
      query["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeConsortiums",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeConsortiumsResponse>(await this.callApi(params, req, runtime), new DescribeConsortiumsResponse({}));
  }

  /**
   * @param request DescribeConsortiumsRequest
   * @return DescribeConsortiumsResponse
   */
  async describeConsortiums(request: DescribeConsortiumsRequest): Promise<DescribeConsortiumsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeConsortiumsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeDownloadPathsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeDownloadPathsResponse
   */
  async describeDownloadPathsWithOptions(request: DescribeDownloadPathsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDownloadPathsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDownloadPaths",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDownloadPathsResponse>(await this.callApi(params, req, runtime), new DescribeDownloadPathsResponse({}));
  }

  /**
   * @param request DescribeDownloadPathsRequest
   * @return DescribeDownloadPathsResponse
   */
  async describeDownloadPaths(request: DescribeDownloadPathsRequest): Promise<DescribeDownloadPathsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDownloadPathsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeDownloadPathsOfContractChainRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeDownloadPathsOfContractChainResponse
   */
  async describeDownloadPathsOfContractChainWithOptions(request: DescribeDownloadPathsOfContractChainRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDownloadPathsOfContractChainResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDownloadPathsOfContractChain",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDownloadPathsOfContractChainResponse>(await this.callApi(params, req, runtime), new DescribeDownloadPathsOfContractChainResponse({}));
  }

  /**
   * @param request DescribeDownloadPathsOfContractChainRequest
   * @return DescribeDownloadPathsOfContractChainResponse
   */
  async describeDownloadPathsOfContractChain(request: DescribeDownloadPathsOfContractChainRequest): Promise<DescribeDownloadPathsOfContractChainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDownloadPathsOfContractChainWithOptions(request, runtime);
  }

  /**
   * @param request DescribeDownloadPathsOfNotaryChainRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeDownloadPathsOfNotaryChainResponse
   */
  async describeDownloadPathsOfNotaryChainWithOptions(request: DescribeDownloadPathsOfNotaryChainRequest, runtime: $Util.RuntimeOptions): Promise<DescribeDownloadPathsOfNotaryChainResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeDownloadPathsOfNotaryChain",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeDownloadPathsOfNotaryChainResponse>(await this.callApi(params, req, runtime), new DescribeDownloadPathsOfNotaryChainResponse({}));
  }

  /**
   * @param request DescribeDownloadPathsOfNotaryChainRequest
   * @return DescribeDownloadPathsOfNotaryChainResponse
   */
  async describeDownloadPathsOfNotaryChain(request: DescribeDownloadPathsOfNotaryChainRequest): Promise<DescribeDownloadPathsOfNotaryChainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeDownloadPathsOfNotaryChainWithOptions(request, runtime);
  }

  /**
   * @param request DescribeEcosphereSpecsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeEcosphereSpecsResponse
   */
  async describeEcosphereSpecsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeEcosphereSpecsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeEcosphereSpecs",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEcosphereSpecsResponse>(await this.callApi(params, req, runtime), new DescribeEcosphereSpecsResponse({}));
  }

  /**
   * @return DescribeEcosphereSpecsResponse
   */
  async describeEcosphereSpecs(): Promise<DescribeEcosphereSpecsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEcosphereSpecsWithOptions(runtime);
  }

  /**
   * @param request DescribeEthereumRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeEthereumResponse
   */
  async describeEthereumWithOptions(request: DescribeEthereumRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEthereumResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEthereum",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEthereumResponse>(await this.callApi(params, req, runtime), new DescribeEthereumResponse({}));
  }

  /**
   * @param request DescribeEthereumRequest
   * @return DescribeEthereumResponse
   */
  async describeEthereum(request: DescribeEthereumRequest): Promise<DescribeEthereumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEthereumWithOptions(request, runtime);
  }

  /**
   * @param request DescribeEthereumClientUsersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeEthereumClientUsersResponse
   */
  async describeEthereumClientUsersWithOptions(request: DescribeEthereumClientUsersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEthereumClientUsersResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEthereumClientUsers",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEthereumClientUsersResponse>(await this.callApi(params, req, runtime), new DescribeEthereumClientUsersResponse({}));
  }

  /**
   * @param request DescribeEthereumClientUsersRequest
   * @return DescribeEthereumClientUsersResponse
   */
  async describeEthereumClientUsers(request: DescribeEthereumClientUsersRequest): Promise<DescribeEthereumClientUsersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEthereumClientUsersWithOptions(request, runtime);
  }

  /**
   * @param request DescribeEthereumDeletableRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeEthereumDeletableResponse
   */
  async describeEthereumDeletableWithOptions(request: DescribeEthereumDeletableRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEthereumDeletableResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ethereumId)) {
      body["EthereumId"] = request.ethereumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEthereumDeletable",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEthereumDeletableResponse>(await this.callApi(params, req, runtime), new DescribeEthereumDeletableResponse({}));
  }

  /**
   * @param request DescribeEthereumDeletableRequest
   * @return DescribeEthereumDeletableResponse
   */
  async describeEthereumDeletable(request: DescribeEthereumDeletableRequest): Promise<DescribeEthereumDeletableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEthereumDeletableWithOptions(request, runtime);
  }

  /**
   * @param request DescribeEthereumInvitaionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeEthereumInvitaionResponse
   */
  async describeEthereumInvitaionWithOptions(request: DescribeEthereumInvitaionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEthereumInvitaionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.token)) {
      body["Token"] = request.token;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEthereumInvitaion",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEthereumInvitaionResponse>(await this.callApi(params, req, runtime), new DescribeEthereumInvitaionResponse({}));
  }

  /**
   * @param request DescribeEthereumInvitaionRequest
   * @return DescribeEthereumInvitaionResponse
   */
  async describeEthereumInvitaion(request: DescribeEthereumInvitaionRequest): Promise<DescribeEthereumInvitaionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEthereumInvitaionWithOptions(request, runtime);
  }

  /**
   * @param request DescribeEthereumInviteeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeEthereumInviteeResponse
   */
  async describeEthereumInviteeWithOptions(request: DescribeEthereumInviteeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEthereumInviteeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEthereumInvitee",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEthereumInviteeResponse>(await this.callApi(params, req, runtime), new DescribeEthereumInviteeResponse({}));
  }

  /**
   * @param request DescribeEthereumInviteeRequest
   * @return DescribeEthereumInviteeResponse
   */
  async describeEthereumInvitee(request: DescribeEthereumInviteeRequest): Promise<DescribeEthereumInviteeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEthereumInviteeWithOptions(request, runtime);
  }

  /**
   * @param request DescribeEthereumNodeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeEthereumNodeResponse
   */
  async describeEthereumNodeWithOptions(request: DescribeEthereumNodeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEthereumNodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEthereumNode",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEthereumNodeResponse>(await this.callApi(params, req, runtime), new DescribeEthereumNodeResponse({}));
  }

  /**
   * @param request DescribeEthereumNodeRequest
   * @return DescribeEthereumNodeResponse
   */
  async describeEthereumNode(request: DescribeEthereumNodeRequest): Promise<DescribeEthereumNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEthereumNodeWithOptions(request, runtime);
  }

  /**
   * @param request DescribeEthereumNodeConfigurationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeEthereumNodeConfigurationResponse
   */
  async describeEthereumNodeConfigurationWithOptions(request: DescribeEthereumNodeConfigurationRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEthereumNodeConfigurationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEthereumNodeConfiguration",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEthereumNodeConfigurationResponse>(await this.callApi(params, req, runtime), new DescribeEthereumNodeConfigurationResponse({}));
  }

  /**
   * @param request DescribeEthereumNodeConfigurationRequest
   * @return DescribeEthereumNodeConfigurationResponse
   */
  async describeEthereumNodeConfiguration(request: DescribeEthereumNodeConfigurationRequest): Promise<DescribeEthereumNodeConfigurationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEthereumNodeConfigurationWithOptions(request, runtime);
  }

  /**
   * @param request DescribeEthereumNodeInfoRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeEthereumNodeInfoResponse
   */
  async describeEthereumNodeInfoWithOptions(request: DescribeEthereumNodeInfoRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEthereumNodeInfoResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEthereumNodeInfo",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEthereumNodeInfoResponse>(await this.callApi(params, req, runtime), new DescribeEthereumNodeInfoResponse({}));
  }

  /**
   * @param request DescribeEthereumNodeInfoRequest
   * @return DescribeEthereumNodeInfoResponse
   */
  async describeEthereumNodeInfo(request: DescribeEthereumNodeInfoRequest): Promise<DescribeEthereumNodeInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEthereumNodeInfoWithOptions(request, runtime);
  }

  /**
   * @param request DescribeEthereumNodeLogsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeEthereumNodeLogsResponse
   */
  async describeEthereumNodeLogsWithOptions(request: DescribeEthereumNodeLogsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeEthereumNodeLogsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.lines)) {
      body["Lines"] = request.lines;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.target)) {
      body["Target"] = request.target;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeEthereumNodeLogs",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEthereumNodeLogsResponse>(await this.callApi(params, req, runtime), new DescribeEthereumNodeLogsResponse({}));
  }

  /**
   * @param request DescribeEthereumNodeLogsRequest
   * @return DescribeEthereumNodeLogsResponse
   */
  async describeEthereumNodeLogs(request: DescribeEthereumNodeLogsRequest): Promise<DescribeEthereumNodeLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEthereumNodeLogsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeEthereumNodesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeEthereumNodesResponse
   */
  async describeEthereumNodesWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeEthereumNodesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeEthereumNodes",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEthereumNodesResponse>(await this.callApi(params, req, runtime), new DescribeEthereumNodesResponse({}));
  }

  /**
   * @return DescribeEthereumNodesResponse
   */
  async describeEthereumNodes(): Promise<DescribeEthereumNodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEthereumNodesWithOptions(runtime);
  }

  /**
   * @param request DescribeEthereumsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeEthereumsResponse
   */
  async describeEthereumsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeEthereumsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeEthereums",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeEthereumsResponse>(await this.callApi(params, req, runtime), new DescribeEthereumsResponse({}));
  }

  /**
   * @return DescribeEthereumsResponse
   */
  async describeEthereums(): Promise<DescribeEthereumsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeEthereumsWithOptions(runtime);
  }

  /**
   * @param request DescribeExplorerRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeExplorerResponse
   */
  async describeExplorerWithOptions(request: DescribeExplorerRequest, runtime: $Util.RuntimeOptions): Promise<DescribeExplorerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.exBody)) {
      query["ExBody"] = request.exBody;
    }

    if (!Util.isUnset(request.exMethod)) {
      query["ExMethod"] = request.exMethod;
    }

    if (!Util.isUnset(request.exUrl)) {
      query["ExUrl"] = request.exUrl;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeExplorer",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeExplorerResponse>(await this.callApi(params, req, runtime), new DescribeExplorerResponse({}));
  }

  /**
   * @param request DescribeExplorerRequest
   * @return DescribeExplorerResponse
   */
  async describeExplorer(request: DescribeExplorerRequest): Promise<DescribeExplorerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeExplorerWithOptions(request, runtime);
  }

  /**
   * @param request DescribeExplorerURLRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeExplorerURLResponse
   */
  async describeExplorerURLWithOptions(request: DescribeExplorerURLRequest, runtime: $Util.RuntimeOptions): Promise<DescribeExplorerURLResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeExplorerURL",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeExplorerURLResponse>(await this.callApi(params, req, runtime), new DescribeExplorerURLResponse({}));
  }

  /**
   * @param request DescribeExplorerURLRequest
   * @return DescribeExplorerURLResponse
   */
  async describeExplorerURL(request: DescribeExplorerURLRequest): Promise<DescribeExplorerURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeExplorerURLWithOptions(request, runtime);
  }

  /**
   * @param request DescribeFabricChaincodeEndorsePolicyRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeFabricChaincodeEndorsePolicyResponse
   */
  async describeFabricChaincodeEndorsePolicyWithOptions(request: DescribeFabricChaincodeEndorsePolicyRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFabricChaincodeEndorsePolicyResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodeName)) {
      body["ChaincodeName"] = request.chaincodeName;
    }

    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFabricChaincodeEndorsePolicy",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFabricChaincodeEndorsePolicyResponse>(await this.callApi(params, req, runtime), new DescribeFabricChaincodeEndorsePolicyResponse({}));
  }

  /**
   * @param request DescribeFabricChaincodeEndorsePolicyRequest
   * @return DescribeFabricChaincodeEndorsePolicyResponse
   */
  async describeFabricChaincodeEndorsePolicy(request: DescribeFabricChaincodeEndorsePolicyRequest): Promise<DescribeFabricChaincodeEndorsePolicyResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFabricChaincodeEndorsePolicyWithOptions(request, runtime);
  }

  /**
   * @param request DescribeFabricChaincodeLogsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeFabricChaincodeLogsResponse
   */
  async describeFabricChaincodeLogsWithOptions(request: DescribeFabricChaincodeLogsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFabricChaincodeLogsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.chaincodeId)) {
      query["ChaincodeId"] = request.chaincodeId;
    }

    if (!Util.isUnset(request.lines)) {
      query["Lines"] = request.lines;
    }

    if (!Util.isUnset(request.offset)) {
      query["Offset"] = request.offset;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.peerName)) {
      query["PeerName"] = request.peerName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFabricChaincodeLogs",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFabricChaincodeLogsResponse>(await this.callApi(params, req, runtime), new DescribeFabricChaincodeLogsResponse({}));
  }

  /**
   * @param request DescribeFabricChaincodeLogsRequest
   * @return DescribeFabricChaincodeLogsResponse
   */
  async describeFabricChaincodeLogs(request: DescribeFabricChaincodeLogsRequest): Promise<DescribeFabricChaincodeLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFabricChaincodeLogsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeFabricChannelConfigRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeFabricChannelConfigResponse
   */
  async describeFabricChannelConfigWithOptions(request: DescribeFabricChannelConfigRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFabricChannelConfigResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFabricChannelConfig",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFabricChannelConfigResponse>(await this.callApi(params, req, runtime), new DescribeFabricChannelConfigResponse({}));
  }

  /**
   * @param request DescribeFabricChannelConfigRequest
   * @return DescribeFabricChannelConfigResponse
   */
  async describeFabricChannelConfig(request: DescribeFabricChannelConfigRequest): Promise<DescribeFabricChannelConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFabricChannelConfigWithOptions(request, runtime);
  }

  /**
   * @param request DescribeFabricChannelOrdererRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeFabricChannelOrdererResponse
   */
  async describeFabricChannelOrdererWithOptions(request: DescribeFabricChannelOrdererRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFabricChannelOrdererResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFabricChannelOrderer",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFabricChannelOrdererResponse>(await this.callApi(params, req, runtime), new DescribeFabricChannelOrdererResponse({}));
  }

  /**
   * @param request DescribeFabricChannelOrdererRequest
   * @return DescribeFabricChannelOrdererResponse
   */
  async describeFabricChannelOrderer(request: DescribeFabricChannelOrdererRequest): Promise<DescribeFabricChannelOrdererResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFabricChannelOrdererWithOptions(request, runtime);
  }

  /**
   * @param request DescribeFabricChannelOrganizationsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeFabricChannelOrganizationsResponse
   */
  async describeFabricChannelOrganizationsWithOptions(request: DescribeFabricChannelOrganizationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFabricChannelOrganizationsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFabricChannelOrganizations",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFabricChannelOrganizationsResponse>(await this.callApi(params, req, runtime), new DescribeFabricChannelOrganizationsResponse({}));
  }

  /**
   * @param request DescribeFabricChannelOrganizationsRequest
   * @return DescribeFabricChannelOrganizationsResponse
   */
  async describeFabricChannelOrganizations(request: DescribeFabricChannelOrganizationsRequest): Promise<DescribeFabricChannelOrganizationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFabricChannelOrganizationsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeFabricJoinRequestRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeFabricJoinRequestResponse
   */
  async describeFabricJoinRequestWithOptions(request: DescribeFabricJoinRequestRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFabricJoinRequestResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFabricJoinRequest",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFabricJoinRequestResponse>(await this.callApi(params, req, runtime), new DescribeFabricJoinRequestResponse({}));
  }

  /**
   * @param request DescribeFabricJoinRequestRequest
   * @return DescribeFabricJoinRequestResponse
   */
  async describeFabricJoinRequest(request: DescribeFabricJoinRequestRequest): Promise<DescribeFabricJoinRequestResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFabricJoinRequestWithOptions(request, runtime);
  }

  /**
   * @param request DescribeFabricJoinResponseRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeFabricJoinResponseResponse
   */
  async describeFabricJoinResponseWithOptions(request: DescribeFabricJoinResponseRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFabricJoinResponseResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFabricJoinResponse",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFabricJoinResponseResponse>(await this.callApi(params, req, runtime), new DescribeFabricJoinResponseResponse({}));
  }

  /**
   * @param request DescribeFabricJoinResponseRequest
   * @return DescribeFabricJoinResponseResponse
   */
  async describeFabricJoinResponse(request: DescribeFabricJoinResponseRequest): Promise<DescribeFabricJoinResponseResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFabricJoinResponseWithOptions(request, runtime);
  }

  /**
   * @param request DescribeFabricManagementChaincodesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeFabricManagementChaincodesResponse
   */
  async describeFabricManagementChaincodesWithOptions(request: DescribeFabricManagementChaincodesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFabricManagementChaincodesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFabricManagementChaincodes",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFabricManagementChaincodesResponse>(await this.callApi(params, req, runtime), new DescribeFabricManagementChaincodesResponse({}));
  }

  /**
   * @param request DescribeFabricManagementChaincodesRequest
   * @return DescribeFabricManagementChaincodesResponse
   */
  async describeFabricManagementChaincodes(request: DescribeFabricManagementChaincodesRequest): Promise<DescribeFabricManagementChaincodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFabricManagementChaincodesWithOptions(request, runtime);
  }

  /**
   * @param request DescribeFabricOrganizationChaincodePackageRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeFabricOrganizationChaincodePackageResponse
   */
  async describeFabricOrganizationChaincodePackageWithOptions(request: DescribeFabricOrganizationChaincodePackageRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFabricOrganizationChaincodePackageResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFabricOrganizationChaincodePackage",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFabricOrganizationChaincodePackageResponse>(await this.callApi(params, req, runtime), new DescribeFabricOrganizationChaincodePackageResponse({}));
  }

  /**
   * @param request DescribeFabricOrganizationChaincodePackageRequest
   * @return DescribeFabricOrganizationChaincodePackageResponse
   */
  async describeFabricOrganizationChaincodePackage(request: DescribeFabricOrganizationChaincodePackageRequest): Promise<DescribeFabricOrganizationChaincodePackageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFabricOrganizationChaincodePackageWithOptions(request, runtime);
  }

  /**
   * @param request DescribeFabricOrganizationEgressRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeFabricOrganizationEgressResponse
   */
  async describeFabricOrganizationEgressWithOptions(request: DescribeFabricOrganizationEgressRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFabricOrganizationEgressResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFabricOrganizationEgress",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFabricOrganizationEgressResponse>(await this.callApi(params, req, runtime), new DescribeFabricOrganizationEgressResponse({}));
  }

  /**
   * @param request DescribeFabricOrganizationEgressRequest
   * @return DescribeFabricOrganizationEgressResponse
   */
  async describeFabricOrganizationEgress(request: DescribeFabricOrganizationEgressRequest): Promise<DescribeFabricOrganizationEgressResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFabricOrganizationEgressWithOptions(request, runtime);
  }

  /**
   * @param request DescribeFabricPeerChannelsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeFabricPeerChannelsResponse
   */
  async describeFabricPeerChannelsWithOptions(request: DescribeFabricPeerChannelsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeFabricPeerChannelsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeFabricPeerChannels",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeFabricPeerChannelsResponse>(await this.callApi(params, req, runtime), new DescribeFabricPeerChannelsResponse({}));
  }

  /**
   * @param request DescribeFabricPeerChannelsRequest
   * @return DescribeFabricPeerChannelsResponse
   */
  async describeFabricPeerChannels(request: DescribeFabricPeerChannelsRequest): Promise<DescribeFabricPeerChannelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeFabricPeerChannelsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeGovernanceTaskRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeGovernanceTaskResponse
   */
  async describeGovernanceTaskWithOptions(request: DescribeGovernanceTaskRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGovernanceTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.taskId)) {
      body["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGovernanceTask",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGovernanceTaskResponse>(await this.callApi(params, req, runtime), new DescribeGovernanceTaskResponse({}));
  }

  /**
   * @param request DescribeGovernanceTaskRequest
   * @return DescribeGovernanceTaskResponse
   */
  async describeGovernanceTask(request: DescribeGovernanceTaskRequest): Promise<DescribeGovernanceTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGovernanceTaskWithOptions(request, runtime);
  }

  /**
   * @param request DescribeGovernanceTasksRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeGovernanceTasksResponse
   */
  async describeGovernanceTasksWithOptions(request: DescribeGovernanceTasksRequest, runtime: $Util.RuntimeOptions): Promise<DescribeGovernanceTasksResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeGovernanceTasks",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeGovernanceTasksResponse>(await this.callApi(params, req, runtime), new DescribeGovernanceTasksResponse({}));
  }

  /**
   * @param request DescribeGovernanceTasksRequest
   * @return DescribeGovernanceTasksResponse
   */
  async describeGovernanceTasks(request: DescribeGovernanceTasksRequest): Promise<DescribeGovernanceTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeGovernanceTasksWithOptions(request, runtime);
  }

  /**
   * @param request DescribeInvitationCodeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeInvitationCodeResponse
   */
  async describeInvitationCodeWithOptions(request: DescribeInvitationCodeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInvitationCodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInvitationCode",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInvitationCodeResponse>(await this.callApi(params, req, runtime), new DescribeInvitationCodeResponse({}));
  }

  /**
   * @param request DescribeInvitationCodeRequest
   * @return DescribeInvitationCodeResponse
   */
  async describeInvitationCode(request: DescribeInvitationCodeRequest): Promise<DescribeInvitationCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInvitationCodeWithOptions(request, runtime);
  }

  /**
   * @param request DescribeInvitationListRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeInvitationListResponse
   */
  async describeInvitationListWithOptions(request: DescribeInvitationListRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInvitationListResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInvitationList",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInvitationListResponse>(await this.callApi(params, req, runtime), new DescribeInvitationListResponse({}));
  }

  /**
   * @param request DescribeInvitationListRequest
   * @return DescribeInvitationListResponse
   */
  async describeInvitationList(request: DescribeInvitationListRequest): Promise<DescribeInvitationListResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInvitationListWithOptions(request, runtime);
  }

  /**
   * @description ****
   *
   * @param request DescribeInviterRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeInviterResponse
   */
  async describeInviterWithOptions(request: DescribeInviterRequest, runtime: $Util.RuntimeOptions): Promise<DescribeInviterResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.code)) {
      body["Code"] = request.code;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeInviter",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeInviterResponse>(await this.callApi(params, req, runtime), new DescribeInviterResponse({}));
  }

  /**
   * @description ****
   *
   * @param request DescribeInviterRequest
   * @return DescribeInviterResponse
   */
  async describeInviter(request: DescribeInviterRequest): Promise<DescribeInviterResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeInviterWithOptions(request, runtime);
  }

  /**
   * @param request DescribeLatest15BlocksRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeLatest15BlocksResponse
   */
  async describeLatest15BlocksWithOptions(request: DescribeLatest15BlocksRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLatest15BlocksResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLatest15Blocks",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLatest15BlocksResponse>(await this.callApi(params, req, runtime), new DescribeLatest15BlocksResponse({}));
  }

  /**
   * @param request DescribeLatest15BlocksRequest
   * @return DescribeLatest15BlocksResponse
   */
  async describeLatest15Blocks(request: DescribeLatest15BlocksRequest): Promise<DescribeLatest15BlocksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLatest15BlocksWithOptions(request, runtime);
  }

  /**
   * @param request DescribeLatest15TransDigestsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeLatest15TransDigestsResponse
   */
  async describeLatest15TransDigestsWithOptions(request: DescribeLatest15TransDigestsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLatest15TransDigestsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLatest15TransDigests",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLatest15TransDigestsResponse>(await this.callApi(params, req, runtime), new DescribeLatest15TransDigestsResponse({}));
  }

  /**
   * @param request DescribeLatest15TransDigestsRequest
   * @return DescribeLatest15TransDigestsResponse
   */
  async describeLatest15TransDigests(request: DescribeLatest15TransDigestsRequest): Promise<DescribeLatest15TransDigestsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLatest15TransDigestsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeLatestBlocksRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeLatestBlocksResponse
   */
  async describeLatestBlocksWithOptions(request: DescribeLatestBlocksRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLatestBlocksResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLatestBlocks",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLatestBlocksResponse>(await this.callApi(params, req, runtime), new DescribeLatestBlocksResponse({}));
  }

  /**
   * @param request DescribeLatestBlocksRequest
   * @return DescribeLatestBlocksResponse
   */
  async describeLatestBlocks(request: DescribeLatestBlocksRequest): Promise<DescribeLatestBlocksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLatestBlocksWithOptions(request, runtime);
  }

  /**
   * @param request DescribeLatestTransactionDigestsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeLatestTransactionDigestsResponse
   */
  async describeLatestTransactionDigestsWithOptions(request: DescribeLatestTransactionDigestsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeLatestTransactionDigestsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeLatestTransactionDigests",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeLatestTransactionDigestsResponse>(await this.callApi(params, req, runtime), new DescribeLatestTransactionDigestsResponse({}));
  }

  /**
   * @param request DescribeLatestTransactionDigestsRequest
   * @return DescribeLatestTransactionDigestsResponse
   */
  async describeLatestTransactionDigests(request: DescribeLatestTransactionDigestsRequest): Promise<DescribeLatestTransactionDigestsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeLatestTransactionDigestsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeMemberRoleRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeMemberRoleResponse
   */
  async describeMemberRoleWithOptions(request: DescribeMemberRoleRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMemberRoleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMemberRole",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMemberRoleResponse>(await this.callApi(params, req, runtime), new DescribeMemberRoleResponse({}));
  }

  /**
   * @param request DescribeMemberRoleRequest
   * @return DescribeMemberRoleResponse
   */
  async describeMemberRole(request: DescribeMemberRoleRequest): Promise<DescribeMemberRoleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMemberRoleWithOptions(request, runtime);
  }

  /**
   * @param request DescribeMembersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeMembersResponse
   */
  async describeMembersWithOptions(request: DescribeMembersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMembersResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.current)) {
      body["Current"] = request.current;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMembers",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMembersResponse>(await this.callApi(params, req, runtime), new DescribeMembersResponse({}));
  }

  /**
   * @param request DescribeMembersRequest
   * @return DescribeMembersResponse
   */
  async describeMembers(request: DescribeMembersRequest): Promise<DescribeMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMembersWithOptions(request, runtime);
  }

  /**
   * @param request DescribeMetricRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeMetricResponse
   */
  async describeMetricWithOptions(request: DescribeMetricRequest, runtime: $Util.RuntimeOptions): Promise<DescribeMetricResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bizid)) {
      query["Bizid"] = request.bizid;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.innerIp)) {
      body["InnerIp"] = request.innerIp;
    }

    if (!Util.isUnset(request.metric)) {
      body["Metric"] = request.metric;
    }

    if (!Util.isUnset(request.period)) {
      body["Period"] = request.period;
    }

    if (!Util.isUnset(request.port)) {
      body["Port"] = request.port;
    }

    if (!Util.isUnset(request.timeArea)) {
      body["TimeArea"] = request.timeArea;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeMetric",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMetricResponse>(await this.callApi(params, req, runtime), new DescribeMetricResponse({}));
  }

  /**
   * @param request DescribeMetricRequest
   * @return DescribeMetricResponse
   */
  async describeMetric(request: DescribeMetricRequest): Promise<DescribeMetricResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMetricWithOptions(request, runtime);
  }

  /**
   * @param request DescribeMyBlockchainsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeMyBlockchainsResponse
   */
  async describeMyBlockchainsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeMyBlockchainsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeMyBlockchains",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMyBlockchainsResponse>(await this.callApi(params, req, runtime), new DescribeMyBlockchainsResponse({}));
  }

  /**
   * @return DescribeMyBlockchainsResponse
   */
  async describeMyBlockchains(): Promise<DescribeMyBlockchainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMyBlockchainsWithOptions(runtime);
  }

  /**
   * @param request DescribeMyBlockchanInfosRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeMyBlockchanInfosResponse
   */
  async describeMyBlockchanInfosWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeMyBlockchanInfosResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeMyBlockchanInfos",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMyBlockchanInfosResponse>(await this.callApi(params, req, runtime), new DescribeMyBlockchanInfosResponse({}));
  }

  /**
   * @return DescribeMyBlockchanInfosResponse
   */
  async describeMyBlockchanInfos(): Promise<DescribeMyBlockchanInfosResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMyBlockchanInfosWithOptions(runtime);
  }

  /**
   * @param request DescribeMySuccessAppliesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeMySuccessAppliesResponse
   */
  async describeMySuccessAppliesWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeMySuccessAppliesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeMySuccessApplies",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMySuccessAppliesResponse>(await this.callApi(params, req, runtime), new DescribeMySuccessAppliesResponse({}));
  }

  /**
   * @return DescribeMySuccessAppliesResponse
   */
  async describeMySuccessApplies(): Promise<DescribeMySuccessAppliesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMySuccessAppliesWithOptions(runtime);
  }

  /**
   * @param request DescribeMySuccessfulApplicationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeMySuccessfulApplicationResponse
   */
  async describeMySuccessfulApplicationWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeMySuccessfulApplicationResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeMySuccessfulApplication",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeMySuccessfulApplicationResponse>(await this.callApi(params, req, runtime), new DescribeMySuccessfulApplicationResponse({}));
  }

  /**
   * @return DescribeMySuccessfulApplicationResponse
   */
  async describeMySuccessfulApplication(): Promise<DescribeMySuccessfulApplicationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeMySuccessfulApplicationWithOptions(runtime);
  }

  /**
   * @param request DescribeNetstatURLRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeNetstatURLResponse
   */
  async describeNetstatURLWithOptions(request: DescribeNetstatURLRequest, runtime: $Util.RuntimeOptions): Promise<DescribeNetstatURLResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.id)) {
      body["Id"] = request.id;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeNetstatURL",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeNetstatURLResponse>(await this.callApi(params, req, runtime), new DescribeNetstatURLResponse({}));
  }

  /**
   * @param request DescribeNetstatURLRequest
   * @return DescribeNetstatURLResponse
   */
  async describeNetstatURL(request: DescribeNetstatURLRequest): Promise<DescribeNetstatURLResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeNetstatURLWithOptions(request, runtime);
  }

  /**
   * @param request DescribeOrdererLogsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOrdererLogsResponse
   */
  async describeOrdererLogsWithOptions(request: DescribeOrdererLogsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOrdererLogsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consortiumId)) {
      query["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.lines)) {
      query["Lines"] = request.lines;
    }

    if (!Util.isUnset(request.ordererName)) {
      query["OrdererName"] = request.ordererName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOrdererLogs",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrdererLogsResponse>(await this.callApi(params, req, runtime), new DescribeOrdererLogsResponse({}));
  }

  /**
   * @param request DescribeOrdererLogsRequest
   * @return DescribeOrdererLogsResponse
   */
  async describeOrdererLogs(request: DescribeOrdererLogsRequest): Promise<DescribeOrdererLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrdererLogsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeOrganizationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOrganizationResponse
   */
  async describeOrganizationWithOptions(request: DescribeOrganizationRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOrganizationResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOrganization",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrganizationResponse>(await this.callApi(params, req, runtime), new DescribeOrganizationResponse({}));
  }

  /**
   * @param request DescribeOrganizationRequest
   * @return DescribeOrganizationResponse
   */
  async describeOrganization(request: DescribeOrganizationRequest): Promise<DescribeOrganizationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrganizationWithOptions(request, runtime);
  }

  /**
   * @param request DescribeOrganizationChaincodesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOrganizationChaincodesResponse
   */
  async describeOrganizationChaincodesWithOptions(request: DescribeOrganizationChaincodesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOrganizationChaincodesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOrganizationChaincodes",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrganizationChaincodesResponse>(await this.callApi(params, req, runtime), new DescribeOrganizationChaincodesResponse({}));
  }

  /**
   * @param request DescribeOrganizationChaincodesRequest
   * @return DescribeOrganizationChaincodesResponse
   */
  async describeOrganizationChaincodes(request: DescribeOrganizationChaincodesRequest): Promise<DescribeOrganizationChaincodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrganizationChaincodesWithOptions(request, runtime);
  }

  /**
   * @description ****
   *
   * @param request DescribeOrganizationChannelsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOrganizationChannelsResponse
   */
  async describeOrganizationChannelsWithOptions(request: DescribeOrganizationChannelsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOrganizationChannelsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOrganizationChannels",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrganizationChannelsResponse>(await this.callApi(params, req, runtime), new DescribeOrganizationChannelsResponse({}));
  }

  /**
   * @description ****
   *
   * @param request DescribeOrganizationChannelsRequest
   * @return DescribeOrganizationChannelsResponse
   */
  async describeOrganizationChannels(request: DescribeOrganizationChannelsRequest): Promise<DescribeOrganizationChannelsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrganizationChannelsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeOrganizationDeletableRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOrganizationDeletableResponse
   */
  async describeOrganizationDeletableWithOptions(request: DescribeOrganizationDeletableRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOrganizationDeletableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOrganizationDeletable",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrganizationDeletableResponse>(await this.callApi(params, req, runtime), new DescribeOrganizationDeletableResponse({}));
  }

  /**
   * @param request DescribeOrganizationDeletableRequest
   * @return DescribeOrganizationDeletableResponse
   */
  async describeOrganizationDeletable(request: DescribeOrganizationDeletableRequest): Promise<DescribeOrganizationDeletableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrganizationDeletableWithOptions(request, runtime);
  }

  /**
   * @param request DescribeOrganizationMembersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOrganizationMembersResponse
   */
  async describeOrganizationMembersWithOptions(request: DescribeOrganizationMembersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOrganizationMembersResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOrganizationMembers",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrganizationMembersResponse>(await this.callApi(params, req, runtime), new DescribeOrganizationMembersResponse({}));
  }

  /**
   * @param request DescribeOrganizationMembersRequest
   * @return DescribeOrganizationMembersResponse
   */
  async describeOrganizationMembers(request: DescribeOrganizationMembersRequest): Promise<DescribeOrganizationMembersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrganizationMembersWithOptions(request, runtime);
  }

  /**
   * @param request DescribeOrganizationPeersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOrganizationPeersResponse
   */
  async describeOrganizationPeersWithOptions(request: DescribeOrganizationPeersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOrganizationPeersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOrganizationPeers",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrganizationPeersResponse>(await this.callApi(params, req, runtime), new DescribeOrganizationPeersResponse({}));
  }

  /**
   * @param request DescribeOrganizationPeersRequest
   * @return DescribeOrganizationPeersResponse
   */
  async describeOrganizationPeers(request: DescribeOrganizationPeersRequest): Promise<DescribeOrganizationPeersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrganizationPeersWithOptions(request, runtime);
  }

  /**
   * @param request DescribeOrganizationSpecsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOrganizationSpecsResponse
   */
  async describeOrganizationSpecsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeOrganizationSpecsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeOrganizationSpecs",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrganizationSpecsResponse>(await this.callApi(params, req, runtime), new DescribeOrganizationSpecsResponse({}));
  }

  /**
   * @return DescribeOrganizationSpecsResponse
   */
  async describeOrganizationSpecs(): Promise<DescribeOrganizationSpecsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrganizationSpecsWithOptions(runtime);
  }

  /**
   * @param request DescribeOrganizationTriggersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOrganizationTriggersResponse
   */
  async describeOrganizationTriggersWithOptions(request: DescribeOrganizationTriggersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOrganizationTriggersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOrganizationTriggers",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrganizationTriggersResponse>(await this.callApi(params, req, runtime), new DescribeOrganizationTriggersResponse({}));
  }

  /**
   * @param request DescribeOrganizationTriggersRequest
   * @return DescribeOrganizationTriggersResponse
   */
  async describeOrganizationTriggers(request: DescribeOrganizationTriggersRequest): Promise<DescribeOrganizationTriggersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrganizationTriggersWithOptions(request, runtime);
  }

  /**
   * @param request DescribeOrganizationUserCertsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOrganizationUserCertsResponse
   */
  async describeOrganizationUserCertsWithOptions(request: DescribeOrganizationUserCertsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOrganizationUserCertsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.username)) {
      body["Username"] = request.username;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOrganizationUserCerts",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrganizationUserCertsResponse>(await this.callApi(params, req, runtime), new DescribeOrganizationUserCertsResponse({}));
  }

  /**
   * @param request DescribeOrganizationUserCertsRequest
   * @return DescribeOrganizationUserCertsResponse
   */
  async describeOrganizationUserCerts(request: DescribeOrganizationUserCertsRequest): Promise<DescribeOrganizationUserCertsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrganizationUserCertsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeOrganizationUsersRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOrganizationUsersResponse
   */
  async describeOrganizationUsersWithOptions(request: DescribeOrganizationUsersRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOrganizationUsersResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOrganizationUsers",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrganizationUsersResponse>(await this.callApi(params, req, runtime), new DescribeOrganizationUsersResponse({}));
  }

  /**
   * @param request DescribeOrganizationUsersRequest
   * @return DescribeOrganizationUsersResponse
   */
  async describeOrganizationUsers(request: DescribeOrganizationUsersRequest): Promise<DescribeOrganizationUsersResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrganizationUsersWithOptions(request, runtime);
  }

  /**
   * @param request DescribeOrganizationsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOrganizationsResponse
   */
  async describeOrganizationsWithOptions(request: DescribeOrganizationsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOrganizationsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOrganizations",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrganizationsResponse>(await this.callApi(params, req, runtime), new DescribeOrganizationsResponse({}));
  }

  /**
   * @param request DescribeOrganizationsRequest
   * @return DescribeOrganizationsResponse
   */
  async describeOrganizations(request: DescribeOrganizationsRequest): Promise<DescribeOrganizationsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrganizationsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeOrgnaizationChaincodesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOrgnaizationChaincodesResponse
   */
  async describeOrgnaizationChaincodesWithOptions(request: DescribeOrgnaizationChaincodesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOrgnaizationChaincodesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOrgnaizationChaincodes",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOrgnaizationChaincodesResponse>(await this.callApi(params, req, runtime), new DescribeOrgnaizationChaincodesResponse({}));
  }

  /**
   * @param request DescribeOrgnaizationChaincodesRequest
   * @return DescribeOrgnaizationChaincodesResponse
   */
  async describeOrgnaizationChaincodes(request: DescribeOrgnaizationChaincodesRequest): Promise<DescribeOrgnaizationChaincodesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOrgnaizationChaincodesWithOptions(request, runtime);
  }

  /**
   * @param request DescribeOssPropertiesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeOssPropertiesResponse
   */
  async describeOssPropertiesWithOptions(request: DescribeOssPropertiesRequest, runtime: $Util.RuntimeOptions): Promise<DescribeOssPropertiesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeOssProperties",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeOssPropertiesResponse>(await this.callApi(params, req, runtime), new DescribeOssPropertiesResponse({}));
  }

  /**
   * @param request DescribeOssPropertiesRequest
   * @return DescribeOssPropertiesResponse
   */
  async describeOssProperties(request: DescribeOssPropertiesRequest): Promise<DescribeOssPropertiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeOssPropertiesWithOptions(request, runtime);
  }

  /**
   * @param request DescribePeerLogsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribePeerLogsResponse
   */
  async describePeerLogsWithOptions(request: DescribePeerLogsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePeerLogsResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.lines)) {
      query["Lines"] = request.lines;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.peerName)) {
      query["PeerName"] = request.peerName;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribePeerLogs",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePeerLogsResponse>(await this.callApi(params, req, runtime), new DescribePeerLogsResponse({}));
  }

  /**
   * @param request DescribePeerLogsRequest
   * @return DescribePeerLogsResponse
   */
  async describePeerLogs(request: DescribePeerLogsRequest): Promise<DescribePeerLogsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePeerLogsWithOptions(request, runtime);
  }

  /**
   * @param request DescribePublicAntChainContractProjectContentTreeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribePublicAntChainContractProjectContentTreeResponse
   */
  async describePublicAntChainContractProjectContentTreeWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribePublicAntChainContractProjectContentTreeResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribePublicAntChainContractProjectContentTree",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePublicAntChainContractProjectContentTreeResponse>(await this.callApi(params, req, runtime), new DescribePublicAntChainContractProjectContentTreeResponse({}));
  }

  /**
   * @return DescribePublicAntChainContractProjectContentTreeResponse
   */
  async describePublicAntChainContractProjectContentTree(): Promise<DescribePublicAntChainContractProjectContentTreeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePublicAntChainContractProjectContentTreeWithOptions(runtime);
  }

  /**
   * @param request DescribePublicAntChainDownloadPathsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribePublicAntChainDownloadPathsResponse
   */
  async describePublicAntChainDownloadPathsWithOptions(request: DescribePublicAntChainDownloadPathsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePublicAntChainDownloadPathsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribePublicAntChainDownloadPaths",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePublicAntChainDownloadPathsResponse>(await this.callApi(params, req, runtime), new DescribePublicAntChainDownloadPathsResponse({}));
  }

  /**
   * @param request DescribePublicAntChainDownloadPathsRequest
   * @return DescribePublicAntChainDownloadPathsResponse
   */
  async describePublicAntChainDownloadPaths(request: DescribePublicAntChainDownloadPathsRequest): Promise<DescribePublicAntChainDownloadPathsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePublicAntChainDownloadPathsWithOptions(request, runtime);
  }

  /**
   * @param request DescribePublicCloudIDEEnvConfigsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribePublicCloudIDEEnvConfigsResponse
   */
  async describePublicCloudIDEEnvConfigsWithOptions(request: DescribePublicCloudIDEEnvConfigsRequest, runtime: $Util.RuntimeOptions): Promise<DescribePublicCloudIDEEnvConfigsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribePublicCloudIDEEnvConfigs",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribePublicCloudIDEEnvConfigsResponse>(await this.callApi(params, req, runtime), new DescribePublicCloudIDEEnvConfigsResponse({}));
  }

  /**
   * @param request DescribePublicCloudIDEEnvConfigsRequest
   * @return DescribePublicCloudIDEEnvConfigsResponse
   */
  async describePublicCloudIDEEnvConfigs(request: DescribePublicCloudIDEEnvConfigsRequest): Promise<DescribePublicCloudIDEEnvConfigsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describePublicCloudIDEEnvConfigsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeQRCodeAccessLogRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeQRCodeAccessLogResponse
   */
  async describeQRCodeAccessLogWithOptions(request: DescribeQRCodeAccessLogRequest, runtime: $Util.RuntimeOptions): Promise<DescribeQRCodeAccessLogResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeQRCodeAccessLog",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeQRCodeAccessLogResponse>(await this.callApi(params, req, runtime), new DescribeQRCodeAccessLogResponse({}));
  }

  /**
   * @param request DescribeQRCodeAccessLogRequest
   * @return DescribeQRCodeAccessLogResponse
   */
  async describeQRCodeAccessLog(request: DescribeQRCodeAccessLogRequest): Promise<DescribeQRCodeAccessLogResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeQRCodeAccessLogWithOptions(request, runtime);
  }

  /**
   * @param request DescribeQRCodeAuthorityRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeQRCodeAuthorityResponse
   */
  async describeQRCodeAuthorityWithOptions(request: DescribeQRCodeAuthorityRequest, runtime: $Util.RuntimeOptions): Promise<DescribeQRCodeAuthorityResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeQRCodeAuthority",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeQRCodeAuthorityResponse>(await this.callApi(params, req, runtime), new DescribeQRCodeAuthorityResponse({}));
  }

  /**
   * @param request DescribeQRCodeAuthorityRequest
   * @return DescribeQRCodeAuthorityResponse
   */
  async describeQRCodeAuthority(request: DescribeQRCodeAuthorityRequest): Promise<DescribeQRCodeAuthorityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeQRCodeAuthorityWithOptions(request, runtime);
  }

  /**
   * @param request DescribeRegionsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeRegionsResponse
   */
  async describeRegionsWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeRegionsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeRegions",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRegionsResponse>(await this.callApi(params, req, runtime), new DescribeRegionsResponse({}));
  }

  /**
   * @return DescribeRegionsResponse
   */
  async describeRegions(): Promise<DescribeRegionsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRegionsWithOptions(runtime);
  }

  /**
   * @param request DescribeResourceTypeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeResourceTypeResponse
   */
  async describeResourceTypeWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeResourceTypeResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeResourceType",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeResourceTypeResponse>(await this.callApi(params, req, runtime), new DescribeResourceTypeResponse({}));
  }

  /**
   * @return DescribeResourceTypeResponse
   */
  async describeResourceType(): Promise<DescribeResourceTypeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeResourceTypeWithOptions(runtime);
  }

  /**
   * @param request DescribeResourceTypesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeResourceTypesResponse
   */
  async describeResourceTypesWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeResourceTypesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeResourceTypes",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeResourceTypesResponse>(await this.callApi(params, req, runtime), new DescribeResourceTypesResponse({}));
  }

  /**
   * @return DescribeResourceTypesResponse
   */
  async describeResourceTypes(): Promise<DescribeResourceTypesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeResourceTypesWithOptions(runtime);
  }

  /**
   * @param request DescribeRootDomainRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeRootDomainResponse
   */
  async describeRootDomainWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeRootDomainResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeRootDomain",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeRootDomainResponse>(await this.callApi(params, req, runtime), new DescribeRootDomainResponse({}));
  }

  /**
   * @return DescribeRootDomainResponse
   */
  async describeRootDomain(): Promise<DescribeRootDomainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeRootDomainWithOptions(runtime);
  }

  /**
   * @param request DescribeSchemaDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeSchemaDetailResponse
   */
  async describeSchemaDetailWithOptions(request: DescribeSchemaDetailRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSchemaDetailResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.schemaId)) {
      body["SchemaId"] = request.schemaId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSchemaDetail",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSchemaDetailResponse>(await this.callApi(params, req, runtime), new DescribeSchemaDetailResponse({}));
  }

  /**
   * @param request DescribeSchemaDetailRequest
   * @return DescribeSchemaDetailResponse
   */
  async describeSchemaDetail(request: DescribeSchemaDetailRequest): Promise<DescribeSchemaDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSchemaDetailWithOptions(request, runtime);
  }

  /**
   * @param request DescribeSmartContractJobStatusRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeSmartContractJobStatusResponse
   */
  async describeSmartContractJobStatusWithOptions(request: DescribeSmartContractJobStatusRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSmartContractJobStatusResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.jobId)) {
      body["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSmartContractJobStatus",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSmartContractJobStatusResponse>(await this.callApi(params, req, runtime), new DescribeSmartContractJobStatusResponse({}));
  }

  /**
   * @param request DescribeSmartContractJobStatusRequest
   * @return DescribeSmartContractJobStatusResponse
   */
  async describeSmartContractJobStatus(request: DescribeSmartContractJobStatusRequest): Promise<DescribeSmartContractJobStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSmartContractJobStatusWithOptions(request, runtime);
  }

  /**
   * @param request DescribeSmartContractJobsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeSmartContractJobsResponse
   */
  async describeSmartContractJobsWithOptions(request: DescribeSmartContractJobsRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSmartContractJobsResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.size)) {
      body["Size"] = request.size;
    }

    if (!Util.isUnset(request.start)) {
      body["Start"] = request.start;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSmartContractJobs",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSmartContractJobsResponse>(await this.callApi(params, req, runtime), new DescribeSmartContractJobsResponse({}));
  }

  /**
   * @param request DescribeSmartContractJobsRequest
   * @return DescribeSmartContractJobsResponse
   */
  async describeSmartContractJobs(request: DescribeSmartContractJobsRequest): Promise<DescribeSmartContractJobsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSmartContractJobsWithOptions(request, runtime);
  }

  /**
   * @param request DescribeSmartContractJobsByNameRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeSmartContractJobsByNameResponse
   */
  async describeSmartContractJobsByNameWithOptions(request: DescribeSmartContractJobsByNameRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSmartContractJobsByNameResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.size)) {
      body["Size"] = request.size;
    }

    if (!Util.isUnset(request.start)) {
      body["Start"] = request.start;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSmartContractJobsByName",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSmartContractJobsByNameResponse>(await this.callApi(params, req, runtime), new DescribeSmartContractJobsByNameResponse({}));
  }

  /**
   * @param request DescribeSmartContractJobsByNameRequest
   * @return DescribeSmartContractJobsByNameResponse
   */
  async describeSmartContractJobsByName(request: DescribeSmartContractJobsByNameRequest): Promise<DescribeSmartContractJobsByNameResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSmartContractJobsByNameWithOptions(request, runtime);
  }

  /**
   * @param request DescribeSmartContractResultRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeSmartContractResultResponse
   */
  async describeSmartContractResultWithOptions(request: DescribeSmartContractResultRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSmartContractResultResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.jobId)) {
      body["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSmartContractResult",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSmartContractResultResponse>(await this.callApi(params, req, runtime), new DescribeSmartContractResultResponse({}));
  }

  /**
   * @param request DescribeSmartContractResultRequest
   * @return DescribeSmartContractResultResponse
   */
  async describeSmartContractResult(request: DescribeSmartContractResultRequest): Promise<DescribeSmartContractResultResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSmartContractResultWithOptions(request, runtime);
  }

  /**
   * @param request DescribeSmartContractResultContentRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeSmartContractResultContentResponse
   */
  async describeSmartContractResultContentWithOptions(request: DescribeSmartContractResultContentRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSmartContractResultContentResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.jobId)) {
      body["JobId"] = request.jobId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSmartContractResultContent",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSmartContractResultContentResponse>(await this.callApi(params, req, runtime), new DescribeSmartContractResultContentResponse({}));
  }

  /**
   * @param request DescribeSmartContractResultContentRequest
   * @return DescribeSmartContractResultContentResponse
   */
  async describeSmartContractResultContent(request: DescribeSmartContractResultContentRequest): Promise<DescribeSmartContractResultContentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSmartContractResultContentWithOptions(request, runtime);
  }

  /**
   * @param request DescribeSubscribeCloudServiceIntegrationStateRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeSubscribeCloudServiceIntegrationStateResponse
   */
  async describeSubscribeCloudServiceIntegrationStateWithOptions(request: DescribeSubscribeCloudServiceIntegrationStateRequest, runtime: $Util.RuntimeOptions): Promise<DescribeSubscribeCloudServiceIntegrationStateResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeSubscribeCloudServiceIntegrationState",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeSubscribeCloudServiceIntegrationStateResponse>(await this.callApi(params, req, runtime), new DescribeSubscribeCloudServiceIntegrationStateResponse({}));
  }

  /**
   * @param request DescribeSubscribeCloudServiceIntegrationStateRequest
   * @return DescribeSubscribeCloudServiceIntegrationStateResponse
   */
  async describeSubscribeCloudServiceIntegrationState(request: DescribeSubscribeCloudServiceIntegrationStateRequest): Promise<DescribeSubscribeCloudServiceIntegrationStateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeSubscribeCloudServiceIntegrationStateWithOptions(request, runtime);
  }

  /**
   * @param request DescribeTasksRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeTasksResponse
   */
  async describeTasksWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeTasksResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeTasks",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTasksResponse>(await this.callApi(params, req, runtime), new DescribeTasksResponse({}));
  }

  /**
   * @return DescribeTasksResponse
   */
  async describeTasks(): Promise<DescribeTasksResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTasksWithOptions(runtime);
  }

  /**
   * @param request DescribeTemplatesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeTemplatesResponse
   */
  async describeTemplatesWithOptions(runtime: $Util.RuntimeOptions): Promise<DescribeTemplatesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "DescribeTemplates",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTemplatesResponse>(await this.callApi(params, req, runtime), new DescribeTemplatesResponse({}));
  }

  /**
   * @return DescribeTemplatesResponse
   */
  async describeTemplates(): Promise<DescribeTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTemplatesWithOptions(runtime);
  }

  /**
   * @param request DescribeTransactionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeTransactionResponse
   */
  async describeTransactionWithOptions(request: DescribeTransactionRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTransactionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.hash)) {
      body["Hash"] = request.hash;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTransaction",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTransactionResponse>(await this.callApi(params, req, runtime), new DescribeTransactionResponse({}));
  }

  /**
   * @param request DescribeTransactionRequest
   * @return DescribeTransactionResponse
   */
  async describeTransaction(request: DescribeTransactionRequest): Promise<DescribeTransactionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTransactionWithOptions(request, runtime);
  }

  /**
   * @param request DescribeTransactionFor2CBrowserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeTransactionFor2CBrowserResponse
   */
  async describeTransactionFor2CBrowserWithOptions(request: DescribeTransactionFor2CBrowserRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTransactionFor2CBrowserResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alipayAuthCode)) {
      body["AlipayAuthCode"] = request.alipayAuthCode;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.hash)) {
      body["Hash"] = request.hash;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTransactionFor2CBrowser",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "Anonymous",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTransactionFor2CBrowserResponse>(await this.callApi(params, req, runtime), new DescribeTransactionFor2CBrowserResponse({}));
  }

  /**
   * @param request DescribeTransactionFor2CBrowserRequest
   * @return DescribeTransactionFor2CBrowserResponse
   */
  async describeTransactionFor2CBrowser(request: DescribeTransactionFor2CBrowserRequest): Promise<DescribeTransactionFor2CBrowserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTransactionFor2CBrowserWithOptions(request, runtime);
  }

  /**
   * @param request DescribeTransactionQRCodeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeTransactionQRCodeResponse
   */
  async describeTransactionQRCodeWithOptions(request: DescribeTransactionQRCodeRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTransactionQRCodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.hash)) {
      body["Hash"] = request.hash;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTransactionQRCode",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTransactionQRCodeResponse>(await this.callApi(params, req, runtime), new DescribeTransactionQRCodeResponse({}));
  }

  /**
   * @param request DescribeTransactionQRCodeRequest
   * @return DescribeTransactionQRCodeResponse
   */
  async describeTransactionQRCode(request: DescribeTransactionQRCodeRequest): Promise<DescribeTransactionQRCodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTransactionQRCodeWithOptions(request, runtime);
  }

  /**
   * @param request DescribeTransactionReceiptFor2CBrowserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeTransactionReceiptFor2CBrowserResponse
   */
  async describeTransactionReceiptFor2CBrowserWithOptions(request: DescribeTransactionReceiptFor2CBrowserRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTransactionReceiptFor2CBrowserResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.alipayAuthCode)) {
      body["AlipayAuthCode"] = request.alipayAuthCode;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.hash)) {
      body["Hash"] = request.hash;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTransactionReceiptFor2CBrowser",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "Anonymous",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTransactionReceiptFor2CBrowserResponse>(await this.callApi(params, req, runtime), new DescribeTransactionReceiptFor2CBrowserResponse({}));
  }

  /**
   * @param request DescribeTransactionReceiptFor2CBrowserRequest
   * @return DescribeTransactionReceiptFor2CBrowserResponse
   */
  async describeTransactionReceiptFor2CBrowser(request: DescribeTransactionReceiptFor2CBrowserRequest): Promise<DescribeTransactionReceiptFor2CBrowserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTransactionReceiptFor2CBrowserWithOptions(request, runtime);
  }

  /**
   * @param request DescribeTriggerRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DescribeTriggerResponse
   */
  async describeTriggerWithOptions(request: DescribeTriggerRequest, runtime: $Util.RuntimeOptions): Promise<DescribeTriggerResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelId)) {
      query["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.name)) {
      query["Name"] = request.name;
    }

    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "DescribeTrigger",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DescribeTriggerResponse>(await this.callApi(params, req, runtime), new DescribeTriggerResponse({}));
  }

  /**
   * @param request DescribeTriggerRequest
   * @return DescribeTriggerResponse
   */
  async describeTrigger(request: DescribeTriggerRequest): Promise<DescribeTriggerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.describeTriggerWithOptions(request, runtime);
  }

  /**
   * @param request DestroyConsortiumRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DestroyConsortiumResponse
   */
  async destroyConsortiumWithOptions(request: DestroyConsortiumRequest, runtime: $Util.RuntimeOptions): Promise<DestroyConsortiumResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DestroyConsortium",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DestroyConsortiumResponse>(await this.callApi(params, req, runtime), new DestroyConsortiumResponse({}));
  }

  /**
   * @param request DestroyConsortiumRequest
   * @return DestroyConsortiumResponse
   */
  async destroyConsortium(request: DestroyConsortiumRequest): Promise<DestroyConsortiumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.destroyConsortiumWithOptions(request, runtime);
  }

  /**
   * @param request DestroyEthereumRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DestroyEthereumResponse
   */
  async destroyEthereumWithOptions(request: DestroyEthereumRequest, runtime: $Util.RuntimeOptions): Promise<DestroyEthereumResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ethereumId)) {
      body["EthereumId"] = request.ethereumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DestroyEthereum",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DestroyEthereumResponse>(await this.callApi(params, req, runtime), new DestroyEthereumResponse({}));
  }

  /**
   * @param request DestroyEthereumRequest
   * @return DestroyEthereumResponse
   */
  async destroyEthereum(request: DestroyEthereumRequest): Promise<DestroyEthereumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.destroyEthereumWithOptions(request, runtime);
  }

  /**
   * @param request DestroyOrganizationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DestroyOrganizationResponse
   */
  async destroyOrganizationWithOptions(request: DestroyOrganizationRequest, runtime: $Util.RuntimeOptions): Promise<DestroyOrganizationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DestroyOrganization",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DestroyOrganizationResponse>(await this.callApi(params, req, runtime), new DestroyOrganizationResponse({}));
  }

  /**
   * @param request DestroyOrganizationRequest
   * @return DestroyOrganizationResponse
   */
  async destroyOrganization(request: DestroyOrganizationRequest): Promise<DestroyOrganizationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.destroyOrganizationWithOptions(request, runtime);
  }

  /**
   * @param request DownloadAllRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DownloadAllResponse
   */
  async downloadAllWithOptions(request: DownloadAllRequest, runtime: $Util.RuntimeOptions): Promise<DownloadAllResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DownloadAll",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DownloadAllResponse>(await this.callApi(params, req, runtime), new DownloadAllResponse({}));
  }

  /**
   * @param request DownloadAllRequest
   * @return DownloadAllResponse
   */
  async downloadAll(request: DownloadAllRequest): Promise<DownloadAllResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.downloadAllWithOptions(request, runtime);
  }

  /**
   * @param request DownloadBizviewRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DownloadBizviewResponse
   */
  async downloadBizviewWithOptions(request: DownloadBizviewRequest, runtime: $Util.RuntimeOptions): Promise<DownloadBizviewResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DownloadBizview",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DownloadBizviewResponse>(await this.callApi(params, req, runtime), new DownloadBizviewResponse({}));
  }

  /**
   * @param request DownloadBizviewRequest
   * @return DownloadBizviewResponse
   */
  async downloadBizview(request: DownloadBizviewRequest): Promise<DownloadBizviewResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.downloadBizviewWithOptions(request, runtime);
  }

  /**
   * @param request DownloadFabricChannelSDKRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DownloadFabricChannelSDKResponse
   */
  async downloadFabricChannelSDKWithOptions(request: DownloadFabricChannelSDKRequest, runtime: $Util.RuntimeOptions): Promise<DownloadFabricChannelSDKResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.username)) {
      query["Username"] = request.username;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DownloadFabricChannelSDK",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DownloadFabricChannelSDKResponse>(await this.callApi(params, req, runtime), new DownloadFabricChannelSDKResponse({}));
  }

  /**
   * @param request DownloadFabricChannelSDKRequest
   * @return DownloadFabricChannelSDKResponse
   */
  async downloadFabricChannelSDK(request: DownloadFabricChannelSDKRequest): Promise<DownloadFabricChannelSDKResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.downloadFabricChannelSDKWithOptions(request, runtime);
  }

  /**
   * @param request DownloadOrganizationSDKRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DownloadOrganizationSDKResponse
   */
  async downloadOrganizationSDKWithOptions(request: DownloadOrganizationSDKRequest, runtime: $Util.RuntimeOptions): Promise<DownloadOrganizationSDKResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.username)) {
      query["Username"] = request.username;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DownloadOrganizationSDK",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DownloadOrganizationSDKResponse>(await this.callApi(params, req, runtime), new DownloadOrganizationSDKResponse({}));
  }

  /**
   * @param request DownloadOrganizationSDKRequest
   * @return DownloadOrganizationSDKResponse
   */
  async downloadOrganizationSDK(request: DownloadOrganizationSDKRequest): Promise<DownloadOrganizationSDKResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.downloadOrganizationSDKWithOptions(request, runtime);
  }

  /**
   * @param request DownloadSDK2Request
   * @param runtime runtime options for this request RuntimeOptions
   * @return DownloadSDK2Response
   */
  async downloadSDK2WithOptions(request: DownloadSDK2Request, runtime: $Util.RuntimeOptions): Promise<DownloadSDK2Response> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DownloadSDK2",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DownloadSDK2Response>(await this.callApi(params, req, runtime), new DownloadSDK2Response({}));
  }

  /**
   * @param request DownloadSDK2Request
   * @return DownloadSDK2Response
   */
  async downloadSDK2(request: DownloadSDK2Request): Promise<DownloadSDK2Response> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.downloadSDK2WithOptions(request, runtime);
  }

  /**
   * @param request DownloadSdkRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DownloadSdkResponse
   */
  async downloadSdkWithOptions(request: DownloadSdkRequest, runtime: $Util.RuntimeOptions): Promise<DownloadSdkResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DownloadSdk",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DownloadSdkResponse>(await this.callApi(params, req, runtime), new DownloadSdkResponse({}));
  }

  /**
   * @param request DownloadSdkRequest
   * @return DownloadSdkResponse
   */
  async downloadSdk(request: DownloadSdkRequest): Promise<DownloadSdkResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.downloadSdkWithOptions(request, runtime);
  }

  /**
   * @param request DownloadSignedDataRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DownloadSignedDataResponse
   */
  async downloadSignedDataWithOptions(request: DownloadSignedDataRequest, runtime: $Util.RuntimeOptions): Promise<DownloadSignedDataResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.path)) {
      body["Path"] = request.path;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DownloadSignedData",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DownloadSignedDataResponse>(await this.callApi(params, req, runtime), new DownloadSignedDataResponse({}));
  }

  /**
   * @param request DownloadSignedDataRequest
   * @return DownloadSignedDataResponse
   */
  async downloadSignedData(request: DownloadSignedDataRequest): Promise<DownloadSignedDataResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.downloadSignedDataWithOptions(request, runtime);
  }

  /**
   * @param request DuplicateAntChainContractProjectRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return DuplicateAntChainContractProjectResponse
   */
  async duplicateAntChainContractProjectWithOptions(request: DuplicateAntChainContractProjectRequest, runtime: $Util.RuntimeOptions): Promise<DuplicateAntChainContractProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectVersion)) {
      body["ProjectVersion"] = request.projectVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "DuplicateAntChainContractProject",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<DuplicateAntChainContractProjectResponse>(await this.callApi(params, req, runtime), new DuplicateAntChainContractProjectResponse({}));
  }

  /**
   * @param request DuplicateAntChainContractProjectRequest
   * @return DuplicateAntChainContractProjectResponse
   */
  async duplicateAntChainContractProject(request: DuplicateAntChainContractProjectRequest): Promise<DuplicateAntChainContractProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.duplicateAntChainContractProjectWithOptions(request, runtime);
  }

  /**
   * @param request FreezeAccountRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return FreezeAccountResponse
   */
  async freezeAccountWithOptions(request: FreezeAccountRequest, runtime: $Util.RuntimeOptions): Promise<FreezeAccountResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.account)) {
      body["Account"] = request.account;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "FreezeAccount",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<FreezeAccountResponse>(await this.callApi(params, req, runtime), new FreezeAccountResponse({}));
  }

  /**
   * @param request FreezeAccountRequest
   * @return FreezeAccountResponse
   */
  async freezeAccount(request: FreezeAccountRequest): Promise<FreezeAccountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.freezeAccountWithOptions(request, runtime);
  }

  /**
   * @param request FreezeAntChainAccountRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return FreezeAntChainAccountResponse
   */
  async freezeAntChainAccountWithOptions(request: FreezeAntChainAccountRequest, runtime: $Util.RuntimeOptions): Promise<FreezeAntChainAccountResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.account)) {
      body["Account"] = request.account;
    }

    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "FreezeAntChainAccount",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<FreezeAntChainAccountResponse>(await this.callApi(params, req, runtime), new FreezeAntChainAccountResponse({}));
  }

  /**
   * @param request FreezeAntChainAccountRequest
   * @return FreezeAntChainAccountResponse
   */
  async freezeAntChainAccount(request: FreezeAntChainAccountRequest): Promise<FreezeAntChainAccountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.freezeAntChainAccountWithOptions(request, runtime);
  }

  /**
   * @param request GetAppliesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetAppliesResponse
   */
  async getAppliesWithOptions(request: GetAppliesRequest, runtime: $Util.RuntimeOptions): Promise<GetAppliesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.current)) {
      body["Current"] = request.current;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetApplies",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetAppliesResponse>(await this.callApi(params, req, runtime), new GetAppliesResponse({}));
  }

  /**
   * @param request GetAppliesRequest
   * @return GetAppliesResponse
   */
  async getApplies(request: GetAppliesRequest): Promise<GetAppliesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getAppliesWithOptions(request, runtime);
  }

  /**
   * @param request GetBcSchemaRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetBcSchemaResponse
   */
  async getBcSchemaWithOptions(request: GetBcSchemaRequest, runtime: $Util.RuntimeOptions): Promise<GetBcSchemaResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetBcSchema",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetBcSchemaResponse>(await this.callApi(params, req, runtime), new GetBcSchemaResponse({}));
  }

  /**
   * @param request GetBcSchemaRequest
   * @return GetBcSchemaResponse
   */
  async getBcSchema(request: GetBcSchemaRequest): Promise<GetBcSchemaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getBcSchemaWithOptions(request, runtime);
  }

  /**
   * @param request GetBlockchainCreateTaskRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetBlockchainCreateTaskResponse
   */
  async getBlockchainCreateTaskWithOptions(request: GetBlockchainCreateTaskRequest, runtime: $Util.RuntimeOptions): Promise<GetBlockchainCreateTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.current)) {
      body["Current"] = request.current;
    }

    if (!Util.isUnset(request.pageSize)) {
      body["PageSize"] = request.pageSize;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetBlockchainCreateTask",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetBlockchainCreateTaskResponse>(await this.callApi(params, req, runtime), new GetBlockchainCreateTaskResponse({}));
  }

  /**
   * @param request GetBlockchainCreateTaskRequest
   * @return GetBlockchainCreateTaskResponse
   */
  async getBlockchainCreateTask(request: GetBlockchainCreateTaskRequest): Promise<GetBlockchainCreateTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getBlockchainCreateTaskWithOptions(request, runtime);
  }

  /**
   * @param request GetBlockchainInfoRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetBlockchainInfoResponse
   */
  async getBlockchainInfoWithOptions(request: GetBlockchainInfoRequest, runtime: $Util.RuntimeOptions): Promise<GetBlockchainInfoResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetBlockchainInfo",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetBlockchainInfoResponse>(await this.callApi(params, req, runtime), new GetBlockchainInfoResponse({}));
  }

  /**
   * @param request GetBlockchainInfoRequest
   * @return GetBlockchainInfoResponse
   */
  async getBlockchainInfo(request: GetBlockchainInfoRequest): Promise<GetBlockchainInfoResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getBlockchainInfoWithOptions(request, runtime);
  }

  /**
   * @param request GetMyBlockchainsRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetMyBlockchainsResponse
   */
  async getMyBlockchainsWithOptions(runtime: $Util.RuntimeOptions): Promise<GetMyBlockchainsResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetMyBlockchains",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMyBlockchainsResponse>(await this.callApi(params, req, runtime), new GetMyBlockchainsResponse({}));
  }

  /**
   * @return GetMyBlockchainsResponse
   */
  async getMyBlockchains(): Promise<GetMyBlockchainsResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMyBlockchainsWithOptions(runtime);
  }

  /**
   * @param request GetMySuccessAppliesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetMySuccessAppliesResponse
   */
  async getMySuccessAppliesWithOptions(runtime: $Util.RuntimeOptions): Promise<GetMySuccessAppliesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetMySuccessApplies",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetMySuccessAppliesResponse>(await this.callApi(params, req, runtime), new GetMySuccessAppliesResponse({}));
  }

  /**
   * @return GetMySuccessAppliesResponse
   */
  async getMySuccessApplies(): Promise<GetMySuccessAppliesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getMySuccessAppliesWithOptions(runtime);
  }

  /**
   * @param request GetOssPropertiesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetOssPropertiesResponse
   */
  async getOssPropertiesWithOptions(request: GetOssPropertiesRequest, runtime: $Util.RuntimeOptions): Promise<GetOssPropertiesResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "GetOssProperties",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetOssPropertiesResponse>(await this.callApi(params, req, runtime), new GetOssPropertiesResponse({}));
  }

  /**
   * @param request GetOssPropertiesRequest
   * @return GetOssPropertiesResponse
   */
  async getOssProperties(request: GetOssPropertiesRequest): Promise<GetOssPropertiesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getOssPropertiesWithOptions(request, runtime);
  }

  /**
   * @param request GetTemplatesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return GetTemplatesResponse
   */
  async getTemplatesWithOptions(runtime: $Util.RuntimeOptions): Promise<GetTemplatesResponse> {
    let req = new $OpenApi.OpenApiRequest({ });
    let params = new $OpenApi.Params({
      action: "GetTemplates",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<GetTemplatesResponse>(await this.callApi(params, req, runtime), new GetTemplatesResponse({}));
  }

  /**
   * @return GetTemplatesResponse
   */
  async getTemplates(): Promise<GetTemplatesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.getTemplatesWithOptions(runtime);
  }

  /**
   * @param request InstallChaincodeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return InstallChaincodeResponse
   */
  async installChaincodeWithOptions(request: InstallChaincodeRequest, runtime: $Util.RuntimeOptions): Promise<InstallChaincodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodeId)) {
      body["ChaincodeId"] = request.chaincodeId;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "InstallChaincode",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InstallChaincodeResponse>(await this.callApi(params, req, runtime), new InstallChaincodeResponse({}));
  }

  /**
   * @param request InstallChaincodeRequest
   * @return InstallChaincodeResponse
   */
  async installChaincode(request: InstallChaincodeRequest): Promise<InstallChaincodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installChaincodeWithOptions(request, runtime);
  }

  /**
   * @param request InstallFabricChaincodePackageRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return InstallFabricChaincodePackageResponse
   */
  async installFabricChaincodePackageWithOptions(request: InstallFabricChaincodePackageRequest, runtime: $Util.RuntimeOptions): Promise<InstallFabricChaincodePackageResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodePackageId)) {
      body["ChaincodePackageId"] = request.chaincodePackageId;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "InstallFabricChaincodePackage",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InstallFabricChaincodePackageResponse>(await this.callApi(params, req, runtime), new InstallFabricChaincodePackageResponse({}));
  }

  /**
   * @param request InstallFabricChaincodePackageRequest
   * @return InstallFabricChaincodePackageResponse
   */
  async installFabricChaincodePackage(request: InstallFabricChaincodePackageRequest): Promise<InstallFabricChaincodePackageResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.installFabricChaincodePackageWithOptions(request, runtime);
  }

  /**
   * @param request InstantiateChaincodeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return InstantiateChaincodeResponse
   */
  async instantiateChaincodeWithOptions(request: InstantiateChaincodeRequest, runtime: $Util.RuntimeOptions): Promise<InstantiateChaincodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodeId)) {
      body["ChaincodeId"] = request.chaincodeId;
    }

    if (!Util.isUnset(request.collectionConfig)) {
      body["CollectionConfig"] = request.collectionConfig;
    }

    if (!Util.isUnset(request.endorsePolicy)) {
      body["EndorsePolicy"] = request.endorsePolicy;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "InstantiateChaincode",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InstantiateChaincodeResponse>(await this.callApi(params, req, runtime), new InstantiateChaincodeResponse({}));
  }

  /**
   * @param request InstantiateChaincodeRequest
   * @return InstantiateChaincodeResponse
   */
  async instantiateChaincode(request: InstantiateChaincodeRequest): Promise<InstantiateChaincodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.instantiateChaincodeWithOptions(request, runtime);
  }

  /**
   * @param request InviteUserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return InviteUserResponse
   */
  async inviteUserWithOptions(request: InviteUserRequest, runtime: $Util.RuntimeOptions): Promise<InviteUserResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bid)) {
      body["Bid"] = request.bid;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.userEmail)) {
      body["UserEmail"] = request.userEmail;
    }

    if (!Util.isUnset(request.userId)) {
      body["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "InviteUser",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<InviteUserResponse>(await this.callApi(params, req, runtime), new InviteUserResponse({}));
  }

  /**
   * @param request InviteUserRequest
   * @return InviteUserResponse
   */
  async inviteUser(request: InviteUserRequest): Promise<InviteUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.inviteUserWithOptions(request, runtime);
  }

  /**
   * @description ****
   *
   * @param request JoinChannelRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return JoinChannelResponse
   */
  async joinChannelWithOptions(request: JoinChannelRequest, runtime: $Util.RuntimeOptions): Promise<JoinChannelResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.channelId)) {
      query["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.do)) {
      query["Do"] = request.do;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "JoinChannel",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<JoinChannelResponse>(await this.callApi(params, req, runtime), new JoinChannelResponse({}));
  }

  /**
   * @description ****
   *
   * @param request JoinChannelRequest
   * @return JoinChannelResponse
   */
  async joinChannel(request: JoinChannelRequest): Promise<JoinChannelResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.joinChannelWithOptions(request, runtime);
  }

  /**
   * @param request ListTagResourcesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ListTagResourcesResponse
   */
  async listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<ListTagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.nextToken)) {
      query["NextToken"] = request.nextToken;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "ListTagResources",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ListTagResourcesResponse>(await this.callApi(params, req, runtime), new ListTagResourcesResponse({}));
  }

  /**
   * @param request ListTagResourcesRequest
   * @return ListTagResourcesResponse
   */
  async listTagResources(request: ListTagResourcesRequest): Promise<ListTagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.listTagResourcesWithOptions(request, runtime);
  }

  /**
   * @param request ModifyTriggerRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ModifyTriggerResponse
   */
  async modifyTriggerWithOptions(request: ModifyTriggerRequest, runtime: $Util.RuntimeOptions): Promise<ModifyTriggerResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.options)) {
      body["Options"] = request.options;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.source)) {
      body["Source"] = request.source;
    }

    if (!Util.isUnset(request.status)) {
      body["Status"] = request.status;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ModifyTrigger",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ModifyTriggerResponse>(await this.callApi(params, req, runtime), new ModifyTriggerResponse({}));
  }

  /**
   * @param request ModifyTriggerRequest
   * @return ModifyTriggerResponse
   */
  async modifyTrigger(request: ModifyTriggerRequest): Promise<ModifyTriggerResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.modifyTriggerWithOptions(request, runtime);
  }

  /**
   * @param request OperateUserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return OperateUserResponse
   */
  async operateUserWithOptions(request: OperateUserRequest, runtime: $Util.RuntimeOptions): Promise<OperateUserResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bid)) {
      body["Bid"] = request.bid;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.operation)) {
      body["Operation"] = request.operation;
    }

    if (!Util.isUnset(request.userName)) {
      body["UserName"] = request.userName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "OperateUser",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<OperateUserResponse>(await this.callApi(params, req, runtime), new OperateUserResponse({}));
  }

  /**
   * @param request OperateUserRequest
   * @return OperateUserResponse
   */
  async operateUser(request: OperateUserRequest): Promise<OperateUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.operateUserWithOptions(request, runtime);
  }

  /**
   * @param request ProcessCloudIDEContractTransactionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ProcessCloudIDEContractTransactionResponse
   */
  async processCloudIDEContractTransactionWithOptions(request: ProcessCloudIDEContractTransactionRequest, runtime: $Util.RuntimeOptions): Promise<ProcessCloudIDEContractTransactionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.transaction)) {
      body["Transaction"] = request.transaction;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ProcessCloudIDEContractTransaction",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ProcessCloudIDEContractTransactionResponse>(await this.callApi(params, req, runtime), new ProcessCloudIDEContractTransactionResponse({}));
  }

  /**
   * @param request ProcessCloudIDEContractTransactionRequest
   * @return ProcessCloudIDEContractTransactionResponse
   */
  async processCloudIDEContractTransaction(request: ProcessCloudIDEContractTransactionRequest): Promise<ProcessCloudIDEContractTransactionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.processCloudIDEContractTransactionWithOptions(request, runtime);
  }

  /**
   * @param request ProcessPublicCloudIDEContractTransactionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ProcessPublicCloudIDEContractTransactionResponse
   */
  async processPublicCloudIDEContractTransactionWithOptions(request: ProcessPublicCloudIDEContractTransactionRequest, runtime: $Util.RuntimeOptions): Promise<ProcessPublicCloudIDEContractTransactionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.transaction)) {
      body["Transaction"] = request.transaction;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ProcessPublicCloudIDEContractTransaction",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ProcessPublicCloudIDEContractTransactionResponse>(await this.callApi(params, req, runtime), new ProcessPublicCloudIDEContractTransactionResponse({}));
  }

  /**
   * @param request ProcessPublicCloudIDEContractTransactionRequest
   * @return ProcessPublicCloudIDEContractTransactionResponse
   */
  async processPublicCloudIDEContractTransaction(request: ProcessPublicCloudIDEContractTransactionRequest): Promise<ProcessPublicCloudIDEContractTransactionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.processPublicCloudIDEContractTransactionWithOptions(request, runtime);
  }

  /**
   * @param request QueryBlockRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return QueryBlockResponse
   */
  async queryBlockWithOptions(request: QueryBlockRequest, runtime: $Util.RuntimeOptions): Promise<QueryBlockResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.height)) {
      body["Height"] = request.height;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryBlock",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryBlockResponse>(await this.callApi(params, req, runtime), new QueryBlockResponse({}));
  }

  /**
   * @param request QueryBlockRequest
   * @return QueryBlockResponse
   */
  async queryBlock(request: QueryBlockRequest): Promise<QueryBlockResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryBlockWithOptions(request, runtime);
  }

  /**
   * @param request QueryConsortiumDeletableRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return QueryConsortiumDeletableResponse
   */
  async queryConsortiumDeletableWithOptions(request: QueryConsortiumDeletableRequest, runtime: $Util.RuntimeOptions): Promise<QueryConsortiumDeletableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.consortiumId)) {
      query["ConsortiumId"] = request.consortiumId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryConsortiumDeletable",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryConsortiumDeletableResponse>(await this.callApi(params, req, runtime), new QueryConsortiumDeletableResponse({}));
  }

  /**
   * @param request QueryConsortiumDeletableRequest
   * @return QueryConsortiumDeletableResponse
   */
  async queryConsortiumDeletable(request: QueryConsortiumDeletableRequest): Promise<QueryConsortiumDeletableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryConsortiumDeletableWithOptions(request, runtime);
  }

  /**
   * @param request QueryEthereumDeletableRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return QueryEthereumDeletableResponse
   */
  async queryEthereumDeletableWithOptions(request: QueryEthereumDeletableRequest, runtime: $Util.RuntimeOptions): Promise<QueryEthereumDeletableResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.ethereumId)) {
      body["EthereumId"] = request.ethereumId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryEthereumDeletable",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryEthereumDeletableResponse>(await this.callApi(params, req, runtime), new QueryEthereumDeletableResponse({}));
  }

  /**
   * @param request QueryEthereumDeletableRequest
   * @return QueryEthereumDeletableResponse
   */
  async queryEthereumDeletable(request: QueryEthereumDeletableRequest): Promise<QueryEthereumDeletableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryEthereumDeletableWithOptions(request, runtime);
  }

  /**
   * @param request QueryMetricRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return QueryMetricResponse
   */
  async queryMetricWithOptions(request: QueryMetricRequest, runtime: $Util.RuntimeOptions): Promise<QueryMetricResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.bizid)) {
      query["Bizid"] = request.bizid;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.innerIp)) {
      body["InnerIp"] = request.innerIp;
    }

    if (!Util.isUnset(request.metric)) {
      body["Metric"] = request.metric;
    }

    if (!Util.isUnset(request.period)) {
      body["Period"] = request.period;
    }

    if (!Util.isUnset(request.port)) {
      body["Port"] = request.port;
    }

    if (!Util.isUnset(request.timeArea)) {
      body["TimeArea"] = request.timeArea;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryMetric",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryMetricResponse>(await this.callApi(params, req, runtime), new QueryMetricResponse({}));
  }

  /**
   * @param request QueryMetricRequest
   * @return QueryMetricResponse
   */
  async queryMetric(request: QueryMetricRequest): Promise<QueryMetricResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryMetricWithOptions(request, runtime);
  }

  /**
   * @param request QueryOrganizationDeletableRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return QueryOrganizationDeletableResponse
   */
  async queryOrganizationDeletableWithOptions(request: QueryOrganizationDeletableRequest, runtime: $Util.RuntimeOptions): Promise<QueryOrganizationDeletableResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.organizationId)) {
      query["OrganizationId"] = request.organizationId;
    }

    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryOrganizationDeletable",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryOrganizationDeletableResponse>(await this.callApi(params, req, runtime), new QueryOrganizationDeletableResponse({}));
  }

  /**
   * @param request QueryOrganizationDeletableRequest
   * @return QueryOrganizationDeletableResponse
   */
  async queryOrganizationDeletable(request: QueryOrganizationDeletableRequest): Promise<QueryOrganizationDeletableResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryOrganizationDeletableWithOptions(request, runtime);
  }

  /**
   * @param request QueryTransactionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return QueryTransactionResponse
   */
  async queryTransactionWithOptions(request: QueryTransactionRequest, runtime: $Util.RuntimeOptions): Promise<QueryTransactionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.hash)) {
      body["Hash"] = request.hash;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "QueryTransaction",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<QueryTransactionResponse>(await this.callApi(params, req, runtime), new QueryTransactionResponse({}));
  }

  /**
   * @param request QueryTransactionRequest
   * @return QueryTransactionResponse
   */
  async queryTransaction(request: QueryTransactionRequest): Promise<QueryTransactionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.queryTransactionWithOptions(request, runtime);
  }

  /**
   * @param request RejectUserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return RejectUserResponse
   */
  async rejectUserWithOptions(request: RejectUserRequest, runtime: $Util.RuntimeOptions): Promise<RejectUserResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bid)) {
      body["Bid"] = request.bid;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.reason)) {
      body["Reason"] = request.reason;
    }

    if (!Util.isUnset(request.userName)) {
      body["UserName"] = request.userName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RejectUser",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RejectUserResponse>(await this.callApi(params, req, runtime), new RejectUserResponse({}));
  }

  /**
   * @param request RejectUserRequest
   * @return RejectUserResponse
   */
  async rejectUser(request: RejectUserRequest): Promise<RejectUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.rejectUserWithOptions(request, runtime);
  }

  /**
   * @param request RenameBlockchainRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return RenameBlockchainResponse
   */
  async renameBlockchainWithOptions(request: RenameBlockchainRequest, runtime: $Util.RuntimeOptions): Promise<RenameBlockchainResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.newName)) {
      body["NewName"] = request.newName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "RenameBlockchain",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<RenameBlockchainResponse>(await this.callApi(params, req, runtime), new RenameBlockchainResponse({}));
  }

  /**
   * @param request RenameBlockchainRequest
   * @return RenameBlockchainResponse
   */
  async renameBlockchain(request: RenameBlockchainRequest): Promise<RenameBlockchainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.renameBlockchainWithOptions(request, runtime);
  }

  /**
   * @param request ResetAntChainCertificateRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ResetAntChainCertificateResponse
   */
  async resetAntChainCertificateWithOptions(request: ResetAntChainCertificateRequest, runtime: $Util.RuntimeOptions): Promise<ResetAntChainCertificateResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ResetAntChainCertificate",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResetAntChainCertificateResponse>(await this.callApi(params, req, runtime), new ResetAntChainCertificateResponse({}));
  }

  /**
   * @param request ResetAntChainCertificateRequest
   * @return ResetAntChainCertificateResponse
   */
  async resetAntChainCertificate(request: ResetAntChainCertificateRequest): Promise<ResetAntChainCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetAntChainCertificateWithOptions(request, runtime);
  }

  /**
   * @param request ResetAntChainUserCertificateRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ResetAntChainUserCertificateResponse
   */
  async resetAntChainUserCertificateWithOptions(request: ResetAntChainUserCertificateRequest, runtime: $Util.RuntimeOptions): Promise<ResetAntChainUserCertificateResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.bid)) {
      body["Bid"] = request.bid;
    }

    if (!Util.isUnset(request.operation)) {
      body["Operation"] = request.operation;
    }

    if (!Util.isUnset(request.username)) {
      body["Username"] = request.username;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ResetAntChainUserCertificate",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResetAntChainUserCertificateResponse>(await this.callApi(params, req, runtime), new ResetAntChainUserCertificateResponse({}));
  }

  /**
   * @param request ResetAntChainUserCertificateRequest
   * @return ResetAntChainUserCertificateResponse
   */
  async resetAntChainUserCertificate(request: ResetAntChainUserCertificateRequest): Promise<ResetAntChainUserCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetAntChainUserCertificateWithOptions(request, runtime);
  }

  /**
   * @param request ResetCertificateRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ResetCertificateResponse
   */
  async resetCertificateWithOptions(request: ResetCertificateRequest, runtime: $Util.RuntimeOptions): Promise<ResetCertificateResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ResetCertificate",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResetCertificateResponse>(await this.callApi(params, req, runtime), new ResetCertificateResponse({}));
  }

  /**
   * @param request ResetCertificateRequest
   * @return ResetCertificateResponse
   */
  async resetCertificate(request: ResetCertificateRequest): Promise<ResetCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetCertificateWithOptions(request, runtime);
  }

  /**
   * @param request ResetOrganizationUserPasswordRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ResetOrganizationUserPasswordResponse
   */
  async resetOrganizationUserPasswordWithOptions(request: ResetOrganizationUserPasswordRequest, runtime: $Util.RuntimeOptions): Promise<ResetOrganizationUserPasswordResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.username)) {
      body["Username"] = request.username;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ResetOrganizationUserPassword",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResetOrganizationUserPasswordResponse>(await this.callApi(params, req, runtime), new ResetOrganizationUserPasswordResponse({}));
  }

  /**
   * @param request ResetOrganizationUserPasswordRequest
   * @return ResetOrganizationUserPasswordResponse
   */
  async resetOrganizationUserPassword(request: ResetOrganizationUserPasswordRequest): Promise<ResetOrganizationUserPasswordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetOrganizationUserPasswordWithOptions(request, runtime);
  }

  /**
   * @param request ResetPublicAntChainCertificateRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ResetPublicAntChainCertificateResponse
   */
  async resetPublicAntChainCertificateWithOptions(request: ResetPublicAntChainCertificateRequest, runtime: $Util.RuntimeOptions): Promise<ResetPublicAntChainCertificateResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ResetPublicAntChainCertificate",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResetPublicAntChainCertificateResponse>(await this.callApi(params, req, runtime), new ResetPublicAntChainCertificateResponse({}));
  }

  /**
   * @param request ResetPublicAntChainCertificateRequest
   * @return ResetPublicAntChainCertificateResponse
   */
  async resetPublicAntChainCertificate(request: ResetPublicAntChainCertificateRequest): Promise<ResetPublicAntChainCertificateResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetPublicAntChainCertificateWithOptions(request, runtime);
  }

  /**
   * @param request ResetUserRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return ResetUserResponse
   */
  async resetUserWithOptions(request: ResetUserRequest, runtime: $Util.RuntimeOptions): Promise<ResetUserResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bid)) {
      body["Bid"] = request.bid;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.operation)) {
      body["Operation"] = request.operation;
    }

    if (!Util.isUnset(request.userName)) {
      body["UserName"] = request.userName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "ResetUser",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<ResetUserResponse>(await this.callApi(params, req, runtime), new ResetUserResponse({}));
  }

  /**
   * @param request ResetUserRequest
   * @return ResetUserResponse
   */
  async resetUser(request: ResetUserRequest): Promise<ResetUserResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.resetUserWithOptions(request, runtime);
  }

  /**
   * @param request SchemaDetailRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SchemaDetailResponse
   */
  async schemaDetailWithOptions(request: SchemaDetailRequest, runtime: $Util.RuntimeOptions): Promise<SchemaDetailResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.schemaId)) {
      body["SchemaId"] = request.schemaId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SchemaDetail",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SchemaDetailResponse>(await this.callApi(params, req, runtime), new SchemaDetailResponse({}));
  }

  /**
   * @param request SchemaDetailRequest
   * @return SchemaDetailResponse
   */
  async schemaDetail(request: SchemaDetailRequest): Promise<SchemaDetailResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.schemaDetailWithOptions(request, runtime);
  }

  /**
   * @param request StartSmartContractJobRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return StartSmartContractJobResponse
   */
  async startSmartContractJobWithOptions(request: StartSmartContractJobRequest, runtime: $Util.RuntimeOptions): Promise<StartSmartContractJobResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.jobId)) {
      body["JobId"] = request.jobId;
    }

    if (!Util.isUnset(request.jobName)) {
      body["JobName"] = request.jobName;
    }

    if (!Util.isUnset(request.sourceOpt)) {
      body["SourceOpt"] = request.sourceOpt;
    }

    if (!Util.isUnset(request.sourceType)) {
      body["SourceType"] = request.sourceType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "StartSmartContractJob",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<StartSmartContractJobResponse>(await this.callApi(params, req, runtime), new StartSmartContractJobResponse({}));
  }

  /**
   * @param request StartSmartContractJobRequest
   * @return StartSmartContractJobResponse
   */
  async startSmartContractJob(request: StartSmartContractJobRequest): Promise<StartSmartContractJobResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.startSmartContractJobWithOptions(request, runtime);
  }

  /**
   * @param request SubmitFabricChaincodeDefinitionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SubmitFabricChaincodeDefinitionResponse
   */
  async submitFabricChaincodeDefinitionWithOptions(request: SubmitFabricChaincodeDefinitionRequest, runtime: $Util.RuntimeOptions): Promise<SubmitFabricChaincodeDefinitionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodePackageId)) {
      body["ChaincodePackageId"] = request.chaincodePackageId;
    }

    if (!Util.isUnset(request.chaincodeVersion)) {
      body["ChaincodeVersion"] = request.chaincodeVersion;
    }

    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.collectionConfig)) {
      body["CollectionConfig"] = request.collectionConfig;
    }

    if (!Util.isUnset(request.endorsePolicy)) {
      body["EndorsePolicy"] = request.endorsePolicy;
    }

    if (!Util.isUnset(request.initRequired)) {
      body["InitRequired"] = request.initRequired;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SubmitFabricChaincodeDefinition",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SubmitFabricChaincodeDefinitionResponse>(await this.callApi(params, req, runtime), new SubmitFabricChaincodeDefinitionResponse({}));
  }

  /**
   * @param request SubmitFabricChaincodeDefinitionRequest
   * @return SubmitFabricChaincodeDefinitionResponse
   */
  async submitFabricChaincodeDefinition(request: SubmitFabricChaincodeDefinitionRequest): Promise<SubmitFabricChaincodeDefinitionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.submitFabricChaincodeDefinitionWithOptions(request, runtime);
  }

  /**
   * @param request SyncFabricChaincodeStatusRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SyncFabricChaincodeStatusResponse
   */
  async syncFabricChaincodeStatusWithOptions(request: SyncFabricChaincodeStatusRequest, runtime: $Util.RuntimeOptions): Promise<SyncFabricChaincodeStatusResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodeId)) {
      body["ChaincodeId"] = request.chaincodeId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SyncFabricChaincodeStatus",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SyncFabricChaincodeStatusResponse>(await this.callApi(params, req, runtime), new SyncFabricChaincodeStatusResponse({}));
  }

  /**
   * @param request SyncFabricChaincodeStatusRequest
   * @return SyncFabricChaincodeStatusResponse
   */
  async syncFabricChaincodeStatus(request: SyncFabricChaincodeStatusRequest): Promise<SyncFabricChaincodeStatusResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.syncFabricChaincodeStatusWithOptions(request, runtime);
  }

  /**
   * @param request SynchronizeChaincodeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return SynchronizeChaincodeResponse
   */
  async synchronizeChaincodeWithOptions(request: SynchronizeChaincodeRequest, runtime: $Util.RuntimeOptions): Promise<SynchronizeChaincodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodeId)) {
      body["ChaincodeId"] = request.chaincodeId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "SynchronizeChaincode",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<SynchronizeChaincodeResponse>(await this.callApi(params, req, runtime), new SynchronizeChaincodeResponse({}));
  }

  /**
   * @param request SynchronizeChaincodeRequest
   * @return SynchronizeChaincodeResponse
   */
  async synchronizeChaincode(request: SynchronizeChaincodeRequest): Promise<SynchronizeChaincodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.synchronizeChaincodeWithOptions(request, runtime);
  }

  /**
   * @param request TagResourcesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return TagResourcesResponse
   */
  async tagResourcesWithOptions(request: TagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<TagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tag)) {
      query["Tag"] = request.tag;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "TagResources",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<TagResourcesResponse>(await this.callApi(params, req, runtime), new TagResourcesResponse({}));
  }

  /**
   * @param request TagResourcesRequest
   * @return TagResourcesResponse
   */
  async tagResources(request: TagResourcesRequest): Promise<TagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.tagResourcesWithOptions(request, runtime);
  }

  /**
   * @param request UnfreezeAccountRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UnfreezeAccountResponse
   */
  async unfreezeAccountWithOptions(request: UnfreezeAccountRequest, runtime: $Util.RuntimeOptions): Promise<UnfreezeAccountResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.account)) {
      body["Account"] = request.account;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UnfreezeAccount",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnfreezeAccountResponse>(await this.callApi(params, req, runtime), new UnfreezeAccountResponse({}));
  }

  /**
   * @param request UnfreezeAccountRequest
   * @return UnfreezeAccountResponse
   */
  async unfreezeAccount(request: UnfreezeAccountRequest): Promise<UnfreezeAccountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unfreezeAccountWithOptions(request, runtime);
  }

  /**
   * @param request UnfreezeAntChainAccountRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UnfreezeAntChainAccountResponse
   */
  async unfreezeAntChainAccountWithOptions(request: UnfreezeAntChainAccountRequest, runtime: $Util.RuntimeOptions): Promise<UnfreezeAntChainAccountResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.account)) {
      body["Account"] = request.account;
    }

    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UnfreezeAntChainAccount",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UnfreezeAntChainAccountResponse>(await this.callApi(params, req, runtime), new UnfreezeAntChainAccountResponse({}));
  }

  /**
   * @param request UnfreezeAntChainAccountRequest
   * @return UnfreezeAntChainAccountResponse
   */
  async unfreezeAntChainAccount(request: UnfreezeAntChainAccountRequest): Promise<UnfreezeAntChainAccountResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.unfreezeAntChainAccountWithOptions(request, runtime);
  }

  /**
   * @param request UntagResourcesRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UntagResourcesResponse
   */
  async untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $Util.RuntimeOptions): Promise<UntagResourcesResponse> {
    Util.validateModel(request);
    let query = { };
    if (!Util.isUnset(request.all)) {
      query["All"] = request.all;
    }

    if (!Util.isUnset(request.resourceId)) {
      query["ResourceId"] = request.resourceId;
    }

    if (!Util.isUnset(request.resourceType)) {
      query["ResourceType"] = request.resourceType;
    }

    if (!Util.isUnset(request.tagKey)) {
      query["TagKey"] = request.tagKey;
    }

    let req = new $OpenApi.OpenApiRequest({
      query: OpenApiUtil.query(query),
    });
    let params = new $OpenApi.Params({
      action: "UntagResources",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UntagResourcesResponse>(await this.callApi(params, req, runtime), new UntagResourcesResponse({}));
  }

  /**
   * @param request UntagResourcesRequest
   * @return UntagResourcesResponse
   */
  async untagResources(request: UntagResourcesRequest): Promise<UntagResourcesResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.untagResourcesWithOptions(request, runtime);
  }

  /**
   * @param request UpdateAntChainRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateAntChainResponse
   */
  async updateAntChainWithOptions(request: UpdateAntChainRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAntChainResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.antChainName)) {
      body["AntChainName"] = request.antChainName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAntChain",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateAntChainResponse>(await this.callApi(params, req, runtime), new UpdateAntChainResponse({}));
  }

  /**
   * @param request UpdateAntChainRequest
   * @return UpdateAntChainResponse
   */
  async updateAntChain(request: UpdateAntChainRequest): Promise<UpdateAntChainResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAntChainWithOptions(request, runtime);
  }

  /**
   * @param request UpdateAntChainConsortiumRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateAntChainConsortiumResponse
   */
  async updateAntChainConsortiumWithOptions(request: UpdateAntChainConsortiumRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAntChainConsortiumResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumDescription)) {
      body["ConsortiumDescription"] = request.consortiumDescription;
    }

    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.consortiumName)) {
      body["ConsortiumName"] = request.consortiumName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAntChainConsortium",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateAntChainConsortiumResponse>(await this.callApi(params, req, runtime), new UpdateAntChainConsortiumResponse({}));
  }

  /**
   * @param request UpdateAntChainConsortiumRequest
   * @return UpdateAntChainConsortiumResponse
   */
  async updateAntChainConsortium(request: UpdateAntChainConsortiumRequest): Promise<UpdateAntChainConsortiumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAntChainConsortiumWithOptions(request, runtime);
  }

  /**
   * @param request UpdateAntChainContractContentRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateAntChainContractContentResponse
   */
  async updateAntChainContractContentWithOptions(request: UpdateAntChainContractContentRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAntChainContractContentResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.content)) {
      body["Content"] = request.content;
    }

    if (!Util.isUnset(request.contentId)) {
      body["ContentId"] = request.contentId;
    }

    if (!Util.isUnset(request.contentName)) {
      body["ContentName"] = request.contentName;
    }

    if (!Util.isUnset(request.parentContentId)) {
      body["ParentContentId"] = request.parentContentId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAntChainContractContent",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateAntChainContractContentResponse>(await this.callApi(params, req, runtime), new UpdateAntChainContractContentResponse({}));
  }

  /**
   * @param request UpdateAntChainContractContentRequest
   * @return UpdateAntChainContractContentResponse
   */
  async updateAntChainContractContent(request: UpdateAntChainContractContentRequest): Promise<UpdateAntChainContractContentResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAntChainContractContentWithOptions(request, runtime);
  }

  /**
   * @param request UpdateAntChainContractProjectRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateAntChainContractProjectResponse
   */
  async updateAntChainContractProjectWithOptions(request: UpdateAntChainContractProjectRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAntChainContractProjectResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.projectDescription)) {
      body["ProjectDescription"] = request.projectDescription;
    }

    if (!Util.isUnset(request.projectId)) {
      body["ProjectId"] = request.projectId;
    }

    if (!Util.isUnset(request.projectName)) {
      body["ProjectName"] = request.projectName;
    }

    if (!Util.isUnset(request.projectVersion)) {
      body["ProjectVersion"] = request.projectVersion;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAntChainContractProject",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateAntChainContractProjectResponse>(await this.callApi(params, req, runtime), new UpdateAntChainContractProjectResponse({}));
  }

  /**
   * @param request UpdateAntChainContractProjectRequest
   * @return UpdateAntChainContractProjectResponse
   */
  async updateAntChainContractProject(request: UpdateAntChainContractProjectRequest): Promise<UpdateAntChainContractProjectResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAntChainContractProjectWithOptions(request, runtime);
  }

  /**
   * @param request UpdateAntChainMemberRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateAntChainMemberResponse
   */
  async updateAntChainMemberWithOptions(request: UpdateAntChainMemberRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAntChainMemberResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.consortiumId)) {
      body["ConsortiumId"] = request.consortiumId;
    }

    if (!Util.isUnset(request.memberId)) {
      body["MemberId"] = request.memberId;
    }

    if (!Util.isUnset(request.memberName)) {
      body["MemberName"] = request.memberName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAntChainMember",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateAntChainMemberResponse>(await this.callApi(params, req, runtime), new UpdateAntChainMemberResponse({}));
  }

  /**
   * @param request UpdateAntChainMemberRequest
   * @return UpdateAntChainMemberResponse
   */
  async updateAntChainMember(request: UpdateAntChainMemberRequest): Promise<UpdateAntChainMemberResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAntChainMemberWithOptions(request, runtime);
  }

  /**
   * @param request UpdateAntChainQRCodeAuthorizationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateAntChainQRCodeAuthorizationResponse
   */
  async updateAntChainQRCodeAuthorizationWithOptions(request: UpdateAntChainQRCodeAuthorizationRequest, runtime: $Util.RuntimeOptions): Promise<UpdateAntChainQRCodeAuthorizationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.antChainId)) {
      body["AntChainId"] = request.antChainId;
    }

    if (!Util.isUnset(request.authorizationType)) {
      body["AuthorizationType"] = request.authorizationType;
    }

    if (!Util.isUnset(request.QRCodeType)) {
      body["QRCodeType"] = request.QRCodeType;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateAntChainQRCodeAuthorization",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateAntChainQRCodeAuthorizationResponse>(await this.callApi(params, req, runtime), new UpdateAntChainQRCodeAuthorizationResponse({}));
  }

  /**
   * @param request UpdateAntChainQRCodeAuthorizationRequest
   * @return UpdateAntChainQRCodeAuthorizationResponse
   */
  async updateAntChainQRCodeAuthorization(request: UpdateAntChainQRCodeAuthorizationRequest): Promise<UpdateAntChainQRCodeAuthorizationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateAntChainQRCodeAuthorizationWithOptions(request, runtime);
  }

  /**
   * @param request UpdateBlockchainSchemaRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateBlockchainSchemaResponse
   */
  async updateBlockchainSchemaWithOptions(request: UpdateBlockchainSchemaRequest, runtime: $Util.RuntimeOptions): Promise<UpdateBlockchainSchemaResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.categoryConfigs)) {
      body["CategoryConfigs"] = request.categoryConfigs;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.schemaId)) {
      body["SchemaId"] = request.schemaId;
    }

    if (!Util.isUnset(request.schemaName)) {
      body["SchemaName"] = request.schemaName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateBlockchainSchema",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateBlockchainSchemaResponse>(await this.callApi(params, req, runtime), new UpdateBlockchainSchemaResponse({}));
  }

  /**
   * @param request UpdateBlockchainSchemaRequest
   * @return UpdateBlockchainSchemaResponse
   */
  async updateBlockchainSchema(request: UpdateBlockchainSchemaRequest): Promise<UpdateBlockchainSchemaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateBlockchainSchemaWithOptions(request, runtime);
  }

  /**
   * @param request UpdateChannelConfigRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateChannelConfigResponse
   */
  async updateChannelConfigWithOptions(request: UpdateChannelConfigRequest, runtime: $Util.RuntimeOptions): Promise<UpdateChannelConfigResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.batchTimeout)) {
      body["BatchTimeout"] = request.batchTimeout;
    }

    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.maxMessageCount)) {
      body["MaxMessageCount"] = request.maxMessageCount;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.preferredMaxBytes)) {
      body["PreferredMaxBytes"] = request.preferredMaxBytes;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateChannelConfig",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateChannelConfigResponse>(await this.callApi(params, req, runtime), new UpdateChannelConfigResponse({}));
  }

  /**
   * @param request UpdateChannelConfigRequest
   * @return UpdateChannelConfigResponse
   */
  async updateChannelConfig(request: UpdateChannelConfigRequest): Promise<UpdateChannelConfigResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateChannelConfigWithOptions(request, runtime);
  }

  /**
   * @param request UpdateEthereumRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateEthereumResponse
   */
  async updateEthereumWithOptions(request: UpdateEthereumRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEthereumResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.ethereumId)) {
      body["EthereumId"] = request.ethereumId;
    }

    if (!Util.isUnset(request.name)) {
      body["Name"] = request.name;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEthereum",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateEthereumResponse>(await this.callApi(params, req, runtime), new UpdateEthereumResponse({}));
  }

  /**
   * @param request UpdateEthereumRequest
   * @return UpdateEthereumResponse
   */
  async updateEthereum(request: UpdateEthereumRequest): Promise<UpdateEthereumResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEthereumWithOptions(request, runtime);
  }

  /**
   * @param request UpdateEthereumClientUserPasswordRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateEthereumClientUserPasswordResponse
   */
  async updateEthereumClientUserPasswordWithOptions(request: UpdateEthereumClientUserPasswordRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEthereumClientUserPasswordResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.password)) {
      body["Password"] = request.password;
    }

    if (!Util.isUnset(request.username)) {
      body["Username"] = request.username;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEthereumClientUserPassword",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateEthereumClientUserPasswordResponse>(await this.callApi(params, req, runtime), new UpdateEthereumClientUserPasswordResponse({}));
  }

  /**
   * @param request UpdateEthereumClientUserPasswordRequest
   * @return UpdateEthereumClientUserPasswordResponse
   */
  async updateEthereumClientUserPassword(request: UpdateEthereumClientUserPasswordRequest): Promise<UpdateEthereumClientUserPasswordResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEthereumClientUserPasswordWithOptions(request, runtime);
  }

  /**
   * @param request UpdateEthereumNodeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateEthereumNodeResponse
   */
  async updateEthereumNodeWithOptions(request: UpdateEthereumNodeRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEthereumNodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodeName)) {
      body["NodeName"] = request.nodeName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEthereumNode",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateEthereumNodeResponse>(await this.callApi(params, req, runtime), new UpdateEthereumNodeResponse({}));
  }

  /**
   * @param request UpdateEthereumNodeRequest
   * @return UpdateEthereumNodeResponse
   */
  async updateEthereumNode(request: UpdateEthereumNodeRequest): Promise<UpdateEthereumNodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEthereumNodeWithOptions(request, runtime);
  }

  /**
   * @param request UpdateEthereumNodeConfigurationRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateEthereumNodeConfigurationResponse
   */
  async updateEthereumNodeConfigurationWithOptions(request: UpdateEthereumNodeConfigurationRequest, runtime: $Util.RuntimeOptions): Promise<UpdateEthereumNodeConfigurationResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.IP)) {
      body["IP"] = request.IP;
    }

    if (!Util.isUnset(request.nodeId)) {
      body["NodeId"] = request.nodeId;
    }

    if (!Util.isUnset(request.nodePub)) {
      body["NodePub"] = request.nodePub;
    }

    if (!Util.isUnset(request.p2pPort)) {
      body["P2pPort"] = request.p2pPort;
    }

    if (!Util.isUnset(request.raftPort)) {
      body["RaftPort"] = request.raftPort;
    }

    if (!Util.isUnset(request.rpcPort)) {
      body["RpcPort"] = request.rpcPort;
    }

    if (!Util.isUnset(request.TMPort)) {
      body["TMPort"] = request.TMPort;
    }

    if (!Util.isUnset(request.TMPub)) {
      body["TMPub"] = request.TMPub;
    }

    if (!Util.isUnset(request.WSPort)) {
      body["WSPort"] = request.WSPort;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateEthereumNodeConfiguration",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateEthereumNodeConfigurationResponse>(await this.callApi(params, req, runtime), new UpdateEthereumNodeConfigurationResponse({}));
  }

  /**
   * @param request UpdateEthereumNodeConfigurationRequest
   * @return UpdateEthereumNodeConfigurationResponse
   */
  async updateEthereumNodeConfiguration(request: UpdateEthereumNodeConfigurationRequest): Promise<UpdateEthereumNodeConfigurationResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateEthereumNodeConfigurationWithOptions(request, runtime);
  }

  /**
   * @param request UpdateGovernanceTaskRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateGovernanceTaskResponse
   */
  async updateGovernanceTaskWithOptions(request: UpdateGovernanceTaskRequest, runtime: $Util.RuntimeOptions): Promise<UpdateGovernanceTaskResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    if (!Util.isUnset(request.taskAction)) {
      body["TaskAction"] = request.taskAction;
    }

    if (!Util.isUnset(request.taskId)) {
      body["TaskId"] = request.taskId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateGovernanceTask",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateGovernanceTaskResponse>(await this.callApi(params, req, runtime), new UpdateGovernanceTaskResponse({}));
  }

  /**
   * @param request UpdateGovernanceTaskRequest
   * @return UpdateGovernanceTaskResponse
   */
  async updateGovernanceTask(request: UpdateGovernanceTaskRequest): Promise<UpdateGovernanceTaskResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateGovernanceTaskWithOptions(request, runtime);
  }

  /**
   * @param request UpdateMemberRoleRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateMemberRoleResponse
   */
  async updateMemberRoleWithOptions(request: UpdateMemberRoleRequest, runtime: $Util.RuntimeOptions): Promise<UpdateMemberRoleResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bid)) {
      body["Bid"] = request.bid;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.role)) {
      body["Role"] = request.role;
    }

    if (!Util.isUnset(request.userId)) {
      body["UserId"] = request.userId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateMemberRole",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateMemberRoleResponse>(await this.callApi(params, req, runtime), new UpdateMemberRoleResponse({}));
  }

  /**
   * @param request UpdateMemberRoleRequest
   * @return UpdateMemberRoleResponse
   */
  async updateMemberRole(request: UpdateMemberRoleRequest): Promise<UpdateMemberRoleResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateMemberRoleWithOptions(request, runtime);
  }

  /**
   * @param request UpdateQRCodeAuthorityRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateQRCodeAuthorityResponse
   */
  async updateQRCodeAuthorityWithOptions(request: UpdateQRCodeAuthorityRequest, runtime: $Util.RuntimeOptions): Promise<UpdateQRCodeAuthorityResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.authorized)) {
      body["Authorized"] = request.authorized;
    }

    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateQRCodeAuthority",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateQRCodeAuthorityResponse>(await this.callApi(params, req, runtime), new UpdateQRCodeAuthorityResponse({}));
  }

  /**
   * @param request UpdateQRCodeAuthorityRequest
   * @return UpdateQRCodeAuthorityResponse
   */
  async updateQRCodeAuthority(request: UpdateQRCodeAuthorityRequest): Promise<UpdateQRCodeAuthorityResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateQRCodeAuthorityWithOptions(request, runtime);
  }

  /**
   * @param request UpdateSchemaRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpdateSchemaResponse
   */
  async updateSchemaWithOptions(request: UpdateSchemaRequest, runtime: $Util.RuntimeOptions): Promise<UpdateSchemaResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.bizid)) {
      body["Bizid"] = request.bizid;
    }

    if (!Util.isUnset(request.categoryConfigs)) {
      body["CategoryConfigs"] = request.categoryConfigs;
    }

    if (!Util.isUnset(request.description)) {
      body["Description"] = request.description;
    }

    if (!Util.isUnset(request.schemaId)) {
      body["SchemaId"] = request.schemaId;
    }

    if (!Util.isUnset(request.schemaName)) {
      body["SchemaName"] = request.schemaName;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpdateSchema",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpdateSchemaResponse>(await this.callApi(params, req, runtime), new UpdateSchemaResponse({}));
  }

  /**
   * @param request UpdateSchemaRequest
   * @return UpdateSchemaResponse
   */
  async updateSchema(request: UpdateSchemaRequest): Promise<UpdateSchemaResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.updateSchemaWithOptions(request, runtime);
  }

  /**
   * @param request UpgradeChaincodeRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpgradeChaincodeResponse
   */
  async upgradeChaincodeWithOptions(request: UpgradeChaincodeRequest, runtime: $Util.RuntimeOptions): Promise<UpgradeChaincodeResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodeId)) {
      body["ChaincodeId"] = request.chaincodeId;
    }

    if (!Util.isUnset(request.collectionConfig)) {
      body["CollectionConfig"] = request.collectionConfig;
    }

    if (!Util.isUnset(request.endorsePolicy)) {
      body["EndorsePolicy"] = request.endorsePolicy;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpgradeChaincode",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpgradeChaincodeResponse>(await this.callApi(params, req, runtime), new UpgradeChaincodeResponse({}));
  }

  /**
   * @param request UpgradeChaincodeRequest
   * @return UpgradeChaincodeResponse
   */
  async upgradeChaincode(request: UpgradeChaincodeRequest): Promise<UpgradeChaincodeResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.upgradeChaincodeWithOptions(request, runtime);
  }

  /**
   * @param request UpgradeFabricChaincodeDefinitionRequest
   * @param runtime runtime options for this request RuntimeOptions
   * @return UpgradeFabricChaincodeDefinitionResponse
   */
  async upgradeFabricChaincodeDefinitionWithOptions(request: UpgradeFabricChaincodeDefinitionRequest, runtime: $Util.RuntimeOptions): Promise<UpgradeFabricChaincodeDefinitionResponse> {
    Util.validateModel(request);
    let body : {[key: string ]: any} = { };
    if (!Util.isUnset(request.chaincodeId)) {
      body["ChaincodeId"] = request.chaincodeId;
    }

    if (!Util.isUnset(request.chaincodePackageId)) {
      body["ChaincodePackageId"] = request.chaincodePackageId;
    }

    if (!Util.isUnset(request.chaincodeVersion)) {
      body["ChaincodeVersion"] = request.chaincodeVersion;
    }

    if (!Util.isUnset(request.channelId)) {
      body["ChannelId"] = request.channelId;
    }

    if (!Util.isUnset(request.collectionConfig)) {
      body["CollectionConfig"] = request.collectionConfig;
    }

    if (!Util.isUnset(request.endorsePolicy)) {
      body["EndorsePolicy"] = request.endorsePolicy;
    }

    if (!Util.isUnset(request.initRequired)) {
      body["InitRequired"] = request.initRequired;
    }

    if (!Util.isUnset(request.location)) {
      body["Location"] = request.location;
    }

    if (!Util.isUnset(request.organizationId)) {
      body["OrganizationId"] = request.organizationId;
    }

    let req = new $OpenApi.OpenApiRequest({
      body: OpenApiUtil.parseToMap(body),
    });
    let params = new $OpenApi.Params({
      action: "UpgradeFabricChaincodeDefinition",
      version: "2018-07-31",
      protocol: "HTTPS",
      pathname: "/",
      method: "POST",
      authType: "AK",
      style: "RPC",
      reqBodyType: "formData",
      bodyType: "json",
    });
    return $tea.cast<UpgradeFabricChaincodeDefinitionResponse>(await this.callApi(params, req, runtime), new UpgradeFabricChaincodeDefinitionResponse({}));
  }

  /**
   * @param request UpgradeFabricChaincodeDefinitionRequest
   * @return UpgradeFabricChaincodeDefinitionResponse
   */
  async upgradeFabricChaincodeDefinition(request: UpgradeFabricChaincodeDefinitionRequest): Promise<UpgradeFabricChaincodeDefinitionResponse> {
    let runtime = new $Util.RuntimeOptions({ });
    return await this.upgradeFabricChaincodeDefinitionWithOptions(request, runtime);
  }

}
